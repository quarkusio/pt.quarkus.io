<!DOCTYPE html>
<html lang="pt">







<head>
  <title>Escrevendo sua própria extensão - 2.13 - Quarkus</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Security-Policy" content="
  connect-src 'self' https://dpm.demdex.net https://adobedc.demdex.net https://analytics.ossupstream.org/ https://search.quarkus.io https://smetrics.redhat.com https://ajax.googleapis.com; 
  script-src 'self' 'unsafe-inline' 'unsafe-eval'
      
      https://assets.adobedtm.com
      js.bizographics.com
      https://www.redhat.com
      https://static.redhat.com
      https://app.requestly.io/
      jsonip.com
      https://ajax.googleapis.com
      https://use.fontawesome.com
      http://www.youtube.com
      http://www.googleadservices.com
      https://googleads.g.doubleclick.net
      https://giscus.app
      https://analytics.ossupstream.org/
      https://app.mailjet.com;

  style-src 'self' https://fonts.googleapis.com https://use.fontawesome.com; 
  img-src 'self' * data:; 
  media-src 'self'; 
  frame-src https://redhat.demdex.net https://www.youtube.com https://player.restream.io https://app.mailjet.com http://xy0p2.mjt.lu https://mj.quarkus.io https://giscus.app; 
  base-uri 'none'; 
  object-src 'none'; 
  form-action 'none'; 
  font-src 'self' https://use.fontawesome.com https://fonts.gstatic.com;" />

  <script id="adobe_dtm" src="https://www.redhat.com/dtm.js" type="text/javascript"></script>
  <script src="/assets/javascript/highlight.pack.js" type="text/javascript"></script>
  <META HTTP-EQUIV='X-XSS-Protection' CONTENT="1; mode=block">
  <META HTTP-EQUIV='X-Content-Type-Options' CONTENT="nosniff">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Quarkus: Supersonic Subatomic Java">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@QuarkusIO"> 
  <meta name="twitter:creator" content="@QuarkusIO">
  <meta property="og:url" content="https://quarkus.io/version/2.13/guides/writing-extensions" />
  <meta property="og:title" content="Escrevendo sua própria extensão - 2.13" />
  <meta property="og:description" content="Quarkus: Supersonic Subatomic Java" />
  <meta property="og:image" content="https://quarkus.io/assets/images/quarkus_card.png" />
  
  <link rel="canonical" href="https://quarkus.io/guides/writing-extensions">
  <link rel="shortcut icon" type="image/png" href="/favicon.ico" >
  <link rel="stylesheet" href="/guides/stylesheet/config.css" />
  <link rel="stylesheet" href="/assets/css/main.css?2021-07-29" />
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.5.2/css/all.css" crossorigin="anonymous">
  <link rel="alternate" type="application/rss+xml"  href="/feed.xml" title="Quarkus">
  <script src="/assets/javascript/hl.js" type="text/javascript"></script>
  
  
  
  
  <link rel="alternate" hreflang="en" href="https://quarkus.io/version/2.13/guides/writing-extensions" />
  
  <link rel="alternate" hreflang="pt-br" href="https://pt.quarkus.io/version/2.13/guides/writing-extensions" />
  
  <link rel="alternate" hreflang="es" href="https://es.quarkus.io/version/2.13/guides/writing-extensions" />
  
  <link rel="alternate" hreflang="zh" href="https://cn.quarkus.io/version/2.13/guides/writing-extensions" />
  
  <link rel="alternate" hreflang="ja" href="https://ja.quarkus.io/version/2.13/guides/writing-extensions" />
  
  <link rel="alternate" hreflang="x-default" href="https://quarkus.io/" />  
  <script src="/assets/javascript/tracking.js"></script>
  
  <script src="/assets/javascript/colormode.js" type="text/javascript"></script>

</head>

<body class="guides">

  


<div class="grid-wrapper communitysite">
  <div class="grid__item width-12-12">The <a href="https://quarkus.io/version/2.13/guides/writing-extensions">English version of quarkus.io</a> is the official project site. Translated sites are community supported on a best-effort basis.</div>
</div>


  <div class="nav-wrapper">
  <div class="grid-wrapper">
    <div class="width-12-12">
      <input type="checkbox" id="checkbox" />
      <nav id="main-nav" class="main-nav">
        <div class="logo-wrapper">
           <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_600px_reverse.png" class="project-logo" title="Quarkus"></a>
        </div>
    <label class="nav-toggle" for="checkbox"> <i class="fa fa-bars"></i>
</label>
    <ul id="menu" class="menu">
      <li class="dropdown">
        <span href="#">Why<i class="fas fa-chevron-down firsti"></i></span>
        <ul class="submenu">
          <li><a href="/about" class="">O QUE É QUARKUS?</a></li>
          <li><a href="/developer-joy" class="">ALEGRIA DO DESENVOLVEDOR</a></li>
          <li><a href="/performance" class="">PERFORMANCE</a></li>
          <li><a href="/kubernetes-native" class="">KUBERNETES NATIVO</a></li>
          <li><a href="/standards" class="">PADRÕES</a></li>
          <li><a href="/versatility" class="">VERSATILITY</a></li>
          <li><a href="/container-first" class="">CONTAINER PRIMEIRO</a></li>
          <li><a href="/spring" class="">USING SPRING?</a></li>
          <li class="tertiarydropdown">
            <span href="#">AI<i class="fas fa-chevron-down"></i></span>
            <ul class="tertiarymenu">
              <li><a href="/ai" class="">AI OVERVIEW</a></li>
              <li><a href="/java-for-ai" class="">JAVA FOR AI</a></li>
              <li><a href="/quarkus-for-ai" class="">WHY QUARKUS FOR AI</a></li>
              <li><a href="/ai-blueprints" class="">AI BLUEPRINTS</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li class="dropdown">
        <span href="#">Learn<i class="fas fa-chevron-down firsti"></i></span>
        <ul class="submenu">
          <li><a href="/get-started" class="">COMEÇAR</a></li>
          <li><a href="/guides" class="active">DOCUMENTAÇÃO</a></li>
          <li><a href="/userstories/" class="">USER STORIES</a></li>  
          <li><a href="/qtips" class="">VÍDEOS "Q" TIP</a></li>          
          <li><a href="/books" class="">LIVROS</a></li>
          </ul>
      </li>
      <li class="dropdown">
        <span href="#">Extensions<i class="fas fa-chevron-down firsti"></i></span>
        <ul class="submenu">
          
          <!-- Note that quarkus.io is hardcoded here, because it is the only url which supports extensions -->
<li><a href="https://quarkus.io/extensions/" class="">PROCURAR EXTENSÕES</a></li>
          <li><a href="/faq/#what-is-a-quarkus-extension" class="">USAR
EXTENSÕES</a></li>
          <li><a href="/guides/writing-extensions" class="active">CRIAR
EXTENSÕES</a></li>
          <li><a href="https://hub.quarkiverse.io" class="">COMPARTILHE EXTENSÕES</a></li>
        </ul>
      </li>
      <li class="dropdown">
        <span href="#">Community<i class="fas fa-chevron-down firsti"></i></span>
        <ul class="submenu">
          <li><a href="/support/" class="">SUPORTE</a></li>
          <li><a href="/blog" class="">BLOG</a></li>
          <li><a href="/discussion" class="">DISCUSSÃO</a></li>
          <li><a href="/working-groups" class="">WORKING GROUPS</a></li>
          <li><a href="/insights" class="">PODCAST</a></li>
          <li><a href="/events" class="">EVENTOS</a></li>
          <li><a href="/newsletter" class="">BOLETIM INFORMATIVO</a></li>
          <li><a href="https://github.com/orgs/quarkusio/projects/13/views/1" class="">ROADMAP</a></li>
          <li><a href="/benefactors" class="">BENEFACTORS</a></li>
          </ul>
      </li>
      <li>
        <a href="https://code.quarkus.io" class="button-cta secondary white">COMECE
A CODIFICAR</a>
      </li>
      <li class="dropdown">
        <span href="/language/"><div class="fas fa-globe langicon"></div><i class="fas fa-chevron-down"></i></span>
        <ul class="submenu">
          <li><a href="https://quarkus.io/version/2.13/guides/writing-extensions" >OFFICIAL (ENGLISH)</a></li>
          <li><a href="https://pt.quarkus.io/version/2.13/guides/writing-extensions">PORTUGUÊS (BR)</a></li>
          <li><a href="https://es.quarkus.io/version/2.13/guides/writing-extensions">ESPAÑOL</a></li>
          <li><a href="https://cn.quarkus.io/version/2.13/guides/writing-extensions">简体中文</a></li>
          <li><a href="https://ja.quarkus.io/version/2.13/guides/writing-extensions">日本語</a></li>
          </ul>
      </li>
      <li>
        <span href="#" class="modeswitcher" id='theme-toggle'><i class="fas
fa-sun"></i><i class="fas fa-moon"></i><i class="fas fa-cog"></i></span>
      </li>
    </ul>
      </nav>
    </div>
  </div>
</div>

  <div class="content">
    





<section class="full-width-version-bg flexfilterbar guides">
    <div class="guideflexcontainer">
        <div class="docslink">
            <a class="returnlink" href="/version/2.13/guides/"> Voltar aos Guias</a>
        </div>
        <div class="flexlabel">
            <label>Por Versão</label>
        </div>
        <div class="guidepulldown version">
            <select id="guide-version-dropdown">
                
                
                
                <option value="main" >Main - SNAPSHOT</option>
                
                
                
                <option value="latest" >3.32.1 - Latest</option>
                
                
                
                <option value="3.27" >3.27</option>
                
                
                
                <option value="3.20" >3.20</option>
                
                
                
                <option value="3.15" >3.15</option>
                
                
                
                <option value="3.8" >3.8</option>
                </select>
        </div>
    </div>
</section>

<div class="guide">
    <div class="grid-wrapper">
        <div class="grid__item width-8-12 width-12-12-m">
            <h1 class="text-caps">Escrevendo sua própria extensão </h1>
            <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>As extensões Quarkus acrescentam um novo comportamento focado no programador na oferta principal e consistem em duas partes distintas, o aumento do tempo de construção e o contêiner de tempo de execução. A parte de aumento é responsável por todo o processamento de metadados, como a leitura de anotações, descritores XML, etc. O resultado desta fase de aumento é um bytecode registrado que é responsável por instanciar diretamente os serviços de tempo de execução relevantes.</p>
</div>
<div class="paragraph">
<p>Isso significa que os metadados são processados apenas uma vez no momento da construção, o que economiza no tempo de inicialização e também no uso da memória, pois as classes etc usadas para o processamento não são carregadas (ou mesmo presentes) na JVM em tempo de execução.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Esta é uma documentação aprofundada, consulte a seção <a href="building-my-first-extension">construindo minha primeira extensão</a> se precisar de uma introdução.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="extension-philosophy"><a class="anchor" href="#extension-philosophy"></a>1. Filosofia da extensão</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Esta seção é um trabalho em curso e reúne a filosofia segundo a qual as extensões devem ser concebidas e escritas.</p>
</div>
<div class="sect2">
<h3 id="why-an-extension-framework"><a class="anchor" href="#why-an-extension-framework"></a>1.1. Por que um framework de extensão</h3>
<div class="paragraph">
<p>A missão do Quarkus é transformar toda a sua aplicação, inclusive as bibliotecas que ele usa, em um artefato que utiliza significativamente menos recursos do que as abordagens tradicionais. Esses recursos podem então ser usados para criar aplicações nativos usando GraalVM. Para fazer isso, você precisa analisar e entender o "mundo fechado" completo da aplicação. Sem o contexto total e completo, o melhor que se pode conseguir é um suporte genérico parcial e limitado. Ao usar a abordagem de extensão Quarkus, podemos alinhar as aplicações Java com ambientes com restrições de espaço de memória, como Kubernetes ou plataformas de nuvem.</p>
</div>
<div class="paragraph">
<p>O framework de extensão do Quarkus resulta em uma utilização de recursos significativamente melhor, mesmo quando o GraalVM não é usado (por exemplo, no HotSpot). Vamos listar as ações que uma extensão executa:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Recolher metadados de tempo de construção e gerar código</p>
<div class="ulist">
<ul>
<li>
<p>Esta parte não tem nada a ver com o GraalVM, é a forma como o Quarkus inicia os frameworks "no momento da construção"</p>
</li>
<li>
<p>O framework de extensão facilita a leitura de metadados, a pesquisa de classes e a geração de classes conforme necessário</p>
</li>
<li>
<p>Uma pequena parte do trabalho de extensão é executada em tempo de execução através das classes geradas, enquanto a maior parte do trabalho é feita em tempo de construção (chamado tempo de implantação)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Aplicar padrões sensatos e opinativos com base na visão global próxima da aplicação (por exemplo, uma aplicação sem <code>@Entity</code> não precisa iniciar o Hibernate ORM)</p>
</li>
<li>
<p>Uma extensão hospeda a substituição de código da Substrate VM para que as bibliotecas possam ser executadas no GraalVM</p>
<div class="ulist">
<ul>
<li>
<p>A maioria das alterações são encaminhadas para a versão original do código para ajudar a biblioteca subjacente a rodar no GraalVM</p>
</li>
<li>
<p>Nem todas as alterações podem ser encaminhadas para a versão original do código, as extensões hospedam substituições da Substrate VM - que é uma forma de correção de código - para que as bibliotecas possam ser executadas</p>
</li>
</ul>
</div>
</li>
<li>
<p>Hospedar a substituição de código da Substrate VM para ajudar a eliminar o código morto com base nas necessidades da aplicação</p>
<div class="ulist">
<ul>
<li>
<p>Isto depende da aplicação e não pode ser realmente compartilhado na própria biblioteca</p>
</li>
<li>
<p>Por exemplo, o Quarkus otimiza o código do Hibernate porque sabe que só precisa de um conjunto de conexões e de um fornecedor de cache específicos</p>
</li>
</ul>
</div>
</li>
<li>
<p>Enviar metadados ao GraalVM para classes de exemplo que precisam de reflexão</p>
<div class="ulist">
<ul>
<li>
<p>Esta informação não é estática por biblioteca (por exemplo, Hibernate), mas o framework tem o conhecimento semântico e sabe quais as classes que precisam ter reflexão (por exemplo, classes @Entity)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="favor-build-time-work-over-runtime-work"><a class="anchor" href="#favor-build-time-work-over-runtime-work"></a>1.2. Favorecer o trabalho em tempo de construção em detrimento do trabalho em tempo de execução</h3>
<div class="paragraph">
<p>Na medida do possível, prefira fazer o trabalho no momento da construção(parte de implantação da extensão) em vez de deixar que o framework faça o trabalho no momento da inicialização (tempo de execução). Quanto mais trabalho for feito ali, menores serão as aplicações Quarkus que usam essa extensão e mais rápido elas serão carregadas.</p>
</div>
</div>
<div class="sect2">
<h3 id="how-to-expose-configuration"><a class="anchor" href="#how-to-expose-configuration"></a>1.3. Como expor a configuração</h3>
<div class="paragraph">
<p>O Quarkus simplifica os usos mais comuns. Isso significa que seus padrões podem ser diferentes da biblioteca que ele integra.</p>
</div>
<div class="paragraph">
<p>Para tornar a experiência simples mais fácil, unifique a configuração em <code>application.properties</code> por meio do SmallRye Config. Evite arquivos de configuração específicos de bibliotecas ou, pelo menos, torne-os opcionais: por exemplo, <code>persistence.xml</code> para Hibernate ORM é opcional.</p>
</div>
<div class="paragraph">
<p>As extensões devem ver a configuração de forma holística como uma aplicação Quarkus em vez de se concentrarem na experiência da biblioteca. Por exemplo, <code>quarkus.database.url</code> e amigos são compartilhados entre as extensões, pois a definição de um acesso ao banco de dados é uma tarefa compartilhada (em vez de uma propriedade <code>hibernate.</code> , por exemplo). As opções de configuração mais úteis devem ser expostas como <code>quarkus.[extension].</code> em vez do namespace natural da biblioteca. As propriedades menos comuns podem residir no namespace da biblioteca.</p>
</div>
<div class="paragraph">
<p>Para habilitar totalmente as suposições de mundo fechado que o Quarkus pode otimizar melhor, é melhor considerar as opções de configuração como estabelecidas no tempo de construção em vez de substituíveis no tempo de execução. É claro que propriedades como host, porta e senha devem ser substituíveis em tempo de execução. Mas muitas propriedades, como ativar o armazenamento em cache ou definir o driver JDBC, podem exigir com segurança uma reconstrução do aplicativo.</p>
</div>
<div class="sect3">
<h4 id="static-init-config"><a class="anchor" href="#static-init-config"></a>1.3.1. Configuração de Inicialização Estática</h4>
<div class="paragraph">
<p>If the extension provides additional Config Sources and if these are required during Static Init, these must be registered with <code>StaticInitConfigSourceProviderBuildItem</code>. Configuration in Static Init does not scan for additional sources to avoid double initialization at application startup time.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="expose-your-components-via-cdi"><a class="anchor" href="#expose-your-components-via-cdi"></a>1.4. Exponha os seus componentes através de CDI</h3>
<div class="paragraph">
<p>Como a CDI é o modelo de programação central no que se refere à composição de componentes, os frameworks e as extensões devem expor seus componentes como beans facilmente consumíveis pelas aplicações do usuário. Por exemplo, o Hibernate ORM expõe os beans <code>EntityManagerFactory</code> e <code>EntityManager</code> , o pool de conexões expõe os beans <code>DataSource</code> etc. As extensões devem registrar essas definições de beans no momento da construção.</p>
</div>
<div class="sect3">
<h4 id="beans-backed-by-classes"><a class="anchor" href="#beans-backed-by-classes"></a>1.4.1. Beans apoiados por classes</h4>
<div class="paragraph">
<p>Uma extensão pode produzir um <a href="cdi-integration#additional_bean_build_item"><code>AdditionalBeanBuildItem</code></a> para instruir o contêiner a ler uma definição de bean de uma classe como se esta fizesse parte da aplicação original:</p>
</div>
<div class="listingblock">
<div class="title">Classe de Bean Registrada por <code>AdditionalBeanBuildItem</code></div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Singleton <i class="conum" data-value="1"></i><b>(1)</b>
public class Echo {

   public String echo(String val) {
      return val;
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Se um bean registrado por um <code>AdditionalBeanBuildItem</code> não especificar um escopo, assume-se <code>@Dependent</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Todos os outros beans podem injetar esse bean:</p>
</div>
<div class="listingblock">
<div class="title">Bean Injetando um Bean Produzido por um <code>AdditionalBeanBuildItem</code></div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Path("/hello")
public class ExampleResource {

    @Inject
    Echo echo;

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello(String foo) {
        return echo.echo(foo);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>E vice-versa - o bean de extensão pode injetar beans de aplicação e beans fornecidos por outras extensões:</p>
</div>
<div class="listingblock">
<div class="title">Exemplo de Injeção de Bean de Extensão</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Singleton
public class Echo {

    @Inject
    DataSource dataSource;  <i class="conum" data-value="1"></i><b>(1)</b>

    @Inject
    Instance&lt;List&lt;String&gt;&gt; listsOfStrings; <i class="conum" data-value="2"></i><b>(2)</b>

    //...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Injetar um bean fornecido por outra extensão.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Injetar todos os beans que correspondam ao tipo <code>List&lt;String&gt;</code>.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="bean_init"><a class="anchor" href="#bean_init"></a>1.4.2. Inicialização do bean</h4>
<div class="paragraph">
<p>Some components may require additional initialization based on information collected during augmentation.
The most straightforward solution is to obtain a bean instance and call a method directly from a build step.
However, it is <em>illegal</em> to obtain a bean instance during the augmentation phase.
The reason is that the CDI container is not started yet.
It&#8217;s started during the <a href="#bootstrap-three-phases">Static init bootstrap phase</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
As raízes de configuração <code>BUILD_AND_RUN_TIME_FIXED</code> e <code>RUN_TIME</code> podem ser injetadas em qualquer bean. No entanto, raízes de configuração <code>RUN_TIME</code> só devem ser injetadas após o bootstrap.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is possible to invoke a bean method from a <a href="#bytecode-recording">recorder method</a> though.
If you need to access a bean in a <code>@Record(STATIC_INIT)</code> build step then is must either depend on the <code>BeanContainerBuildItem</code> or wrap the logic in a <code>BeanContainerListenerBuildItem</code>.
The reason is simple - we need to make sure the CDI container is fully initialized and started.
However, it is safe to expect that the CDI container is fully initialized and running in a <code>@Record(RUNTIME_INIT)</code> build step.
You can obtain a reference to the container via <code>CDI.current()</code> or Quarkus-specific <code>Arc.container()</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Não se esqueça de se certificar de que o estado do bean garante a visibilidade, por exemplo, através da palavra-chave <code>volatile</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is one significant drawback of this "late initialization" approach.
An <em>uninitialized</em> bean may be accessed by other extensions or application components that are instantiated during bootstrap.
We&#8217;ll cover a more robust solution in the <a href="#synthetic_beans">Beans sintéticos</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="default-beans"><a class="anchor" href="#default-beans"></a>1.4.3. Beans padrões</h4>
<div class="paragraph">
<p>Um padrão muito útil para criar esses beans, mas que também dá ao código do aplicativo a capacidade de substituir facilmente alguns beans com implementações personalizadas, é usar o <code>@DefaultBean</code> que o Quarkus fornece. É melhor explicar isso com um exemplo.</p>
</div>
<div class="paragraph">
<p>Suponhamos que a extensão Quarkus precisa fornecer um <code>Tracer</code> bean que o código da aplicação deve injetar nos seus próprios beans.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Dependent
public class TracerConfiguration {

    @Produces
    public Tracer tracer(Reporter reporter, Configuration configuration) {
        return new Tracer(reporter, configuration);
    }

    @Produces
    @DefaultBean
    public Configuration configuration() {
        // create a Configuration
    }

    @Produces
    @DefaultBean
    public Reporter reporter(){
        // create a Reporter
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se, por exemplo, o código da aplicação quiser utilizar <code>Tracer</code>, mas também precisar utilizar um bean <code>Reporter</code> personalizado, esse requisito pode ser facilmente cumprido utilizando algo do gênero:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Dependent
public class CustomTracerConfiguration {

    @Produces
    public Reporter reporter(){
        // create a custom Reporter
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="how-to-override-a-bean-defined-by-a-libraryquarkus-extension-that-doesnt-use-defaultbean"><a class="anchor" href="#how-to-override-a-bean-defined-by-a-libraryquarkus-extension-that-doesnt-use-defaultbean"></a>1.4.4. Como Substituir um Bean Definido por uma Biblioteca/Extensão Quarkus que não utiliza @DefaultBean</h4>
<div class="paragraph">
<p>Embora <code>@DefaultBean</code> seja a abordagem recomendada, também é possível que o código da aplicação substitua os beans fornecidos por uma extensão marcando-os como um CDI <code>@Alternative</code> e incluindo a anotação <code>@Priority</code> . Vamos mostrar um exemplo simples. Suponha que trabalhamos em uma extensão imaginária "quarkus-parser" e que temos uma implementação de bean padrão:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Dependent
class Parser {

  String[] parse(String expression) {
    return expression.split("::");
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>E a nossa extensão também consome este parser:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@ApplicationScoped
class ParserService {

  @Inject
  Parser parser;

  //...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Agora, se um usuário ou mesmo outra extensão precisa substituir a implementação padrão do <code>Parser</code>, a solução mais simples é utilizar CDI <code>@Alternative</code> + <code>@Priority</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Alternative <i class="conum" data-value="1"></i><b>(1)</b>
@Priority(1) <i class="conum" data-value="2"></i><b>(2)</b>
@Singleton
class MyParser extends Parser {

  String[] parse(String expression) {
    // my super impl...
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>MyParser</code> é um bean alternativo.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Habilita a alternativa. A prioridade pode ser qualquer número para substituir o bean padrão, mas se existirem várias alternativas, a prioridade mais elevada ganha.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As alternativas CDI só são consideradas durante a injeção e a resolução da tipagem segura. Por exemplo, a implementação padrão continuaria a receber notificações do observador.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="synthetic_beans"><a class="anchor" href="#synthetic_beans"></a>1.4.5. Beans sintéticos</h4>
<div class="paragraph">
<p>Às vezes, é muito útil poder registrar um bean sintético. Os atributos de bean de um bean sintético não são derivados de uma classe, método ou campo Java. Em vez disso, os atributos são especificados por uma extensão.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Como o contêiner CDI não controla a instanciação de um bean sintético, não há suporte para injeção de dependência e outros serviços (como interceptadores). Em outras palavras, cabe à extensão fornecer todos os serviços necessários a uma instância de bean sintético.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are several ways to register a <a href="cdi-reference#synthetic_beans">synthetic bean</a> in Quarkus.
In this chapter, we will cover a use case that can be used to initialize extension beans in a safe manner (compared to <a href="#bean_init">Inicialização do bean</a>).</p>
</div>
<div class="paragraph">
<p>O <code>SyntheticBeanBuildItem</code> pode ser utilizado para registrar um bean sintético:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>whose instance can be easily produced through a <a href="#bytecode-recording">recorder</a>,</p>
</li>
<li>
<p>para fornecer um bean de "contexto" que contém todas as informações recolhidas durante a ampliação, de modo a que os componentes reais não necessitem de qualquer "inicialização tardia" porque podem injetar diretamente o bean de contexto.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Instância Produzida Através do Gravador</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildStep
@Record(STATIC_INIT)
SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {
   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)
                .runtimeValue(recorder.createFoo("parameters are recorder in the bytecode")) <i class="conum" data-value="1"></i><b>(1)</b>
                .done();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>O valor da string é gravado no bytecode e utilizado para inicializar a instância de <code>Foo</code>.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Portador do "Contexto"</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildStep
@Record(STATIC_INIT)
SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {
   return SyntheticBeanBuildItem.configure(TestContext.class).scope(Singleton.class)
                .runtimeValue(recorder.createContext("parameters are recorder in the bytecode")) <i class="conum" data-value="1"></i><b>(1)</b>
                .done();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Os componentes "reais" podem injetar diretamente o <code>TestContext</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="some-types-of-extensions"><a class="anchor" href="#some-types-of-extensions"></a>1.5. Alguns tipos de extensões</h3>
<div class="paragraph">
<p>Existem vários estereótipos de extensão, vamos enumerar alguns.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Biblioteca nua em funcionamento</dt>
<dd>
<p>Essa é a extensão menos sofisticada. Ela consiste em um conjunto de patches para garantir que uma biblioteca seja executada no GraalVM. Se possível, contribua com esses patches na fonte original, não em extensões. A segunda melhor opção é escrever substituições de Substrate VM, que são patches aplicados durante a compilação da imagem nativa.</p>
</dd>
<dt class="hdlist1">Colocar um framework em funcionamento</dt>
<dd>
<p>Um framework em tempo de execução normalmente lê a configuração, examina o classpath e as classes em busca de metadados (anotações, getters etc.), constrói um metamodelo sobre o qual é executado, encontra opções por meio do padrão do carregador de serviços, prepara chamadas de invocação (reflexão), interfaces de proxy etc.

 Essas operações devem ser feitas no momento da construção e o metamodelo deve ser passado para a DSL do gravador, que gerará classes que serão executadas no tempo de execução e inicializarão o framework.</p>
</dd>
<dt class="hdlist1">Colocar uma extensão portátil CDI em funcionamento</dt>
<dd>
<p>O modelo de extensão portátil do CDI é muito flexível. Flexível demais para se beneficiar da inicialização do tempo de construção promovida pelo Quarkus. A maioria das extensões que vimos não faz uso desses recursos de extrema flexibilidade. A maneira de portar uma extensão CDI para o Quarkus é reescrevê-la como uma extensão Quarkus que definirá os vários beans no momento da construção (tempo de implantação no jargão da extensão).</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="technical-aspect"><a class="anchor" href="#technical-aspect"></a>2. Aspecto técnico</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="bootstrap-three-phases"><a class="anchor" href="#bootstrap-three-phases"></a>2.1. Três Fases do Bootstrap e Filosofia do Quarkus</h3>
<div class="paragraph">
<p>Há três fases distintas de bootstrap de uma aplicação Quarkus:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Ampliação</dt>
<dd>
<p>This is the first phase, and is done by the <a href="#Build Step Processors">[Build Step Processors]</a>. These processors have access to Jandex annotation
information and can parse any descriptors and read annotations, but should not attempt to load any application classes. The output of these
build steps is some recorded bytecode, using an extension of the ObjectWeb ASM project called Gizmo(ext/gizmo), that is used to actually bootstrap the application at runtime. Depending on the <code>io.quarkus.deployment.annotations.ExecutionTime</code> value of the <code>@io.quarkus.deployment.annotations.Record</code> annotation associated with the build step,
the step may be run in a different JVM based on the following two modes.</p>
</dd>
<dt class="hdlist1">Inicialização Estática</dt>
<dd>
<p>Se o bytecode for gravado com <code>@Record(STATIC_INIT)</code> , ele será executado a partir de um método de inicialização estático na classe principal. Para uma construção executável nativa, esse código é executado em uma JVM normal como parte do processo de construção nativa, e quaisquer objetos retidos que forem produzidos nesse estágio serão serializados diretamente no executável nativo por meio de um arquivo mapeado de imagem. Isso significa que, se um framework puder inicializar nessa fase, ela terá seu estado inicializado gravado diretamente na imagem e, portanto, o código de inicialização não precisará ser executado quando a imagem for iniciada.</p>
<div class="paragraph">
<p>Existem algumas restrições sobre o que pode ser feito nesta fase, uma vez que a Substrate VM não permite alguns objetos no executável nativo. Por exemplo, não se deve tentar escutar numa porta ou iniciar threads nesta fase. Além disso, não é permitido ler a configuração em tempo de execução durante a inicialização estática.</p>
</div>
<div class="paragraph">
<p>No modo JVM puro não nativo, não há diferença real entre Inicialização Estática e Inicialização Em Tempo de Execução, exceto pelo fato de que a inicialização estática é sempre executada primeiro. Esse modo se beneficia da mesma ampliação da fase de construção que o modo nativo, pois a análise do descritor e a varredura de anotações são feitas no momento da construção e quaisquer dependências de classe/framework associadas podem ser removidas do jar de saída da construção. Em servidores como o WildFly, as classes relacionadas à implantação, como os analisadores XML, permanecem durante todo o tempo de vida da aplicação, utilizando uma memória valiosa. O objetivo do Quarkus é eliminar isso, de modo que as únicas classes carregadas em tempo de execução sejam realmente usadas em tempo de execução.</p>
</div>
<div class="paragraph">
<p>Por exemplo, o único motivo pelo qual uma aplicação Quarkus deve carregar um analisador XML é se o usuário estiver usando XML em sua aplicação. Qualquer análise de XML da configuração deve ser feita na fase de ampliação.</p>
</div>
</dd>
<dt class="hdlist1">Inicialização em Tempo de Execução</dt>
<dd>
<p>Se o bytecode for gravado com <code>@Record(RUNTIME_INIT)</code>, ele será executado a partir do método principal do aplicativo. Esse código será executado na inicialização do executável nativo. Em geral, o mínimo possível de código deve ser executado nessa fase e deve ser restrito ao código que precisa abrir portas etc.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Empurrar o máximo possível para a fase <code>@Record(STATIC_INIT)</code> permite duas otimizações diferentes:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Tanto no modo executável nativo quanto no modo JVM puro, isso permite que a aplicação seja iniciada o mais rápido possível, pois o processamento foi feito durante o tempo de construção. Isto também minimiza as classes/código nativo necessário na aplicação para comportamentos puramente relacionados com o tempo de execução.</p>
</li>
<li>
<p>Outra vantagem do modo executável nativo é que o Substrate pode eliminar mais facilmente os recursos que não são usados. Se os recursos forem inicializados diretamente via bytecode, o Substrate pode detectar que um método nunca é chamado e eliminar esse método. Se a configuração for lida em tempo de execução, o Substrate não pode raciocinar sobre o conteúdo da configuração e, portanto, precisa manter todos os recursos, caso sejam necessários.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="project-setup"><a class="anchor" href="#project-setup"></a>2.2. Configuração do projeto</h3>
<div class="paragraph">
<p>O seu projeto de extensão deve ser configurado como um projeto multi-módulo com dois submódulos:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Um submódulo de tempo de implantação que trata do processamento do tempo de construção e da gravação de bytecode.</p>
</li>
<li>
<p>Um submódulo de tempo de execução que contém o comportamento de tempo de execução que fornecerá o comportamento de extensão no executável nativo ou na JVM de tempo de execução.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Seu artefato de tempo de execução deve depender de <code>io.quarkus:quarkus-core</code> e, possivelmente, dos artefatos de tempo de execução de outros módulos do Quarkus, se você quiser usar a funcionalidade fornecida por eles. Seu módulo de tempo de implantação deve depender de <code>io.quarkus:quarkus-core-deployment</code>, do seu artefato de tempo de execução e, possivelmente, dos artefatos de implantação de outros módulos do Quarkus, caso queira usar a funcionalidade fornecida por eles.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Em nenhuma circunstância o módulo de tempo de execução pode depender de um artefato de implantação. Isso resultaria em puxar todo o código de tempo de implantação para o escopo de tempo de execução, o que anula o objetivo de ter a divisão.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="using-maven"><a class="anchor" href="#using-maven"></a>2.2.1. Utilizando o Maven</h4>
<div class="paragraph">
<p>Você precisa incluir o <code>io.quarkus:quarkus-extension-maven-plugin</code> e configurar o <code>maven-compiler-plugin</code> para detectar o processador de anotações <code>quarkus-extension-processor</code> para recolher e gerar os <a href="extension-metadata.html">metadados de extensão Quarkus</a> necessários para os artefatos de extensão. Se estiver utilizando o pom principal do Quarkus, este herdará automaticamente a configuração correta.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You may want to use the <code>create-extension</code> mojo of <code>io.quarkus.platform:quarkus-maven-plugin</code> to create these Maven modules - see the next section.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Por convenção, o artefato de tempo de implantação tem o sufixo <code>-deployment</code> e o artefato de tempo de execução não tem sufixo (e é o que o usuário final adiciona ao seu projeto).
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
      &lt;artifactId&gt;quarkus-core&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
            &lt;artifactId&gt;quarkus-extension-maven-plugin&lt;/artifactId&gt;
            &lt;!-- Executions configuration can be inherited from quarkus-build-parent --&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;extension-descriptor&lt;/goal&gt;
                    &lt;/goals&gt;
                    &lt;configuration&gt;
                         &lt;deployment&gt;${project.groupId}:${project.artifactId}-deployment:${project.version}&lt;/deployment&gt;
                   &lt;/configuration&gt;
               &lt;/execution&gt;
           &lt;/executions&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;annotationProcessorPaths&gt;
                    &lt;path&gt;
                        &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
                        &lt;artifactId&gt;quarkus-extension-processor&lt;/artifactId&gt;
                    &lt;/path&gt;
                &lt;/annotationProcessorPaths&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A configuração <code>maven-compiler-plugin</code> acima requer a versão 3.5+.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Também será necessário configurar o <code>maven-compiler-plugin</code> do módulo de implantação para detectar o processador de anotações <code>quarkus-extension-processor</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
        &lt;artifactId&gt;quarkus-core-deployment&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;annotationProcessorPaths&gt;
                    &lt;path&gt;
                        &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
                        &lt;artifactId&gt;quarkus-extension-processor&lt;/artifactId&gt;
                    &lt;/path&gt;
                &lt;/annotationProcessorPaths&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="create-new-quarkus-core-extension-modules-using-maven"><a class="anchor" href="#create-new-quarkus-core-extension-modules-using-maven"></a>2.2.1.1. Criar novos módulos de extensão do Quarkus Core utilizando o Maven</h5>
<div class="paragraph">
<p>O Quarkus fornece o Mojo <code>create-extension</code> do Maven para inicializar o seu projeto de extensão.</p>
</div>
<div class="paragraph">
<p>Ele tentará detectar automaticamente as suas opções:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a partir do diretório <code>quarkus</code> (Quarkus Core) ou <code>quarkus/extensions</code>, ele utilizará a layout de extensão 'Quarkus Core' e os padrões.</p>
</li>
<li>
<p>com <code>-DgroupId=io.quarkiverse.[extensionId]</code>, ele utilizará o esquema e as predefinições da extensão 'Quarkiverse'.</p>
</li>
<li>
<p>em outros casos, utilizará o layout e os padrões da extensão "Standalone".</p>
</li>
<li>
<p>podemos introduzir outros tipos de layout no futuro.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You may not specify any parameter to use the interactive mode: <code>mvn io.quarkus.platform:quarkus-maven-plugin:2.13.9.Final:create-extension -N</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Como exemplo, vamos adicionar uma nova extensão chamada <code>my-ext</code> à árvore de origem do Quarkus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">git clone https://github.com/quarkusio/quarkus.git
cd quarkus
mvn io.quarkus.platform:quarkus-maven-plugin:2.13.9.Final:create-extension -N \
    -DextensionId=my-ext \
    -DextensionName="My Extension" \
    -DextensionDescription="Do something useful."</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Por padrão, <code>groupId</code>, <code>version</code>, <code>quarkusVersion</code>, <code>namespaceId</code>, e <code>namespaceName</code> serão consistentes com outras extensões do núcleo do Quarkus.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
A descrição da extensão é importante, uma vez que é apresentada em <a href="https://code.quarkus.io/" class="bare">https://code.quarkus.io/</a>, ao listar extensões com o Quarkus CLI, etc.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A sequência de comandos acima faz o seguinte:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cria quatro novos módulos Maven:</p>
<div class="ulist">
<ul>
<li>
<p><code>quarkus-my-ext-parent</code> no diretório <code>extensions/my-ext</code></p>
</li>
<li>
<p><code>quarkus-my-ext</code> no diretório <code>extensions/my-ext/runtime</code></p>
</li>
<li>
<p><code>quarkus-my-ext-deployment</code> no diretório <code>extensions/my-ext/deployment</code>; neste módulo é gerada uma classe básica <code>MyExtProcessor</code>.</p>
</li>
<li>
<p><code>quarkus-my-ext-integration-test</code> in the <code>integration-tests/my-ext/deployment</code> directory; an empty JAX-RS Resource class and two test classes (for JVM mode and native mode) are generated in this module.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Liga estes três módulos onde necessário:</p>
<div class="ulist">
<ul>
<li>
<p><code>quarkus-my-ext-parent</code> é adicionado ao <code>&lt;modules&gt;</code> do <code>quarkus-extensions-parent</code></p>
</li>
<li>
<p><code>quarkus-my-ext</code> é adicionado ao <code>&lt;dependencyManagement&gt;</code> do BOM (Bill of Materials) do Quarkus <code>bom/application/pom.xml</code></p>
</li>
<li>
<p><code>quarkus-my-ext-deployment</code> é adicionado ao <code>&lt;dependencyManagement&gt;</code> do BOM (Bill of Materials) do Quarkus <code>bom/application/pom.xml</code></p>
</li>
<li>
<p><code>quarkus-my-ext-integration-test</code> é adicionado ao sítio <code>&lt;modules&gt;</code> de <code>quarkus-integration-tests-parent</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Você também precisa preencher o arquivo de modelo <a href="extension-metadata#quarkus-extension-yaml">quarkus-extension.yaml</a> que descreve a sua extensão dentro da pasta <code>src/main/resources/META-INF</code> do módulo de tempo de execução.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Este é o modelo <code>quarkus-extension.yaml</code> da extensão <code>quarkus-agroal</code>. Pode utilizá-lo como exemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">name: "Agroal - Database connection pool" <i class="conum" data-value="1"></i><b>(1)</b>
metadata:
  keywords: <i class="conum" data-value="2"></i><b>(2)</b>
  - "agroal"
  - "database-connection-pool"
  - "datasource"
  - "jdbc"
  guide: "https://quarkus.io/guides/datasource" <i class="conum" data-value="3"></i><b>(3)</b>
  categories: <i class="conum" data-value="4"></i><b>(4)</b>
  - "data"
  status: "stable" <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>o nome da extensão que será apresentada aos usuários</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>palavras-chave que podem ser usadas para encontrar a extensão no catálogo de extensões</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>link para o guia ou documentação da extensão</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>as categorias em que a extensão deve aparecer em <a href="https://code.quarkus.io">code.quarkus.io</a>, podem ser omitidas, caso em que a extensão continuará a ser listada mas não numa categoria específica</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>estado de maturidade, que pode ser <code>stable</code>, <code>preview</code> ou <code>experimental</code>, avaliado pelos responsáveis pela extensão</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
O parâmetro <code>name</code> do mojo é opcional. Se você não o especificar na linha de comando, o plug-in o derivará de <code>extensionId</code> substituindo os traços por espaços e colocando cada token em caixa alta. Portanto, você pode considerar omitir explicitamente <code>name</code> em alguns casos.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Consulte o <a href="https://github.com/quarkusio/quarkus/blob/2.13.9.Final/devtools/maven/src/main/java/io/quarkus/maven/CreateExtensionMojo.java">JavaDoc do CreateExtensionMojo</a> para conhecer todas as opções disponíveis do mojo.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-gradle"><a class="anchor" href="#using-gradle"></a>2.2.2. Usando Gradle</h4>
<div class="paragraph">
<p>Você precisará aplicar o plug-in <code>io.quarkus.extension</code> no módulo <code>runtime</code> do seu projeto de extensão. O plug-in inclui a tarefa <code>extensionDescriptor</code> que gerará os arquivos <code>META-INF/quarkus-extension.properties</code> e <code>META-INF/quarkus-extension.yml</code>. O plug-in também habilita o processador de anotações <code>io.quarkus:quarkus-extension-processor</code> nos módulos <code>deployment</code> e <code>runtime</code> para coletar e gerar o restante dos <a href="extension-metadata">metadados da extensão Quarkus</a>. O nome do módulo de implantação pode ser configurado no plug-in, definindo a propriedade <code>deploymentModule</code>. A propriedade é definida como <code>deployment</code> por padrão:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">plugins {
    id 'java'
    id 'io.quarkus.extension'
}

quarkusExtension {
    deploymentModule = 'deployment'
}

dependencies {
    implementation platform('io.quarkus:quarkus-bom:2.13.9.Final')
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Este plugin ainda é experimental, não valida as dependências da extensão como faz o plugin Maven equivalente.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="build-step-processors"><a class="anchor" href="#build-step-processors"></a>2.3. Processadores de Etapas de Construção</h3>
<div class="paragraph">
<p>O trabalho é feito no momento da ampliação por <em>etapas de construção</em> que produzem e consomem <em>itens de construção</em>. As etapas de construção encontradas nos módulos de implantação que correspondem às extensões na construção do projeto são automaticamente conectadas e executadas para produzir o(s) artefato(s) de construção final.</p>
</div>
<div class="sect3">
<h4 id="build-steps"><a class="anchor" href="#build-steps"></a>2.3.1. Etapas de Construção</h4>
<div class="paragraph">
<p>A <em>build step</em> is a non-static method which is annotated with the <code>@io.quarkus.deployment.annotations.BuildStep</code> annotation.
Each build step may <a href="#consuming-values">consume</a> items that are produced by earlier stages, and <a href="#producing-values">produce</a> items that can be consumed by later stages. Build steps are normally only run when they produce a build item that is
ultimately consumed by another step.</p>
</div>
<div class="paragraph">
<p>Build steps are normally placed on plain classes within an extension&#8217;s deployment module.  The classes are automatically
instantiated during the augment process and utilize <a href="#injection">injection</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="build-items"><a class="anchor" href="#build-items"></a>2.3.2. Itens de Construção</h4>
<div class="paragraph">
<p>Build items are concrete, final subclasses of the abstract <code>io.quarkus.builder.item.BuildItem</code> class.  Each build item represents
some unit of information that must be passed from one stage to another.  The base <code>BuildItem</code> class may not itself be directly
subclassed; rather, there are abstract subclasses for each of the kinds of build item subclasses that <em>may</em> be created:
<a href="#simple-build-items">simple</a>, <a href="#multi-build-items">multi</a>, and <a href="#empty-build-items">empty</a>.</p>
</div>
<div class="paragraph">
<p>Pense nos itens de construção como uma forma das diferentes extensões comunicarem umas com as outras. Por exemplo, um item de construção pode:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>expor o fato de existir uma configuração da base de dados</p>
</li>
<li>
<p>consumir essa configuração de base de dados (por exemplo, uma extensão de pool de conexões ou uma extensão ORM)</p>
</li>
<li>
<p>solicitar que uma extensão faça o trabalho para outra extensão: por exemplo, uma extensão que deseja definir um novo bean CDI e solicita que a extensão ArC o faça</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Trata-se de um mecanismo muito flexível.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>BuildItem</code> devem ser imutáveis, pois o modelo produtor/consumidor não permite que a mutação seja ordenada corretamente. Isso não é imposto, mas a não observância dessa regra pode resultar em condições de corrida.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Os passos de construção são executados se e somente se eles produzem itens de construção que são (transitivamente) necessários para outros passos de construção. Certifique-se de que sua etapa de construção produz um item de construção, caso contrário, você provavelmente deve produzir <code>ValidationErrorBuildItem</code> para validações de construção, ou <code>ArtifactResultBuildItem</code> para artefatos gerados.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="simple-build-items"><a class="anchor" href="#simple-build-items"></a>2.3.2.1. Itens de construção simples</h5>
<div class="paragraph">
<p>Os itens de construção simples são classes finais que estendem <code>io.quarkus.builder.item.SimpleBuildItem</code>. Os itens de construção simples só podem ser produzidos por uma etapa em uma determinada construção; se várias etapas em uma construção declararem que produzem o mesmo item de construção simples, será gerado um erro. Qualquer número de etapas de construção pode consumir um item de construção simples. Uma etapa de construção que consome um item de construção simples sempre será executada <em>após</em> a etapa de construção que produziu esse item.</p>
</div>
<div class="listingblock">
<div class="title">Exemplo de um item de construção individual</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">/**
 * The build item which represents the Jandex index of the application,
 * and would normally be used by many build steps to find usages
 * of annotations.
 */
public final class ApplicationIndexBuildItem extends SimpleBuildItem {

    private final Index index;

    public ApplicationIndexBuildItem(Index index) {
        this.index = index;
    }

    public Index getIndex() {
        return index;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="multi-build-items"><a class="anchor" href="#multi-build-items"></a>2.3.2.2. Itens de construção múltipla</h5>
<div class="paragraph">
<p>Itens de construção múltipla ou "multi" são classes finais que estendem <code>io.quarkus.builder.item.MultiBuildItem</code>. Qualquer número de itens de construção múltipla de uma determinada classe pode ser produzido por qualquer número de etapas, mas qualquer etapa que consuma itens de construção múltipla só será executada <em>após a</em> execução de todas as etapas que podem produzi-los.</p>
</div>
<div class="listingblock">
<div class="title">Exemplo de um item de construção múltipla</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">public final class ServiceWriterBuildItem extends MultiBuildItem {
    private final String serviceName;
    private final List&lt;String&gt; implementations;

    public ServiceWriterBuildItem(String serviceName, String... implementations) {
        this.serviceName = serviceName;
        // Make sure it's immutable
        this.implementations = Collections.unmodifiableList(
            Arrays.asList(
                implementations.clone()
            )
        );
    }

    public String getServiceName() {
        return serviceName;
    }

    public List&lt;String&gt; getImplementations() {
        return implementations;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemplo de utilização de vários itens de construção</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">/**
 * This build step produces a single multi build item that declares two
 * providers of one configuration-related service.
 */
@BuildStep
public ServiceWriterBuildItem registerOneService() {
    return new ServiceWriterBuildItem(
        Converter.class.getName(),
        MyFirstConfigConverterImpl.class.getName(),
        MySecondConfigConverterImpl.class.getName()
    );
}

/**
 * This build step produces several multi build items that declare multiple
 * providers of multiple configuration-related services.
 */
@BuildStep
public void registerSeveralServices(
    BuildProducer&lt;ServiceWriterBuildItem&gt; providerProducer
) {
    providerProducer.produce(new ServiceWriterBuildItem(
        Converter.class.getName(),
        MyThirdConfigConverterImpl.class.getName(),
        MyFourthConfigConverterImpl.class.getName()
    ));
    providerProducer.produce(new ServiceWriterBuildItem(
        ConfigSource.class.getName(),
        MyConfigSourceImpl.class.getName()
    ));
}

/**
 * This build step aggregates all the produced service providers
 * and outputs them as resources.
 */
@BuildStep
public void produceServiceFiles(
    List&lt;ServiceWriterBuildItem&gt; items,
    BuildProducer&lt;GeneratedResourceBuildItem&gt; resourceProducer
) throws IOException {
    // Aggregate all the providers

    Map&lt;String, Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;();
    for (ServiceWriterBuildItem item : items) {
        String serviceName = item.getName();
        for (String implName : item.getImplementations()) {
            map.computeIfAbsent(
                serviceName,
                (k, v) -&gt; new LinkedHashSet&lt;&gt;()
            ).add(implName);
        }
    }

    // Now produce the resource(s) for the SPI files
    for (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : map.entrySet()) {
        String serviceName = entry.getKey();
        try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {
            try (OutputStreamWriter w = new OutputStreamWriter(os, StandardCharsets.UTF_8)) {
                for (String implName : entry.getValue()) {
                    w.write(implName);
                    w.write(System.lineSeparator());
                }
                w.flush();
            }
            resourceProducer.produce(
                new GeneratedResourceBuildItem(
                    "META-INF/services/" + serviceName,
                    os.toByteArray()
                )
            );
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="empty-build-items"><a class="anchor" href="#empty-build-items"></a>2.3.2.3. Itens de construção vazios</h5>
<div class="paragraph">
<p>Os itens de construção vazios são classes finais (geralmente vazias) que estendem <code>io.quarkus.builder.item.EmptyBuildItem</code>. Eles representam itens de construção que, na verdade, não contêm dados e permitem que esses itens sejam produzidos e consumidos sem a necessidade de instanciar classes vazias. Eles não podem ser instanciados.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Como não podem ser instanciados, não podem ser injetados por nenhum meio nem retornados por uma etapa de construção (ou por meio de um <code>BuildProducer</code> ). Para produzir um item de construção vazio, você deve anotar a etapa de construção com <code>@Produce(MyEmptyBuildItem.class)</code> e consumi-la com <code>@Consume(MyEmptyBuildItem.class)</code> .
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Exemplo de um item de construção vazio</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">public final class NativeImageBuildItem extends EmptyBuildItem {
    // empty
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Os itens de construção vazios podem representar "barreiras" que podem impor a ordem entre as etapas. Eles também podem ser usados da mesma forma que os sistemas de construção populares usam "pseudo-alvos", ou seja, o item de construção pode representar um objetivo conceitual que não tem uma representação concreta.</p>
</div>
<div class="listingblock">
<div class="title">Exemplo de utilização de um item de construção vazio num estilo "pseudo-alvo"</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">/**
 * Contrived build step that produces the native image on disk.  The main augmentation
 * step (which is run by Maven or Gradle) would be declared to consume this empty item,
 * causing this step to be run.
 */
@BuildStep
@Produce(NativeImageBuildItem.class)
void produceNativeImage() {
    // ...
    // (produce the native image)
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exemplo de utilização de um item de construção vazio num estilo "barreira"</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">/**
 * This would always run after {@link #produceNativeImage()} completes, producing
 * an instance of {@code SomeOtherBuildItem}.
 */
@BuildStep
@Consume(NativeImageBuildItem.class)
SomeOtherBuildItem secondBuildStep() {
    return new SomeOtherBuildItem("foobar");
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="validation-error-build-item"><a class="anchor" href="#validation-error-build-item"></a>2.3.2.4. Itens de construção de Erro de Validação</h5>
<div class="paragraph">
<p>Eles representam itens de construção com erros de validação que fazem a construção falhar. Estes itens de construção são consumidos durante a inicialização do contêiner CDI.</p>
</div>
<div class="listingblock">
<div class="title">Exemplo de utilização de um item de construção de erro de validação num estilo "pseudo-alvo"</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildStep
void checkCompatibility(Capabilities capabilities, BuildProducer&lt;ValidationErrorBuildItem&gt; validationErrors) {
    if (capabilities.isMissing(Capability.RESTEASY_REACTIVE)
            &amp;&amp; capabilities.isMissing(Capability.RESTEASY_CLASSIC)) {
        validationErrors.produce(new ValidationErrorBuildItem(
                new ConfigurationException("Cannot use both RESTEasy Classic and Reactive extensions at the same time")));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="artifact-result-build-item"><a class="anchor" href="#artifact-result-build-item"></a>2.3.2.5. Itens de construção de Resultado de Artefato</h5>
<div class="paragraph">
<p>Eles representam itens de construção que contêm o artefato executável gerado pela construção, como um uberjar ou thin jar. Esses itens de construção também podem ser usados para sempre executar uma etapa de construção sem a necessidade de produzir nada.</p>
</div>
<div class="listingblock">
<div class="title">Exemplo de passo de construção que é sempre executado num estilo "pseudo-alvo"</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildStep
@Produce(ArtifactResultBuildItem.class)
void runBuildStepThatProducesNothing() {
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="injection"><a class="anchor" href="#injection"></a>2.3.3. Injeção</h4>
<div class="paragraph">
<p>As classes que contêm etapas de construção suportam os seguintes tipos de injeção:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Injeção de parâmetros do construtor</p>
</li>
<li>
<p>Injeção de campo</p>
</li>
<li>
<p>Injeção de parâmetros de métodos (apenas para métodos de etapas de construção)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As classes de etapa de construção são instanciadas e injetadas para cada invocação de etapa de construção e são descartadas posteriormente. O estado só deve ser comunicado entre as etapas de construção por meio de itens de construção, mesmo que as etapas estejam na mesma classe.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Os campos finais não são considerados para injeção, mas podem ser preenchidos por meio da injeção de parâmetros do construtor, se desejado. Os campos estáticos nunca são considerados para injeção.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Os tipos de valores que podem ser injetados incluem:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#build-items">Build items</a> produced by previous build steps</p>
</li>
<li>
<p><a href="#producing-values">Build producers</a> to produce items for subsequent build steps</p>
</li>
<li>
<p><a href="#configuration">Configuration Mapping</a> types</p>
</li>
<li>
<p>Template objects for <a href="#bytecode-recording">bytecode recording</a></p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Os objetos que são injetados em um método de etapa de construção ou em sua classe <em>não devem</em> ser usados fora da execução desse método.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A injeção é resolvida no momento da compilação por meio de um processador de anotações, e o código resultante não tem permissão para injetar campos privados ou invocar métodos privados.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="producing-values"><a class="anchor" href="#producing-values"></a>2.3.4. Produzindo valores</h4>
<div class="paragraph">
<p>Uma etapa de construção pode produzir valores para as etapas subsequentes de várias maneiras possíveis:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>By returning a <a href="#simple-build-items">simple build item</a> or <a href="#multi-build-items">multi build item</a> instance</p>
</li>
<li>
<p>Ao devolver um <code>List</code> de uma classe de item de construção múltipla</p>
</li>
<li>
<p>Ao injetar um <code>BuildProducer</code> de uma classe de item simples ou de construção múltipla</p>
</li>
<li>
<p>By annotating the method with <code>@io.quarkus.deployment.annotations.Produce</code>, giving the class name of an
<a href="#empty-build-items">empty build item</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Se um item de construção simples for declarado em uma etapa de construção, ele <em>deverá</em> ser produzido durante essa etapa de construção, caso contrário, ocorrerá um erro. Os produtores de construção, que são injetados nas etapas, <em>não devem</em> ser usados fora dessa etapa.</p>
</div>
<div class="paragraph">
<p>Observe que um método <code>@BuildStep</code> só será chamado se produzir algo que outro consumidor ou o resultado final exija. Se não houver um consumidor para um determinado item, ele não será produzido. O que é necessário dependerá do destino final que está sendo produzido. Por exemplo, ao executar no modo de desenvolvedor, a saída final não solicitará itens de construção específicos do GraalVM, como <code>ReflectiveClassBuildItem</code>, portanto, os métodos que produzem apenas esses itens não serão chamados.</p>
</div>
</div>
<div class="sect3">
<h4 id="consuming-values"><a class="anchor" href="#consuming-values"></a>2.3.5. Consumindo valores</h4>
<div class="paragraph">
<p>Um passo de construção pode consumir valores de passos anteriores das seguintes formas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>By injecting a <a href="#simple-build-items">simple build item</a></p>
</li>
<li>
<p>Ao injetar um <code>Optional</code> de uma classe de item de construção simples</p>
</li>
<li>
<p>By injecting a <code>List</code> of a <a href="#multi-build-items">multi build item</a> class</p>
</li>
<li>
<p>By annotating the method with <code>@io.quarkus.deployment.annotations.Consume</code>, giving the class name of an
<a href="#empty-build-items">empty build item</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Normalmente, é um erro uma etapa incluída consumir um item de construção simples que não é produzido por nenhuma outra etapa. Dessa forma, é garantido que todos os valores declarados estarão presentes e não <code>null</code> quando uma etapa for executada.</p>
</div>
<div class="paragraph">
<p>Às vezes, um valor não é necessário para que a construção seja concluída, mas pode informar algum comportamento da etapa de construção se estiver presente. Nesse caso, o valor pode ser injetado opcionalmente.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Os valores de construção múltipla são sempre considerados <em>opcionais</em>. Se não estiverem presentes, será injetada uma lista vazia.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="producing-weak-values"><a class="anchor" href="#producing-weak-values"></a>2.3.5.1. Produção de valor fraco</h5>
<div class="paragraph">
<p>Normalmente, uma etapa de construção é incluída sempre que produz qualquer item de construção que, por sua vez, é consumido por qualquer outra etapa de construção. Dessa forma, apenas as etapas necessárias para produzir o(s) artefato(s) final(is) são incluídas, e as etapas relacionadas a extensões que não estão instaladas ou que produzem apenas itens de construção que não são relevantes para o tipo de artefato em questão são excluídas.</p>
</div>
<div class="paragraph">
<p>Nos casos em que esse não é o comportamento desejado, a anotação <code>@io.quarkus.deployment.annotations.Weak</code> pode ser usada. Essa anotação indica que a etapa de construção não deve ser incluída automaticamente apenas com base na produção do valor anotado.</p>
</div>
<div class="listingblock">
<div class="title">Exemplo de produção de um item de construção de forma fraca</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">/**
 * This build step is only run if something consumes the ExecutorClassBuildItem.
 */
@BuildStep
void createExecutor(
        @Weak BuildProducer&lt;GeneratedClassBuildItem&gt; classConsumer,
        BuildProducer&lt;ExecutorClassBuildItem&gt; executorClassConsumer
) {
        ClassWriter cw = new ClassWriter(Gizmo.ASM_API_VERSION);
        String className = generateClassThatCreatesExecutor(cw); <i class="conum" data-value="1"></i><b>(1)</b>
        classConsumer.produce(new GeneratedClassBuildItem(true, className, cw.toByteArray()));
        executorClassConsumer.produce(new ExecutorClassBuildItem(className));
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Este método (não fornecido neste exemplo) geraria a classe utilizando a API ASM.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Certos tipos de itens de construção geralmente são sempre consumidos, como classes ou recursos gerados. Uma extensão pode produzir um item de construção junto com uma classe gerada para facilitar o uso desse item de construção. Essa etapa de construção usaria a anotação <code>@Weak</code> no item de construção da classe gerada, enquanto produziria normalmente o outro item de construção. Se o outro item de construção for consumido por algo, a etapa será executada e a classe será gerada. Se nada consumir o outro item de construção, a etapa não será incluída no processo de construção.</p>
</div>
<div class="paragraph">
<p>No exemplo acima, <code>GeneratedClassBuildItem</code> só seria produzido se <code>ExecutorClassBuildItem</code> fosse consumido por alguma outra etapa de construção.</p>
</div>
<div class="paragraph">
<p>Note that when using <a href="#bytecode-recording">bytecode recording</a>, the implicitly generated class can be declared to be weak by
using the <code>optional</code> attribute of the <code>@io.quarkus.deployment.annotations.Record</code> annotation.</p>
</div>
<div class="listingblock">
<div class="title">Exemplo de utilização de um gravador de bytecode em que a classe gerada é fracamente produzida</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">/**
 * This build step is only run if something consumes the ExecutorBuildItem.
 */
@BuildStep
@Record(value = ExecutionTime.RUNTIME_INIT, optional = true) <i class="conum" data-value="1"></i><b>(1)</b>
ExecutorBuildItem createExecutor( <i class="conum" data-value="2"></i><b>(2)</b>
        ExecutorTemplate executorTemplate,
        ThreadPoolConfig threadPoolConfig
) {

    return new ExecutorBuildItem(
        setupTemplate.setupRunTime(
            shutdownContextBuildItem,
            threadPoolConfig,
            launchModeBuildItem.getLaunchMode()
        )
    );
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Note o atributo <code>optional</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This example is using recorder proxies; see the section on <a href="#bytecode-recording">bytecode recording</a> for more information.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="application-archives"><a class="anchor" href="#application-archives"></a>2.3.6. Arquivos de Aplicações</h4>
<div class="paragraph">
<p>A anotação <code>@BuildStep</code> também pode registrar arquivos de marcadores que determinam quais arquivos no caminho da classe são considerados "Arquivos de Aplicações" e, portanto, serão indexados. Isso é feito por meio do <code>applicationArchiveMarkers</code> . Por exemplo, a extensão ArC registra <code>META-INF/beans.xml</code> , o que significa que todos os arquivos no caminho da classe com um arquivo <code>beans.xml</code> serão indexados.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-threads-context-class-loader"><a class="anchor" href="#using-threads-context-class-loader"></a>2.3.7. Usando o Carregador de Classe de Contexto da Thread</h4>
<div class="paragraph">
<p>A etapa de construção será executada com um TCCL que pode carregar classes de usuário da implantação de forma segura para o transformador. Esse carregador de classes dura apenas a vida útil da ampliação e é descartado depois. As classes serão carregadas novamente em um carregador de classes diferente no tempo de execução. Isso significa que carregar uma classe durante a ampliação não impede que ela seja transformada ao ser executada no modo de desenvolvimento/teste.</p>
</div>
</div>
<div class="sect3">
<h4 id="adding-external-jars-to-the-indexer-with-indexdependencybuilditem"><a class="anchor" href="#adding-external-jars-to-the-indexer-with-indexdependencybuilditem"></a>2.3.8. Adicionar JARs externos ao indexador com IndexDependencyBuildItem</h4>
<div class="paragraph">
<p>O índice de classes verificadas não incluirá automaticamente suas dependências de classe externas. Para adicionar dependências, crie um <code>@BuildStep</code> que produza objetos <code>IndexDependencyBuildItem</code> , para um <code>groupId</code> e <code>artifactId</code> .</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
É importante especificar todos os artefatos necessários a serem adicionados ao indexador. Nenhum artefato é adicionado implicitamente de forma transitória.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A extensão <code>Amazon Alexa</code> adiciona bibliotecas dependentes do Alexa SDK que são utilizadas nas transformações Jackson JSON, para que as classes reflexivas sejam identificadas e incluídas em <code>BUILD_TIME</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">   @BuildStep
    void addDependencies(BuildProducer&lt;IndexDependencyBuildItem&gt; indexDependency) {
        indexDependency.produce(new IndexDependencyBuildItem("com.amazon.alexa", "ask-sdk"));
        indexDependency.produce(new IndexDependencyBuildItem("com.amazon.alexa", "ask-sdk-runtime"));
        indexDependency.produce(new IndexDependencyBuildItem("com.amazon.alexa", "ask-sdk-model"));
        indexDependency.produce(new IndexDependencyBuildItem("com.amazon.alexa", "ask-sdk-lambda-support"));
        indexDependency.produce(new IndexDependencyBuildItem("com.amazon.alexa", "ask-sdk-servlet-support"));
        indexDependency.produce(new IndexDependencyBuildItem("com.amazon.alexa", "ask-sdk-dynamodb-persistence-adapter"));
        indexDependency.produce(new IndexDependencyBuildItem("com.amazon.alexa", "ask-sdk-apache-client"));
        indexDependency.produce(new IndexDependencyBuildItem("com.amazon.alexa", "ask-sdk-model-runtime"));
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Com os artefatos adicionados ao indexador <code>Jandex</code>, você pode agora pesquisar o índice para identificar classes que implementam uma interface, subclasses de uma classe específica ou classes com uma anotação de alvo.</p>
</div>
<div class="paragraph">
<p>Por exemplo, a extensão <code>Jackson</code> usa um código como o abaixo para pesquisar anotações usadas na desserialização de JSON e adicioná-las à hierarquia reflexiva para análise <code>BUILD_TIME</code> .</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">    DotName JSON_DESERIALIZE = DotName.createSimple(JsonDeserialize.class.getName());

    IndexView index = combinedIndexBuildItem.getIndex();

    // handle the various @JsonDeserialize cases
    for (AnnotationInstance deserializeInstance : index.getAnnotations(JSON_DESERIALIZE)) {
        AnnotationTarget annotationTarget = deserializeInstance.target();
        if (CLASS.equals(annotationTarget.kind())) {
            DotName dotName = annotationTarget.asClass().name();
            Type jandexType = Type.create(dotName, Type.Kind.CLASS);
            reflectiveHierarchyClass.produce(new ReflectiveHierarchyBuildItem(jandexType));
        }

    }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="visualizing-build-step-dependencies"><a class="anchor" href="#visualizing-build-step-dependencies"></a>2.3.9. Visualizando dependências de etapas de construção</h4>
<div class="paragraph">
<p>It can occasionally be useful to see a visual representation of the interactions between the various build steps. For such cases, adding <code>-Djboss.builder.graph-output=build.dot</code> when building an application
will result in the creation of the <code>build.dot</code> file in the project&#8217;s root directory. See <a href="https://graphviz.org/resources/">this</a> for a list of software that can open the file and show the actual visual representation.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuration"><a class="anchor" href="#configuration"></a>2.4. Configuração</h3>
<div class="paragraph">
<p>A configuração no Quarkus é baseada no <a href="https://smallrye.io/smallrye-config/Main/">SmallRye Config</a>. Todos os recursos fornecidos pelo <a href="https://smallrye.io/smallrye-config/Main/">SmallRye Config</a> também estão disponíveis no Quarkus.</p>
</div>
<div class="paragraph">
<p>As extensões devem usar o <a href="https://smallrye.io/smallrye-config/Main/config/mappings/">@ConfigMapping do SmallRye Config</a> para mapear a configuração exigida pela extensão. Isso permitirá que o Quarkus exponha automaticamente uma instância do mapeamento para cada fase de configuração e gere a documentação da configuração.</p>
</div>
<div class="sect3">
<h4 id="config-phases"><a class="anchor" href="#config-phases"></a>2.4.1. Fases de Configuração</h4>
<div class="paragraph">
<p>Os mapeamentos de configuração são estritamente vinculados à fase de configuração, e a tentativa de acessar um mapeamento de configuração fora da fase correspondente resultará em um erro. Eles determinam quando as chaves contidas são lidas da configuração e quando estão disponíveis para as aplicações. As fases definidas pelo <code>io.quarkus.runtime.annotations.ConfigPhase</code> são as seguintes:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 6.6666%;">
<col style="width: 6.6666%;">
<col style="width: 6.6666%;">
<col style="width: 6.6666%;">
<col style="width: 53.3336%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Nome da fase</th>
<th class="tableblock halign-center valign-top">Lido e disponível em tempo de construção</th>
<th class="tableblock halign-center valign-top">Disponível em tempo de execução</th>
<th class="tableblock halign-center valign-top">Lido durante a inicialização estática</th>
<th class="tableblock halign-center valign-top">Relido durante a inicialização (executável nativo)</th>
<th class="tableblock halign-left valign-top">Notas</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BUILD_TIME</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Adequado para coisas que afetam a construção.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BUILD_AND_RUN_TIME_FIXED</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apropriado para coisas que afetam a construção e devem ser visíveis para o código em tempo de execução. Não lido da configuração em tempo de execução.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BOOTSTRAP</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Usado quando a configuração do tempo de execução precisa ser obtida de um sistema externo (como o <code>Consul</code>), mas os detalhes desse sistema precisam ser configuráveis (por exemplo, a URL do Consul). A maneira de alto nível como isso funciona é usando as fontes de configuração padrão do Quarkus (como arquivos de propriedades, propriedades do sistema, etc.) e produzindo objetos <code>ConfigSourceProvider</code> que são posteriormente levados em conta pelo Quarkus ao criar o objeto <code>Config</code> de tempo de execução final.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RUN_TIME</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✗</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">✓</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Não disponível na construção, lido no início em todos os modos.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Para todos os casos, com exceção do caso <code>BUILD_TIME</code>, a interface de mapeamento da configuração e todos os grupos e tipos de configuração nela contidos devem estar localizados ou ser acessíveis a partir do artefato de tempo de execução da extensão. Os mapeamentos de configuração da fase <code>BUILD_TIME</code> podem estar localizados ou acessíveis a partir de qualquer um dos artefatos de tempo de execução ou de implantação da extensão.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
As etapas de configuração <em>do bootstrap</em> são executadas durante o runtime-init <strong>antes de</strong> qualquer outra etapa de tempo de execução. Isso significa que o código executado como parte dessa etapa não pode acessar nada que seja inicializado nas etapas de inicialização em tempo de execução (beans CDI sintéticos em tempo de execução são um exemplo disso).
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="configuration-example"><a class="anchor" href="#configuration-example"></a>2.4.2. Exemplo de Configuração</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">import io.quarkus.runtime.annotations.ConfigGroup;
import io.quarkus.runtime.annotations.ConfigPhase;
import io.quarkus.runtime.annotations.ConfigRoot;
import io.smallrye.config.ConfigMapping;
import io.smallrye.config.WithDefault;

import java.io.File;
import java.util.logging.Level;

/**
 * Logging configuration.
 */
@ConfigMapping(prefix = "quarkus.log")      <i class="conum" data-value="1"></i><b>(1)</b>
@ConfigRoot(phase = ConfigPhase.RUN_TIME)   <i class="conum" data-value="2"></i><b>(2)</b>
public interface LogConfiguration {
    // ...

    /**
     * Configuration properties for the logging file handler.
     */
    FileConfig file();

    @ConfigGroup <i class="conum" data-value="3"></i><b>(3)</b>
    interface FileConfig {
        /**
         * Enable logging to a file.
         */
        @WithDefault("true")
        boolean enable();

        /**
         * The log format.
         */
        @WithDefault("%d{yyyy-MM-dd HH:mm:ss,SSS} %h %N[%i] %-5p [%c{1.}] (%t) %s%e%n")
        String format();

        /**
         * The level of logs to be written into the file.
         */
        @WithDefault("ALL")
        Level level();

        /**
         * The name of the file in which logs will be written.
         */
        @WithDefault("application.log")
        File path();
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">public class LoggingProcessor {
    // ...

    /*
     * Logging configuration.
     */
    LogConfiguration config; <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Um nome de propriedade de configuração pode ser dividido em segmentos. Por exemplo, um nome de propriedade como <code>quarkus.log.file.enable</code> pode ser dividido nos seguintes segmentos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>quarkus</code> - um namespace reivindicado pelo Quarkus que é um prefixo para as interfaces <code>@ConfigMapping</code>,</p>
</li>
<li>
<p><code>log</code> - um segmento de nome que corresponde ao prefixo definido na interface anotada com <code>@ConfigMapping</code>,</p>
</li>
<li>
<p><code>file</code> - um segmento de nome que corresponde ao campo <code>file</code> desta classe,</p>
</li>
<li>
<p><code>enabled</code> - a name segment which corresponds to <code>enable</code> field in <code>FileConfig</code> class annotated with <code>@ConfigGroup</code>.</p>
</li>
</ul>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A anotação <code>@ConfigMapping</code> indica que a interface é um mapeamento de configuração, nesse caso, um que corresponde a um segmento <code>quarkus.log</code> .</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A anotação <code>@ConfigRoot</code> indica qual fase de configuração a configuração se aplica.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>FileConfig</code> class is annotated with <code>@ConfigGroup</code> to indicate that this is an aggregate
configuration object containing a collection of configurable properties, rather than being a simple configuration
key type.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Aqui, o <code>LoggingProcessor</code> injeta uma instância <code>LogConfiguration</code> automaticamente ao detectar a anotação <code>@ConfigRoot</code> .</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Um <code>application.properties</code> correspondente para o exemplo acima poderia ser:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-properties hljs" data-lang="properties">quarkus.log.file.enable=true
quarkus.log.file.level=DEBUG
quarkus.log.file.path=/tmp/debug.log</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since <code>format</code> is not defined in these properties, the default value from <code>@ConfigItem</code> will be used instead.</p>
</div>
<div class="paragraph">
<p>A configuration mapping name can contain an extra suffix segment for the case where there are configuration
mappings for multiple <a href="#Config Phases">[Config Phases]</a>. Classes which correspond to the <code>BUILD_TIME</code> and <code>BUILD_AND_RUN_TIME_FIXED</code>
may end with <code>BuildTimeConfig</code> or <code>BuildTimeConfiguration</code>, classes which correspond to the <code>RUN_TIME</code> phase
may end with <code>RuntimeConfig</code>, <code>RunTimeConfig</code>, <code>RuntimeConfiguration</code> or <code>RunTimeConfiguration</code> while classes which
correspond to the <code>BOOTSTRAP</code> configuration may end with <code>BootstrapConfig</code> or <code>BootstrapConfiguration</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="conditional-step-inclusion"><a class="anchor" href="#conditional-step-inclusion"></a>2.5. Inclusão Condicional de Etapas</h3>
<div class="paragraph">
<p>É possível incluir um determinado <code>@BuildStep</code> somente em determinadas condições. A anotação <code>@BuildStep</code> tem dois parâmetros opcionais: <code>onlyIf</code> e <code>onlyIfNot</code> . Esses parâmetros podem ser definidos para uma ou mais classes que implementam <code>BooleanSupplier</code> . A etapa de construção só será incluída quando o método retornar <code>true</code> (para <code>onlyIf</code> ) ou <code>false</code> (para <code>onlyIfNot</code> ).</p>
</div>
<div class="paragraph">
<p>The condition class can inject <a href="#configuration">configuration mappings</a> as long as they belong to
a build-time phase.  Run time configuration is not available for condition classes.</p>
</div>
<div class="paragraph">
<p>A classe de condição também pode injetar um valor do tipo <code>io.quarkus.runtime.LaunchMode</code> . Há suporte para injeção de campo e parâmetro de construtor.</p>
</div>
<div class="listingblock">
<div class="title">Um exemplo de um passo de construção condicional</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildStep(onlyIf = IsDevMode.class)
LogCategoryBuildItem enableDebugLogging() {
    return new LogCategoryBuildItem("org.your.quarkus.extension", Level.DEBUG);
}

static class IsDevMode implements BooleanSupplier {
    LaunchMode launchMode;

    public boolean getAsBoolean() {
        return launchMode == LaunchMode.DEVELOPMENT;
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you need to make your build step conditional on the presence or absence of another extension, you can
use <a href="#capabilities">Capacidades</a> for that.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Também é possível aplicar um conjunto de condições a todos os passos de construção numa determinada classe com <code>@BuildSteps</code>:</p>
</div>
<div class="listingblock">
<div class="title">Condição em toda a classe para o passo de construção com @BuildSteps</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildSteps(onlyIf = MyDevModeProcessor.IsDevMode.class) <i class="conum" data-value="1"></i><b>(1)</b>
class MyDevModeProcessor {

    @BuildStep
    SomeOutputBuildItem mainBuildStep(SomeOtherBuildItem input) { <i class="conum" data-value="2"></i><b>(2)</b>
        return new SomeOutputBuildItem(input.getValue());
    }

    @BuildStep
    SomeOtherOutputBuildItem otherBuildStep(SomeOtherInputBuildItem input) { <i class="conum" data-value="3"></i><b>(3)</b>
        return new SomeOtherOutputBuildItem(input.getValue());
    }

    static class IsDevMode implements BooleanSupplier {
        LaunchMode launchMode;

        public boolean getAsBoolean() {
            return launchMode == LaunchMode.DEVELOPMENT;
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Esta condição será aplicada a todos os métodos definidos em <code>MyDevModeProcessor</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A etapa principal de construção só será executada no modo de desenvolvimento.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A outra etapa de construção só será executada no modo de desenvolvimento.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="bytecode-recording"><a class="anchor" href="#bytecode-recording"></a>2.6. Gravação de Bytecode</h3>
<div class="paragraph">
<p>Um dos principais resultados do processo de construção é o bytecode gravado. Na verdade, esse bytecode configura o ambiente de tempo de execução. Por exemplo, para iniciar o Undertow, a aplicação resultante terá algum bytecode que registra diretamente todas as instâncias de Servlet e, em seguida, inicia o Undertow.</p>
</div>
<div class="paragraph">
<p>Como escrever bytecode diretamente é complexo, isso é feito por meio de gravadores de bytecode. No momento da implantação, as invocações são feitas em objetos gravadores que contêm a lógica real do tempo de execução, mas, em vez de essas invocações prosseguirem normalmente, elas são interceptadas e gravadas (daí o nome). Essa gravação é então usada para gerar bytecode que executa a mesma sequência de invocações no tempo de execução. Essencialmente, essa é uma forma de execução diferida em que as invocações feitas no momento da implantação são adiadas até o tempo de execução.</p>
</div>
<div class="paragraph">
<p>Vejamos o exemplo clássico do tipo 'Olá Mundo'. Para fazer isto à maneira do Quarkus, criaríamos um gravador como se segue:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Recorder
class HelloRecorder {

  public void sayHello(String name) {
    System.out.println("Hello" + name);
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>E, em seguida, criaríamos um passo de construção que utilize este gravador:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@Record(RUNTIME_INIT)
@BuildStep
public void helloBuildStep(HelloRecorder recorder) {
    recorder.sayHello("World");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quando essa etapa de construção é executada, nada é impresso no console. Isso ocorre porque o <code>HelloRecorder</code> que é injetado é, na verdade, um proxy que registra todas as invocações. Em vez disso, se executarmos o programa Quarkus resultante, veremos "Hello World" impresso no console.</p>
</div>
<div class="paragraph">
<p>Os métodos em um gravador podem retornar um valor, que deve ser proxiable (se você quiser retornar um item não proxiable, envolva-o em <code>io.quarkus.runtime.RuntimeValue</code> ). Esses proxies não podem ser invocados diretamente, mas podem ser passados para outros métodos do gravador. Esse pode ser qualquer método de gravador, inclusive de outros métodos <code>@BuildStep</code>, portanto, um padrão comum é produzir instâncias <code>BuildItem</code> que envolvam os resultados dessas invocações de gravadores.</p>
</div>
<div class="paragraph">
<p>Por exemplo, para fazer alterações arbitrárias em uma implantação de Servlet, o Undertow tem um <code>ServletExtensionBuildItem</code> , que é um <code>MultiBuildItem</code> que envolve uma instância de <code>ServletExtension</code> . Posso retornar um <code>ServletExtension</code> de um gravador em outro módulo, e o Undertow o consumirá e o passará para o método do gravador que inicia o Undertow.</p>
</div>
<div class="paragraph">
<p>No tempo de execução, o bytecode será chamado na ordem em que foi gerado. Isso significa que as dependências da etapa de construção controlam implicitamente a ordem em que o bytecode gerado é executado. No exemplo acima, sabemos que o bytecode que produz um <code>ServletExtensionBuildItem</code> será executado antes do bytecode que o consome.</p>
</div>
<div class="paragraph">
<p>Os seguintes objetos podem ser passados aos gravadores:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Primitivos</p>
</li>
<li>
<p>String</p>
</li>
<li>
<p>Objetos Class&lt;?&gt;</p>
</li>
<li>
<p>Objetos retornados de uma invocação anterior do gravador</p>
</li>
<li>
<p>Objetos com um construtor sem argumentos e getter/setters para todas as propriedades (ou campos públicos)</p>
</li>
<li>
<p>Objetos com um construtor anotado com <code>@RecordableConstructor</code> com nomes de parâmetros que correspondem a nomes de campos</p>
</li>
<li>
<p>Qualquer objeto arbitrário através do mecanismo <code>io.quarkus.deployment.recording.RecorderContext#registerSubstitution(Class, Class, Class)</code></p>
</li>
<li>
<p>Vetores, Listas e Mapas dos elementos acima</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="injecting-configuration-into-recorders"><a class="anchor" href="#injecting-configuration-into-recorders"></a>2.6.1. Injetando Configuração nos Gravadores</h4>
<div class="paragraph">
<p>Os objetos de configuração com a fase <code>RUNTIME</code> ou <code>BUILD_AND_RUNTIME_FIXED</code> podem ser injetados nos gravadores por meio da injeção de construtor. Basta criar um construtor que receba os objetos de configuração de que o gravador precisa. Se o gravador tiver vários construtores, o usuário poderá anotar aquele que deseja que o Quarkus use com <code>@Inject</code> . Se o gravador quiser injetar a configuração de tempo de execução, mas também for usado no momento da inicialização estática, será necessário injetar um <code>RuntimeValue&lt;ConfigObject&gt;</code>. Esse valor só será definido quando os métodos de tempo de execução estiverem sendo invocados.</p>
</div>
</div>
<div class="sect3">
<h4 id="recordercontext"><a class="anchor" href="#recordercontext"></a>2.6.2. RecorderContext</h4>
<div class="paragraph">
<p><code>io.quarkus.deployment.recording.RecorderContext</code> fornece alguns métodos de conveniência para aprimorar a gravação de bytecode, o que inclui a capacidade de registrar funções de criação para classes sem construtores sem argumento, registrar uma substituição de objeto (basicamente um transformador de um objeto não serializável para um serializável e vice-versa) e criar um proxy de classe. Essa interface pode ser injetada diretamente como um parâmetro de método em qualquer método <code>@Record</code>.</p>
</div>
<div class="paragraph">
<p>Calling <code>classProxy</code> with a given class name will create a <code>Class</code> that can be passed into recorder
methods, and at runtime will be substituted with the class whose name was passed in to <code>classProxy</code>. This is basically a
convenience to avoid the need to explicitly load classes in the recorders.</p>
</div>
</div>
<div class="sect3">
<h4 id="printing-step-execution-time"><a class="anchor" href="#printing-step-execution-time"></a>2.6.3. Imprimindo o tempo de execução da etapa</h4>
<div class="paragraph">
<p>Às vezes, pode ser útil saber o tempo exato que cada tarefa de inicialização (que é o resultado de cada gravação de bytecode) leva quando a aplicação é executada. A maneira mais simples de determinar essas informações é iniciar o aplicativo Quarkus com a propriedade de sistema <code>-Dquarkus.debug.print-startup-times=true</code>. O resultado será algo parecido com:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">Build step LoggingResourceProcessor.setupLoggingRuntimeInit completed in: 42ms
Build step ConfigGenerationBuildStep.checkForBuildTimeConfigChange completed in: 4ms
Build step SyntheticBeansProcessor.initRuntime completed in: 0ms
Build step ConfigBuildStep.validateConfigProperties completed in: 1ms
Build step ResteasyStandaloneBuildStep.boot completed in: 95ms
Build step VertxHttpProcessor.initializeRouter completed in: 1ms
Build step VertxHttpProcessor.finalizeRouter completed in: 4ms
Build step LifecycleEventsBuildStep.startupEvent completed in: 1ms
Build step VertxHttpProcessor.openSocket completed in: 93ms
Build step ShutdownListenerBuildStep.setupShutdown completed in: 1ms</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="contexts-and-dependency-injection"><a class="anchor" href="#contexts-and-dependency-injection"></a>2.7. Contextos e Injeção de Dependência</h3>
<div class="sect3">
<h4 id="extension-points"><a class="anchor" href="#extension-points"></a>2.7.1. Pontos de Extensão</h4>
<div class="paragraph">
<p>Como um tempo de execução baseado em CDI, as extensões do Quarkus geralmente disponibilizam beans CDI como parte do comportamento da extensão. No entanto, a solução de DI do Quarkus não suporta Extensões Portáteis CDI. Em vez disso, as extensões do Quarkus podem fazer uso de vários <a href="cdi-reference">Pontos de Extensão de Tempo de Construção</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="quarkus-dev-ui"><a class="anchor" href="#quarkus-dev-ui"></a>2.8. Quarkus Dev UI</h3>
<div class="paragraph">
<p>You can make your extension support the <a href="dev-ui">Quarkus Dev UI</a> for a greater developer experience.</p>
</div>
</div>
<div class="sect2">
<h3 id="extension-defined-endpoints"><a class="anchor" href="#extension-defined-endpoints"></a>2.9. Endpoints definidos pela extensão</h3>
<div class="paragraph">
<p>Sua extensão pode adicionar endpoints adicionais que não sejam de aplicações para serem servidos juntamente com endpoints para Health, Metrics, OpenAPI, Swagger UI, etc.</p>
</div>
<div class="paragraph">
<p>Use um <code>NonApplicationRootPathBuildItem</code> para definir um endpoint:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildStep
RouteBuildItem myExtensionRoute(NonApplicationRootPathBuildItem nonApplicationRootPathBuildItem) {
    return nonApplicationRootPathBuildItem.routeBuilder()
                .route("custom-endpoint")
                .handler(new MyCustomHandler())
                .displayOnNotFoundPage()
                .build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Observe que o caminho acima não começa com um '/', o que indica que é um caminho relativo. O endpoint acima será servido em relação à raiz configurada do endpoint sem aplicação. A raiz do endpoint que não é de aplicação é <code>/q</code> por padrão, o que significa que o endpoint resultante será encontrado em <code>/q/custom-endpoint</code>.</p>
</div>
<div class="paragraph">
<p>Os caminhos absolutos são tratados de forma diferente. Se o acima chamou <code>route("/custom-endpoint")</code>, o endpoint resultante será encontrado em <code>/custom-endpoint</code> .</p>
</div>
<div class="paragraph">
<p>Se uma extensão precisar de endpoints não relacionados com a aplicação aninhados:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildStep
RouteBuildItem myNestedExtensionRoute(NonApplicationRootPathBuildItem nonApplicationRootPathBuildItem) {
    return nonApplicationRootPathBuildItem.routeBuilder()
                .nestedRoute("custom-endpoint", "deep")
                .handler(new MyCustomHandler())
                .displayOnNotFoundPage()
                .build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dada uma raiz padrão de endpoint não relacionado a aplicação de <code>/q</code>, isto criará um endpoint em <code>/q/custom-endpoint/deep</code>.</p>
</div>
<div class="paragraph">
<p>Os caminhos absolutos também têm impacto sobre os endpoints aninhados. Se o usuário acima chamou <code>nestedRoute("custom-endpoint", "/deep")</code> , o endpoint resultante será encontrado em <code>/deep</code>.</p>
</div>
<div class="paragraph">
<p>Consulte a <a href="all-config#quarkus-vertx-http_quarkus.http.non-application-root-path">referência de configuração HTTP do Quarkus Vertx</a> para obter detalhes sobre como o caminho raiz que não é da aplicação é configurado.</p>
</div>
</div>
<div class="sect2">
<h3 id="extension-health-check"><a class="anchor" href="#extension-health-check"></a>2.10. Verificação de Integridade da Extensão</h3>
<div class="paragraph">
<p>As verificações de integridade são fornecidas através da extensão <code>quarkus-smallrye-health</code>. Ela fornece capacidades de verificação de vivacidade e prontidão.</p>
</div>
<div class="paragraph">
<p>Ao escrever uma extensão, é vantajoso fornecer verificações de integridade para a extensão, que podem ser automaticamente incluídas sem que o programador tenha de escrever os seus próprios controles.</p>
</div>
<div class="paragraph">
<p>Para prover uma verificação de integridade, você deve fazer o seguinte:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Importe a extensão <code>quarkus-smallrye-health</code> como uma dependência <strong>opcional</strong> em seu módulo de tempo de execução para que ela não afete o tamanho da aplicação se a verificação de integridade não for incluída.</p>
</li>
<li>
<p>Crie sua verificação de integridade seguindo o guia <a href="smallrye-health">SmallRye Health</a>. Recomendamos que você forneça apenas uma verificação de prontidão para uma extensão (a verificação de vivacidade foi criada para expressar o fato de que um aplicativo está ativo e precisa ser leve).</p>
</li>
<li>
<p>Importe a biblioteca <code>quarkus-smallrye-health-spi</code> no seu módulo de implantação.</p>
</li>
<li>
<p>Adicione uma etapa de construção no seu módulo de implantação que produz um <code>HealthBuildItem</code>.</p>
</li>
<li>
<p>Adicione uma forma de desativar a verificação de integridade da extensão através de um item de configuração <code>quarkus.&lt;extension&gt;.health.enabled</code> que deve estar ativado por padrão.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Segue um exemplo da extensão Agroal que fornece um <code>DataSourceHealthCheck</code> para validar a prontidão de uma fonte de dados.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildStep
HealthBuildItem addHealthCheck(AgroalBuildTimeConfig agroalBuildTimeConfig) {
    return new HealthBuildItem("io.quarkus.agroal.runtime.health.DataSourceHealthCheck",
            agroalBuildTimeConfig.healthEnabled);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="extension-metrics"><a class="anchor" href="#extension-metrics"></a>2.11. Métricas de Extensão</h3>
<div class="paragraph">
<p>A extensão <code>quarkus-micrometer</code> e a extensão <code>quarkus-smallrye-metrics</code> oferecem suporte à coleta de métricas. Como uma nota de compatibilidade, a extensão <code>quarkus-micrometer</code> adapta a API MP Metrics aos primitivos da biblioteca Micrometer, de modo que a extensão <code>quarkus-micrometer</code> pode ser ativada sem quebrar o código que depende da API MP Metrics. Observe que as métricas emitidas pelo Micrometer são diferentes; consulte a documentação da extensão <code>quarkus-micrometer</code> para obter mais informações.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A camada de compatibilidade para as APIs de Métricas MP será transferida para uma extensão diferente no futuro.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Existem dois padrões gerais que as extensões podem utilizar para interagir com uma extensão de métricas opcional para adicionar as suas próprias métricas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Padrão Consumidor: Uma extensão declara um <code>MetricsFactoryConsumerBuildItem</code> e usa-o para fornecer um gravador de bytecode para a extensão de métricas. Quando a extensão de métricas for inicializada, ela irá iterar sobre os consumidores registrados para inicializá-los com um <code>MetricsFactory</code>. Essa fábrica pode ser usada para declarar métricas agnósticas à API, o que pode ser uma boa opção para extensões que fornecem um objeto instrumentável para coletar estatísticas (por exemplo, a classe <code>Statistics</code> do Hibernate).</p>
</li>
<li>
<p>Padrão Binder: Uma extensão pode optar por usar implementações de coleta completamente diferentes, dependendo do sistema de métricas. Um parâmetro da etapa de construção <code>Optional&lt;MetricsCapabilityBuildItem&gt; metricsCapability</code> pode ser usado para declarar ou inicializar métricas específicas da API com base na extensão de métricas ativa (por exemplo, "smallrye-metrics" ou "micrometer"). Este padrão pode ser combinado com o padrão Consumidor utilizando <code>MetricsFactory::metricsSystemSupported()</code> para testar a extensão de métrica ativa dentro do gravador.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Lembre-se de que o suporte para métricas é opcional. As extensões podem usar um parâmetro <code>Optional&lt;MetricsCapabilityBuildItem&gt; metricsCapability</code> em sua etapa de construção para testar a presença de uma extensão de métricas habilitada. Considere o uso de configuração adicional para controlar o comportamento das métricas. As métricas de fontes de dados podem ser caras, por exemplo, portanto, sinalizadores de configuração adicionais são usados para habilitar a coleta de métricas em fontes de dados individuais.</p>
</div>
<div class="paragraph">
<p>Ao adicionar métricas para a sua extensão, você pode se encontrar em uma das seguintes situações:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Uma biblioteca subjacente utilizada pela extensão está usando diretamente uma API de métricas específica (MP Metrics, Micrometer ou outra).</p>
</li>
<li>
<p>Uma biblioteca subjacente usa o seu próprio mecanismo de coleta de métricas e as disponibiliza em tempo de execução utilizando a sua própria API, por exemplo, a classe <code>Statistics</code> do Hibernate ou a Vert.x <code>MetricsOptions</code>.</p>
</li>
<li>
<p>Uma biblioteca subjacente não fornece métricas (ou não existe qualquer biblioteca) e você pretende adicionar instrumentação.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="case-1-the-library-uses-a-metrics-library-directly"><a class="anchor" href="#case-1-the-library-uses-a-metrics-library-directly"></a>2.11.1. Caso 1: A biblioteca utiliza diretamente uma biblioteca de métricas</h4>
<div class="paragraph">
<p>Se a biblioteca utilizar diretamente uma API de métricas, existem duas opções:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use um parâmetro <code>Optional&lt;MetricsCapabilityBuildItem&gt; metricsCapability</code> para testar qual API de métricas é suportada (por exemplo, "smallrye-metrics" ou "micrometer") em sua etapa de construção e use isso para declarar ou inicializar seletivamente beans ou itens de construção específicos da API.</p>
</li>
<li>
<p>Crie uma etapa de construção separada que consuma um <code>MetricsFactory</code> e utilize o método <code>MetricsFactory::metricsSystemSupported()</code> no gravador de bytecode para inicializar os recursos necessários se a API de métricas pretendida for suportada (por exemplo, "smallrye-metrics" ou "micrometer").</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As extensões podem precisar fornecer uma alternativa se não existir uma extensão de métricas ativa ou se a extensão não suportar a API exigida pela biblioteca.</p>
</div>
</div>
<div class="sect3">
<h4 id="case-2-the-library-provides-its-own-metric-api"><a class="anchor" href="#case-2-the-library-provides-its-own-metric-api"></a>2.11.2. Caso 2: A biblioteca fornece a sua própria API métrica</h4>
<div class="paragraph">
<p>Existem dois exemplos de uma biblioteca que fornece a sua própria API de métricas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A extensão define um objeto instrumentável como faz o Agroal com <code>io.agroal.api.AgroalDataSourceMetrics</code>, ou</p>
</li>
<li>
<p>A extensão fornece a sua própria abstração de métricas, tal como Jaeger faz com <code>io.jaegertracing.spi.MetricsFactory</code>.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="observing-instrumentable-objects"><a class="anchor" href="#observing-instrumentable-objects"></a>2.11.2.1. Observação de objetos instrumentáveis</h5>
<div class="paragraph">
<p>Vejamos primeiro o caso do objeto instrumentável ( <code>io.agroal.api.AgroalDataSourceMetrics</code>). Neste caso, você pode fazer o seguinte:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Defina um <code>BuildStep</code> que produz um <code>MetricsFactoryConsumerBuildItem</code> que usa um Gravador <code>RUNTIME_INIT</code> ou <code>STATIC_INIT</code> para definir um consumidor <code>MetricsFactory</code>. Por exemplo, o seguinte cria um <code>MetricsFactoryConsumerBuildItem</code> se e apenas se as métricas estiverem ativadas para o Agroal em geral e para uma fonte de dados especificamente:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildStep
@Record(ExecutionTime.RUNTIME_INIT)
void registerMetrics(AgroalMetricsRecorder recorder,
        DataSourcesBuildTimeConfig dataSourcesBuildTimeConfig,
        BuildProducer&lt;MetricsFactoryConsumerBuildItem&gt; datasourceMetrics,
        List&lt;AggregatedDataSourceBuildTimeConfigBuildItem&gt; aggregatedDataSourceBuildTimeConfigs) {

    for (AggregatedDataSourceBuildTimeConfigBuildItem aggregatedDataSourceBuildTimeConfig : aggregatedDataSourceBuildTimeConfigs) {
        // Create a MetricsFactory consumer to register metrics for a data source
        // IFF metrics are enabled globally and for the data source
        // (they are enabled for each data source by default if they are also enabled globally)
        if (dataSourcesBuildTimeConfig.metricsEnabled &amp;&amp;
                aggregatedDataSourceBuildTimeConfig.getJdbcConfig().enableMetrics.orElse(true)) {
            datasourceMetrics.produce(new MetricsFactoryConsumerBuildItem(
                    recorder.registerDataSourceMetrics(aggregatedDataSourceBuildTimeConfig.getName())));
        }
    }
}</code></pre>
</div>
</div>
</li>
<li>
<p>O gravador associado deve usar o <code>MetricsFactory</code> fornecido para registrar métricas. Para o Agroal, isto significa usar a API <code>MetricFactory</code> para observar os métodos <code>io.agroal.api.AgroalDataSourceMetrics</code>. Por exemplo:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">/* RUNTIME_INIT */
public Consumer&lt;MetricsFactory&gt; registerDataSourceMetrics(String dataSourceName) {
    return new Consumer&lt;MetricsFactory&gt;() {
        @Override
        public void accept(MetricsFactory metricsFactory) {
            String tagValue = DataSourceUtil.isDefault(dataSourceName) ? "default" : dataSourceName;
            AgroalDataSourceMetrics metrics = getDataSource(dataSourceName).getMetrics();

            // When using MP Metrics, the builder uses the VENDOR registry by default.
            metricsFactory.builder("agroal.active.count")
                    .description(
                            "Number of active connections. These connections are in use and not available to be acquired.")
                    .tag("datasource", tagValue)
                    .buildGauge(metrics::activeCount);
            ....</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>O <code>MetricsFactory</code> fornece um construtor fluido para o registro de métricas, com o passo final para construir medidores ou contadores com base num <code>Supplier</code> ou <code>ToDoubleFunction</code>. Os temporizadores podem envolver implementações <code>Callable</code>, <code>Runnable</code> ou <code>Supplier</code>, ou podem utilizar um <code>TimeRecorder</code> para acumular pedaços de tempo. A extensão de métrica subjacente criará artefatos apropriados para observar ou medir as funções definidas.</p>
</div>
</div>
<div class="sect4">
<h5 id="using-a-metrics-api-specific-implementation"><a class="anchor" href="#using-a-metrics-api-specific-implementation"></a>2.11.2.2. Usando uma implementação específica da API de Métricas</h5>
<div class="paragraph">
<p>Usar implementações específicas da API de Métricas pode ser preferível em alguns casos. O Jaeger, por exemplo, define a sua própria interface de métricas, <code>io.jaegertracing.spi.MetricsFactory</code>, que usa para definir contadores e medidores. Um mapeamento direto dessa interface para o sistema de métricas será o mais eficiente. Nesse caso, é importante isolar essas implementações especializadas e evitar o carregamento antecipado de classes para garantir que a API de métricas permaneça uma dependência opcional em tempo de compilação.</p>
</div>
<div class="paragraph">
<p><code>Optional&lt;MetricsCapabilityBuildItem&gt; metricsCapability</code> podem ser usados na etapa de construção para controlar seletivamente a inicialização de beans ou a produção de outros itens de construção. A extensão Jaeger, por exemplo, pode usar o seguinte para controlar a inicialização de adaptadores especializados da API de Métricas:</p>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">/* RUNTIME_INIT */
@BuildStep
@Record(ExecutionTime.RUNTIME_INIT)
void setupTracer(JaegerDeploymentRecorder jdr, JaegerBuildTimeConfig buildTimeConfig, JaegerConfig jaeger,
        ApplicationConfig appConfig, Optional&lt;MetricsCapabilityBuildItem&gt; metricsCapability) {

    // Indicates that this extension would like the SSL support to be enabled
    extensionSslNativeSupport.produce(new ExtensionSslNativeSupportBuildItem(Feature.JAEGER.getName()));

    if (buildTimeConfig.enabled) {
        // To avoid dependency creep, use two separate recorder methods for the two metrics systems
        if (buildTimeConfig.metricsEnabled &amp;&amp; metricsCapability.isPresent()) {
            if (metricsCapability.get().metricsSupported(MetricsFactory.MICROMETER)) {
                jdr.registerTracerWithMicrometerMetrics(jaeger, appConfig);
            } else {
                jdr.registerTracerWithMpMetrics(jaeger, appConfig);
            }
        } else {
            jdr.registerTracerWithoutMetrics(jaeger, appConfig);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Um gravador que consome um <code>MetricsFactory</code> pode usar <code>MetricsFactory::metricsSystemSupported()</code> pode ser usado para controlar a inicialização de objetos de métricas durante a gravação de bytecode de forma semelhante.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="case-3-it-is-necessary-to-collect-metrics-within-the-extension-code"><a class="anchor" href="#case-3-it-is-necessary-to-collect-metrics-within-the-extension-code"></a>2.11.3. Caso 3: É necessário coletar métricas no código da extensão</h4>
<div class="paragraph">
<p>Para definir suas próprias métricas do zero, você tem duas opções básicas: Usar os construtores genéricos do <code>MetricFactory</code> ou seguir o padrão binder e criar instrumentação específica para a extensão de métricas habilitada.</p>
</div>
<div class="paragraph">
<p>Para utilizar a API <code>MetricFactory</code> agnóstica em termos de extensão, o seu processador pode definir um <code>BuildStep</code> que produz um <code>MetricsFactoryConsumerBuildItem</code> que usa um Gravador <code>RUNTIME_INIT</code> ou <code>STATIC_INIT</code> para definir um consumidor <code>MetricsFactory</code>.</p>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildStep
@Record(ExecutionTime.RUNTIME_INIT)
MetricsFactoryConsumerBuildItem registerMetrics(MyExtensionRecorder recorder) {
    return new MetricsFactoryConsumerBuildItem(recorder.registerMetrics());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>+ - O registrador associado deve usar o <code>MetricsFactory</code> fornecido para registrar métricas, por exemplo</p>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">final LongAdder extensionCounter = new LongAdder();

/* RUNTIME_INIT */
public Consumer&lt;MetricsFactory&gt; registerMetrics() {
    return new Consumer&lt;MetricsFactory&gt;() {
        @Override
        public void accept(MetricsFactory metricsFactory) {
            metricsFactory.builder("my.extension.counter")
                    .buildGauge(extensionCounter::longValue);
            ....</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lembre-se de que as extensões de métricas são opcionais. Mantenha a inicialização relacionada a métricas isolada de outras configurações para sua extensão e estruture seu código para evitar importações antecipadas de APIs de métricas. A coleta de métricas também pode ser cara. Considere o uso de configuração adicional específica da extensão para controlar o comportamento das métricas se a presença/ausência de suporte a métricas não for suficiente.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="customizing-json-handling-from-an-extension"><a class="anchor" href="#customizing-json-handling-from-an-extension"></a>2.12. Personalizando tratamento JSON a partir de uma extensão</h3>
<div class="paragraph">
<p>As extensões necessitam frequentemente de registrar serializadores e/ou desserializadores para os tipos que a extensão fornece.</p>
</div>
<div class="paragraph">
<p>Para isso, as extensões Jackson e JSON-B oferecem uma maneira de registrar o serializador/desserializador de dentro de um módulo de implantação de extensão.</p>
</div>
<div class="paragraph">
<p>Lembre-se que nem todo mundo vai precisar de JSON, por isso deve torná-lo opcional.</p>
</div>
<div class="paragraph">
<p>Se uma extensão pretende fornecer personalização relacionada a JSON, é altamente recomendável fornecer personalização para Jackson e JSON-B.</p>
</div>
<div class="sect3">
<h4 id="customizing-jackson"><a class="anchor" href="#customizing-jackson"></a>2.12.1. Personalizando Jackson</h4>
<div class="paragraph">
<p>Primeiro, adicione uma dependência <strong>opcional</strong> a <code>quarkus-jackson</code> no módulo de tempo de execução da sua extensão.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
  &lt;artifactId&gt;quarkus-jackson&lt;/artifactId&gt;
  &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida, crie um serializador ou um desserializador (ou ambos) para a Jackson, um exemplo do qual pode ser visto na extensão <code>mongodb-panache</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">public class ObjectIdSerializer extends StdSerializer&lt;ObjectId&gt; {
    public ObjectIdSerializer() {
        super(ObjectId.class);
    }
    @Override
    public void serialize(ObjectId objectId, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)
            throws IOException {
        if (objectId != null) {
            jsonGenerator.writeString(objectId.toString());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adicione uma dependência a <code>quarkus-jackson-spi</code> no módulo de implantação da sua extensão.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
  &lt;artifactId&gt;quarkus-jackson-spi&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adicione uma etapa de construção ao seu processador para registrar um módulo Jackson por meio do <code>JacksonModuleBuildItem</code>. Você precisa nomear o seu módulo de uma forma única em todos os módulos Jackson.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildStep
JacksonModuleBuildItem registerJacksonSerDeser() {
    return new JacksonModuleBuildItem.Builder("ObjectIdModule")
                    .add(io.quarkus.mongodb.panache.jackson.ObjectIdSerializer.class.getName(),
                            io.quarkus.mongodb.panache.jackson.ObjectIdDeserializer.class.getName(),
                            ObjectId.class.getName())
                    .build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A extensão Jackson utilizará então o item de construção produzido para registrar automaticamente um módulo no Jackson.</p>
</div>
<div class="paragraph">
<p>If you need more customization capabilities than registering a module,
you can produce a CDI bean that implements <code>io.quarkus.jackson.ObjectMapperCustomizer</code> via an <code>AdditionalBeanBuildItem</code>.
More info about customizing Jackson can be found on the JSON guide <a href="rest-json#configuring-json-support">Configuring JSON support</a></p>
</div>
</div>
<div class="sect3">
<h4 id="customizing-json-b"><a class="anchor" href="#customizing-json-b"></a>2.12.2. Personalizando JSON-B</h4>
<div class="paragraph">
<p>Primeiro, adicione uma dependência <strong>opcional</strong> a <code>quarkus-jsonb</code> no módulo de tempo de execução da sua extensão.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
  &lt;artifactId&gt;quarkus-jsonb&lt;/artifactId&gt;
  &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida, crie um serializador e/ou desserializador para JSON-B, um exemplo do qual pode ser visto na extensão <code>mongodb-panache</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">public class ObjectIdSerializer implements JsonbSerializer&lt;ObjectId&gt; {
    @Override
    public void serialize(ObjectId obj, JsonGenerator generator, SerializationContext ctx) {
        if (obj != null) {
            generator.write(obj.toString());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adicione uma dependência a <code>quarkus-jsonb-spi</code> no módulo de implantação da sua extensão.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
  &lt;artifactId&gt;quarkus-jsonb-spi&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adicione um passo de construção ao seu processador para registrar o serializador através do <code>JsonbSerializerBuildItem</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">@BuildStep
JsonbSerializerBuildItem registerJsonbSerializer() {
    return new JsonbSerializerBuildItem(io.quarkus.mongodb.panache.jsonb.ObjectIdSerializer.class.getName()));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A extensão JSON-B utilizará então o item de construção produzido para registrar automaticamente o seu serializador/desserializador.</p>
</div>
<div class="paragraph">
<p>Se você precisar de mais recursos de personalização do que o registro de um serializador ou desserializador, poderá produzir um bean CDI que implemente o <code>io.quarkus.jsonb.JsonbConfigCustomizer</code> por meio de um <code>AdditionalBeanBuildItem</code> . Mais informações sobre a personalização do JSON-B podem ser encontradas no guia JSON <a href="rest-json#configuring-json-support">Configurando Suporte a JSON</a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="integrating-with-development-mode"><a class="anchor" href="#integrating-with-development-mode"></a>2.13. Integração com o Modo de Desenvolvimento</h3>
<div class="paragraph">
<p>Existem várias APIS que você pode usar para integrar com o modo de desenvolvimento e para obter informações sobre o estado atual.</p>
</div>
<div class="sect3">
<h4 id="handling-restarts"><a class="anchor" href="#handling-restarts"></a>2.13.1. Lidando com reinicializações</h4>
<div class="paragraph">
<p>Quando o Quarkus está iniciando, é garantido que o site <code>io.quarkus.deployment.builditem.LiveReloadBuildItem</code> esteja presente e forneça informações sobre esse início, em particular:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>É uma inicialização limpa ou um recarregamento ao vivo</p>
</li>
<li>
<p>Se se tratar de um recarregamento ao vivo onde arquivos/classes alterados ativaram o recarregamento</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ele também fornece um mapa de contexto global que pode ser usado para armazenar informações entre reinicializações, sem a necessidade de recorrer a campos estáticos.</p>
</div>
</div>
<div class="sect3">
<h4 id="triggering-live-reload"><a class="anchor" href="#triggering-live-reload"></a>2.13.2. Ativando o Recarregamento ao Vivo</h4>
<div class="paragraph">
<p>O recarregamento ao vivo geralmente é acionado por uma requisição HTTP, mas nem todas as aplicações são aplicações HTTP e algumas extensões podem querer acionar o recarregamento ao vivo com base em outros eventos. Para isso, você precisa implementar o <code>io.quarkus.dev.spi.HotReplacementSetup</code> no seu módulo de tempo de execução e adicionar um <code>META-INF/services/io.quarkus.dev.spi.HotReplacementSetup</code> que liste a sua implementação.</p>
</div>
<div class="paragraph">
<p>Na inicialização, o método <code>setupHotDeployment</code> será chamado, e você pode usar o <code>io.quarkus.dev.spi.HotReplacementContext</code> fornecido para iniciar uma varredura de arquivos alterados.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="testing-extensions"><a class="anchor" href="#testing-extensions"></a>2.14. Testando Extensões</h3>
<div class="paragraph">
<p>O teste das extensões do Quarkus deve ser feito com a extensão <code>io.quarkus.test.QuarkusUnitTest</code> JUnit 5. Essa extensão permite a realização de testes no estilo Arquillian que testam funcionalidades específicas. Ela não se destina a testar aplicações de usuário, pois isso deve ser feito por meio de <code>io.quarkus.test.junit.QuarkusTest</code>. A principal diferença é que <code>QuarkusTest</code> simplesmente inicializa o aplicativo uma vez no início da execução, enquanto <code>QuarkusUnitTest</code> implanta uma aplicação Quarkus personalizada para cada classe de teste.</p>
</div>
<div class="paragraph">
<p>Esses testes devem ser colocados no módulo de implantação; se módulos adicionais do Quarkus forem necessários para o teste, seus módulos de implantação também deverão ser adicionados como dependências com escopo de teste.</p>
</div>
<div class="paragraph">
<p>Note que <code>QuarkusUnitTest</code> está no módulo <code>quarkus-junit5-internal</code>.</p>
</div>
<div class="paragraph">
<p>Um exemplo de classe de teste pode ter o seguinte aspecto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.health.test;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.ArrayList;
import java.util.List;

import javax.enterprise.inject.Instance;
import javax.inject.Inject;

import org.eclipse.microprofile.health.Liveness;
import org.eclipse.microprofile.health.HealthCheck;
import org.eclipse.microprofile.health.HealthCheckResponse;
import io.quarkus.test.QuarkusUnitTest;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.asset.EmptyAsset;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.RegisterExtension;

import io.restassured.RestAssured;

public class FailingUnitTest {

    @RegisterExtension                                                                  <i class="conum" data-value="1"></i><b>(1)</b>
    static final QuarkusUnitTest config = new QuarkusUnitTest()
            .setArchiveProducer(() -&gt;
                    ShrinkWrap.create(JavaArchive.class)                                <i class="conum" data-value="2"></i><b>(2)</b>
                            .addClasses(FailingHealthCheck.class)
                            .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml")
            );

    @Inject                                                                             <i class="conum" data-value="3"></i><b>(3)</b>
    @Liveness
    Instance&lt;HealthCheck&gt; checks;

    @Test
    public void testHealthServlet() {
        RestAssured.when().get("/q/health").then().statusCode(503);                       <i class="conum" data-value="4"></i><b>(4)</b>
    }

    @Test
    public void testHealthBeans() {
        List&lt;HealthCheck&gt; check = new ArrayList&lt;&gt;();                                    <i class="conum" data-value="5"></i><b>(5)</b>
        for (HealthCheck i : checks) {
            check.add(i);
        }
        assertEquals(1, check.size());
        assertEquals(HealthCheckResponse.State.DOWN, check.get(0).call().getState());
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A extensão <code>QuarkusUnitTest</code> deve ser usada com um campo estático. Se for utilizada com um campo não estático, a aplicação de teste não é iniciada.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Este produtor é usado para construir a aplicação a ser testada. Ele usa o Shrinkwrap para criar um JavaArchive para testar</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>É possível injetar beans da nossa implantação de teste diretamente no caso de teste</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Este método invoca diretamente o Servlet de verificação de integridade e verifica a resposta</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Este método usa o bean de verificação de integridade injetado para verificar se está devolvendo o resultado esperado</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Se você pretende testar se uma extensão falha corretamente em tempo de construção, use o método <code>setExpectedException</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.hibernate.orm;

import io.quarkus.runtime.configuration.ConfigurationException;
import io.quarkus.test.QuarkusUnitTest;
import org.jboss.shrinkwrap.api.ShrinkWrap;
import org.jboss.shrinkwrap.api.spec.JavaArchive;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.RegisterExtension;

public class PersistenceAndQuarkusConfigTest {

    @RegisterExtension
    static QuarkusUnitTest runner = new QuarkusUnitTest()
            .setExpectedException(ConfigurationException.class)                     <i class="conum" data-value="1"></i><b>(1)</b>
            .withApplicationRoot((jar) -&gt; jar
                    .addAsManifestResource("META-INF/some-persistence.xml", "persistence.xml")
                    .addAsResource("application.properties"));

    @Test
    public void testPersistenceAndConfigTest() {
        // should not be called, deployment exception should happen first:
        // it's illegal to have Hibernate configuration properties in both the
        // application.properties and in the persistence.xml
        Assertions.fail();
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Isto diz ao JUnit que a implantação do Quarkus deve falhar com uma exceção específica</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="testing-hot-reload"><a class="anchor" href="#testing-hot-reload"></a>2.15. Testando recarga em tempo real</h3>
<div class="paragraph">
<p>Também é possível escrever testes que verifiquem se uma extensão funciona corretamente no modo de desenvolvimento e se consegue lidar corretamente com as atualizações.</p>
</div>
<div class="paragraph">
<p>Para a maioria das extensões, isso funcionará sem ajustes, mas ainda assim é uma boa ideia fazer um teste de fumaça para verificar se essa funcionalidade está funcionando conforme o esperado. Para testar isso, usamos o site <code>QuarkusDevModeTest</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ServletChangeTestCase {

    @RegisterExtension
    final static QuarkusDevModeTest test = new QuarkusDevModeTest()
            .setArchiveProducer(new Supplier&lt;&gt;() {
                @Override
                public JavaArchive get() {
                    return ShrinkWrap.create(JavaArchive.class)   <i class="conum" data-value="1"></i><b>(1)</b>
                            .addClass(DevServlet.class)
                            .addAsManifestResource(new StringAsset("Hello Resource"), "resources/file.txt");
                }
            });

    @Test
    public void testServletChange() throws InterruptedException {
        RestAssured.when().get("/dev").then()
                .statusCode(200)
                .body(is("Hello World"));

        test.modifySourceFile("DevServlet.java", new Function&lt;String, String&gt;() {  <i class="conum" data-value="2"></i><b>(2)</b>

            @Override
            public String apply(String s) {
                return s.replace("Hello World", "Hello Quarkus");
            }
        });

        RestAssured.when().get("/dev").then()
                .statusCode(200)
                .body(is("Hello Quarkus"));
    }

    @Test
    public void testAddServlet() throws InterruptedException {
        RestAssured.when().get("/new").then()
                .statusCode(404);

        test.addSourceFile(NewServlet.class);                                       <i class="conum" data-value="3"></i><b>(3)</b>

        RestAssured.when().get("/new").then()
                .statusCode(200)
                .body(is("A new Servlet"));
    }

    @Test
    public void testResourceChange() throws InterruptedException {
        RestAssured.when().get("/file.txt").then()
                .statusCode(200)
                .body(is("Hello Resource"));

        test.modifyResourceFile("META-INF/resources/file.txt", new Function&lt;String, String&gt;() { <i class="conum" data-value="4"></i><b>(4)</b>

            @Override
            public String apply(String s) {
                return "A new resource";
            }
        });

        RestAssured.when().get("file.txt").then()
                .statusCode(200)
                .body(is("A new resource"));
    }

    @Test
    public void testAddResource() throws InterruptedException {

        RestAssured.when().get("/new.txt").then()
                .statusCode(404);

        test.addResourceFile("META-INF/resources/new.txt", "New File");  <i class="conum" data-value="5"></i><b>(5)</b>

        RestAssured.when().get("/new.txt").then()
                .statusCode(200)
                .body(is("New File"));

    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Isso inicia a implantação, e seu teste pode modificá-la como parte do conjunto de testes. O Quarkus será reiniciado entre cada método de teste para que cada método comece com uma implantação limpa.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Esse método permite que você modifique o código-fonte de um arquivo de classe. O código-fonte antigo é passado para a função e o código-fonte atualizado é retornado.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Esse método adiciona um novo arquivo de classe à implantação. A fonte usada será a fonte original que faz parte do projeto atual.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Este método modifica um recurso estático</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Este método adiciona um novo recurso estático</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="native-executable-support"><a class="anchor" href="#native-executable-support"></a>2.16. Suporte a Executáveis Nativos</h3>
<div class="paragraph">
<p>O Quarkus fornece vários itens de construção que controlam aspectos da construção do executável nativo. Isso permite que as extensões executem tarefas de forma programática, como o registro de classes para reflexão ou a adição de recursos estáticos ao executável nativo. Alguns desses itens de construção estão listados abaixo:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem</code></dt>
<dd>
<p>Inclui recursos estáticos no executável nativo.</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.nativeimage.NativeImageResourceDirectoryBuildItem</code></dt>
<dd>
<p>Inclui os recursos estáticos do diretório no executável nativo.</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.nativeimage.RuntimeReinitializedClassBuildItem</code></dt>
<dd>
<p>Uma classe que será reinicializada em tempo de execução pelo Substrate. Isso fará com que o inicializador estático seja executado duas vezes.</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.nativeimage.NativeImageSystemPropertyBuildItem</code></dt>
<dd>
<p>Uma propriedade do sistema que será definida em tempo de construção do executável nativo.</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBundleBuildItem</code></dt>
<dd>
<p>Inclui um pacote de recursos no executável nativo.</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem</code></dt>
<dd>
<p>Registra uma classe para reflexão no Substrate. Os construtores são sempre registrados, enquanto os métodos e campos são opcionais.</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem</code></dt>
<dd>
<p>Uma classe que será inicializada em tempo de execução e não em tempo de construção. Isso fará com que a construção falhe se a classe for inicializada como parte do processo de construção do executável nativo, portanto, é preciso ter cuidado.</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.nativeimage.NativeImageConfigBuildItem</code></dt>
<dd>
<p>Uma funcionalidade de conveniência que permite controlar a maioria das funcionalidades acima referidas a partir de um único item de construção.</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.NativeImageEnableAllCharsetsBuildItem</code></dt>
<dd>
<p>Indica que todos os conjuntos de caracteres devem ser ativados na imagem nativa.</p>
</dd>
<dt class="hdlist1"><code>io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem</code></dt>
<dd>
<p>Uma maneira conveniente de informar ao Quarkus que a extensão requer SSL e deve ser ativada durante a criação da imagem nativa. Ao usar esse recurso, lembre-se de adicionar sua extensão à lista de extensões que oferecem suporte a SSL automaticamente na <a href="https://github.com/quarkusio/quarkus/blob/main/docs/src/main/asciidoc/native-and-ssl.adoc">guia nativo e ssl</a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="ide-support-tips"><a class="anchor" href="#ide-support-tips"></a>2.17. Sugestões de suporte à IDE</h3>
<div class="sect3">
<h4 id="writing-quarkus-extensions-in-eclipse"><a class="anchor" href="#writing-quarkus-extensions-in-eclipse"></a>2.17.1. Escrevendo extensões Quarkus no Eclipse</h4>
<div class="paragraph">
<p>O único aspecto particular da escrita de extensões Quarkus no Eclipse é o fato de a APT (Annotation Processing Tool - Ferramenta de Processamento de Anotação) ser necessária como parte das compilações de extensões, o que significa que é necessário:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Instalar <code>m2e-apt</code> a partir de <a href="https://marketplace.eclipse.org/content/m2e-apt" class="bare">https://marketplace.eclipse.org/content/m2e-apt</a></p>
</li>
<li>
<p>Defina esta propriedade em <code>pom.xml</code>: <code>&lt;m2e.apt.activation&gt;jdt_apt&lt;/m2e.apt.activation&gt;</code>, no entando se você recorrer a <code>io.quarkus:quarkus-build-parent</code> a obterá gratuitamente.</p>
</li>
<li>
<p>Se tiver o projeto <code>io.quarkus:quarkus-extension-processor</code> aberto ao mesmo tempo no seu IDE (por exemplo, se tiver as fontes Quarkus verificadas e abertas no seu IDE), terá de fechar esse projeto. Caso contrário, o Eclipse não invocará o plug-in APT que ele contém.</p>
</li>
<li>
<p>Se acabou de fechar o projeto do processador de extensões, certifique-se de fazer <code>Maven &gt; Update Project</code> nos outros projetos para que o Eclipse vá buscar o processador de extensões no repositório Maven.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="troubleshooting-debugging-tips"><a class="anchor" href="#troubleshooting-debugging-tips"></a>2.18. Dicas de Resolução de Problemas / Depuração</h3>
<div class="sect3">
<h4 id="dump-the-generated-classes-to-the-file-system"><a class="anchor" href="#dump-the-generated-classes-to-the-file-system"></a>2.18.1. Inspecionando as Classes Geradas/Transformadas</h4>
<div class="paragraph">
<p>O Quarkus gera muitas classes durante a fase de construção e, em muitos casos, também transforma as classes existentes. Muitas vezes, é extremamente útil ver o bytecode gerado e as classes transformadas durante o desenvolvimento de uma extensão.</p>
</div>
<div class="paragraph">
<p>If you set the <code>quarkus.package.quiltflower.enabled</code> property to <code>true</code> then Quarkus will download and invoke the <a href="https://github.com/QuiltMC/quiltflower">Quiltflower decompiler</a> and dump the result in the <code>decompiled</code> directory of the build tool output (<code>target/decompiled</code> for Maven for example).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Esta propriedade só funciona durante uma construção de produção normal (ou seja, não para o modo de desenvolvimento/testes) e quando o tipo de empacotamento <code>fast-jar</code> é usado (o comportamento padrão).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Existem também três propriedades do sistema que lhe permitem despejar as classes geradas/transformadas para o sistema de arquivos e inspecioná-las mais tarde, por exemplo, através de um descompilador no seu IDE.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>quarkus.debug.generated-classes-dir</code> - para despejar as classes geradas, tais como metadados de beans</p>
</li>
<li>
<p><code>quarkus.debug.transformed-classes-dir</code> - para despejar as classes transformadas, por exemplo, entidades Panache</p>
</li>
<li>
<p><code>quarkus.debug.generated-sources-dir</code> - para despejar os arquivos ZIG; o arquivo ZIG é uma representação textual do código gerado que é referenciado nos rastreamentos de pilha</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Estas propriedades são especialmente úteis no modo de desenvolvimento ou durante a execução dos testes em que as classes geradas/transformadas são apenas mantidas em memória num carregador de classes.</p>
</div>
<div class="paragraph">
<p>Por exemplo, você pode especificar a propriedade de sistema <code>quarkus.debug.generated-classes-dir</code> para que estas classes sejam gravadas no disco para inspeção no modo de desenvolvimento:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">./mvnw quarkus:dev -Dquarkus.debug.generated-classes-dir=dump-classes</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
O valor da propriedade pode ser um caminho absoluto, como <code>/home/foo/dump</code> numa máquina Linux, ou um caminho relativo ao diretório de trabalho do usuário, ou seja, <code>dump</code> corresponde a <code>{user.dir}/target/dump</code> no modo de desenvolvimento e <code>{user.dir}/dump</code> quando se executam os testes.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Você deve ver uma linha no registro para cada classe escrita no diretório:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">INFO  [io.qua.run.boo.StartupActionImpl] (main) Wrote /path/to/my/app/target/dump-classes/io/quarkus/arc/impl/ActivateRequestContextInterceptor_Bean.class</code></pre>
</div>
</div>
<div class="paragraph">
<p>A propriedade também é honrada durante a execução de testes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">./mvnw clean test -Dquarkus.debug.generated-classes-dir=target/dump-generated-classes</code></pre>
</div>
</div>
<div class="paragraph">
<p>De forma análoga, você pode usar as propriedades <code>quarkus.debug.transformed-classes-dir</code> e <code>quarkus.debug.generated-sources-dir</code> para despejar a saída relevante.</p>
</div>
</div>
<div class="sect3">
<h4 id="multi-module-maven-projects-and-the-development-mode"><a class="anchor" href="#multi-module-maven-projects-and-the-development-mode"></a>2.18.2. Projetos Maven de Múltiplos Módulos e o Modo de Desenvolvimento</h4>
<div class="paragraph">
<p>Não é incomum desenvolver uma extensão em um projeto Maven de múltiplos módulos que também contém um módulo de "exemplo". No entanto, se você quiser executar o exemplo no modo de desenvolvimento, a propriedade do sistema <code>-DnoDeps</code> deverá ser usada para excluir as dependências do projeto local. Caso contrário, o Quarkus tentará monitorar as classes de extensão e isso pode resultar em problemas estranhos de carregamento de classes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">./mvnw compile quarkus:dev -DnoDeps</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="indexer-does-not-include-your-external-dependency"><a class="anchor" href="#indexer-does-not-include-your-external-dependency"></a>2.18.3. O indexador não inclui a sua dependência externa</h4>
<div class="paragraph">
<p>Não se esqueça de adicionar os artefatos <code>IndexDependencyBuildItem</code> ao seu <code>@BuildStep</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sample-test-extension"><a class="anchor" href="#sample-test-extension"></a>2.19. Exemplo de Extensão de Teste</h3>
<div class="paragraph">
<p>Temos uma extensão que é usada para testar regressões no processamento da extensão. Ela está localizada no diretório <a href="https://github.com/quarkusio/quarkus/tree/main/integration-tests/test-extension/extension" class="bare">https://github.com/quarkusio/quarkus/tree/main/integration-tests/test-extension/extension</a>. Nesta seção, abordaremos algumas tarefas que um autor de extensão normalmente precisará executar usando o código test-extension para ilustrar como a tarefa pode ser realizada.</p>
</div>
<div class="sect3">
<h4 id="features-and-capabilities"><a class="anchor" href="#features-and-capabilities"></a>2.19.1. Funcionalidades e Capacidades</h4>
<div class="sect4">
<h5 id="features"><a class="anchor" href="#features"></a>2.19.1.1. Características</h5>
<div class="paragraph">
<p>Uma <em>funcionalidade</em> representa uma funcionalidade fornecida por uma extensão. O nome da funcionalidade é exibido no registro durante o bootstrap da aplicação.</p>
</div>
<div class="listingblock">
<div class="title">Linhas de Inicialização de Exemplo</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">2019-03-22 14:02:37,884 INFO  [io.quarkus] (main) Quarkus 999-SNAPSHOT started in 0.061s.
2019-03-22 14:02:37,884 INFO  [io.quarkus] (main) Installed features: [cdi, test-extension] <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Uma lista de funcionalidades instaladas na imagem de tempo de execução</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A feature can be registered in a <a href="#Build Step Processors">[Build Step Processors]</a> method that produces a <code>FeatureBuildItem</code>:</p>
</div>
<div class="listingblock">
<div class="title">TestProcessor#feature()</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @BuildStep
    FeatureBuildItem feature() {
        return new FeatureBuildItem("test-extension");
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>O nome da funcionalidade deve conter apenas caracteres minúsculos, as palavras são separadas por traço; por exemplo, <code>security-jpa</code>. Uma extensão deve fornecer no máximo uma funcionalidade e o nome deve ser exclusivo. Se várias extensões registrarem uma funcionalidade com o mesmo nome, a construção falhará.</p>
</div>
<div class="paragraph">
<p>O nome da funcionalidade também deve ser mapeado para um rótulo na entrada <code>devtools/common/src/main/filtered/extensions.json</code> da extensão, de modo que o nome da funcionalidade exibido pela linha de inicialização corresponda a um rótulo que possa ser usado para selecionar a extensão ao criar um projeto usando o plug-in maven do Quarkus, conforme mostrado neste exemplo retirado do guia <a href="rest-json">Escrevendo Serviços REST JSON</a> , no qual a funcionalidade <code>resteasy-reactive-jackson</code> é referenciada:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">mvn io.quarkus.platform:quarkus-maven-plugin:2.13.9.Final:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=rest-json \
    -DclassName="org.acme.rest.json.FruitResource" \
    -Dpath="/fruits" \
    -Dextensions="resteasy-reactive,resteasy-reactive-jackson"
cd rest-json</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="capabilities"><a class="anchor" href="#capabilities"></a>2.19.1.2. Capacidades</h5>
<div class="paragraph">
<p>Uma <em>capacidade</em> representa um recurso técnico que pode ser consultado por outras extensões. Uma extensão pode fornecer várias capacidades e várias extensões podem fornecer a mesma capacidade. Por padrão, as capacidades não são exibidas aos usuários. As capacidades devem ser usadas ao verificar a presença de uma extensão em vez de verificações baseadas em caminhos de classe.</p>
</div>
<div class="paragraph">
<p>Capabilities can be registered in a <a href="#Build Step Processors">[Build Step Processors]</a> method that produces a <code>CapabilityBuildItem</code>:</p>
</div>
<div class="listingblock">
<div class="title">TestProcessor#capability()</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @BuildStep
    void capabilities(BuildProducer&lt;CapabilityBuildItem&gt; capabilityProducer) {
        capabilityProducer.produce(new CapabilityBuildItem("org.acme.test-transactions"));
        capabilityProducer.produce(new CapabilityBuildItem("org.acme.test-metrics"));
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>As extensões podem consumir capacidades registradas usando o item de construção <code>Capabilities</code>:</p>
</div>
<div class="listingblock">
<div class="title">TestProcessor#doSomeCoolStuff()</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @BuildStep
    void doSomeCoolStuff(Capabilities capabilities) {
        if (capabilities.isPresent(Capability.TRANSACTIONS)) {
          // do something only if JTA transactions are in...
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>As capacidades devem seguir as convenções de nomenclatura dos pacotes Java; por exemplo, <code>io.quarkus.security.jpa</code> . As capacidades fornecidas pelas extensões principais devem ser listados no enum <code>io.quarkus.deployment.Capability</code> e seu nome deve sempre começar com o prefixo <code>io.quarkus</code> .</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bean-defining-annotations"><a class="anchor" href="#bean-defining-annotations"></a>2.19.2. Anotações de Definição de Bean</h4>
<div class="paragraph">
<p>A camada CDI processa beans CDI que são explicitamente registrados ou que descobre com base em anotações de definição de beans, tal como definido em <a href="https://jakarta.ee/specifications/cdi/2.0/cdi-spec-2.0.html#bean_defining_annotations">2.5.1. Bean defining annotations</a>. Você pode expandir este conjunto de anotações para incluir anotações que a sua extensão processa utilizando um <code>BeanDefiningAnnotationBuildItem</code>, tal como mostrado neste exemplo <code>TestProcessor#registrerBeanDefinningAnnotations</code>:</p>
</div>
<div class="listingblock">
<div class="title">Registrando uma Anotação de Definição de Bean</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import javax.enterprise.context.ApplicationScoped;
import org.jboss.jandex.DotName;
import io.quarkus.extest.runtime.TestAnnotation;

public final class TestProcessor {
    static DotName TEST_ANNOTATION = DotName.createSimple(TestAnnotation.class.getName());
    static DotName TEST_ANNOTATION_SCOPE = DotName.createSimple(ApplicationScoped.class.getName());

...

    @BuildStep
    BeanDefiningAnnotationBuildItem registerX() {
        <i class="conum" data-value="1"></i><b>(1)</b>
        return new BeanDefiningAnnotationBuildItem(TEST_ANNOTATION, TEST_ANNOTATION_SCOPE);
    }
...
}

/**
 * Marker annotation for test configuration target beans
 */
@Target({ TYPE })
@Retention(RUNTIME)
@Documented
@Inherited
public @interface TestAnnotation {
}

/**
 * A sample bean
 */
@TestAnnotation <i class="conum" data-value="2"></i><b>(2)</b>
public class ConfiguredBean implements IConfigConsumer {

...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Registre a classe de anotação e o escopo padrão CDI usando a classe Jandex <code>DotName</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>ConfiguredBean</code> será processado pela camada CDI da mesma forma que um bean anotado com a @ApplicationScoped padrão CDI.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="parsing-config-to-objects"><a class="anchor" href="#parsing-config-to-objects"></a>2.19.3. Analisando Configurações para Objetos</h4>
<div class="paragraph">
<p>Uma das principais coisas que uma extensão provavelmente fará é separar completamente a fase de configuração do comportamento da fase de tempo de execução. Os frameworks geralmente fazem a análise/carregamento da configuração na inicialização que pode ser feita durante o tempo de construção para reduzir as dependências de tempo de execução em frameworks como analisadores xml bem como reduzir o tempo de inicialização que a análise incorre.</p>
</div>
<div class="paragraph">
<p>An example of parsing an XML config file using JAXB is shown in the <code>TestProcessor#parseServiceXmlConfig</code> method:
.Parsing an XML Configuration into Runtime XmlConfig Instance</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @BuildStep
    @Record(STATIC_INIT)
    RuntimeServiceBuildItem parseServiceXmlConfig(TestRecorder recorder) throws JAXBException {
        RuntimeServiceBuildItem serviceBuildItem = null;
        JAXBContext context = JAXBContext.newInstance(XmlConfig.class);
        Unmarshaller unmarshaller = context.createUnmarshaller();
        InputStream is = getClass().getResourceAsStream("/config.xml"); <i class="conum" data-value="1"></i><b>(1)</b>
        if (is != null) {
            log.info("Have XmlConfig, loading");
            XmlConfig config = (XmlConfig) unmarshaller.unmarshal(is); <i class="conum" data-value="2"></i><b>(2)</b>
...
        }
        return serviceBuildItem;
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Procura por um recurso classpath config.xml</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Se for encontrado, analisa utilizando o contexto JAXB para <code>XmlConfig.class</code></td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Se não houvesse nenhum recurso /config.xml disponível no ambiente de construção, seria devolvido um <code>RuntimeServiceBuildItem</code> nulo e não seria executada qualquer lógica subsequente baseada num <code>RuntimeServiceBuildItem</code> produzido.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Typically, one is loading a configuration to create some runtime component/service as <code>parseServiceXmlConfig</code> is doing. We will come back to the rest of the behavior in <code>parseServiceXmlConfig</code> in the following <a href="#Manage Non-CDI Service">[Manage Non-CDI Service]</a> section.</p>
</div>
<div class="paragraph">
<p>Se, por algum motivo, for necessário analisar a configuração e utilizá-la em outros passos de construção num processador de extensão, será necessário criar um <code>XmlConfigBuildItem</code> para transmitir a instância XmlConfig analisada.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you look at the XmlConfig code you will see that it does carry around the JAXB annotations. If you don&#8217;t want these in the runtime image, you could clone the XmlConfig instance into some POJO object graph and then replace XmlConfig with the POJO class. We will do this in <a href="#Replacing Classes in the Native Image">[Replacing Classes in the Native Image]</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="scanning-deployments-using-jandex"><a class="anchor" href="#scanning-deployments-using-jandex"></a>2.19.4. Verificando Implantações Usando Jandex</h4>
<div class="paragraph">
<p>Se a sua extensão definir anotações ou interfaces que marcam os beans que precisam ser processados, você pode localizar esses beans utilizando a API Jandex, um indexador de anotações Java e uma biblioteca de reflexão offline. O método <code>TestProcessor#scanForBeans</code> a seguir mostra como localizar os beans anotados com nosso <code>@TestAnnotation</code> que também implementam a interface <code>IConfigConsumer</code>:</p>
</div>
<div class="listingblock">
<div class="title">Exemplo de Uso do Jandex</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    static DotName TEST_ANNOTATION = DotName.createSimple(TestAnnotation.class.getName());
...

    @BuildStep
    @Record(STATIC_INIT)
    void scanForBeans(TestRecorder recorder, BeanArchiveIndexBuildItem beanArchiveIndex, <i class="conum" data-value="1"></i><b>(1)</b>
            BuildProducer&lt;TestBeanBuildItem&gt; testBeanProducer) {
        IndexView indexView = beanArchiveIndex.getIndex(); <i class="conum" data-value="2"></i><b>(2)</b>
        Collection&lt;AnnotationInstance&gt; testBeans = indexView.getAnnotations(TEST_ANNOTATION); <i class="conum" data-value="3"></i><b>(3)</b>
        for (AnnotationInstance ann : testBeans) {
            ClassInfo beanClassInfo = ann.target().asClass();
            try {
                boolean isConfigConsumer = beanClassInfo.interfaceNames()
                        .stream()
                        .anyMatch(dotName -&gt; dotName.equals(DotName.createSimple(IConfigConsumer.class.getName()))); <i class="conum" data-value="4"></i><b>(4)</b>
                if (isConfigConsumer) {
                    Class&lt;IConfigConsumer&gt; beanClass = (Class&lt;IConfigConsumer&gt;) Class.forName(beanClassInfo.name().toString(), false, Thread.currentThread().getContextClassLoader());
                    testBeanProducer.produce(new TestBeanBuildItem(beanClass)); <i class="conum" data-value="5"></i><b>(5)</b>
                    log.infof("Configured bean: %s", beanClass);
                }
            } catch (ClassNotFoundException e) {
                log.warn("Failed to load bean class", e);
            }
        }
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Depende de um <code>BeanArchiveIndexBuildItem</code> para que o passo de construção seja executado depois da implantação ter sido indexada.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Recupera o índice.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Encontra todos os beans anotados com <code>@TestAnnotation</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Determina qual destes beans também tem a interface <code>IConfigConsumer</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Salva a classe do bean em <code>TestBeanBuildItem</code> para utilizar num passo de construção RUNTIME_INIT posterior que irá interagir com as instâncias do bean.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="interacting-with-extension-beans"><a class="anchor" href="#interacting-with-extension-beans"></a>2.19.5. Interagindo Com os Beans de Extensão</h4>
<div class="paragraph">
<p>Você pode utilizar a interface <code>io.quarkus.arc.runtime.BeanContainer</code> para interagir com os seus beans de extensão. Os seguintes métodos <code>configureBeans</code> ilustram a interação com os beans analisados na seção anterior:</p>
</div>
<div class="listingblock">
<div class="title">Usando a Interface CDI BeanContainer</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// TestProcessor#configureBeans
    @BuildStep
    @Record(RUNTIME_INIT)
    void configureBeans(TestRecorder recorder, List&lt;TestBeanBuildItem&gt; testBeans, <i class="conum" data-value="1"></i><b>(1)</b>
            BeanContainerBuildItem beanContainer, <i class="conum" data-value="2"></i><b>(2)</b>
            TestRunTimeConfig runTimeConfig) {

        for (TestBeanBuildItem testBeanBuildItem : testBeans) {
            Class&lt;IConfigConsumer&gt; beanClass = testBeanBuildItem.getConfigConsumer();
            recorder.configureBeans(beanContainer.getValue(), beanClass, buildAndRunTimeConfig, runTimeConfig); <i class="conum" data-value="3"></i><b>(3)</b>
        }
    }

// TestRecorder#configureBeans
    public void configureBeans(BeanContainer beanContainer, Class&lt;IConfigConsumer&gt; beanClass,
            TestBuildAndRunTimeConfig buildTimeConfig,
            TestRunTimeConfig runTimeConfig) {
        log.info("Begin BeanContainerListener callback\n");
        IConfigConsumer instance = beanContainer.instance(beanClass); <i class="conum" data-value="4"></i><b>(4)</b>
        instance.loadConfig(buildTimeConfig, runTimeConfig); <i class="conum" data-value="5"></i><b>(5)</b>
        log.infof("configureBeans, instance=%s\n", instance);
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Consome o <code>TestBeanBuildItem</code> produzido a partir da etapa de construção de varredura.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Consume o <code>BeanContainerBuildItem</code> para ordenar que este passo de construção seja executado depois que o contêiner de beans CDI tenha sido criado.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Chame o gravador de tempo de execução para registrar as interações do bean.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>O gravador de tempo de execução recupera o bean usando o seu tipo.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>O gravador de tempo de execução invoca o método <code>IConfigConsumer#loadConfig(…​)</code>, passando os objetos de configuração com informações de tempo de execução.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="manage-non-cdi-service"><a class="anchor" href="#manage-non-cdi-service"></a>2.19.6. Gerenciar Serviço Não CDI</h4>
<div class="paragraph">
<p>A common purpose for an extension is to integrate a non-CDI aware service into the CDI based Quarkus runtime. Step 1 of this task is to load any configuration needed in a STATIC_INIT build step as we did in <a href="#Parsing Config to Objects">[Parsing Config to Objects]</a>. Now we need to create an instance of the service using the configuration. Let&#8217;s return to the <code>TestProcessor#parseServiceXmlConfig</code> method to see how this can be done.</p>
</div>
<div class="listingblock">
<div class="title">Criando um Serviço Não CDI</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// TestProcessor#parseServiceXmlConfig
    @BuildStep
    @Record(STATIC_INIT)
    RuntimeServiceBuildItem parseServiceXmlConfig(TestRecorder recorder) throws JAXBException {
        RuntimeServiceBuildItem serviceBuildItem = null;
        JAXBContext context = JAXBContext.newInstance(XmlConfig.class);
        Unmarshaller unmarshaller = context.createUnmarshaller();
        InputStream is = getClass().getResourceAsStream("/config.xml");
        if (is != null) {
            log.info("Have XmlConfig, loading");
            XmlConfig config = (XmlConfig) unmarshaller.unmarshal(is);
            log.info("Loaded XmlConfig, creating service");
            RuntimeValue&lt;RuntimeXmlConfigService&gt; service = recorder.initRuntimeService(config); <i class="conum" data-value="1"></i><b>(1)</b>
            serviceBuildItem = new RuntimeServiceBuildItem(service); <i class="conum" data-value="3"></i><b>(3)</b>
        }
        return serviceBuildItem;
    }

// TestRecorder#initRuntimeService
    public RuntimeValue&lt;RuntimeXmlConfigService&gt; initRuntimeService(XmlConfig config) {
        RuntimeXmlConfigService service = new RuntimeXmlConfigService(config); <i class="conum" data-value="2"></i><b>(2)</b>
        return new RuntimeValue&lt;&gt;(service);
    }

// RuntimeServiceBuildItem
    final public class RuntimeServiceBuildItem extends SimpleBuildItem {
    private RuntimeValue&lt;RuntimeXmlConfigService&gt; service;

    public RuntimeServiceBuildItem(RuntimeValue&lt;RuntimeXmlConfigService&gt; service) {
        this.service = service;
    }

    public RuntimeValue&lt;RuntimeXmlConfigService&gt; getService() {
        return service;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Chame gravador de tempo de execução para registrar a criação do serviço.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Usando a instância analisada de <code>XmlConfig</code>, crie uma instância de <code>RuntimeXmlConfigService</code> e envolva-a numa <code>RuntimeValue</code>. Use um invólucro <code>RuntimeValue</code> para objetos que não sejam de interface e que são não-proxyable.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Envolva o valor do serviço de retorno num <code>RuntimeServiceBuildItem</code> para utilização num passo de construção RUNTIME_INIT que iniciará o serviço.</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="starting-a-service"><a class="anchor" href="#starting-a-service"></a>2.19.6.1. Iniciando um Serviço</h5>
<div class="paragraph">
<p>Agora que você gravou a criação de um serviço durante a fase de construção, precisa gravar como iniciar o serviço em tempo de execução durante a inicialização. Você faz isso com uma etapa de construção RUNTIME_INIT, conforme mostrado no método <code>TestProcessor#startRuntimeService</code> .</p>
</div>
<div class="listingblock">
<div class="title">Iniciando/Parando um Serviço Não CDI</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// TestProcessor#startRuntimeService
    @BuildStep
    @Record(RUNTIME_INIT)
    ServiceStartBuildItem startRuntimeService(TestRecorder recorder, ShutdownContextBuildItem shutdownContextBuildItem , <i class="conum" data-value="1"></i><b>(1)</b>
            RuntimeServiceBuildItem serviceBuildItem) throws IOException { <i class="conum" data-value="2"></i><b>(2)</b>
        if (serviceBuildItem != null) {
            log.info("Registering service start");
            recorder.startRuntimeService(shutdownContextBuildItem, serviceBuildItem.getService()); <i class="conum" data-value="3"></i><b>(3)</b>
        } else {
            log.info("No RuntimeServiceBuildItem seen, check config.xml");
        }
        return new ServiceStartBuildItem("RuntimeXmlConfigService"); <i class="conum" data-value="4"></i><b>(4)</b>
    }

// TestRecorder#startRuntimeService
    public void startRuntimeService(ShutdownContext shutdownContext, RuntimeValue&lt;RuntimeXmlConfigService&gt; runtimeValue)
            throws IOException {
        RuntimeXmlConfigService service = runtimeValue.getValue();
        service.startService(); <i class="conum" data-value="5"></i><b>(5)</b>
        shutdownContext.addShutdownTask(service::stopService); <i class="conum" data-value="6"></i><b>(6)</b>
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Consumimos um ShutdownContextBuildItem para registrar o encerramento do serviço.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Consumimos o serviço previamente inicializado capturado em <code>RuntimeServiceBuildItem</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Chame o gravador de tempo de execução para gravar a invocação do início do serviço.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Produce a <code>ServiceStartBuildItem</code> to indicate the startup of a service. See <a href="#Startup and Shutdown Events">[Startup and Shutdown Events]</a> for details.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>O gravador de tempo de execução recupera a referência da instância do serviço e chama o seu método <code>startService</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>O registrador de tempo de execução registra uma invocação do método <code>stopService</code> da instância do serviço com o Quarkus <code>ShutdownContext</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>O código para o <code>RuntimeXmlConfigService</code> pode ser visualizado aqui: <a href="https://github.com/quarkusio/quarkus/blob/main/integration-tests/test-extension/extension/runtime/src/main/java/io/quarkus/extest/runtime/RuntimeXmlConfigService.java">RuntimeXmlConfigService.java</a></p>
</div>
<div class="paragraph">
<p>O caso de teste para validar que o <code>RuntimeXmlConfigService</code> foi iniciado pode ser encontrado no teste <code>testRuntimeXmlConfigService</code> de <code>ConfiguredBeanTest</code> e <code>NativeImageIT</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="startup-and-shutdown-events"><a class="anchor" href="#startup-and-shutdown-events"></a>2.19.7. Eventos de Inicialização e Encerramento</h4>
<div class="paragraph">
<p>O contêiner Quarkus suporta eventos de ciclo de vida de inicialização e encerramento para notificar os componentes sobre a inicialização e o encerramento do contêiner. Há eventos CDI disparados que os componentes podem observar, conforme ilustrado neste exemplo:</p>
</div>
<div class="listingblock">
<div class="title">Observando a Inicialização do Contêiner</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.quarkus.runtime.ShutdownEvent;
import io.quarkus.runtime.StartupEvent;

public class SomeBean {
    /**
     * Called when the runtime has started
     * @param event
     */
    void onStart(@Observes StartupEvent event) { <i class="conum" data-value="1"></i><b>(1)</b>
        System.out.printf("onStart, event=%s%n", event);
    }

    /**
     * Called when the runtime is shutting down
     * @param event
    */
    void onStop(@Observes ShutdownEvent event) { <i class="conum" data-value="2"></i><b>(2)</b>
        System.out.printf("onStop, event=%s%n", event);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Observe um <code>StartupEvent</code> para ser notificado de que o tempo de execução foi iniciado.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Observe um <code>ShutdownEvent</code> para ser notificado quando o tempo de execução for encerrado.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>What is the relevance of startup and shutdown events for extension authors? We have already seen the use of a <code>ShutdownContext</code>
to register a callback to perform shutdown tasks in the <a href="#Starting a Service">[Starting a Service]</a> section. These shutdown tasks would be called
after a <code>ShutdownEvent</code> had been sent.</p>
</div>
<div class="paragraph">
<p>Um <code>StartupEvent</code> é disparado após todos os produtores de <code>io.quarkus.deployment.builditem.ServiceStartBuildItem</code> terem sido consumidos. A implicação disso é que, se uma extensão tiver serviços que os componentes da aplicação esperam que tenham sido iniciados quando observam um <code>StartupEvent</code> , as etapas de construção que invocam o código de tempo de execução para iniciar esses serviços precisam produzir um <code>ServiceStartBuildItem</code> para garantir que o código de tempo de execução seja executado antes que o <code>StartupEvent</code> seja enviado. Lembre-se de que vimos a produção de um <code>ServiceStartBuildItem</code> na seção anterior, e ela é repetida aqui para maior clareza:</p>
</div>
<div class="listingblock">
<div class="title">Exemplo de Produção de um ServiceStartBuildItem</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// TestProcessor#startRuntimeService
    @BuildStep
    @Record(RUNTIME_INIT)
    ServiceStartBuildItem startRuntimeService(TestRecorder recorder, ShutdownContextBuildItem shutdownContextBuildItem,
            RuntimeServiceBuildItem serviceBuildItem) throws IOException {
...
        return new ServiceStartBuildItem("RuntimeXmlConfigService"); <i class="conum" data-value="1"></i><b>(1)</b>
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Produza um <code>ServiceStartBuildItem</code> para indicar que se trata de uma etapa de inicialização do serviço que tem de ser executada antes de o <code>StartupEvent</code> ser enviado.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="register-resources-for-use-in-native-image"><a class="anchor" href="#register-resources-for-use-in-native-image"></a>2.19.8. Registre Recursos para Uso na Imagem Nativa</h4>
<div class="paragraph">
<p>Nem todas as configurações ou recursos podem ser consumidos no momento da construção. Se você tiver recursos do classpath que o tempo de execução precisa acessar, é necessário informar à fase de construção que esses recursos precisam ser copiados para a imagem nativa. Isso é feito produzindo um ou mais <code>NativeImageResourceBuildItem</code> ou <code>NativeImageResourceBundleBuildItem</code> no caso de pacotes de recursos. Exemplos disso são mostrados neste exemplo de etapa de construção <code>registerNativeImageResources</code>:</p>
</div>
<div class="listingblock">
<div class="title">Registrando Recursos e Pacotes de Recursos</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public final class MyExtProcessor {
    @Inject
    BuildProducer&lt;NativeImageResourceBuildItem&gt; resource;
    @Inject
    BuildProducer&lt;NativeImageResourceBundleBuildItem&gt; resourceBundle;

    @BuildStep
    void registerNativeImageResources() {
        resource.produce(new NativeImageResourceBuildItem("/security/runtime.keys")); <i class="conum" data-value="1"></i><b>(1)</b>

        resource.produce(new NativeImageResourceBuildItem(
                "META-INF/my-descriptor.xml")); <i class="conum" data-value="2"></i><b>(2)</b>

        resourceBundle.produce(new NativeImageResourceBuildItem("javax.xml.bind.Messages")); <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Indica que o recurso de classpath /security/runtime.keys deve ser copiado para a imagem nativa.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Indica que o recurso <code>META-INF/my-descriptor.xml</code> deve ser copiado para a imagem nativa</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Indicate that the "javax.xml.bind.Messages" resource bundle should be copied into native image.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="service-files"><a class="anchor" href="#service-files"></a>2.19.9. Arquivos de serviço</h4>
<div class="paragraph">
<p>Se você estiver usando arquivos <code>META-INF/services</code> , será necessário registrar os arquivos como recursos para que a imagem nativa possa encontrá-los, mas também será necessário registrar cada classe listada para reflexão, para que possam ser instanciadas ou inspecionadas em tempo de execução:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public final class MyExtProcessor {

    @BuildStep
    void registerNativeImageResources(BuildProducer&lt;ServiceProviderBuildItem&gt; services) {
        String service = "META-INF/services/" + io.quarkus.SomeService.class.getName();

        // find out all the implementation classes listed in the service files
        Set&lt;String&gt; implementations =
            ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),
                                          service);

        // register every listed implementation class so they can be instantiated
        // in native-image at run-time
        services.produce(
            new ServiceProviderBuildItem(io.quarkus.SomeService.class.getName(),
                                         implementations.toArray(new String[0])));
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>ServiceProviderBuildItem</code> recebe uma lista de classes de implementação de serviço como parâmetros: se você não as estiver lendo do arquivo de serviço, certifique-se de que elas correspondam ao conteúdo do arquivo de serviço, pois o arquivo de serviço ainda será lido e usado em tempo de execução. Isso não substitui a gravação de um arquivo de serviço.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Isso apenas registra as classes de implementação para instanciação por meio de reflexão (você não poderá inspecionar seus campos e métodos). Se você precisar fazer isso, pode fazê-lo dessa forma:
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public final class MyExtProcessor {

    @BuildStep
    void registerNativeImageResources(BuildProducer&lt;NativeImageResourceBuildItem&gt; resource,
                                     BuildProducer&lt;ReflectiveClassBuildItem&gt; reflectionClasses) {
        String service = "META-INF/services/" + io.quarkus.SomeService.class.getName();

        // register the service file so it is visible in native-image
        resource.produce(new NativeImageResourceBuildItem(service));

        // register every listed implementation class so they can be inspected/instantiated
        // in native-image at run-time
        Set&lt;String&gt; implementations =
            ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),
                                          service);
        reflectionClasses.produce(
            new ReflectiveClassBuildItem(true, true, implementations.toArray(new String[0])));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Embora essa seja a maneira mais fácil de fazer com que seus serviços sejam executados nativamente, é menos eficiente do que verificar as classes de implementação em tempo de construção e gerar código que as registre no momento da inicialização estática, em vez de depender da reflexão.</p>
</div>
<div class="paragraph">
<p>Você pode conseguir isso adaptando a etapa de construção anterior para usar um gravador de inicialização estática em vez de registrar classes para reflexão:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public final class MyExtProcessor {

    @BuildStep
    @Record(ExecutionTime.STATIC_INIT)
    void registerNativeImageResources(RecorderContext recorderContext,
                                     SomeServiceRecorder recorder) {
        String service = "META-INF/services/" + io.quarkus.SomeService.class.getName();

        // read the implementation classes
        Collection&lt;Class&lt;? extends io.quarkus.SomeService&gt;&gt; implementationClasses = new LinkedHashSet&lt;&gt;();
        Set&lt;String&gt; implementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),
                                                                    service);
        for(String implementation : implementations) {
            implementationClasses.add((Class&lt;? extends io.quarkus.SomeService&gt;)
                recorderContext.classProxy(implementation));
        }

        // produce a static-initializer with those classes
        recorder.configure(implementationClasses);
    }
}

@Recorder
public class SomeServiceRecorder {

    public void configure(List&lt;Class&lt;? extends io.quarkus.SomeService&gt;&gt; implementations) {
        // configure our service statically
        SomeServiceProvider serviceProvider = SomeServiceProvider.instance();
        SomeServiceBuilder builder = serviceProvider.getSomeServiceBuilder();

        List&lt;io.quarkus.SomeService&gt; services = new ArrayList&lt;&gt;(implementations.size());
        // instantiate the service implementations
        for (Class&lt;? extends io.quarkus.SomeService&gt; implementationClass : implementations) {
            try {
                services.add(implementationClass.getConstructor().newInstance());
            } catch (Exception e) {
                throw new IllegalArgumentException("Unable to instantiate service " + implementationClass, e);
            }
        }

        // build our service
        builder.withSomeServices(implementations.toArray(new io.quarkus.SomeService[0]));
        ServiceManager serviceManager = builder.build();

        // register it
        serviceProvider.registerServiceManager(serviceManager, Thread.currentThread().getContextClassLoader());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="object-substitution"><a class="anchor" href="#object-substitution"></a>2.19.10. Substituição de Objetos</h4>
<div class="paragraph">
<p>Os objetos criados durante a fase de construção que são passados para o tempo de execução têm de ter um construtor padrão para que sejam criados e configurados na inicialização do tempo de execução a partir do estado do tempo de construção. Se um objeto não tiver um construtor padrão, verá um erro semelhante ao seguinte durante a geração dos artefatos ampliados:</p>
</div>
<div class="listingblock">
<div class="title">Erro de Serialização de DSAPublicKey</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">	[error]: Build step io.quarkus.deployment.steps.MainClassBuildStep#build threw an exception: java.lang.RuntimeException: Unable to serialize objects of type class sun.security.provider.DSAPublicKeyImpl to bytecode as it has no default constructor
	at io.quarkus.builder.Execution.run(Execution.java:123)
	at io.quarkus.builder.BuildExecutionBuilder.execute(BuildExecutionBuilder.java:136)
	at io.quarkus.deployment.QuarkusAugmentor.run(QuarkusAugmentor.java:110)
	at io.quarkus.runner.RuntimeRunner.run(RuntimeRunner.java:99)
	... 36 more</code></pre>
</div>
</div>
<div class="paragraph">
<p>Existe uma interface <code>io.quarkus.runtime.ObjectSubstitution</code> que pode ser implementada para dizer ao Quarkus como lidar com essas classes. Um exemplo de implementação para a interface <code>DSAPublicKey</code> é mostrado aqui:</p>
</div>
<div class="listingblock">
<div class="title">Exemplo de DSAPublicKeyObjectSubstitution</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.extest.runtime.subst;

import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.interfaces.DSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.X509EncodedKeySpec;
import java.util.logging.Logger;

import io.quarkus.runtime.ObjectSubstitution;

public class DSAPublicKeyObjectSubstitution implements ObjectSubstitution&lt;DSAPublicKey, KeyProxy&gt; {
    private static final Logger log = Logger.getLogger("DSAPublicKeyObjectSubstitution");
    @Override
    public KeyProxy serialize(DSAPublicKey obj) { <i class="conum" data-value="1"></i><b>(1)</b>
        log.info("DSAPublicKeyObjectSubstitution.serialize");
        byte[] encoded = obj.getEncoded();
        KeyProxy proxy = new KeyProxy();
        proxy.setContent(encoded);
        return proxy;
    }

    @Override
    public DSAPublicKey deserialize(KeyProxy obj) { <i class="conum" data-value="2"></i><b>(2)</b>
        log.info("DSAPublicKeyObjectSubstitution.deserialize");
        byte[] encoded = obj.getContent();
        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(encoded);
        DSAPublicKey dsaPublicKey = null;
        try {
            KeyFactory kf = KeyFactory.getInstance("DSA");
            dsaPublicKey = (DSAPublicKey) kf.generatePublic(publicKeySpec);

        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
            e.printStackTrace();
        }
        return dsaPublicKey;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>O método serialize pega o objeto sem um construtor padrão e cria um <code>KeyProxy</code> que contém as informações necessárias para recriar o <code>DSAPublicKey</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>O método deserialize utiliza o <code>KeyProxy</code> para recriar o <code>DSAPublicKey</code> a partir da sua forma codificada, utilizando a fábrica de chaves.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Uma extensão registra esta substituição produzindo um <code>ObjectSubstitutionBuildItem</code>, como mostra este fragmento de <code>TestProcessor#loadDSAPublicKey</code>:</p>
</div>
<div class="listingblock">
<div class="title">Registrando uma Substituição de Objeto</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @BuildStep
    @Record(STATIC_INIT)
    PublicKeyBuildItem loadDSAPublicKey(TestRecorder recorder,
            BuildProducer&lt;ObjectSubstitutionBuildItem&gt; substitutions) throws IOException, GeneralSecurityException {
...
        // Register how to serialize DSAPublicKey
        ObjectSubstitutionBuildItem.Holder&lt;DSAPublicKey, KeyProxy&gt; holder = new ObjectSubstitutionBuildItem.Holder(
                DSAPublicKey.class, KeyProxy.class, DSAPublicKeyObjectSubstitution.class);
        ObjectSubstitutionBuildItem keysub = new ObjectSubstitutionBuildItem(holder);
        substitutions.produce(keysub);

        log.info("loadDSAPublicKey run");
        return new PublicKeyBuildItem(publicKey);
    }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="replacing-classes-in-the-native-image"><a class="anchor" href="#replacing-classes-in-the-native-image"></a>2.19.11. Substituindo Classes na Imagem Nativa</h4>
<div class="paragraph">
<p>O Graal SDK oferece suporte a substituições de classes na imagem nativa. Um exemplo de como é possível substituir as classes <code>XmlConfig/XmlData</code> por versões que não têm dependências de anotação JAXB é mostrado nestas classes de exemplo:</p>
</div>
<div class="listingblock">
<div class="title">Exemplo de Substituição das Classes XmlConfig/XmlData</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.extest.runtime.graal;
import java.util.Date;
import com.oracle.svm.core.annotate.Substitute;
import com.oracle.svm.core.annotate.TargetClass;
import io.quarkus.extest.runtime.config.XmlData;

@TargetClass(XmlConfig.class)
@Substitute
public final class Target_XmlConfig {

    @Substitute
    private String address;
    @Substitute
    private int port;
    @Substitute
    private ArrayList&lt;XData&gt; dataList;

    @Substitute
    public String getAddress() {
        return address;
    }

    @Substitute
    public int getPort() {
        return port;
    }

    @Substitute
    public ArrayList&lt;XData&gt; getDataList() {
        return dataList;
    }

    @Substitute
    @Override
    public String toString() {
        return "Target_XmlConfig{" +
                "address='" + address + '\'' +
                ", port=" + port +
                ", dataList=" + dataList +
                '}';
    }
}

@TargetClass(XmlData.class)
@Substitute
public final class Target_XmlData {

    @Substitute
    private String name;
    @Substitute
    private String model;
    @Substitute
    private Date date;

    @Substitute
    public String getName() {
        return name;
    }

    @Substitute
    public String getModel() {
        return model;
    }

    @Substitute
    public Date getDate() {
        return date;
    }

    @Substitute
    @Override
    public String toString() {
        return "Target_XmlData{" +
                "name='" + name + '\'' +
                ", model='" + model + '\'' +
                ", date='" + date + '\'' +
                '}';
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration-reference-documentation"><a class="anchor" href="#configuration-reference-documentation"></a>3. Configuration reference documentation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A configuração é uma parte importante de cada extensão e, portanto, precisa ser documentada adequadamente. Cada propriedade de configuração deve ter um comentário Javadoc adequado.</p>
</div>
<div class="paragraph">
<p>While it is handy to have the documentation available when coding, this configuration documentation must also be available in the extension guides.
The Quarkus build automatically generates the configuration documentation for you based on the Javadoc comments, but you need to explicitly include it in your guide.</p>
</div>
<div class="paragraph">
<p>In this section, we will explain everything you need to know about the configuration reference documentation.</p>
</div>
<div class="sect2">
<h3 id="writing-the-documentation"><a class="anchor" href="#writing-the-documentation"></a>3.1. Escrevendo a documentação</h3>
<div class="paragraph">
<p>For each configuration property, you need to write some Javadoc explaining its purpose.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Always make the first sentence meaningful and self-contained as it is included in the summary table.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can either use standard Javadoc comments or Asciidoc directly as a Javadoc comment.</p>
</div>
<div class="paragraph">
<p>We assume you are familiar with writing Javadoc comments so let&#8217;s focus on our Asciidoc support.
While standard Javadoc comments are perfectly fine for simple documentation (recommended even),
if you want to include tips, source code extracts, lists&#8230;&#8203; Asciidoc comes in handy.</p>
</div>
<div class="paragraph">
<p>Here is a typical configuration property commented with Asciidoc:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * Class name of the Hibernate ORM dialect. The complete list of bundled dialects is available in the
 * https://docs.jboss.org/hibernate/stable/orm/javadocs/org/hibernate/dialect/package-summary.html[Hibernate ORM JavaDoc].
 *
 * [NOTE]
 * ====
 * Not all the dialects are supported in GraalVM native executables: we currently provide driver extensions for PostgreSQL,
 * MariaDB, Microsoft SQL Server and H2.
 * ====
 *
 * @asciidoclet
 */
@ConfigItem
public Optional&lt;String&gt; dialect;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the simple case: you just have to write Asciidoc and mark the comment with the <code>@asciidoclet</code> tag.
This tag has two purposes: it is used as a marker for our generation tool, but it is also used by the <code>javadoc</code> process for proper Javadoc generation.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s consider a more complicated example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// @formatter:off
/**
 * Name of the file containing the SQL statements to execute when Hibernate ORM starts.
 * Its default value differs depending on the Quarkus launch mode:
 *
 * * In dev and test modes, it defaults to `import.sql`.
 *   Simply add an `import.sql` file in the root of your resources directory
 *   and it will be picked up without having to set this property.
 *   Pass `no-file` to force Hibernate ORM to ignore the SQL import file.
 * * In production mode, it defaults to `no-file`.
 *   It means Hibernate ORM won't try to execute any SQL import file by default.
 *   Pass an explicit value to force Hibernate ORM to execute the SQL import file.
 *
 * If you need different SQL statements between dev mode, test (`@QuarkusTest`) and in production, use Quarkus
 * https://quarkus.io/guides/config#configuration-profiles[configuration profiles facility].
 *
 * [source,property]
 * .application.properties
 * ----
 * %dev.quarkus.hibernate-orm.sql-load-script = import-dev.sql
 * %test.quarkus.hibernate-orm.sql-load-script = import-test.sql
 * %prod.quarkus.hibernate-orm.sql-load-script = no-file
 * ----
 *
 * [NOTE]
 * ====
 * Quarkus supports `.sql` file with SQL statements or comments spread over multiple lines.
 * Each SQL statement must be terminated by a semicolon.
 * ====
 *
 * @asciidoclet
 */
// @formatter:on
@ConfigItem
public Optional&lt;String&gt; sqlLoadScript;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A few comments on this one:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Every time you will need the indentation to be respected in the Javadoc comment (think list items spread on multiple lines or indented source code),
you will need to disable temporarily the automatic Eclipse formatter
(this, even if you don&#8217;t use Eclipse as the formatter is included in our build).
To do so, use the <code>// @formatter:off</code>/<code>// @formatter:on</code> markers.
Note the fact that they are separate comments and there is a space after the <code>//</code> marker. This is required.</p>
</li>
<li>
<p>As you can see, you can use the full power of Asciidoctor (except for the limitation below)</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You cannot use open blocks (<code>--</code>) in your Asciidoctor documentation.
All the other types of blocks (source, admonitions&#8230;&#8203;) are supported.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>By default, the doc generator will use the hyphenated field name as the key of a <code>java.util.Map</code> configuration item.
To override this default and have a user-friendly key (independent of implementation details), you may use the <code>io.quarkus.runtime.annotations.ConfigDocMapKey</code> annotation.
See the following example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigRoot
public class SomeConfig {
    /**
     * Namespace configuration.
     */
    @ConfigItem(name = ConfigItem.PARENT)
    @ConfigDocMapKey("cache-name") <i class="conum" data-value="1"></i><b>(1)</b>
    Map&lt;String, CaffeineNamespaceConfig&gt; namespace;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Isto irá gerar uma chave de mapa de configuração com o nome <code>quarkus.some."cache-name"</code> em vez de <code>quarkus.some."namespace"</code>.</td>
</tr>
</table>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="writing-section-documentation"><a class="anchor" href="#writing-section-documentation"></a>3.2. Escrevendo documentação de seção</h3>
<div class="paragraph">
<p>If you wish to generate configuration section of a given <code>@ConfigGroup</code>, Quarkus has got you covered with the <code>@ConfigDocSection</code> annotation.
See the code  example below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
* Config group related configuration.
* Amazing introduction here
*/
@ConfigItem
@ConfigDocSection <i class="conum" data-value="1"></i><b>(1)</b>
public ConfigGroupConfig configGroup;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This will add a section documentation for the <code>configGroup</code> config item in the generated documentation.
Section&#8217;s title and introduction will be derived from the javadoc of the configuration item. The first sentence from the javadoc is considered as the section title and the remaining sentences used as section introduction.
You can also use the <code>@asciidoclet</code> tag as shown above.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="generating-the-documentation"><a class="anchor" href="#generating-the-documentation"></a>3.3. Gerando a documentação</h3>
<div class="paragraph">
<p>Generating the documentation is easy:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Running <code>./mvnw clean install -DskipTests -DskipITs</code> will do.</p>
</li>
<li>
<p>You  can either do it globally or in a specific extension directory (e.g. <code>extensions/mailer</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A documentação é gerada na <code>target/asciidoc/generated/config/</code> global localizada na raiz do projeto.</p>
</div>
</div>
<div class="sect2">
<h3 id="including-the-documentation-in-the-extension-guide"><a class="anchor" href="#including-the-documentation-in-the-extension-guide"></a>3.4. Incluindo a documentação no guia de extensão</h3>
<div class="paragraph">
<p>Now that you have generated the configuration reference documentation for your extension, you need to include it in your guide (and review it).</p>
</div>
<div class="paragraph">
<p>This is simple, include the generated documentation in your guide:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">include::{generated-dir}/config/quarkus-your-extension.adoc[opts=optional, leveloffset=+1]</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are interested in including the generated documentation for the config group, you can use the include statement below</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">include::{generated-dir}/config/hyphenated-config-group-class-name-with-runtime-or-deployment-namespace-replaced-by-config-group-namespace.adoc[opts=optional, leveloffset=+1]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Por exemplo, o grupo de configuração <code>io.quarkus.vertx.http.runtime.FormAuthConfig</code> será gerado em um arquivo chamado <code>quarkus-vertx-http-config-group-form-auth-config.adoc</code>.</p>
</div>
<div class="paragraph">
<p>Algumas recomendações:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>opts=optional</code> is mandatory as we don&#8217;t want the build to fail if only part of the configuration documentation has been generated</p>
</li>
<li>
<p>The documentation is generated with a title level of 2 (i.e. <code>==</code>).
You usually need to adjust it.
It can be done with <code>leveloffset=+N</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It is not recommended to include the whole configuration documentation in the middle of your guide as it&#8217;s heavy.
If you have an <code>application.properties</code> extract with your configuration, just do as follows.</p>
</div>
<div class="paragraph">
<p>First, include a tip just below your <code>application.properties</code> extract:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">[TIP]
For more information about the extension configuration please refer to the &lt;&lt;configuration-reference, Configuration Reference&gt;&gt;.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, at the end of your documentation, include the extensive documentation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">[[configuration-reference]]
== Configuration Reference

include::{generated-dir}/config/quarkus-your-extension.adoc[opts=optional, leveloffset=+1]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, generate the documentation and check it out.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ecosystem"><a class="anchor" href="#ecosystem"></a>4. Integração do ecossistema</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Algumas extensões podem ser privadas e outras podem desejar fazer parte do ecossistema mais amplo do Quarkus e estar disponíveis para reutilização pela comunidade. A inclusão no Quarkiverse Hub é um mecanismo conveniente para lidar com testes e publicações contínuos. O <a href="https://github.com/quarkiverse/quarkiverse/wiki#getting-an-extension-onboarded">wiki do Quarkiverse Hub</a> tem instruções para integrar sua extensão.</p>
</div>
<div class="paragraph">
<p>Alternativamente, os testes contínuos e a publicação podem ser efetuados manualmente.</p>
</div>
<div class="sect2">
<h3 id="ecosystem-ci"><a class="anchor" href="#ecosystem-ci"></a>4.1. Testes contínuos da sua extensão</h3>
<div class="paragraph">
<p>Para facilitar que os autores de extensões testem suas extensões diariamente em relação ao último snapshot do Quarkus, o Quarkus introduziu a noção de Ecosystem CI. O <a href="https://github.com/quarkusio/quarkus-ecosystem-ci/blob/main/README.adoc">README</a> do Ecosystem CI tem todos os detalhes sobre como configurar um job do GitHub Actions para aproveitar esse recurso, enquanto este <a href="https://www.youtube.com/watch?v=VpbRA1n0hHQ">vídeo</a> fornece uma visão geral de como é o processo.</p>
</div>
</div>
<div class="sect2">
<h3 id="publish-your-extension-in-registry-quarkus-io"><a class="anchor" href="#publish-your-extension-in-registry-quarkus-io"></a>4.2. Publique a sua extensão em registry.quarkus.io</h3>
<div class="paragraph">
<p>Antes de publicar a sua extensão nas <a href="tooling.html">ferramentas Quarkus</a>, certifique-se de que os seguintes requisitos são cumpridos:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>O arquivo <a href="extension-metadata#quarkus-extension-yaml">quarkus-extension.yaml</a> (no módulo <code>runtime/</code> da extensão) tem o conjunto mínimo de metadados:</p>
<div class="ulist">
<ul>
<li>
<p><code>name</code></p>
</li>
<li>
<p><code>description</code> (a menos que já esteja definido no elemento <code>&lt;description&gt;</code> do <code>runtime/pom.xml</code>, que é a abordagem recomendada)</p>
</li>
</ul>
</div>
</li>
<li>
<p>A sua extensão é publicada no Maven Central</p>
</li>
<li>
<p>Your extension repository is configured to use the <a href="#ecosystem-ci">Ecosystem CI</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Em seguida, deve criar um pull request adicionando um arquivo <code>your-extension.yaml</code> no diretório <code>extensions/</code> no <a href="https://github.com/quarkusio/quarkus-extension-catalog">Catálogo de Extensões do Quarkus</a>. O YAML deve ter a seguinte estrutura:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">group-id: &lt;YOUR_EXTENSION_RUNTIME_GROUP_ID&gt;
artifact-id: &lt;YOUR_EXTENSION_RUNTIME_ARTIFACT_ID&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Isso é tudo. Assim que o pull request for integrado, um job agendado irá verificar o Maven Central para novas versões e atualizar o <a href="extension-registry-user">Registro de Extensões Quarkus</a>.</p>
</div>
</div>
</div>
</div>
        </div>
        <div class="grid__item width-4-12 width-12-12-m tocwrapper">
            <div class="hide-mobile toc"><ul class="sectlevel1">
<li><a href="#extension-philosophy">1. Filosofia da extensão</a>
<ul class="sectlevel2">
<li><a href="#why-an-extension-framework">1.1. Por que um framework de extensão</a></li>
<li><a href="#favor-build-time-work-over-runtime-work">1.2. Favorecer o trabalho em tempo de construção em detrimento do trabalho em tempo de execução</a></li>
<li><a href="#how-to-expose-configuration">1.3. Como expor a configuração</a></li>
<li><a href="#expose-your-components-via-cdi">1.4. Exponha os seus componentes através de CDI</a></li>
<li><a href="#some-types-of-extensions">1.5. Alguns tipos de extensões</a></li>
</ul>
</li>
<li><a href="#technical-aspect">2. Aspecto técnico</a>
<ul class="sectlevel2">
<li><a href="#bootstrap-three-phases">2.1. Três Fases do Bootstrap e Filosofia do Quarkus</a></li>
<li><a href="#project-setup">2.2. Configuração do projeto</a></li>
<li><a href="#build-step-processors">2.3. Processadores de Etapas de Construção</a></li>
<li><a href="#configuration">2.4. Configuração</a></li>
<li><a href="#conditional-step-inclusion">2.5. Inclusão Condicional de Etapas</a></li>
<li><a href="#bytecode-recording">2.6. Gravação de Bytecode</a></li>
<li><a href="#contexts-and-dependency-injection">2.7. Contextos e Injeção de Dependência</a></li>
<li><a href="#quarkus-dev-ui">2.8. Quarkus Dev UI</a></li>
<li><a href="#extension-defined-endpoints">2.9. Endpoints definidos pela extensão</a></li>
<li><a href="#extension-health-check">2.10. Verificação de Integridade da Extensão</a></li>
<li><a href="#extension-metrics">2.11. Métricas de Extensão</a></li>
<li><a href="#customizing-json-handling-from-an-extension">2.12. Personalizando tratamento JSON a partir de uma extensão</a></li>
<li><a href="#integrating-with-development-mode">2.13. Integração com o Modo de Desenvolvimento</a></li>
<li><a href="#testing-extensions">2.14. Testando Extensões</a></li>
<li><a href="#testing-hot-reload">2.15. Testando recarga em tempo real</a></li>
<li><a href="#native-executable-support">2.16. Suporte a Executáveis Nativos</a></li>
<li><a href="#ide-support-tips">2.17. Sugestões de suporte à IDE</a></li>
<li><a href="#troubleshooting-debugging-tips">2.18. Dicas de Resolução de Problemas / Depuração</a></li>
<li><a href="#sample-test-extension">2.19. Exemplo de Extensão de Teste</a></li>
</ul>
</li>
<li><a href="#configuration-reference-documentation">3. Configuration reference documentation</a>
<ul class="sectlevel2">
<li><a href="#writing-the-documentation">3.1. Escrevendo a documentação</a></li>
<li><a href="#writing-section-documentation">3.2. Escrevendo documentação de seção</a></li>
<li><a href="#generating-the-documentation">3.3. Gerando a documentação</a></li>
<li><a href="#including-the-documentation-in-the-extension-guide">3.4. Incluindo a documentação no guia de extensão</a></li>
</ul>
</li>
<li><a href="#ecosystem">4. Integração do ecossistema</a>
<ul class="sectlevel2">
<li><a href="#ecosystem-ci">4.1. Testes contínuos da sua extensão</a></li>
<li><a href="#publish-your-extension-in-registry-quarkus-io">4.2. Publique a sua extensão em registry.quarkus.io</a></li>
</ul>
</li>
</ul></div>
        </div>
    </div>
    </div>

  </div>

  <div class="content project-footer">
  <div class="footer-section">
    <div class="logo-wrapper">
      <a href="/"><img src="/assets/images/quarkus_logo_horizontal_rgb_reverse.svg" class="project-logo" title="Quarkus"></a>
    </div>
  </div>
  <div class="grid-wrapper">
    <p class="grid__item width-3-12">Quarkus is open. All dependencies of this project are available under the <a href='https://www.apache.org/licenses/LICENSE-2.0' target='_blank'>Apache Software License 2.0</a> or compatible license. <i class='fab fa-creative-commons'></i><i class='fab fa-creative-commons-by'></i> <a href='https://creativecommons.org/licenses/by/3.0/' target='_blank'>CC by 3.0</a><br /><br />This website was built with <a href='https://jekyllrb.com/' target='_blank'>Jekyll</a>, is hosted on <a href='https://pages.github.com/' target='_blank'>GitHub Pages</a> and is completely open source. If you want to make it better, <a href='https://github.com/quarkusio/quarkusio.github.io' target='_blank'>fork the website</a> and show us what you’ve got.</p>

    
      <div class="width-1-12 project-links">
        <span>Navigation</span>
        <ul class="footer-links">
          
          
            <li><a href="/" target="_blank">Home</a></li>
          
          
          
            <li><a href="/about" target="_blank">About</a></li>
          
          
          
            <li><a href="/blog" target="_blank">Blog</a></li>
          
          
          
            <li><a href="/insights" target="_blank">Podcast</a></li>
          
          
          
            <li><a href="/events" target="_blank">Eventos</a></li>
          
          
          
            <li><a href="/newsletter" target="_blank">Newsletter</a></li>
          
          
          
            <li><a href="/userstories" target="_blank">User Stories</a></li>
          
          
          
            <li><a href="https://github.com/orgs/quarkusio/projects/13/views/1" target="_blank">Roadmap</a></li>
          
          
          
            <li><a href="/security" target="_blank">Security&nbsp;policy</a></li>
          
          
          
            <li><a href="/usage" target="_blank">Usage</a></li>
          
          
          
            <li><a href="https://github.com/commonhaus/artwork/tree/main/projects/quarkus" target="_blank">Brand</a></li>
          
          
          
            <li><a href="/desktopwallpapers" target="_blank">Wallpapers</a></li>
          
          
          
            <li><a href="https://www.redhat.com/en/about/privacy-policy" target="_blank">Privacy Policy</a></li>
          
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>Follow Us</span>
        <ul class="footer-links">
          
          
            <li><a href="https://x.com/quarkusio" target="_blank">X</a></li>
          
          
          
            <li><a href="https://bsky.app/profile/quarkus.io" target="_blank">Bluesky</a></li>
          
          
          
            <li><a rel="me" href="https://fosstodon.org/@quarkusio" target="_blank">Mastodon</a></li>
            
          
          
            <li><a href="https://www.threads.com/@quarkusio" target="_blank">Threads</a></li>
          
          
          
            <li><a href="https://www.facebook.com/quarkusio" target="_blank">Facebook</a></li>
          
          
          
            <li><a href="https://www.linkedin.com/company/quarkusio/" target="_blank">Linkedin</a></li>
          
          
          
            <li><a href="https://www.youtube.com/channel/UCaW8QG_QoIk_FnjLgr5eOqg" target="_blank">Youtube</a></li>
          
          
          
            <li><a href="https://github.com/quarkusio" target="_blank">GitHub</a></li>
          
          
        </ul>
      </div>
    
      <div class="width-2-12 project-links">
        <span>Get Help</span>
        <ul class="footer-links">
          
          
            <li><a href="/support" target="_blank">Support</a></li>
          
          
          
            <li><a href="/guides" target="_blank">Guias</a></li>
          
          
          
            <li><a href="/faq" target="_blank">FAQ</a></li>
          
          
          
            <li><a href="/get-started" target="_blank">Get Started</a></li>
          
          
          
            <li><a href="https://stackoverflow.com/questions/tagged/quarkus" target="_blank">Stack Overflow</a></li>
          
          
          
            <li><a href="https://github.com/quarkusio/quarkus/discussions" target="_blank">Discussions</a></li>
          
          
          
            <li><a href="https://groups.google.com/forum/#!forum/quarkus-dev" target="_blank">Development mailing list</a></li>
          
          
          
            <li><a href="https://stats.uptimerobot.com/ze1PfweT2p" target="_blank">Quarkus Service Status</a></li>
          
          
        </ul>
      </div>
    
      <div class="width-1-12 project-links">
        <span>Languages</span>
        <ul class="footer-links">
          
          
            <li><a href="https://quarkus.io/" target="_blank">English</a></li>
          
          
          
            <li><a href="https://pt.quarkus.io/" target="_blank">Português&nbsp;(Brasileiro)</a></li>
          
          
          
            <li><a href="https://es.quarkus.io/" target="_blank">Español</a></li>
          
          
          
            <li><a href="https://cn.quarkus.io/" target="_blank">简体中文</a></li>
          
          
          
            <li><a href="https://ja.quarkus.io/" target="_blank">日本語</a></li>
          
          
        </ul>
      </div>
    

    
      <div class="width-4-12 more-links">
        <span>Quarkus is made of community projects</span>
        <ul class="footer-links">
          
            <li><a blah href="https://vertx.io/" target="_blank">Eclipse Vert.x</a></li>
          
            <li><a blah href="https://smallrye.io" target="_blank">SmallRye</a></li>
          
            <li><a blah href="https://hibernate.org" target="_blank">Hibernate</a></li>
          
            <li><a blah href="https://netty.io" target="_blank">Netty</a></li>
          
            <li><a blah href="https://resteasy.github.io" target="_blank">RESTEasy</a></li>
          
            <li><a blah href="https://camel.apache.org" target="_blank">Apache Camel</a></li>
          
            <li><a blah href="https://microprofile.io" target="_blank">Eclipse MicroProfile</a></li>
          
            <li><a blah href="https://code.quarkus.io/" target="_blank">And many more...</a></li>
          
        </ul>
      </div>
    
  </div>
</div>

  <div class="content cf-footer">
  <div class="flexcontainer">
    <div class="cf-logo">
      <a class="cf-logo" href="https://www.commonhaus.org/" target="_blank"><img src="https://raw.githubusercontent.com/commonhaus/artwork/main/foundation/brand/svg/CF_logo_horizontal_single_reverse.svg"/></a>
    </div>
    <div class="license">
      Copyright © Quarkus. All rights reserved. For details on our trademarks, please visit our <a href="https://www.commonhaus.org/policies/trademark-policy/">Trademark Policy</a> and <a href="https://www.commonhaus.org/trademarks/">Trademark List</a>. Trademarks of third parties are owned by their respective holders and their mention here does not suggest any endorsement or association.
    </div>
  </div>
</div>


  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>
  <script type="text/javascript" src="/assets/javascript/mobile-nav.js"></script>
  <script type="text/javascript" src="/assets/javascript/scroll-down.js"></script>
  <script src="/assets/javascript/satellite.js" type="text/javascript"></script>
  <script src="/guides/javascript/config.js" type="text/javascript"></script>
  <script src="/assets/javascript/guides-version-dropdown.js" type="text/javascript"></script>
  <script src="/assets/javascript/back-to-top.js" type="text/javascript"></script>
  <script src="/assets/javascript/clipboard.min.js" type="text/javascript"></script>
  <script src="/assets/javascript/copy.js" type="text/javascript"></script>
  <script src="/assets/javascript/asciidoc-tabs.js" type="text/javascript"></script>
  <script src="/assets/javascript/future-date.js" type="text/javascript"></script>
  <script src="/assets/javascript/randomize.js" type="text/javascript"></script>
  <script src="/assets/javascript/time.js" type="text/javascript"></script>
</body>

</html>
