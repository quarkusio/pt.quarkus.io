# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-10-29 08:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:7
#, fuzzy, no-wrap
msgid "OpenID Connect (OIDC) Bearer token authentication"
msgstr "OpenID Connect (OIDC) Autenticação de token de portador"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:15
#, fuzzy
msgid "Secure HTTP access to Jakarta REST (formerly known as JAX-RS) endpoints in your application with Bearer token authentication by using the Quarkus OpenID Connect (OIDC) extension."
msgstr "Acesso HTTP seguro a pontos de extremidade Jakarta REST (anteriormente conhecidos como JAX-RS) na sua aplicação com autenticação de token Bearer utilizando a extensão Quarkus OpenID Connect (OIDC)."

#. type: Title ==
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:16
#, fuzzy, no-wrap
msgid "Overview of the Bearer token authentication mechanism in Quarkus"
msgstr "Visão geral do mecanismo de autenticação do token de portador no Quarkus"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:19
#, fuzzy
msgid "Quarkus supports the Bearer token authentication mechanism through the Quarkus OpenID Connect (OIDC) extension."
msgstr "O Quarkus suporta o mecanismo de autenticação de token Bearer através da extensão Quarkus OpenID Connect (OIDC)."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:21
#, fuzzy
msgid "The bearer tokens are issued by OIDC and OAuth 2.0 compliant authorization servers, such as link:https://www.keycloak.org[Keycloak]."
msgstr "Os tokens de portador são emitidos por servidores de autorização compatíveis com OIDC e OAuth 2.0, como o  link:https://www.keycloak.org[Keycloak]."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:24
#, fuzzy
msgid "Bearer token authentication is the process of authorizing HTTP requests based on the existence and validity of a bearer token.  The bearer token provides information about the subject of the call, which is used to determine whether or not an HTTP resource can be accessed."
msgstr "A autenticação do token portador é o processo de autorização de pedidos HTTP com base na existência e validade de um token portador. O token do portador fornece informações sobre o sujeito da chamada, que são utilizadas para determinar se um recurso HTTP pode ou não ser acedido."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:26
#, fuzzy
msgid "The following diagrams outline the Bearer token authentication mechanism in Quarkus:"
msgstr "Os diagramas seguintes descrevem o mecanismo de autenticação do token de portador no Quarkus:"

#. type: Block title
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:27
#, fuzzy, no-wrap
msgid "Bearer token authentication mechanism in Quarkus with Single-page application"
msgstr "Mecanismo de autenticação de token de portador no Quarkus com aplicação de página única"

#. type: Named 'alt' AttributeList argument for macro 'image'
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:28
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:38
#, fuzzy, no-wrap
msgid "Bearer"
msgstr "Portador"

#. type: Target for macro image
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:28
#, no-wrap
msgid "security-bearer-token-authorization-mechanism-1.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:31
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:41
#, fuzzy
msgid "The Quarkus service retrieves verification keys from the OpenID Connect provider. The verification keys are used to verify the bearer access token signatures."
msgstr "O serviço Quarkus obtém chaves de verificação do fornecedor OpenID Connect. As chaves de verificação são utilizadas para verificar as assinaturas do token de acesso ao portador."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:32
#, fuzzy
msgid "The Quarkus user accesses the Single-page application."
msgstr "O utilizador Quarkus acede à aplicação Single-page."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:33
#, fuzzy
msgid "The Single-page application uses Authorization Code Flow to authenticate the user and retrieve tokens from the OpenID Connect provider."
msgstr "A aplicação de página única utiliza o fluxo de código de autorização para autenticar o utilizador e obter tokens do fornecedor OpenID Connect."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:34
#, fuzzy
msgid "The Single-page application uses the access token to retrieve the service data from the Quarkus service."
msgstr "A aplicação de página única utiliza o token de acesso para obter os dados do serviço Quarkus."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:35
#, fuzzy
msgid "The Quarkus service verifies the bearer access token signature using the verification keys, checks the token expiry date and other claims, allows the request to proceed if the token is valid, and returns the service response to the Single-page application."
msgstr "O serviço Quarkus verifica a assinatura do token de acesso ao portador utilizando as chaves de verificação, verifica a data de expiração do token e outras reivindicações, permite que o pedido prossiga se o token for válido e devolve a resposta do serviço à aplicação de página única."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:36
#, fuzzy
msgid "The Single-page application returns the same data to the Quarkus user."
msgstr "A aplicação de página única devolve os mesmos dados ao utilizador Quarkus."

#. type: Block title
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:37
#, fuzzy, no-wrap
msgid "Bearer token authentication mechanism in Quarkus with Java or command line client"
msgstr "Mecanismo de autenticação de token de portador no Quarkus com Java ou cliente de linha de comando"

#. type: Target for macro image
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:38
#, no-wrap
msgid "security-bearer-token-authorization-mechanism-2.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:42
#, fuzzy
msgid "The Client uses `client_credentials` that requires client ID and secret or password grant, which also requires client ID, secret, user name, and password to retrieve the access token from the OpenID Connect provider."
msgstr "O Cliente utiliza `client_credentials` que requer a ID do cliente e o segredo ou a concessão de palavra-passe, que também requer a ID do cliente, o segredo, o nome de utilizador e a palavra-passe para recuperar o token de acesso do fornecedor OpenID Connect."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:43
#, fuzzy
msgid "The Client uses the access token to retrieve the service data from the Quarkus service."
msgstr "O Cliente utiliza o token de acesso para recuperar os dados do serviço Quarkus."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:44
#, fuzzy
msgid "The Quarkus service verifies the bearer access token signature using the verification keys, checks the token expiry date and other claims, allows the request to proceed if the token is valid, and returns the service response to the Client."
msgstr "O serviço Quarkus verifica a assinatura do token de acesso ao portador utilizando as chaves de verificação, verifica a data de expiração do token e outras reivindicações, permite que o pedido prossiga se o token for válido e devolve a resposta do serviço ao Cliente."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:47
#, fuzzy
msgid "If you need to authenticate and authorize the users using OpenID Connect Authorization Code Flow, see xref:security-oidc-code-flow-authentication.adoc[OIDC code flow mechanism for protecting web applications].  Also, if you use Keycloak and bearer tokens, see xref:security-keycloak-authorization.adoc[Using Keycloak to Centralize Authorization]."
msgstr "Se precisar de autenticar e autorizar os utilizadores utilizando o Fluxo de Código de Autorização OpenID Connect, consulte  link:security-oidc-code-flow-authentication.html[Mecanismo de fluxo de código OIDC para proteger aplicações Web]. Além disso, se utilizar Keycloak e tokens de portador, consulte  link:security-keycloak-authorization.html[Utilizar Keycloak para centralizar a autorização]."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:49
#, fuzzy
msgid "To learn about how you can protect service applications by using OIDC Bearer token authentication, see xref:security-oidc-bearer-token-authentication-tutorial.adoc[OIDC Bearer token authentication tutorial]."
msgstr "Para saber como pode proteger as aplicações de serviço utilizando a autenticação de token do OIDC Bearer, consulte o  link:security-oidc-bearer-token-authentication-tutorial.html[tutorial de autenticação de token do OIDC Bearer]."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:51
#, fuzzy
msgid "If you want to protect web applications by using OIDC authorization code flow authentication, see xref:security-oidc-code-flow-authentication-concept.adoc[OIDC authorization code flow authentication]."
msgstr "Se pretender proteger aplicações Web utilizando a autenticação de fluxo de código de autorização OIDC, consulte  link:security-oidc-code-flow-authentication-concept.html[Autenticação de fluxo de código de autorização OIDC]."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:53
#, fuzzy
msgid "For information about how to support multiple tenants, see xref:security-openid-connect-multitenancy.adoc[Using OpenID Connect Multi-Tenancy]."
msgstr "Para obter informações sobre como oferecer suporte a vários locatários, consulte  link:security-openid-connect-multitenancy.html[Usando o OpenID Connect Multi-Tenancy]."

#. type: Title ===
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:54
#, fuzzy, no-wrap
msgid "Accessing JWT claims"
msgstr "Aceder a reivindicações JWT"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:57
#, fuzzy
msgid "If you need to access JWT token claims then you can inject `JsonWebToken`:"
msgstr "Se precisar de aceder a reivindicações de token JWT, pode injetar `JsonWebToken`:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:61
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:632
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:666
#, no-wrap
msgid "package org.acme.security.openid.connect;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:69
#, no-wrap
msgid ""
"import org.eclipse.microprofile.jwt.JsonWebToken;\n"
"import jakarta.inject.Inject;\n"
"import jakarta.annotation.security.RolesAllowed;\n"
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:72
#, no-wrap
msgid ""
"@Path(\"/api/admin\")\n"
"public class AdminResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:75
#, no-wrap
msgid ""
"    @Inject\n"
"    JsonWebToken jwt;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:83
#, no-wrap
msgid ""
"    @GET\n"
"    @RolesAllowed(\"admin\")\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String admin() {\n"
"        return \"Access for subject \" + jwt.getSubject() + \" is granted\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:86
#, fuzzy
msgid "Injection of `JsonWebToken` is supported in `@ApplicationScoped`, `@Singleton` and `@RequestScoped` scopes however the use of `@RequestScoped` is required if the individual claims are injected as simple types, please see xref:security-jwt.adoc#supported-injection-scopes[Support Injection Scopes for JsonWebToken and Claims] for more details."
msgstr "A injeção de `JsonWebToken` é suportada nos âmbitos `@ApplicationScoped`, `@Singleton` e `@RequestScoped`. No entanto, é necessária a utilização de `@RequestScoped` se as afirmações individuais forem injectadas como tipos simples. Para mais informações, consulte  link:security-jwt.html#supported-injection-scopes[Âmbitos de injeção de suporte para JsonWebToken e afirmações]."

#. type: Title ===
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:88
#, fuzzy, no-wrap
msgid "User Info"
msgstr "Informações do utilizador"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:93
#, fuzzy
msgid "Set `quarkus.oidc.authentication.user-info-required=true` if a UserInfo JSON object from the OIDC userinfo endpoint has to be requested.  A request will be sent to the OpenID Provider UserInfo endpoint and an `io.quarkus.oidc.UserInfo` (a simple `jakarta.json.JsonObject` wrapper) object will be created.  `io.quarkus.oidc.UserInfo` can be either injected or accessed as a SecurityIdentity `userinfo` attribute."
msgstr "Defina `quarkus.oidc.authentication.user-info-required=true` se tiver de ser pedido um objeto JSON UserInfo do ponto final userinfo do OIDC. Será enviado um pedido para o ponto de extremidade UserInfo do fornecedor OpenID e será criado um objeto `io.quarkus.oidc.UserInfo` (um simples `jakarta.json.JsonObject` wrapper). `io.quarkus.oidc.UserInfo` pode ser injetado ou acedido como um atributo SecurityIdentity `userinfo`."

#. type: Title ===
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:95
#, fuzzy, no-wrap
msgid "Configuration Metadata"
msgstr "Metadados de configuração"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:98
#, fuzzy
msgid "The current tenant's discovered link:https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata[OpenID Connect Configuration Metadata] is represented by `io.quarkus.oidc.OidcConfigurationMetadata` and can be either injected or accessed as a `SecurityIdentity` `configuration-metadata` attribute."
msgstr "link:https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata[Os Metadados de Configuração OpenID Connect] descobertos do locatário atual são representados por `io.quarkus.oidc.OidcConfigurationMetadata` e podem ser injectados ou acedidos como um atributo `SecurityIdentity` `configuration-metadata` ."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:100
#, fuzzy
msgid "The default tenant's `OidcConfigurationMetadata` is injected if the endpoint is public."
msgstr "O `OidcConfigurationMetadata` do inquilino predefinido é injetado se o ponto final for público."

#. type: Title ===
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:102
#, fuzzy, no-wrap
msgid "Token Claims And SecurityIdentity Roles"
msgstr "Reivindicações de Token e funções de SecurityIdentity"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:105
#, fuzzy
msgid "SecurityIdentity roles can be mapped from the verified JWT access tokens as follows:"
msgstr "As funções SecurityIdentity podem ser mapeadas a partir dos tokens de acesso JWT verificados da seguinte forma:"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:108
#, fuzzy
msgid "If `quarkus.oidc.roles.role-claim-path` property is set and matching array or string claims are found then the roles are extracted from these claims.  For example, `customroles`, `customroles/array`, `scope`, `\"http://namespace-qualified-custom-claim\"/roles`, `\"http://namespace-qualified-roles\"`, etc."
msgstr "Se a propriedade `quarkus.oidc.roles.role-claim-path` estiver definida e forem encontradas afirmações de matriz ou cadeia de caracteres correspondentes, as funções são extraídas dessas afirmações. Por exemplo, `customroles`, `customroles/array`, `scope`, `\"http://namespace-qualified-custom-claim\"/roles`, `\"http://namespace-qualified-roles\"`, etc."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:109
#, fuzzy
msgid "If `groups` claim is available then its value is used"
msgstr "Se o pedido `groups` estiver disponível, é utilizado o seu valor"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:111
#, fuzzy
msgid "If `realm_access/roles` or `resource_access/client_id/roles` (where `client_id` is the value of the `quarkus.oidc.client-id` property) claim is available then its value is used.  This check supports the tokens issued by Keycloak"
msgstr "Se a reivindicação `realm_access/roles` ou `resource_access/client_id/roles` (em que `client_id` é o valor da propriedade `quarkus.oidc.client-id` ) estiver disponível, é utilizado o seu valor. Esta verificação suporta os tokens emitidos pelo Keycloak"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:113
#, fuzzy
msgid "If the token is opaque (binary) then a `scope` property from the remote token introspection response will be used."
msgstr "Se o token for opaco (binário), será utilizada uma propriedade `scope` da resposta de introspeção do token remoto."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:115
#, fuzzy
msgid "If UserInfo is the source of the roles then set `quarkus.oidc.authentication.user-info-required=true` and `quarkus.oidc.roles.source=userinfo`, and if needed, `quarkus.oidc.roles.role-claim-path`."
msgstr "Se UserInfo for a fonte das funções, definir `quarkus.oidc.authentication.user-info-required=true` e `quarkus.oidc.roles.source=userinfo` e, se necessário, `quarkus.oidc.roles.role-claim-path`."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:117
#, fuzzy
msgid "Additionally, a custom `SecurityIdentityAugmentor` can also be used to add the roles as documented in xref:security-customization.adoc#security-identity-customization[Security Identity Customization]."
msgstr "Além disso, também pode ser utilizado um `SecurityIdentityAugmentor` personalizado para adicionar as funções, conforme documentado em  link:security-customization.html#security-identity-customization[Personalização da identidade de segurança]."

#. type: Title ===
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:119
#, fuzzy, no-wrap
msgid "Token scopes And SecurityIdentity permissions"
msgstr "Reivindicações de Token e funções de SecurityIdentity"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:122
#, fuzzy
msgid "SecurityIdentity permissions are mapped in the form of the `io.quarkus.security.StringPermission` from the scope parameter of the xref:token-claims-and-security-identity-roles[source of the roles], using the same claim separator."
msgstr "As permissões de SecurityIdentity são mapeadas na forma de `io.quarkus.security.StringPermission` a partir do parâmetro de escopo da  link:#token-claims-and-security-identity-roles[origem das funções], usando o mesmo separador de declarações."

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:128
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:131
#, no-wrap
msgid ""
"import org.eclipse.microprofile.jwt.Claims;\n"
"import org.eclipse.microprofile.jwt.JsonWebToken;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:133
#, no-wrap
msgid "import io.quarkus.security.PermissionsAllowed;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:136
#, no-wrap
msgid ""
"@Path(\"/service\")\n"
"public class ProtectedResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:139
#, no-wrap
msgid ""
"    @Inject\n"
"    JsonWebToken accessToken;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:146
#, no-wrap
msgid ""
"    @PermissionsAllowed(\"email\") <1>\n"
"    @GET\n"
"    @Path(\"/email\")\n"
"    public Boolean isUserEmailAddressVerifiedByUser() {\n"
"        return accessToken.getClaim(Claims.email_verified.name());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:153
#, no-wrap
msgid ""
"    @PermissionsAllowed(\"orders_read\") <2>\n"
"    @GET\n"
"    @Path(\"/order\")\n"
"    public List<Order> listOrders() {\n"
"        return List.of(new Order(1));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:155
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:764
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:853
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:925
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:157
#, fuzzy
msgid "Only requests with OpenID Connect scope `email` are going to be granted access."
msgstr "Somente solicitações com o escopo do OpenID Connect `email` receberão acesso."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:158
#, fuzzy
msgid "The read access is limited to the client requests with scope `orders_read`."
msgstr "O acesso de leitura é limitado às solicitações do cliente com escopo `orders_read`."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:161
#, fuzzy
msgid "Please refer to the Permission annotation section of the xref:security-authorize-web-endpoints-reference.adoc#permission-annotation[Authorization of web endpoints] guide for more information about the `io.quarkus.security.PermissionsAllowed` annotation."
msgstr "Consulte a seção Anotação de permissão do guia  link:security-authorize-web-endpoints-reference.html#permission-annotation[Autorização de pontos de extremidade da Web] para obter mais informações sobre a anotação `io.quarkus.security.PermissionsAllowed`."

#. type: Title ===
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:163
#, fuzzy, no-wrap
msgid "Token Verification And Introspection"
msgstr "Verificação e introspeção de tokens"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:168
#, fuzzy
msgid "If the token is a JWT token then, by default, it will be verified with a `JsonWebKey` (JWK) key from a local `JsonWebKeySet` retrieved from the OpenID Connect Provider's JWK endpoint. The token's key identifier `kid` header value will be used to find the matching JWK key.  If no matching `JWK` is available locally then `JsonWebKeySet` will be refreshed by fetching the current key set from the JWK endpoint. The `JsonWebKeySet` refresh can be repeated only after the `quarkus.oidc.token.forced-jwk-refresh-interval` (default is 10 minutes) expires.  If no matching `JWK` is available after the refresh then the JWT token will be sent to the OpenID Connect Provider's token introspection endpoint."
msgstr "Se o token for um token JWT, então, por predefinição, será verificado com uma chave `JsonWebKey` (JWK) de um `JsonWebKeySet` local recuperado do ponto de extremidade JWK do fornecedor OpenID Connect. O identificador de chave do token `kid` valor do cabeçalho será usado para encontrar a chave JWK correspondente. Se não estiver disponível localmente nenhum `JWK` correspondente, então `JsonWebKeySet` será atualizado, obtendo o conjunto de chaves atual do ponto de extremidade JWK. A atualização de `JsonWebKeySet` só pode ser repetida após a expiração de `quarkus.oidc.token.forced-jwk-refresh-interval` (a predefinição é 10 minutos). Se não estiver disponível nenhum `JWK` correspondente após a atualização, o token JWT será enviado para o ponto de extremidade de introspeção de token do fornecedor de ligação OpenID."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:170
#, fuzzy
msgid "If the token is opaque (it can be a binary token or an encrypted JWT token) then it will always be sent to the OpenID Connect Provider's token introspection endpoint."
msgstr "Se o token for opaco (pode ser um token binário ou um token JWT encriptado), será sempre enviado para o ponto de extremidade de introspeção de token do fornecedor de ligação OpenID."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:172
#, fuzzy
msgid "If you work with JWT tokens only and expect that a matching `JsonWebKey` will always be available (possibly after a key set refresh) then you should disable the token introspection:"
msgstr "Se trabalhar apenas com tokens JWT e esperar que um `JsonWebKey` correspondente esteja sempre disponível (possivelmente após uma atualização do conjunto de chaves), deve desativar a introspeção de tokens:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:177
#, no-wrap
msgid ""
"quarkus.oidc.token.allow-jwt-introspection=false\n"
"quarkus.oidc.token.allow-opaque-token-introspection=false\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:180
#, fuzzy
msgid "However, there could be cases where JWT tokens must be verified via the introspection only. It can be forced by configuring an introspection endpoint address only, for example, in case of Keycloak you can do it like this:"
msgstr "No entanto, pode haver casos em que os tokens JWT têm de ser verificados apenas através da introspeção. Pode ser forçado configurando apenas um endereço de ponto final de introspeção, por exemplo, no caso do Keycloak, pode fazê-lo assim:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:187
#, no-wrap
msgid ""
"quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus\n"
"quarkus.oidc.discovery-enabled=false\n"
"# Token Introspection endpoint: http://localhost:8180/realms/quarkus/protocol/openid-connect/tokens/introspect\n"
"quarkus.oidc.introspection-path=/protocol/openid-connect/tokens/introspect\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:190
#, fuzzy
msgid "An advantage of this indirect enforcement of JWT tokens being only introspected remotely is that two remote call are avoided: a remote OIDC metadata discovery call followed by another remote call fetching the verification keys which will not be used, while its disavantage is that the users need to know the introspection endpoint address and configure it manually."
msgstr "Uma vantagem desta imposição indireta de tokens JWT serem introspeccionados apenas remotamente é que são evitadas duas chamadas remotas: uma chamada remota de descoberta de metadados OIDC seguida de outra chamada remota para obter as chaves de verificação que não serão utilizadas, enquanto a sua desvantagem é que os utilizadores precisam de conhecer o endereço do ponto final de introspeção e configurá-lo manualmente."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:192
#, fuzzy
msgid "The alternative approach is to allow discovering the OIDC metadata (which is a default option) but require that only the remote JWT introspection is performed:"
msgstr "A abordagem alternativa consiste em permitir a descoberta dos metadados do OIDC (que é uma opção predefinida), mas exigir que apenas seja efectuada a introspeção remota do JWT:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:197
#, no-wrap
msgid ""
"quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus\n"
"quarkus.oidc.token.require-jwt-introspection-only=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:200
#, fuzzy
msgid "An advantage of this approach is that the configuration is simple and easy to understand, while its disavantage is that a remote OIDC metadata discovery call is required to discover an introspection endpoint address (though the verification keys will also not be fetched)."
msgstr "Uma vantagem desta abordagem é o facto de a configuração ser simples e fácil de compreender, enquanto a sua desvantagem é o facto de ser necessária uma chamada de descoberta de metadados OIDC remota para descobrir um endereço de ponto final de introspeção (embora as chaves de verificação também não sejam obtidas)."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:202
#, fuzzy
msgid "Note that `io.quarkus.oidc.TokenIntrospection` (a simple `jakarta.json.JsonObject` wrapper) object will be created and can be either injected or accessed as a SecurityIdentity `introspection` attribute if either JWT or opaque token has been successfully introspected."
msgstr "Note-se que o objeto `io.quarkus.oidc.TokenIntrospection` (um simples `jakarta.json.JsonObject` wrapper) será criado e pode ser injetado ou acedido como um atributo SecurityIdentity `introspection` se o JWT ou o token opaco tiverem sido introspectados com êxito."

#. type: Title ===
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:204
#, fuzzy, no-wrap
msgid "Token Introspection and UserInfo Cache"
msgstr "Introspeção de Token e Cache UserInfo"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:207
#, fuzzy
msgid "All opaque and sometimes JWT Bearer access tokens have to be remotely introspected. If `UserInfo` is also required then the same access token will be used to do a remote call to OpenID Connect Provider again. So, if `UserInfo` is required and the current access token is opaque then for every such token there will be 2 remote calls done - one to introspect it and one to get UserInfo with it, and if the token is JWT then usually only a single remote call will be needed - to get UserInfo with it."
msgstr "Todos os tokens de acesso opacos e por vezes JWT Bearer têm de ser introspeccionados remotamente. Se `UserInfo` também for necessário, o mesmo token de acesso será utilizado para efetuar novamente uma chamada remota ao fornecedor de ligação OpenID. Assim, se `UserInfo` for necessário e o token de acesso atual for opaco, serão efectuadas duas chamadas remotas para cada um desses tokens - uma para o introspeccionar e outra para obter UserInfo com ele, e se o token for JWT, normalmente só será necessária uma única chamada remota - para obter UserInfo com ele."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:209
#, fuzzy
msgid "The cost of making up to 2 remote calls per every incoming bearer or code flow access token can sometimes be problematic."
msgstr "O custo de efetuar até 2 chamadas remotas por cada portador de entrada ou ficha de acesso ao fluxo de códigos pode, por vezes, ser problemático."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:211
#, fuzzy
msgid "If it is the case in your production then it can be recommended that the token introspection and `UserInfo` data are cached for a short period of time, for example, for 3 or 5 minutes."
msgstr "Se for esse o caso na sua produção, pode ser recomendado que os dados de introspeção de token e `UserInfo` sejam colocados em cache durante um curto período de tempo, por exemplo, durante 3 ou 5 minutos."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:213
#, fuzzy
msgid "`quarkus-oidc` provides `quarkus.oidc.TokenIntrospectionCache` and `quarkus.oidc.UserInfoCache` interfaces which can be used to implement `@ApplicationScoped` cache implementation which can be used to store and retrieve `quarkus.oidc.TokenIntrospection` and/or `quarkus.oidc.UserInfo` objects, for example:"
msgstr "`quarkus-oidc` fornece as interfaces `quarkus.oidc.TokenIntrospectionCache` e `quarkus.oidc.UserInfoCache` que podem ser utilizadas para implementar a implementação da cache `@ApplicationScoped` que pode ser utilizada para armazenar e recuperar objectos `quarkus.oidc.TokenIntrospection` e/ou `quarkus.oidc.UserInfo`, por exemplo:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:222
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"@Alternative\n"
"@Priority(1)\n"
"public class CustomIntrospectionUserInfoCache implements TokenIntrospectionCache, UserInfoCache {\n"
"...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:225
#, fuzzy
msgid "Each OIDC tenant can either permit or deny storing its `quarkus.oidc.TokenIntrospection` and/or `quarkus.oidc.UserInfo` data with boolean `quarkus.oidc.\"tenant\".allow-token-introspection-cache` and `quarkus.oidc.\"tenant\".allow-user-info-cache` properties."
msgstr "Cada locatário OIDC pode permitir ou recusar o armazenamento dos seus dados `quarkus.oidc.TokenIntrospection` e/ou `quarkus.oidc.UserInfo` com as propriedades booleanas `quarkus.oidc.\"tenant\".allow-token-introspection-cache` e `quarkus.oidc.\"tenant\".allow-user-info-cache`."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:227
#, fuzzy
msgid "Additionally, `quarkus-oidc` provides a simple default memory based token cache which implements both `quarkus.oidc.TokenIntrospectionCache` and `quarkus.oidc.UserInfoCache` interfaces."
msgstr "Além disso, `quarkus-oidc` fornece um cache de token simples baseado em memória padrão que implementa as interfaces `quarkus.oidc.TokenIntrospectionCache` e `quarkus.oidc.UserInfoCache`."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:229
#, fuzzy
msgid "It can be activated and configured as follows:"
msgstr "Pode ser ativado e configurado da seguinte forma:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:238
#, no-wrap
msgid ""
"# 'max-size' is 0 by default so the cache can be activated by setting 'max-size' to a positive value.\n"
"quarkus.oidc.token-cache.max-size=1000\n"
"# 'time-to-live' specifies how long a cache entry can be valid for and will be used by a cleanup timer.\n"
"quarkus.oidc.token-cache.time-to-live=3M\n"
"# 'clean-up-timer-interval' is not set by default so the cleanup timer can be activated by setting 'clean-up-timer-interval'.\n"
"quarkus.oidc.token-cache.clean-up-timer-interval=1M\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:241
#, fuzzy
msgid "The default cache uses a token as a key and each entry can have `TokenIntrospection` and/or `UserInfo`. It will only keep up to a `max-size` number of entries. If the cache is full when a new entry is to be added then an attempt will be made to find a space for it by removing a single expired entry. Additionally, the cleanup timer, if activated, will periodically check for the expired entries and remove them."
msgstr "A cache predefinida utiliza um token como chave e cada entrada pode ter `TokenIntrospection` e/ou `UserInfo`. Ele só manterá até um número `max-size` de entradas. Se a cache estiver cheia quando uma nova entrada for adicionada, será feita uma tentativa de encontrar um espaço para ela, removendo uma única entrada expirada. Além disso, o temporizador de limpeza, se ativado, verifica periodicamente as entradas expiradas e remove-as."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:243
#, fuzzy
msgid "Please experiment with the default cache implementation or register a custom one."
msgstr "Experimente a implementação da cache predefinida ou registe uma personalizada."

#. type: Title ===
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:245
#, fuzzy, no-wrap
msgid "JSON Web Token Claim Verification"
msgstr "Verificação de declaração de Token Web JSON"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:248
#, fuzzy
msgid "Once the bearer JWT token's signature has been verified and its `expires at` (`exp`) claim has been checked, the `iss` (`issuer`) claim value is verified next."
msgstr "Depois de a assinatura do token JWT portador ter sido verificada e a sua reivindicação `expires at` ( `exp`) ter sido verificada, o valor da reivindicação `iss` ( `issuer`) é verificado em seguida."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:251
#, fuzzy
msgid "By default, the `iss` claim value is compared to the `issuer` property which may have been discovered in the well-known provider configuration.  But if `quarkus.oidc.token.issuer` property is set then the `iss` claim value is compared to it instead."
msgstr "Por predefinição, o valor da afirmação `iss` é comparado com a propriedade `issuer` que pode ter sido descoberta na configuração do fornecedor conhecido. Mas se a propriedade `quarkus.oidc.token.issuer` estiver definida, então o valor da declaração `iss` é comparado a ela."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:253
#, fuzzy
msgid "In some cases, this `iss` claim verification may not work. For example, if the discovered `issuer` property contains an internal HTTP/IP address while the token `iss` claim value contains an external HTTP/IP address. Or when a discovered `issuer` property contains the template tenant variable but the token `iss` claim value has the complete tenant-specific issuer value."
msgstr "Em alguns casos, esta verificação da declaração `iss` pode não funcionar. Por exemplo, se a propriedade descoberta `issuer` contiver um endereço HTTP/IP interno enquanto o valor de declaração do token `iss` contiver um endereço HTTP/IP externo. Ou quando uma propriedade descoberta `issuer` contém a variável de inquilino do modelo, mas o valor de declaração do token `iss` tem o valor completo do emissor específico do inquilino."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:255
#, fuzzy
msgid "In such cases you may want to consider skipping the issuer verification by setting `quarkus.oidc.token.issuer=any`. Please note that it is not recommended and should be avoided unless no other options are available:"
msgstr "Nestes casos, pode considerar saltar a verificação do emissor, definindo `quarkus.oidc.token.issuer=any`. Tenha em atenção que esta opção não é recomendada e deve ser evitada, exceto se não existirem outras opções disponíveis:"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:257
#, fuzzy
msgid "If you work with Keycloak and observe the issuer verification errors due to the different host addresses then configure Keycloak with a `KEYCLOAK_FRONTEND_URL` property to ensure the same host address is used."
msgstr "Se trabalhar com o Keycloak e observar os erros de verificação do emissor devido aos diferentes endereços de anfitrião, configure o Keycloak com uma propriedade `KEYCLOAK_FRONTEND_URL` para garantir que é utilizado o mesmo endereço de anfitrião."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:258
#, fuzzy
msgid "If the `iss` property is tenant specific in a multi-tenant deployment then you can use the `SecurityIdentity` `tenant-id` attribute to check the issuer is correct in the endpoint itself or the custom Jakarta REST filter, for example:"
msgstr "Se a propriedade `iss` for específica do inquilino numa implementação multilocatário, pode utilizar o atributo `SecurityIdentity` `tenant-id` para verificar se o emissor está correto no próprio ponto final ou no filtro Jakarta REST personalizado, por exemplo:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:265
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import jakarta.ws.rs.container.ContainerRequestContext;\n"
"import jakarta.ws.rs.container.ContainerRequestFilter;\n"
"import jakarta.ws.rs.ext.Provider;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:269
#, no-wrap
msgid ""
"import org.eclipse.microprofile.jwt.JsonWebToken;\n"
"import io.quarkus.oidc.OidcConfigurationMetadata;\n"
"import io.quarkus.security.identity.SecurityIdentity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:274
#, no-wrap
msgid ""
"@Provider\n"
"public class IssuerValidator implements ContainerRequestFilter {\n"
"    @Inject\n"
"    OidcConfigurationMetadata configMetadata;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:277
#, no-wrap
msgid ""
"    @Inject JsonWebToken jwt;\n"
"    @Inject SecurityIdentity identity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:285
#, no-wrap
msgid ""
"    public void filter(ContainerRequestContext requestContext) {\n"
"        String issuer = configMetadata.getIssuer().replace(\"{tenant-id}\", identity.getAttribute(\"tenant-id\"));\n"
"        if (!issuer.equals(jwt.getIssuer())) {\n"
"            requestContext.abortWith(Response.status(401).build());\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:288
#, fuzzy
msgid "Note it is also recommended to use `quarkus.oidc.token.audience` property to verify the token `aud` (`audience`) claim value."
msgstr "Nota: recomenda-se também a utilização da propriedade `quarkus.oidc.token.audience` para verificar o valor da reivindicação do token `aud` ( `audience`)."

#. type: Title ===
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:290
#, fuzzy, no-wrap
msgid "Single Page Applications"
msgstr "Aplicações de página única"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:294
#, fuzzy
msgid "Single Page Application (SPA) typically uses `XMLHttpRequest`(XHR) and the JavaScript utility code provided by the OpenID Connect provider to acquire a bearer token and use it to access Quarkus `service` applications."
msgstr "A aplicação de página única (SPA) utiliza normalmente `XMLHttpRequest`(XHR) e o código utilitário JavaScript fornecido pelo fornecedor OpenID Connect para adquirir um token de portador e utilizá-lo para aceder às aplicações Quarkus `service`."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:296
#, fuzzy
msgid "For example, here is how you can use `keycloak.js` to authenticate the users and refresh the expired tokens from the SPA:"
msgstr "Por exemplo, eis como pode utilizar `keycloak.js` para autenticar os utilizadores e atualizar os tokens expirados a partir do SPA:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:335
#, no-wrap
msgid ""
"<html>\n"
"<head>\n"
"    <title>keycloak-spa</title>\n"
"    <script src=\"https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\"></script>\n"
"    <script src=\"http://localhost:8180/js/keycloak.js\"></script>\n"
"    <script>\n"
"        var keycloak = new Keycloak();\n"
"        keycloak.init({onLoad: 'login-required'}).success(function () {\n"
"            console.log('User is now authenticated.');\n"
"        }).error(function () {\n"
"            window.location.reload();\n"
"        });\n"
"        function makeAjaxRequest() {\n"
"            axios.get(\"/api/hello\", {\n"
"                headers: {\n"
"                    'Authorization': 'Bearer ' + keycloak.token\n"
"                }\n"
"            })\n"
"            .then( function (response) {\n"
"                console.log(\"Response: \", response.status);\n"
"            }).catch(function (error) {\n"
"                console.log('refreshing');\n"
"                keycloak.updateToken(5).then(function () {\n"
"                    console.log('Token refreshed');\n"
"                }).catch(function () {\n"
"                    console.log('Failed to refresh token');\n"
"                    window.location.reload();\n"
"                });\n"
"            });\n"
"    }\n"
"    </script>\n"
"</head>\n"
"<body>\n"
"    <button onclick=\"makeAjaxRequest()\">Request</button>\n"
"</body>\n"
"</html>\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:337
#, fuzzy, no-wrap
msgid "Cross Origin Resource Sharing"
msgstr "Partilha de recursos entre origens"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:340
#, fuzzy
msgid "If you plan to consume your OpenID Connect `service` application from a Single Page Application running on a different domain, you will need to configure CORS (Cross-Origin Resource Sharing). Please read the xref:http-reference.adoc#cors-filter[HTTP CORS documentation] for more details."
msgstr "Se planeia consumir a sua aplicação OpenID Connect `service` a partir de uma aplicação de página única executada num domínio diferente, terá de configurar CORS (Cross-Origin Resource Sharing). Leia a  link:http-reference.html#cors-filter[documentação do HTTP CORS] para obter mais detalhes."

#. type: Title ===
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:341
#, fuzzy, no-wrap
msgid "Provider Endpoint configuration"
msgstr "Configuração do ponto final do fornecedor"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:344
#, fuzzy
msgid "OIDC `service` application needs to know OpenID Connect provider's token, `JsonWebKey` (JWK) set and possibly `UserInfo` and introspection endpoint addresses."
msgstr "A aplicação OIDC `service` precisa de conhecer o token do fornecedor OpenID Connect, o conjunto `JsonWebKey` (JWK) e, possivelmente, os endereços dos pontos finais `UserInfo` e introspeção."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:346
#, fuzzy
msgid "By default, they are discovered by adding a `/.well-known/openid-configuration` path to the configured `quarkus.oidc.auth-server-url`."
msgstr "Por defeito, são descobertos adicionando um caminho `/.well-known/openid-configuration` ao `quarkus.oidc.auth-server-url` configurado."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:348
#, fuzzy
msgid "Alternatively, if the discovery endpoint is not available, or if you would like to save on the discovery endpoint round-trip, you can disable the discovery and configure them with relative path values, for example:"
msgstr "Em alternativa, se o ponto final de descoberta não estiver disponível, ou se pretender poupar na viagem de ida e volta do ponto final de descoberta, pode desativar a descoberta e configurá-los com valores de caminho relativos, por exemplo:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:361
#, no-wrap
msgid ""
"quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus\n"
"quarkus.oidc.discovery-enabled=false\n"
"# Token endpoint: http://localhost:8180/realms/quarkus/protocol/openid-connect/token\n"
"quarkus.oidc.token-path=/protocol/openid-connect/token\n"
"# JWK set endpoint: http://localhost:8180/realms/quarkus/protocol/openid-connect/certs\n"
"quarkus.oidc.jwks-path=/protocol/openid-connect/certs\n"
"# UserInfo endpoint: http://localhost:8180/realms/quarkus/protocol/openid-connect/userinfo\n"
"quarkus.oidc.user-info-path=/protocol/openid-connect/userinfo\n"
"# Token Introspection endpoint: http://localhost:8180/realms/quarkus/protocol/openid-connect/tokens/introspect\n"
"quarkus.oidc.introspection-path=/protocol/openid-connect/tokens/introspect\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:363
#, fuzzy, no-wrap
msgid "Token Propagation"
msgstr "Propagação de tokens"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:366
#, fuzzy
msgid "Please see xref:security-openid-connect-client-reference.adoc#token-propagation[Token Propagation] section about the Bearer access token propagation to the downstream services."
msgstr "Consulte a secção  link:security-openid-connect-client-reference.html#token-propagation[Propagação de Token] sobre a propagação do token de acesso ao portador para os serviços a jusante."

#. type: Title ===
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:368
#, fuzzy, no-wrap
msgid "Oidc Provider Client Authentication"
msgstr "Autenticação de cliente do provedor Oidc"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:371
#, fuzzy
msgid "`quarkus.oidc.runtime.OidcProviderClient` is used when a remote request to an OpenID Connect Provider has to be done. If the bearer token has to be introspected then `OidcProviderClient` has to authenticate to the OpenID Connect Provider. Please see xref:security-oidc-code-flow-authentication.adoc#oidc-provider-client-authentication[OidcProviderClient Authentication] for more information about all the supported authentication options."
msgstr "`quarkus.oidc.runtime.OidcProviderClient` é utilizado quando tem de ser efectuado um pedido remoto a um fornecedor OpenID Connect. Se o token do portador tiver de ser introspeccionado, então `OidcProviderClient` tem de se autenticar no OpenID Connect Provider. Para mais informações sobre todas as opções de autenticação suportadas, consulte  link:security-oidc-code-flow-authentication.html#oidc-provider-client-authentication[Autenticação OidcProviderClient]."

#. type: Title ===
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:373
#, fuzzy, no-wrap
msgid "Testing"
msgstr "Ensaios"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:376
#, fuzzy
msgid "Start by adding the following dependencies to your test project:"
msgstr "Comece por adicionar as seguintes dependências ao seu projeto de teste:"

#. type: Block title
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:378
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:405
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:593
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:685
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:796
#, fuzzy, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:390
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.rest-assured</groupId>\n"
"    <artifactId>rest-assured</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-junit5</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:393
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:415
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:603
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:695
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:806
#, fuzzy, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:397
#, no-wrap
msgid ""
"testImplementation(\"io.rest-assured:rest-assured\")\n"
"testImplementation(\"io.quarkus:quarkus-junit5\")\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:400
#, fuzzy, no-wrap
msgid "Wiremock"
msgstr "Wiremock"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:403
#, fuzzy
msgid "Add the following dependencies to your test project:"
msgstr "Adicione as seguintes dependências ao seu projeto de teste:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:412
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-test-oidc-server</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:418
#, no-wrap
msgid "testImplementation(\"io.quarkus:quarkus-test-oidc-server\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:421
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:724
#, fuzzy
msgid "Prepare the REST test endpoint, set `application.properties`, for example:"
msgstr "Preparar o ponto de extremidade de teste REST, definir `application.properties`, por exemplo:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:428
#, no-wrap
msgid ""
"# keycloak.url is set by OidcWiremockTestResource\n"
"quarkus.oidc.auth-server-url=${keycloak.url}/realms/quarkus/\n"
"quarkus.oidc.client-id=quarkus-service-app\n"
"quarkus.oidc.application-type=service\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:431
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:735
#, fuzzy
msgid "and finally write the test code, for example:"
msgstr "e, por fim, escrever o código de teste, por exemplo:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:435
#, no-wrap
msgid "import static org.hamcrest.Matchers.equalTo;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:437
#, no-wrap
msgid "import java.util.Set;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:439
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:491
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:549
#, no-wrap
msgid "import org.junit.jupiter.api.Test;\n"
msgstr "import org.junit.jupiter.api.Test;\n"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:445
#, no-wrap
msgid ""
"import io.quarkus.test.common.QuarkusTestResource;\n"
"import io.quarkus.test.junit.QuarkusTest;\n"
"import io.quarkus.test.oidc.server.OidcWiremockTestResource;\n"
"import io.restassured.RestAssured;\n"
"import io.smallrye.jwt.build.Jwt;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:449
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@QuarkusTestResource(OidcWiremockTestResource.class)\n"
"public class BearerTokenAuthorizationTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:459
#, no-wrap
msgid ""
"    @Test\n"
"    public void testBearerToken() {\n"
"        RestAssured.given().auth().oauth2(getAccessToken(\"alice\", Set.of(\"user\")))\n"
"            .when().get(\"/api/users/me\")\n"
"            .then()\n"
"            .statusCode(200)\n"
"            // the test endpoint returns the name extracted from the injected SecurityIdentity Principal\n"
"            .body(\"userName\", equalTo(\"alice\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:468
#, no-wrap
msgid ""
"    private String getAccessToken(String userName, Set<String> groups) {\n"
"        return Jwt.preferredUserName(userName)\n"
"                .groups(groups)\n"
"                .issuer(\"https://server.example.com\")\n"
"                .audience(\"https://service.example.com\")\n"
"                .sign();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:471
#, fuzzy
msgid "Note that the `quarkus-test-oidc-server` extension includes a signing RSA private key file in a `JSON Web Key` (`JWK`) format and points to it with a `smallrye.jwt.sign.key.location` configuration property. It allows to use a no argument `sign()` operation to sign the token."
msgstr "Note-se que a extensão `quarkus-test-oidc-server` inclui um ficheiro de chave privada RSA de assinatura num formato `JSON Web Key` ( `JWK`) e aponta para ele com uma propriedade de configuração `smallrye.jwt.sign.key.location`. Permite utilizar uma operação `sign()` sem argumentos para assinar o token."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:474
#, fuzzy
msgid "Testing your `quarkus-oidc` `service` application with `OidcWiremockTestResource` provides the best coverage as even the communication channel is tested against the Wiremock HTTP stubs.  `OidcWiremockTestResource` will be enhanced going forward to support more complex bearer token test scenarios."
msgstr "Testar a sua aplicação `quarkus-oidc` `service` com `OidcWiremockTestResource` fornece a melhor cobertura, uma vez que até o canal de comunicação é testado contra os stubs HTTP Wiremock. `OidcWiremockTestResource` será melhorado no futuro para suportar cenários de teste de token de portador mais complexos."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:477
#, fuzzy
msgid "If there is an immediate need for a test to define Wiremock stubs not currently supported by `OidcWiremockTestResource` one can do so via a `WireMockServer` instance injected into the test class, for example:"
msgstr "Se houver uma necessidade imediata de um teste para definir stubs Wiremock não suportados atualmente por `OidcWiremockTestResource`, é possível fazê-lo através de uma instância `WireMockServer` injectada na classe de teste, por exemplo:"

#. type: delimited block =
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:481
#, fuzzy
msgid "`OidcWiremockTestResource` does not work with `@QuarkusIntegrationTest` against Docker containers, because the Wiremock server is running in the JVM running the test, which cannot be accessed from the Docker container running the Quarkus application."
msgstr "`OidcWiremockTestResource` não funciona com `@QuarkusIntegrationTest` contra contentores Docker, porque o servidor Wiremock está a ser executado na JVM que executa o teste, que não pode ser acedido a partir do contentor Docker que executa a aplicação Quarkus."

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:486
#, no-wrap
msgid "package io.quarkus.it.keycloak;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:489
#, no-wrap
msgid ""
"import static com.github.tomakehurst.wiremock.client.WireMock.matching;\n"
"import static org.hamcrest.Matchers.equalTo;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:494
#, no-wrap
msgid ""
"import com.github.tomakehurst.wiremock.WireMockServer;\n"
"import com.github.tomakehurst.wiremock.client.WireMock;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:498
#, no-wrap
msgid ""
"import io.quarkus.test.junit.QuarkusTest;\n"
"import io.quarkus.test.oidc.server.OidcWireMock;\n"
"import io.restassured.RestAssured;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:501
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class CustomOidcWireMockStubTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:504
#, no-wrap
msgid ""
"    @OidcWireMock\n"
"    WireMockServer wireMockServer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:510
#, no-wrap
msgid ""
"    @Test\n"
"    public void testInvalidBearerToken() {\n"
"        wireMockServer.stubFor(WireMock.post(\"/auth/realms/quarkus/protocol/openid-connect/token/introspect\")\n"
"                .withRequestBody(matching(\".*token=invalid_token.*\"))\n"
"                .willReturn(WireMock.aResponse().withStatus(400)));\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:518
#, no-wrap
msgid ""
"        RestAssured.given().auth().oauth2(\"invalid_token\").when()\n"
"                .get(\"/api/users/me/bearer\")\n"
"                .then()\n"
"                .statusCode(401)\n"
"                .header(\"WWW-Authenticate\", equalTo(\"Bearer\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:521
#, fuzzy, no-wrap
msgid "OidcTestClient"
msgstr "OidcTestClient"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:524
#, fuzzy
msgid "If you work with SaaS OIDC providers such as `Auth0` and would like to run tests against the test (development) domain or prefer to run tests against a remote Keycloak test realm, when you already have `quarkus.oidc.auth-server-url` configured, you can use `OidcTestClient`."
msgstr "Se você trabalha com provedores SaaS OIDC, como `Auth0`, e gostaria de executar testes no domínio de teste (desenvolvimento) ou prefere executar testes em um domínio de teste remoto do Keycloak, quando já tiver configurado `quarkus.oidc.auth-server-url`, poderá usar `OidcTestClient`."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:526
#, fuzzy
msgid "For example, lets assume you have the following configuration:"
msgstr "Por exemplo, vamos supor que você tenha a seguinte configuração:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:532
#, no-wrap
msgid ""
"%test.quarkus.oidc.auth-server-url=https://dev-123456.eu.auth0.com/\n"
"%test.quarkus.oidc.client-id=test-auth0-client\n"
"%test.quarkus.oidc.credentials.secret=secret\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:535
#, fuzzy
msgid "Start with addding the same dependency as in the xref:integration-testing-wiremock[Wiremock] section, `quarkus-test-oidc-server`."
msgstr "Comece adicionando a mesma dependência da seção  link:#integration-testing-wiremock[Wiremock], `quarkus-test-oidc-server`."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:537
#, fuzzy
msgid "Next, write the test code like this:"
msgstr "e escrever um código de teste como este:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:541
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:545
#, no-wrap
msgid ""
"import org.junit.jupiter.api.AfterAll;\n"
"import static io.restassured.RestAssured.given;\n"
"import static org.hamcrest.CoreMatchers.is;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:547
#, no-wrap
msgid "import java.util.Map;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:552
#, no-wrap
msgid ""
"import io.quarkus.test.junit.QuarkusTest;\n"
"import io.quarkus.test.oidc.client.OidcTestClient;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:555
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class GreetingResourceTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:557
#, no-wrap
msgid "    static OidcTestClient oidcTestClient = new OidcTestClient();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:562
#, no-wrap
msgid ""
"    @AfterAll\n"
"    public static void close() {\n"
"        client.close();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:572
#, no-wrap
msgid ""
"    @Test\n"
"    public void testHelloEndpoint() {\n"
"        given()\n"
"          .auth().oauth2(getAccessToken(\"alice\", \"alice\"))\n"
"          .when().get(\"/hello\")\n"
"          .then()\n"
"             .statusCode(200)\n"
"             .body(is(\"Hello, Alice\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:579
#, no-wrap
msgid ""
"    private String getAccessToken(String name, String secret) {\n"
"        return oidcTestClient.getAccessToken(name, secret,\n"
"            Map.of(\"audience\", \"https://dev-123456.eu.auth0.com/api/v2/\",\n"
"\t           \"scope\", \"profile\"));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:582
#, fuzzy
msgid "This test code acquires a token using a `password` grant from the test `Auth0` domain which has an application with the client id `test-auth0-client` registered, and which has a user `alice` with a password `alice` created. The test `Auth0` application must have the `password` grant enabled for a test like this one to work. This example code also shows how to pass additional parameters. For `Auth0`, these are the `audience` and `scope` parameters."
msgstr "Esse código de teste adquire um token usando uma concessão `password` do domínio de teste `Auth0` que tem um aplicativo com o ID do cliente `test-auth0-client` registrado e que tem um usuário `alice` com uma senha `alice` criada. O aplicativo de teste `Auth0` deve ter a concessão `password` ativada para que um teste como esse funcione. Esse código de exemplo também mostra como passar parâmetros adicionais. Para `Auth0`, esses são os parâmetros `audience` e `scope`."

#. type: Title ====
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:585
#, fuzzy, no-wrap
msgid "Dev Services for Keycloak"
msgstr "Serviços de desenvolvimento para Keycloak"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:589
#, fuzzy
msgid "Using xref:security-openid-connect-dev-services.adoc[Dev Services for Keycloak] is recommended for the integration testing against Keycloak.  `Dev Services for Keycloak` will launch and initialize a test container: it will create a `quarkus` realm, a `quarkus-app` client (`secret` secret) and add `alice` (`admin` and `user` roles) and `bob` (`user` role) users, where all of these properties can be customized."
msgstr "Recomenda-se a utilização dos Dev  link:security-openid-connect-dev-services.html[Services for Keycloak] para os testes de integração com o Keycloak. `Dev Services for Keycloak` lançará e inicializará um contentor de teste: criará um reino `quarkus`, um cliente `quarkus-app` (segredo `secret` ) e adicionará utilizadores `alice` (funções `admin` e `user` ) e `bob` (função `user` ), onde todas estas propriedades podem ser personalizadas."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:591
#, fuzzy
msgid "First you need to add the following dependency:"
msgstr "Em primeiro lugar, é necessário adicionar a seguinte dependência:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:600
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:692
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-test-keycloak-server</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:606
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:698
#, no-wrap
msgid "testImplementation(\"io.quarkus:quarkus-test-keycloak-server\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:609
#, fuzzy
msgid "which provides a utility class `io.quarkus.test.keycloak.client.KeycloakTestClient` you can use in tests for acquiring the access tokens."
msgstr "que fornece uma classe utilitária `io.quarkus.test.keycloak.client.KeycloakTestClient` que pode utilizar nos testes para adquirir os tokens de acesso."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:611
#, fuzzy
msgid "Next prepare your `application.properties`. You can start with a completely empty `application.properties` as `Dev Services for Keycloak` will register `quarkus.oidc.auth-server-url` pointing to the running test container as well as `quarkus.oidc.client-id=quarkus-app` and `quarkus.oidc.credentials.secret=secret`."
msgstr "De seguida, prepare o seu `application.properties`. Pode começar com um `application.properties` completamente vazio, pois o `Dev Services for Keycloak` registará o `quarkus.oidc.auth-server-url` que aponta para o contentor de teste em execução, bem como o `quarkus.oidc.client-id=quarkus-app` e o `quarkus.oidc.credentials.secret=secret`."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:613
#, fuzzy
msgid "But if you already have all the required `quarkus-oidc` properties configured then you only need to associate `quarkus.oidc.auth-server-url` with the `prod` profile for `Dev Services for Keycloak`to start a container, for example:"
msgstr "Mas se já tiver todas as propriedades necessárias de `quarkus-oidc` configuradas, então só precisa de associar `quarkus.oidc.auth-server-url` com o perfil `prod` para `Dev Services for Keycloak` para iniciar um contentor, por exemplo:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:617
#, no-wrap
msgid "%prod.quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:620
#, fuzzy
msgid "If a custom realm file has to be imported into Keycloak before running the tests then you can configure `Dev Services for Keycloak` as follows:"
msgstr "Se um ficheiro realm personalizado tiver de ser importado para o Keycloak antes de executar os testes, pode configurar `Dev Services for Keycloak` da seguinte forma:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:625
#, no-wrap
msgid ""
"%prod.quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus\n"
"quarkus.keycloak.devservices.realm-path=quarkus-realm.json\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:628
#, fuzzy
msgid "Finally, write your test which will be executed in JVM mode:"
msgstr "Finalmente, escreva o seu teste que será executado no modo JVM:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:637
#, no-wrap
msgid ""
"import io.quarkus.test.junit.QuarkusTest;\n"
"import io.quarkus.test.keycloak.client.KeycloakTestClient;\n"
"import io.restassured.RestAssured;\n"
"import org.junit.jupiter.api.Test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:640
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class BearerTokenAuthenticationTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:642
#, no-wrap
msgid "    KeycloakTestClient keycloakClient = new KeycloakTestClient();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:654
#, no-wrap
msgid ""
"    @Test\n"
"    public void testAdminAccess() {\n"
"        RestAssured.given().auth().oauth2(getAccessToken(\"alice\"))\n"
"                .when().get(\"/api/admin\")\n"
"                .then()\n"
"                .statusCode(200);\n"
"        RestAssured.given().auth().oauth2(getAccessToken(\"bob\"))\n"
"                .when().get(\"/api/admin\")\n"
"                .then()\n"
"                .statusCode(403);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:659
#, no-wrap
msgid ""
"    protected String getAccessToken(String userName) {\n"
"        return keycloakClient.getAccessToken(userName);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:662
#, fuzzy
msgid "and in native mode:"
msgstr "e no modo nativo:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:668
#, no-wrap
msgid "import io.quarkus.test.junit.QuarkusIntegrationTest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:672
#, no-wrap
msgid ""
"@QuarkusIntegrationTest\n"
"public class NativeBearerTokenAuthenticationIT extends BearerTokenAuthenticationTest {\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:675
#, fuzzy
msgid "Please see xref:security-openid-connect-dev-services.adoc[Dev Services for Keycloak] for more information about the way it is initialized and configured."
msgstr "Consulte  link:security-openid-connect-dev-services.html[Serviços de desenvolvimento para Keycloak] para obter mais informações sobre a forma como é inicializado e configurado."

#. type: Title ====
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:677
#, fuzzy, no-wrap
msgid "KeycloakTestResourceLifecycleManager"
msgstr "KeycloakTestResourceLifecycleManager"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:681
#, fuzzy
msgid "If you need to do some integration testing against Keycloak then you are encouraged to do it with xref:integration-testing-keycloak-devservices[Dev Services For Keycloak].  Use `KeycloakTestResourceLifecycleManager` for your tests only if there is a good reason not to use `Dev Services for Keycloak`."
msgstr "Se precisar de fazer alguns testes de integração com o Keycloak, é aconselhável fazê-lo com Dev  link:#integration-testing-keycloak-devservices[Services For Keycloak]. Use `KeycloakTestResourceLifecycleManager` para seus testes somente se houver uma boa razão para não usar `Dev Services for Keycloak`."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:683
#, fuzzy
msgid "Start with adding the following dependency:"
msgstr "Comece por adicionar a seguinte dependência:"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:701
#, fuzzy
msgid "which provides `io.quarkus.test.keycloak.server.KeycloakTestResourceLifecycleManager` - an implementation of `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` which starts a Keycloak container."
msgstr "que fornece `io.quarkus.test.keycloak.server.KeycloakTestResourceLifecycleManager` - uma implementação de `io.quarkus.test.common.QuarkusTestResourceLifecycleManager` que inicia um contentor Keycloak."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:703
#, fuzzy
msgid "And configure the Maven Surefire plugin as follows:"
msgstr "E configure o plugin Maven Surefire da seguinte forma:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:719
#, no-wrap
msgid ""
"<plugin>\n"
"    <artifactId>maven-surefire-plugin</artifactId>\n"
"    <configuration>\n"
"        <systemPropertyVariables>\n"
"            <!-- or, alternatively, configure 'keycloak.version' -->\n"
"            <keycloak.docker.image>${keycloak.docker.image}</keycloak.docker.image>\n"
"            <!--\n"
"              Disable HTTPS if required:\n"
"              <keycloak.use.https>false</keycloak.use.https>\n"
"            -->\n"
"        </systemPropertyVariables>\n"
"    </configuration>\n"
"</plugin>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:722
#, fuzzy
msgid "(and similarly `maven.failsafe.plugin` when testing in native image)."
msgstr "(e da mesma forma `maven.failsafe.plugin` ao testar em imagem nativa)."

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:732
#, no-wrap
msgid ""
"# keycloak.url is set by KeycloakTestResourceLifecycleManager\n"
"quarkus.oidc.auth-server-url=${keycloak.url}/realms/quarkus/\n"
"quarkus.oidc.client-id=quarkus-service-app\n"
"quarkus.oidc.credentials=secret\n"
"quarkus.oidc.application-type=service\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:740
#, no-wrap
msgid ""
"import static io.quarkus.test.keycloak.server.KeycloakTestResourceLifecycleManager.getAccessToken;\n"
"import static org.hamcrest.Matchers.equalTo;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:743
#, no-wrap
msgid ""
"import org.hamcrest.Matchers;\n"
"import org.junit.jupiter.api.Test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:748
#, no-wrap
msgid ""
"import io.quarkus.test.common.QuarkusTestResource;\n"
"import io.quarkus.test.junit.QuarkusTest;\n"
"import io.quarkus.test.keycloak.server.KeycloakTestResourceLifecycleManager;\n"
"import io.restassured.RestAssured;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:752
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@QuarkusTestResource(KeycloakTestResourceLifecycleManager.class)\n"
"public class BearerTokenAuthorizationTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:762
#, no-wrap
msgid ""
"    @Test\n"
"    public void testBearerToken() {\n"
"        RestAssured.given().auth().oauth2(getAccessToken(\"alice\"))))\n"
"            .when().get(\"/api/users/preferredUserName\")\n"
"            .then()\n"
"            .statusCode(200)\n"
"            // the test endpoint returns the name extracted from the injected SecurityIdentity Principal\n"
"            .body(\"userName\", equalTo(\"alice\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:767
#, fuzzy
msgid "`KeycloakTestResourceLifecycleManager` registers `alice` and `admin` users. The user `alice` has the `user` role only by default - it can be customized with a `keycloak.token.user-roles` system property. The user `admin` has the `user` and `admin` roles by default - it can be customized with a `keycloak.token.admin-roles` system property."
msgstr "`KeycloakTestResourceLifecycleManager` regista os utilizadores `alice` e `admin`. O utilizador `alice` tem a função `user` apenas por predefinição - pode ser personalizado com uma propriedade de sistema `keycloak.token.user-roles`. O utilizador `admin` tem as funções `user` e `admin` por predefinição - pode ser personalizado com uma propriedade de sistema `keycloak.token.admin-roles`."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:770
#, fuzzy
msgid "By default, `KeycloakTestResourceLifecycleManager` uses HTTPS to initialize a Keycloak instance which can be disabled with `keycloak.use.https=false`.  Default realm name is `quarkus` and client id - `quarkus-service-app` - set `keycloak.realm` and `keycloak.service.client` system properties to customize the values if needed."
msgstr "Por predefinição, `KeycloakTestResourceLifecycleManager` utiliza HTTPS para inicializar uma instância do Keycloak que pode ser desactivada com `keycloak.use.https=false`. O nome do domínio predefinido é `quarkus` e o ID do cliente - `quarkus-service-app` - defina as propriedades do sistema `keycloak.realm` e `keycloak.service.client` para personalizar os valores, se necessário."

#. type: Title ====
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:772
#, fuzzy, no-wrap
msgid "Local Public Key"
msgstr "Chave pública local"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:775
#, fuzzy
msgid "You can also use a local inlined public key for testing your `quarkus-oidc` `service` applications:"
msgstr "Também pode utilizar uma chave pública local incorporada para testar as suas aplicações `quarkus-oidc` `service` :"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:780
#, no-wrap
msgid ""
"quarkus.oidc.client-id=test\n"
"quarkus.oidc.public-key=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAlivFI8qB4D0y2jy0CfEqFyy46R0o7S8TKpsx5xbHKoU1VWg6QkQm+ntyIv1p4kE1sPEQO73+HY8+Bzs75XwRTYL1BmR1w8J5hmjVWjc6R2BTBGAYRPFRhor3kpM6ni2SPmNNhurEAHw7TaqszP5eUF/F9+KEBWkwVta+PZ37bwqSE4sCb1soZFrVz/UT/LF4tYpuVYt3YbqToZ3pZOZ9AX2o1GCG3xwOjkc4x0W7ezbQZdC9iftPxVHR8irOijJRRjcPDtA6vPKpzLl6CyYnsIYPd99ltwxTHjr3npfv/3Lw50bAkbT4HeLFxTx4flEoZLKO/g0bAoV2uqBhkA9xnQIDAQAB\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:782
#, no-wrap
msgid "smallrye.jwt.sign.key.location=/privateKey.pem\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:785
#, fuzzy
msgid "copy `privateKey.pem` from the `integration-tests/oidc-tenancy` in the `main` Quarkus repository and use a test code similar to the one in the `Wiremock` section above to generate JWT tokens. You can use your own test keys if preferred."
msgstr "copie `privateKey.pem` do `integration-tests/oidc-tenancy` no repositório `main` Quarkus e utilize um código de teste semelhante ao da secção `Wiremock` acima para gerar tokens JWT. Se preferir, pode utilizar as suas próprias chaves de teste."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:787
#, fuzzy
msgid "This approach provides a more limited coverage compared to the Wiremock approach - for example, the remote communication code is not covered."
msgstr "Esta abordagem oferece uma cobertura mais limitada em comparação com a abordagem Wiremock - por exemplo, o código de comunicação remota não é abrangido."

#. type: Title ====
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:789
#, fuzzy, no-wrap
msgid "TestSecurity annotation"
msgstr "Anotação TestSecurity"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:792
#, fuzzy
msgid "You can use `@TestSecurity` and `@OidcSecurity` annotations for testing the `service` application endpoint code which depends on the injected `JsonWebToken` as well as `UserInfo` and `OidcConfigurationMetadata`."
msgstr "Pode utilizar as anotações `@TestSecurity` e `@OidcSecurity` para testar o código do ponto final da aplicação `service` que depende do `JsonWebToken` injetado, bem como `UserInfo` e `OidcConfigurationMetadata`."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:794
#, fuzzy
msgid "Add the following dependency:"
msgstr "Adicione a seguinte dependência:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:803
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-test-security-oidc</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:809
#, no-wrap
msgid "testImplementation(\"io.quarkus:quarkus-test-security-oidc\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:812
#, fuzzy
msgid "and write a test code like this one:"
msgstr "e escrever um código de teste como este:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:826
#, no-wrap
msgid ""
"import static org.hamcrest.Matchers.is;\n"
"import org.junit.jupiter.api.Test;\n"
"import io.quarkus.test.common.http.TestHTTPEndpoint;\n"
"import io.quarkus.test.junit.QuarkusTest;\n"
"import io.quarkus.test.security.TestSecurity;\n"
"import io.quarkus.test.security.oidc.Claim;\n"
"import io.quarkus.test.security.oidc.ConfigMetadata;\n"
"import io.quarkus.test.security.oidc.OidcSecurity;\n"
"import io.quarkus.test.security.oidc.OidcConfigurationMetadata;\n"
"import io.quarkus.test.security.oidc.UserInfo;\n"
"import io.restassured.RestAssured;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:830
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:911
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@TestHTTPEndpoint(ProtectedResource.class)\n"
"public class TestSecurityAuthTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:837
#, no-wrap
msgid ""
"    @Test\n"
"    @TestSecurity(user = \"userOidc\", roles = \"viewer\")\n"
"    public void testOidc() {\n"
"        RestAssured.when().get(\"test-security-oidc\").then()\n"
"                .body(is(\"userOidc:viewer\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:851
#, no-wrap
msgid ""
"    @Test\n"
"    @TestSecurity(user = \"userOidc\", roles = \"viewer\")\n"
"    @OidcSecurity(claims = {\n"
"            @Claim(key = \"email\", value = \"user@gmail.com\")\n"
"    }, userinfo = {\n"
"            @UserInfo(key = \"sub\", value = \"subject\")\n"
"    }, config = {\n"
"            @ConfigMetadata(key = \"issuer\", value = \"issuer\")\n"
"    })\n"
"    public void testOidcWithClaimsUserInfoAndMetadata() {\n"
"        RestAssured.when().get(\"test-security-oidc-claims-userinfo-metadata\").then()\n"
"                .body(is(\"userOidc:viewer:user@gmail.com:subject:issuer\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:856
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:928
#, fuzzy
msgid "where `ProtectedResource` class may look like this:"
msgstr "onde a classe `ProtectedResource` pode ter o seguinte aspeto:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:862
#, no-wrap
msgid ""
"import io.quarkus.oidc.OidcConfigurationMetadata;\n"
"import io.quarkus.oidc.UserInfo;\n"
"import org.eclipse.microprofile.jwt.JsonWebToken;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:866
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:937
#, no-wrap
msgid ""
"@Path(\"/service\")\n"
"@Authenticated\n"
"public class ProtectedResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:873
#, no-wrap
msgid ""
"    @Inject\n"
"    JsonWebToken accessToken;\n"
"    @Inject\n"
"    UserInfo userInfo;\n"
"    @Inject\n"
"    OidcConfigurationMetadata configMetadata;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:879
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"test-security-oidc\")\n"
"    public String testSecurityOidc() {\n"
"        return accessToken.getName() + \":\" + accessToken.getGroups().iterator().next();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:889
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"test-security-oidc-claims-userinfo-metadata\")\n"
"    public String testSecurityOidcWithClaimsUserInfoMetadata() {\n"
"        return accessToken.getName() + \":\" + accessToken.getGroups().iterator().next()\n"
"                + \":\" + accessToken.getClaim(\"email\")\n"
"                + \":\" + userInfo.getString(\"sub\")\n"
"                + \":\" + configMetadata.get(\"issuer\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:894
#, fuzzy
msgid "Note that `@TestSecurity` annotation must always be used and its `user` property is returned as `JsonWebToken.getName()` and `roles` property - as `JsonWebToken.getGroups()`.  `@OidcSecurity` annotation is optional and can be used to set the additional token claims, as well as `UserInfo` and `OidcConfigurationMetadata` properties.  Additionally, if `quarkus.oidc.token.issuer` property is configured then it will be used as an `OidcConfigurationMetadata` `issuer` property value."
msgstr "Note-se que a anotação `@TestSecurity` tem de ser sempre utilizada e a sua propriedade `user` é devolvida como `JsonWebToken.getName()` e a propriedade `roles` - como `JsonWebToken.getGroups()`. A anotação `@OidcSecurity` é opcional e pode ser utilizada para definir as declarações de token adicionais, bem como as propriedades `UserInfo` e `OidcConfigurationMetadata`. Além disso, se a propriedade `quarkus.oidc.token.issuer` estiver configurada, será utilizada como um valor da propriedade `OidcConfigurationMetadata` `issuer` ."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:896
#, fuzzy
msgid "If you work with the opaque tokens then you can test them as follows:"
msgstr "Se trabalhar com os tokens opacos, pode testá-los da seguinte forma:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:907
#, no-wrap
msgid ""
"import static org.hamcrest.Matchers.is;\n"
"import org.junit.jupiter.api.Test;\n"
"import io.quarkus.test.common.http.TestHTTPEndpoint;\n"
"import io.quarkus.test.junit.QuarkusTest;\n"
"import io.quarkus.test.security.TestSecurity;\n"
"import io.quarkus.test.security.oidc.OidcSecurity;\n"
"import io.quarkus.test.security.oidc.TokenIntrospection;\n"
"import io.restassured.RestAssured;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:923
#, no-wrap
msgid ""
"    @Test\n"
"    @TestSecurity(user = \"userOidc\", roles = \"viewer\")\n"
"    @OidcSecurity(introspectionRequired = true,\n"
"        introspection = {\n"
"            @TokenIntrospection(key = \"email\", value = \"user@gmail.com\")\n"
"        }\n"
"    )\n"
"    public void testOidcWithClaimsUserInfoAndMetadata() {\n"
"        RestAssured.when().get(\"test-security-oidc-claims-userinfo-metadata\").then()\n"
"                .body(is(\"userOidc:viewer:userOidc:viewer\"));\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:933
#, no-wrap
msgid ""
"import io.quarkus.oidc.TokenIntrospection;\n"
"import io.quarkus.security.identity.SecurityIdentity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:942
#, no-wrap
msgid ""
"    @Inject\n"
"    SecurityIdentity securityIdentity;\n"
"    @Inject\n"
"    TokenIntrospection introspection;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:952
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"test-security-oidc-opaque-token\")\n"
"    public String testSecurityOidcOpaqueToken() {\n"
"        return securityIdentity.getPrincipal().getName() + \":\" + securityIdentity.getRoles().iterator().next()\n"
"            + \":\" + introspection.getString(\"username\")\n"
"            + \":\" + introspection.getString(\"scope\")\n"
"            + \":\" + introspection.getString(\"email\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:955
#, fuzzy
msgid "Note that `@TestSecurity` `user` and `roles` attributes are available as `TokenIntrospection` `username` and `scope` properties and you can use `io.quarkus.test.security.oidc.TokenIntrospection` to add the additional introspection response properties such as an `email`, etc."
msgstr "Note-se que os atributos `@TestSecurity` `user` e `roles` estão disponíveis como propriedades `TokenIntrospection` `username` e `scope` e pode utilizar `io.quarkus.test.security.oidc.TokenIntrospection` para adicionar propriedades de resposta de introspeção adicionais, tais como `email`, etc."

#. type: delimited block =
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:959
#, fuzzy
msgid "`@TestSecurity` and `@OidcSecurity` can be combined in a meta-annotation, for example like so:"
msgstr "`@TestSecurity` e `@OidcSecurity` podem ser combinados numa meta-anotação, por exemplo, desta forma:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:971
#, no-wrap
msgid ""
"    @Retention(RetentionPolicy.RUNTIME)\n"
"    @Target({ ElementType.METHOD })\n"
"    @TestSecurity(user = \"userOidc\", roles = \"viewer\")\n"
"    @OidcSecurity(introspectionRequired = true,\n"
"        introspection = {\n"
"            @TokenIntrospection(key = \"email\", value = \"user@gmail.com\")\n"
"        }\n"
"    )\n"
"    public @interface TestSecurityMetaAnnotation {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:973
#, no-wrap
msgid "    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:976
#, fuzzy
msgid "This is particularly useful if the same set of security settings needs to be used in multiple test methods."
msgstr "Isto é particularmente útil se o mesmo conjunto de definições de segurança precisar de ser utilizado em vários métodos de teste."

#. type: Title ===
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:978
#, fuzzy, no-wrap
msgid "How to check the errors in the logs"
msgstr "Como verificar os erros nos registos"

#. type: delimited block =
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:981
#, fuzzy
msgid "Please enable `io.quarkus.oidc.runtime.OidcProvider` `TRACE` level logging to see more details about the token verification errors:"
msgstr "Active o registo de nível `io.quarkus.oidc.runtime.OidcProvider` `TRACE` para ver mais detalhes sobre os erros de verificação do token:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:986
#, no-wrap
msgid ""
"quarkus.log.category.\"io.quarkus.oidc.runtime.OidcProvider\".level=TRACE\n"
"quarkus.log.category.\"io.quarkus.oidc.runtime.OidcProvider\".min-level=TRACE\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:989
#, fuzzy
msgid "Please enable `io.quarkus.oidc.runtime.OidcRecorder` `TRACE` level logging to see more details about the OidcProvider client initialization errors:"
msgstr "Ative `io.quarkus.oidc.runtime.OidcRecorder` `TRACE` level logging para ver mais detalhes sobre os erros de inicialização do cliente OidcProvider:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:994
#, no-wrap
msgid ""
"quarkus.log.category.\"io.quarkus.oidc.runtime.OidcRecorder\".level=TRACE\n"
"quarkus.log.category.\"io.quarkus.oidc.runtime.OidcRecorder\".min-level=TRACE\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:996
#, fuzzy, no-wrap
msgid "External and Internal Access to OpenID Connect Provider"
msgstr "Acesso externo e interno ao provedor OpenID Connect"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:999
#, fuzzy
msgid "Note that the OpenID Connect Provider externally accessible token and other endpoints may have different HTTP(S) URLs compared to the URLs auto-discovered or configured relative to `quarkus.oidc.auth-server-url` internal URL. For example, if your SPA acquires a token from an external token endpoint address and sends it to Quarkus as a bearer token then an issuer verification failure may be reported by the endpoint."
msgstr "Note-se que o token acessível externamente do OpenID Connect Provider e outros pontos finais podem ter URLs HTTP(S) diferentes em comparação com os URLs auto-descobertos ou configurados relativamente ao URL interno `quarkus.oidc.auth-server-url`. Por exemplo, se a sua SPA adquirir um token a partir de um endereço de ponto de extremidade de token externo e o enviar para o Quarkus como um token portador, o ponto de extremidade pode comunicar uma falha de verificação do emissor."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1002
#, fuzzy
msgid "In such cases, if you work with Keycloak then please start it with a `KEYCLOAK_FRONTEND_URL` system property set to the externally accessible base URL.  If you work with other Openid Connect providers then please check your provider's documentation."
msgstr "Nesses casos, se trabalhar com o Keycloak, inicie-o com uma propriedade do sistema `KEYCLOAK_FRONTEND_URL` definida para o URL de base acessível externamente. Se trabalhar com outros fornecedores Openid Connect, consulte a documentação do seu fornecedor."

#. type: Title ===
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1003
#, fuzzy, no-wrap
msgid "How to use 'client-id' property"
msgstr "Como utilizar a propriedade \"client-id\"?"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1006
#, fuzzy
msgid "`quarkus.oidc.client-id` property identifies an OpenID Connect Client which requested the current bearer token. It can be an SPA application running in a browser or a Quarkus `web-app` confidential client application propagating the access token to the Quarkus `service` application."
msgstr "`quarkus.oidc.client-id` A propriedade identifica um cliente OpenID Connect que solicitou o token de portador atual. Pode ser uma aplicação SPA executada num navegador ou uma aplicação cliente confidencial Quarkus `web-app` que propaga o token de acesso para a aplicação Quarkus `service`."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1009
#, fuzzy
msgid "This property is required if the `service` application is expected to introspect the tokens remotely - which is always the case for the opaque tokens.  This property is optional if the local Json Web Key token verification only is used."
msgstr "Esta propriedade é necessária se for expetável que a aplicação `service` introspeccione os tokens remotamente - o que é sempre o caso para os tokens opacos. Esta propriedade é opcional se for utilizada apenas a verificação local do token Json Web Key."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1011
#, fuzzy
msgid "Nonetheless, setting this property is encouraged even if the endpoint does not require access to the remote introspection endpoint. The reasons behind it that `client-id`, if set, can be used to verify the token audience and will also be included in the logs when the token verification fails for the better traceability of the tokens issued to specific clients to be analyzed over a longer period of time."
msgstr "No entanto, a definição desta propriedade é encorajada mesmo que o ponto final não exija acesso ao ponto final de introspeção remota. As razões subjacentes são que `client-id`, se definido, pode ser utilizado para verificar o público do token e também será incluído nos registos quando a verificação do token falhar para uma melhor rastreabilidade dos tokens emitidos para clientes específicos a analisar durante um período de tempo mais longo."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1013
#, fuzzy
msgid "For example, if your OpenID Connect provider sets a token audience then the following configuration pattern is recommended:"
msgstr "Por exemplo, se o seu fornecedor OpenID Connect definir um público de token, é recomendado o seguinte padrão de configuração:"

#. type: delimited block -
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1020
#, no-wrap
msgid ""
"# Set client-id\n"
"quarkus.oidc.client-id=quarkus-app\n"
"# Token audience claim must contain 'quarkus-app'\n"
"quarkus.oidc.token.audience=${quarkus.oidc.client-id}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1023
#, fuzzy
msgid "If you set `quarkus.oidc.client-id` but your endpoint does not require remote access to one of OpenID Connect Provider endpoints (introspection, token acquisition, etc.) then do not set a client secret with the `quarkus.oidc.credentials` or similar properties as it will not be used."
msgstr "Se definir `quarkus.oidc.client-id` mas o seu ponto final não exigir acesso remoto a um dos pontos finais do fornecedor de ligação OpenID (introspeção, aquisição de token, etc.), não defina um segredo de cliente com as propriedades `quarkus.oidc.credentials` ou semelhantes, uma vez que não será utilizado."

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1025
#, fuzzy
msgid "Note Quarkus `web-app` applications always require `quarkus.oidc.client-id` property."
msgstr "Nota: As aplicações Quarkus `web-app` requerem sempre a propriedade `quarkus.oidc.client-id`."

#. type: Title ==
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1026
#, fuzzy, no-wrap
msgid "References"
msgstr "Referências"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1029
#, fuzzy
msgid "xref:security-oidc-configuration-properties-reference.adoc[OIDC configuration properties]"
msgstr "link:security-oidc-configuration-properties-reference.html[Propriedades de configuração do OIDC]"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1030
#, fuzzy
msgid "xref:security-oidc-bearer-token-authentication-tutorial.adoc[Protect a service application by using OIDC Bearer token authentication]"
msgstr "link:security-oidc-bearer-token-authentication-tutorial.html[Proteger uma aplicação de serviço utilizando a autenticação de token de portador OIDC]"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1031
#, fuzzy
msgid "xref:security-protect-service-applications-by-using-oidc-bearer-authentication-how-to.adoc[Protect service applications by using OIDC Bearer token authentication]"
msgstr "link:security-protect-service-applications-by-using-oidc-bearer-authentication-how-to.html[Proteger as aplicações de serviço utilizando a autenticação de token de portador OIDC]"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1032
#, fuzzy
msgid "https://www.keycloak.org/documentation.html[Keycloak Documentation]"
msgstr "link:https://www.keycloak.org/documentation.html[Documentação do Keycloak]"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1033
#, fuzzy
msgid "https://openid.net/connect/[OpenID Connect]"
msgstr "link:https://openid.net/connect/[Ligação OpenID]"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1034
#, fuzzy
msgid "https://tools.ietf.org/html/rfc7519[JSON Web Token]"
msgstr "link:https://tools.ietf.org/html/rfc7519[Token Web JSON]"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1035
#, fuzzy
msgid "xref:security-openid-connect-client-reference.adoc[OpenID Connect and OAuth2 Client and Filters Reference Guide]"
msgstr "link:security-openid-connect-client-reference.html[Guia de referência para clientes e filtros OpenID Connect e OAuth2]"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1036
#, fuzzy
msgid "xref:security-openid-connect-dev-services.adoc[Dev Services for Keycloak]"
msgstr "link:security-openid-connect-dev-services.html[Serviços de desenvolvimento para Keycloak]"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1037
#, fuzzy
msgid "xref:security-jwt-build.adoc[Sign and encrypt JWT tokens with SmallRye JWT Build]"
msgstr "link:security-jwt-build.html[Assine e criptografe tokens JWT com o SmallRye JWT Build]"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1038
#, fuzzy
msgid "xref:security-authentication-mechanisms.adoc#oidc-jwt-oauth2-comparison[Choosing between OpenID Connect, SmallRye JWT, and OAuth2 authentication mechanisms]"
msgstr "link:security-authentication-mechanisms.html#oidc-jwt-oauth2-comparison[Escolher entre os mecanismos de autenticação OpenID Connect, SmallRye JWT e OAuth2]"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1039
#, fuzzy
msgid "xref:security-authentication-mechanisms.adoc#combining-authentication-mechanisms[Combining authentication mechanisms]"
msgstr "link:security-authentication-mechanisms.html#combining-authentication-mechanisms[Combinação de mecanismos de autenticação]"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1040
#, fuzzy
msgid "xref:security-overview.adoc[Quarkus Security overview]"
msgstr "link:security-overview.html[Visão geral do Quarkus Security]"

#. type: Plain text
#: upstream/_guides/security-oidc-bearer-token-authentication.adoc:1040
#, fuzzy
msgid "xref:security-keycloak-admin-client.adoc[Quarkus Keycloak Admin Client]"
msgstr "link:security-keycloak-admin-client.html[Cliente de administração do Keycloak Quarkus]"
