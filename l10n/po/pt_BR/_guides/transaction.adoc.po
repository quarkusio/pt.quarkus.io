# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2023-10-29 08:09+0000\n"
"PO-Revision-Date: 2023-11-02 13:11-0300\n"
"Last-Translator: George Gastaldi <gegastaldi@gmail.com>\n"
"Language-Team: \n"
"Language: pt\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.4.1\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/transaction.adoc:6
#, no-wrap
msgid "Using Transactions in Quarkus"
msgstr "Usando transações no Quarkus"

#. type: Plain text
#: upstream/_guides/transaction.adoc:17
msgid "Quarkus comes with a Transaction Manager and uses it to coordinate and expose transactions to your applications.  Each extension dealing with persistence will integrate with it for you.  And you will explicitly interact with transactions via CDI.  This guide will walk you through all that."
msgstr "O Quarkus vem com um Gerenciador de Transações e o usa para coordenar e expor transações para seus aplicativos.  Cada extensão que lida com persistência irá se integrar com ele para você.  E você interagirá explicitamente com as transações via CDI.  Este guia irá guiá-lo através de tudo isso."

#. type: Title ==
#: upstream/_guides/transaction.adoc:18
#, no-wrap
msgid "Setting it up"
msgstr "Configuração"

#. type: Plain text
#: upstream/_guides/transaction.adoc:22
msgid "You don't need to worry about setting it up most of the time as extensions needing it will simply add it as a dependency.  Hibernate ORM for example will include the transaction manager and set it up properly."
msgstr "Você não precisa se preocupar em configurá-lo na maioria das vezes, pois as extensões que precisam dele simplesmente o adicionarão como uma dependência.  O Hibernate ORM, por exemplo, incluirá o gerenciador de transações e o configurará corretamente."

#. type: Plain text
#: upstream/_guides/transaction.adoc:25
msgid "You might need to add it as a dependency explicitly if you are using transactions directly without Hibernate ORM for example.  Add the following to your build file:"
msgstr "Talvez seja necessário adicioná-lo como uma dependência explicitamente se estiver usando transações diretamente sem o Hibernate ORM, por exemplo.  Adicione o seguinte ao seu arquivo de compilação:"

#. type: Block title
#: upstream/_guides/transaction.adoc:27
#, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/transaction.adoc:33
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-narayana-jta</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/transaction.adoc:36
#, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/transaction.adoc:39
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-narayana-jta\")\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/transaction.adoc:41
#, no-wrap
msgid "Starting and stopping transactions: defining your boundaries"
msgstr "Iniciando e interrompendo transações: definindo seus limites"

#. type: Plain text
#: upstream/_guides/transaction.adoc:45
msgid "You can define your transaction boundaries either declaratively with `@Transactional` or programmatically with `QuarkusTransaction`. You can also use the JTA `UserTransaction` API directly, however this is less user-friendly than `QuarkusTransaction`."
msgstr "Você pode definir seus limites de transação declarativamente com '@Transactional' ou programaticamente com 'QuarkusTransaction'. Você também pode usar a API JTA 'UserTransaction' diretamente, no entanto, isso é menos amigável do que 'QuarkusTransaction'."

#. type: Title ===
#: upstream/_guides/transaction.adoc:46
#, no-wrap
msgid "Declarative approach"
msgstr "Abordagem declarativa"

#. type: Plain text
#: upstream/_guides/transaction.adoc:49
msgid "The easiest way to define your transaction boundaries is to use the `@Transactional` annotation on your entry method (`jakarta.transaction.Transactional`)."
msgstr "A forma mais fácil de definir os limites da sua transação é utilizar a anotação `@Transactional` no seu método de entrada ( `jakarta.transaction.Transactional`)."

#. type: delimited block -
#: upstream/_guides/transaction.adoc:54 upstream/_guides/transaction.adoc:102
#: upstream/_guides/transaction.adoc:261
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class SantaClausService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:57
#, no-wrap
msgid ""
"    @Inject ChildDAO childDAO;\n"
"    @Inject SantaClausDAO santaDAO;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:70
#, no-wrap
msgid ""
"    @Transactional // <1>\n"
"    public void getAGiftFromSanta(Child child, String giftDescription) {\n"
"        // some transaction work\n"
"        Gift gift = childDAO.addToGiftList(child, giftDescription);\n"
"        if (gift == null) {\n"
"            throw new OMGGiftNotRecognizedException(); // <2>\n"
"        }\n"
"        else {\n"
"            santaDAO.addToSantaTodoList(gift);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/transaction.adoc:73
msgid "This annotation defines your transaction boundaries and will wrap this call within a transaction."
msgstr "Essa anotação define os limites da transação e encapsulará essa chamada em uma transação."

#. type: Plain text
#: upstream/_guides/transaction.adoc:74
msgid "A `RuntimeException` crossing the transaction boundaries will roll back the transaction."
msgstr "Um 'RuntimeException' cruzando os limites da transação reverterá a transação."

#. type: Plain text
#: upstream/_guides/transaction.adoc:77
msgid "`@Transactional` can be used to control transaction boundaries on any CDI bean at the method level or at the class level to ensure every method is transactional.  That includes REST endpoints."
msgstr "'@Transactional' pode ser usado para controlar limites de transação em qualquer bean CDI no nível do método ou no nível da classe para garantir que cada método seja transacional.  Isso inclui pontos de extremidade REST."

#. type: Plain text
#: upstream/_guides/transaction.adoc:79
msgid "You can control whether and how the transaction is started with parameters on `@Transactional`:"
msgstr "Você pode controlar se e como a transação é iniciada com parâmetros em '@Transactional':"

#. type: Plain text
#: upstream/_guides/transaction.adoc:81
msgid "`@Transactional(REQUIRED)` (default): starts a transaction if none was started, stays with the existing one otherwise."
msgstr "'@Transactional(REQUIRED)' (padrão): inicia uma transação se nenhuma foi iniciada, permanece com a existente caso contrário."

#. type: Plain text
#: upstream/_guides/transaction.adoc:82
msgid "`@Transactional(REQUIRES_NEW)`: starts a transaction if none was started ; if an existing one was started, suspends it and starts a new one for the boundary of that method."
msgstr "«@Transactional(REQUIRES_NEW)»: inicia uma transação se não tiver sido iniciada nenhuma; se um existente foi iniciado, suspende-o e inicia um novo para o limite desse método."

#. type: Plain text
#: upstream/_guides/transaction.adoc:83
msgid "`@Transactional(MANDATORY)`: fails if no transaction was started ; works within the existing transaction otherwise."
msgstr "`@Transactional(MANDATORY)`: falha se não tiver sido iniciada nenhuma transação; caso contrário, funciona dentro da transação existente."

#. type: Plain text
#: upstream/_guides/transaction.adoc:84
msgid "`@Transactional(SUPPORTS)`: if a transaction was started, joins it ; otherwise works with no transaction."
msgstr "`@Transactional(SUPPORTS)`: se foi iniciada uma transação, junta-se a ela; caso contrário, não funciona com nenhuma transação."

#. type: Plain text
#: upstream/_guides/transaction.adoc:85
msgid "`@Transactional(NOT_SUPPORTED)`: if a transaction was started, suspends it and works with no transaction for the boundary of the method ; otherwise works with no transaction."
msgstr "`@Transactional(NOT_SUPPORTED)`: Se uma transação foi iniciada, suspende-a e trabalha sem transação durante o limite do método; caso contrário, trabalha sem transação."

#. type: Plain text
#: upstream/_guides/transaction.adoc:86
msgid "`@Transactional(NEVER)`: if a transaction was started, raises an exception ; otherwise works with no transaction."
msgstr "`@Transactional(NEVER)`: se foi iniciada uma transação, levanta uma exceção; caso contrário, funciona sem transação."

#. type: Plain text
#: upstream/_guides/transaction.adoc:90
msgid "`REQUIRED` or `NOT_SUPPORTED` are probably the most useful ones.  This is how you decide whether a method is to be running within or outside a transaction.  Make sure to check the JavaDoc for the precise semantic."
msgstr "‘REQUIRED’ ou 'NOT_SUPPORTED' são provavelmente os mais úteis.  É assim que você decide se um método deve ser executado dentro ou fora de uma transação.  Certifique-se de verificar o JavaDoc para a semântica precisa."

#. type: Plain text
#: upstream/_guides/transaction.adoc:94
msgid "The transaction context is propagated to all calls nested in the `@Transactional` method as you would expect (in this example `childDAO.addToGiftList()` and `santaDAO.addToSantaTodoList()`).  The transaction will commit unless a runtime exception crosses the method boundary.  You can override whether an exception forces the rollback or not by using `@Transactional(dontRollbackOn=SomeException.class)` (or `rollbackOn`)."
msgstr "O contexto da transação é propagado a todas as chamadas aninhadas no método `@Transactional` como seria de esperar (neste exemplo `childDAO.addToGiftList()` e `santaDAO.addToSantaTodoList()`). A transação será confirmada a menos que uma exceção de tempo de execução atravesse o limite do método. É possível substituir se uma exceção força ou não a reversão utilizando `@Transactional(dontRollbackOn=SomeException.class)` (ou `rollbackOn`)."

#. type: Plain text
#: upstream/_guides/transaction.adoc:97
msgid "You can also programmatically ask for a transaction to be marked for rollback.  Inject a `TransactionManager` for this."
msgstr "Você também pode solicitar programaticamente que uma transação seja marcada para reversão.  Injete um 'TransactionManager' para isso."

#. type: delimited block -
#: upstream/_guides/transaction.adoc:106
#, no-wrap
msgid ""
"    @Inject TransactionManager tm; // <1>\n"
"    @Inject ChildDAO childDAO;\n"
"    @Inject SantaClausDAO santaDAO;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:119
#, no-wrap
msgid ""
"    @Transactional\n"
"    public void getAGiftFromSanta(Child child, String giftDescription) {\n"
"        // some transaction work\n"
"        Gift gift = childDAO.addToGiftList(child, giftDescription);\n"
"        if (gift == null) {\n"
"            tm.setRollbackOnly(); // <2>\n"
"        }\n"
"        else {\n"
"            santaDAO.addToSantaTodoList(gift);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/transaction.adoc:122
msgid "Inject the `TransactionManager` to be able to activate `setRollbackOnly` semantic."
msgstr "Injete o `TransactionManager` para poder ativar a semântica `setRollbackOnly`."

#. type: Plain text
#: upstream/_guides/transaction.adoc:123
msgid "Programmatically decide to set the transaction for rollback."
msgstr "Decida programaticamente definir a transação para reversão."

#. type: Title ===
#: upstream/_guides/transaction.adoc:125
#, no-wrap
msgid "Transaction Configuration"
msgstr "Configuração de transações"

#. type: Plain text
#: upstream/_guides/transaction.adoc:128
msgid "Advanced configuration of the transaction is possible with the use of the `@TransactionConfiguration` annotation that is set in addition to the standard `@Transactional` annotation on your entry method or at the class level."
msgstr "A configuração avançada da transação é possível com a utilização da anotação `@TransactionConfiguration` que é definida para além da anotação `@Transactional` padrão no seu método de entrada ou ao nível da classe."

#. type: Plain text
#: upstream/_guides/transaction.adoc:130
msgid "The `@TransactionConfiguration` annotation allows to set a timeout property, in seconds, that applies to transactions created within the annotated method."
msgstr "A anotação '@TransactionConfiguration' permite definir uma propriedade de tempo limite, em segundos, que se aplica a transações criadas dentro do método anotado."

#. type: Plain text
#: upstream/_guides/transaction.adoc:133
msgid "This annotation may only be placed on the top level method delineating the transaction.  Annotated nested methods once a transaction has started will throw an exception."
msgstr "Essa anotação só pode ser colocada no método de nível superior que delineia a transação.  Os métodos aninhados anotados depois que uma transação for iniciada lançarão uma exceção."

#. type: Plain text
#: upstream/_guides/transaction.adoc:136
msgid "If defined on a class, it is equivalent to defining it on all the methods of the class marked with `@Transactional`.  The configuration defined on a method takes precedence over the configuration defined on a class."
msgstr "Se for definida numa classe, é equivalente a defini-la em todos os métodos da classe marcados com `@Transactional`. A configuração definida num método tem precedência sobre a configuração definida numa classe."

#. type: Title ===
#: upstream/_guides/transaction.adoc:137
#, no-wrap
msgid "Reactive extensions"
msgstr "Extensões reativas"

#. type: Plain text
#: upstream/_guides/transaction.adoc:140
msgid "If your `@Transactional`-annotated method returns a reactive value, such as:"
msgstr "Se o método anotado '@Transactional' retornar um valor reativo, como:"

#. type: Plain text
#: upstream/_guides/transaction.adoc:142
msgid "`CompletionStage` (from the JDK)"
msgstr "`CompletionStage` (do JDK)"

#. type: Plain text
#: upstream/_guides/transaction.adoc:143
msgid "`Publisher` (from Reactive-Streams)"
msgstr "`Publisher` (de Reactive-Streams)"

#. type: Plain text
#: upstream/_guides/transaction.adoc:144
msgid "Any type which can be converted to one of the two previous types using Reactive Type Converters"
msgstr "Qualquer tipo que possa ser convertido em um dos dois tipos anteriores usando conversores de tipo reativo"

#. type: Plain text
#: upstream/_guides/transaction.adoc:149
msgid "then the behaviour is a bit different, because the transaction will not be terminated until the returned reactive value is terminated. In effect, the returned reactive value will be listened to and if it terminates exceptionally the transaction will be marked for rollback, and will be committed or rolled-back only at termination of the reactive value."
msgstr "então o comportamento é um pouco diferente, porque a transação não será encerrada até que o valor reativo retornado seja encerrado. Na verdade, o valor reativo retornado será ouvido e, se for encerrado excepcionalmente, a transação será marcada para reversão e será confirmada ou revertida somente no término do valor reativo."

#. type: Plain text
#: upstream/_guides/transaction.adoc:152
msgid "This allows your reactive methods to keep on working on the transaction asynchronously until their work is really done, and not just until the reactive method returns."
msgstr "Isso permite que seus métodos reativos continuem trabalhando na transação de forma assíncrona até que seu trabalho seja realmente concluído, e não apenas até que o método reativo retorne."

#. type: Plain text
#: upstream/_guides/transaction.adoc:155
msgid "If you need to propagate your transaction context across your reactive pipeline, please see the xref:context-propagation.adoc[Context Propagation guide]."
msgstr "Se você precisar propagar seu contexto de transação pelo pipeline reativo, consulte o xref:context-propagation.adoc[Guia de propagação de contexto]."

#. type: Title ===
#: upstream/_guides/transaction.adoc:156
#, no-wrap
msgid "Programmatic Approach"
msgstr "Abordagem Programática"

#. type: Plain text
#: upstream/_guides/transaction.adoc:161
msgid "You can use static methods on `QuarkusTransaction` to define transaction boundaries. This provides two different options, a functional approach that allows you to run a lambda within the scope of a transaction, or by using explicit `begin`, `commit` and `rollback` methods."
msgstr "Você pode usar métodos estáticos em 'QuarkusTransaction' para definir limites de transação. Isso fornece duas opções diferentes, uma abordagem funcional que permite executar um lambda dentro do escopo de uma transação ou usando métodos explícitos 'begin', 'commit' e 'rollback'."

#. type: delimited block -
#: upstream/_guides/transaction.adoc:166
#, no-wrap
msgid ""
"import io.quarkus.narayana.jta.QuarkusTransaction;\n"
"import io.quarkus.narayana.jta.RunOptions;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:168
#, no-wrap
msgid "public class TransactionExample {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:173
#, no-wrap
msgid ""
"    public void beginExample() {\n"
"        QuarkusTransaction.begin();\n"
"        //do work\n"
"        QuarkusTransaction.commit();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:179
#, no-wrap
msgid ""
"        QuarkusTransaction.begin(QuarkusTransaction.beginOptions()\n"
"                .timeout(10));\n"
"        //do work\n"
"        QuarkusTransaction.rollback();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:187
#, no-wrap
msgid ""
"    public void runnerExample() {\n"
"        QuarkusTransaction.requiringNew().run(() -> {\n"
"            //do work\n"
"        });\n"
"        QuarkusTransaction.joiningExisting().run(() -> {\n"
"            //do work\n"
"        });\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:202
#, no-wrap
msgid ""
"        int result = QuarkusTransaction.requiringNew()\n"
"                .timeout(10)\n"
"                .exceptionHandler((throwable) -> {\n"
"                    if (throwable instanceof SomeException) {\n"
"                        return RunOptions.ExceptionResult.COMMIT;\n"
"                    }\n"
"                    return TransactionExceptionResult.ROLLBACK;\n"
"                })\n"
"                .call(() -> {\n"
"                    //do work\n"
"                    return 0;\n"
"                });\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/transaction.adoc:205
msgid "The above example shows a few different ways the API can be used."
msgstr "O exemplo acima mostra algumas maneiras diferentes de usar a API."

#. type: Plain text
#: upstream/_guides/transaction.adoc:211
msgid "The first method simply calls begin, does some work and commits it.  This created transaction is tied to the CDI request scope, so if it is still active when the request scope is destroyed then it will be automatically rolled back. This removes the need to explicitly catch exceptions and call `rollback`, and acts as a safety net against inadvertent transaction leaks, however it does mean that this can only be used when the request scope is active. The second example in the method calls begin with a timeout option, and then rolls back the transaction."
msgstr "O primeiro método simplesmente chama começar, faz algum trabalho e o compromete.  Essa transação criada está vinculada ao escopo de requisição do CDI, portanto, se ainda estiver ativa quando o escopo for destruído, ela será revertida automaticamente. Isso elimina a necessidade de capturar explicitamente exceções e chamar `rollback` e atua como uma rede de segurança contra vazamentos inadvertidos de transações, no entanto, significa que isso só pode ser usado quando o escopo da solicitação estiver ativo. O segundo exemplo nas chamadas de método começa com uma opção de tempo limite e, em seguida, reverte a transação."

#. type: Plain text
#: upstream/_guides/transaction.adoc:217
msgid "The second method shows the use of lambda scoped transactions with `QuarkusTransaction.runner(...)`; the first example just runs a `Runnable` within a new transaction, the second does the same but joining the existing transaction (if any), and the third calls a `Callable` with some specific options.  In particular the `exceptionHandler` method can be used to control if the transaction is rolled back or not on exception."
msgstr "O segundo método mostra o uso de transações com escopo lambda com 'QuarkusTransaction.runner(...) `; o primeiro exemplo apenas executa um 'Runnable' dentro de uma nova transação, o segundo faz o mesmo, mas juntando-se à transação existente (se houver), e o terceiro chama um 'Callable' com algumas opções específicas.  Em particular, o método 'exceptionHandler' pode ser usado para controlar se a transação é revertida ou não na exceção."

#. type: Plain text
#: upstream/_guides/transaction.adoc:219
msgid "The following semantics are supported:"
msgstr "A seguinte semântica é suportada:"

#. type: Labeled list
#: upstream/_guides/transaction.adoc:221
#, no-wrap
msgid "`QuarkusTransaction.disallowingExisting()`/`DISALLOW_EXISTING`"
msgstr "`QuarkusTransaction.disallowingExisting()`/ `DISALLOW_EXISTING`"

#. type: Plain text
#: upstream/_guides/transaction.adoc:225
msgid "If a transaction is already associated with the current thread a `QuarkusTransactionException` will be thrown, otherwise a new transaction is started, and follows all the normal lifecycle rules."
msgstr "Se uma transação já estiver associada à thread atual, será lançado um `QuarkusTransactionException`. Caso contrário, é iniciada uma nova transação, que segue todas as regras normais do ciclo de vida."

#. type: Labeled list
#: upstream/_guides/transaction.adoc:226
#, no-wrap
msgid "`QuarkusTransaction.joiningExisting()`/`JOIN_EXISTING`"
msgstr "`QuarkusTransaction.joiningExisting()`/ `JOIN_EXISTING`"

#. type: Plain text
#: upstream/_guides/transaction.adoc:235
msgid "If no transaction is active then a new transaction will be started, and committed when the method ends.  If an exception is thrown the exception handler registered by `#exceptionHandler(Function)` will be called to decide if the TX should be committed or rolled back.  If an existing transaction is active then the method is run in the context of the existing transaction. If an exception is thrown the exception handler will be called, however a result of `ExceptionResult#ROLLBACK` will result in the TX marked as rollback only, while a result of `ExceptionResult#COMMIT` will result in no action being taken."
msgstr "Se nenhuma transação estiver ativa, será iniciada uma nova transação, que será confirmada quando o método terminar. Se for lançada uma exceção, o gestor de excepções registado em `#exceptionHandler(Function)` será chamado para decidir se a TX deve ser confirmada ou revertida. Se uma transação existente estiver ativa, o método é executado no contexto da transação existente. Se for lançada uma exceção, o gestor de excepções será chamado, mas um resultado de `ExceptionResult#ROLLBACK` fará com que o TX seja marcado apenas como reversão, enquanto um resultado de `ExceptionResult#COMMIT` fará com que não seja tomada qualquer ação."

#. type: Labeled list
#: upstream/_guides/transaction.adoc:236
#, no-wrap
msgid "`QuarkusTransaction.requiringNew()`/`REQUIRE_NEW`"
msgstr "`QuarkusTransaction.requiringNew()`/ `REQUIRE_NEW`"

#. type: Plain text
#: upstream/_guides/transaction.adoc:242
msgid "If an existing transaction is already associated with the current thread then the transaction is suspended, then a new transaction is started which follows all the normal lifecycle rules, and when it's complete the original transaction is resumed.  Otherwise, a new transaction is started, and follows all the normal lifecycle rules."
msgstr "Se uma transação existente já estiver associada ao thread atual, a transação é suspensa, é iniciada uma nova transação que segue todas as regras normais do ciclo de vida e, quando estiver concluída, a transação original é retomada. Caso contrário, é iniciada uma nova transação, que segue todas as regras normais do ciclo de vida."

#. type: Labeled list
#: upstream/_guides/transaction.adoc:243
#, no-wrap
msgid "`QuarkusTransaction.suspendingExisting()`/`SUSPEND_EXISTING`"
msgstr "`QuarkusTransaction.suspendingExisting()`/ `SUSPEND_EXISTING`"

#. type: Plain text
#: upstream/_guides/transaction.adoc:250
msgid "If no transaction is active then these semantics are basically a no-op.  If a transaction is active then it is suspended, and resumed after the task is run.  The exception handler will never be consulted when these semantics are in use, specifying both an exception handler and these semantics are considered an error.  These semantics allows for code to easily be run outside the scope of a transaction."
msgstr "Se nenhuma transação estiver ativa, estas semânticas são basicamente um no-op. Se estiver ativa uma transação, esta é suspensa e retomada após a execução da tarefa. O manipulador de exceção nunca será consultado quando estas semânticas estiverem a ser utilizadas, especificando um manipulador de exceção e estas semânticas são consideradas um erro. Esta semântica permite que o código seja facilmente executado fora do âmbito de uma transação."

#. type: Title ===
#: upstream/_guides/transaction.adoc:253
#, no-wrap
msgid "Legacy API approach"
msgstr "Abordagem API legada"

#. type: Plain text
#: upstream/_guides/transaction.adoc:256
msgid "The less easy way is to inject a `UserTransaction` and use the various transaction demarcation methods."
msgstr "A forma menos fácil é injetar um `UserTransaction` e utilizar os vários métodos de demarcação de transacções."

#. type: delimited block -
#: upstream/_guides/transaction.adoc:265
#, no-wrap
msgid ""
"    @Inject ChildDAO childDAO;\n"
"    @Inject SantaClausDAO santaDAO;\n"
"    @Inject UserTransaction transaction;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:280
#, no-wrap
msgid ""
"    public void getAGiftFromSanta(Child child, String giftDescription) {\n"
"        // some transaction work\n"
"        try {\n"
"            transaction.begin();\n"
"            Gift gift = childDAO.addToGiftList(child, giftDescription);\n"
"            santaDAO.addToSantaTodoList(gift);\n"
"            transaction.commit();\n"
"        }\n"
"        catch(SomeException e) {\n"
"            // do something on Tx failure\n"
"            transaction.rollback();\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/transaction.adoc:285
msgid "You cannot use `UserTransaction` in a method having a transaction started by a `@Transactional` call."
msgstr "Não é possível utilizar `UserTransaction` num método com uma transação iniciada por uma chamada `@Transactional`."

#. type: Title ==
#: upstream/_guides/transaction.adoc:287
#, no-wrap
msgid "Configuring the transaction timeout"
msgstr "Configurando o tempo limite da transação"

#. type: Plain text
#: upstream/_guides/transaction.adoc:289
msgid "You can configure the default transaction timeout, the timeout that applies to all transactions managed by the transaction manager, via the property `quarkus.transaction-manager.default-transaction-timeout`, specified as a duration."
msgstr "Pode configurar o tempo limite de transação predefinido, o tempo limite que se aplica a todas as transacções geridas pelo gestor de transacções, através da propriedade `quarkus.transaction-manager.default-transaction-timeout`, especificada como uma duração."

#. type: Plain text
#: upstream/_guides/transaction.adoc:293
msgid "The default value is 60 seconds."
msgstr "O valor padrão é 60 segundos."

#. type: Title ==
#: upstream/_guides/transaction.adoc:294
#, no-wrap
msgid "Configuring transaction node name identifier"
msgstr "Configurando o identificador de nome do nó de transação"

#. type: Plain text
#: upstream/_guides/transaction.adoc:298
msgid "Narayana, as the underlying transaction manager, has a concept of a unique node identifier.  This is important if you consider using XA transactions that involve multiple resources."
msgstr "Narayana, como o gerente de transações subjacente, tem um conceito de um identificador de nó exclusivo.  Isso é importante se você considerar o uso de transações XA que envolvem vários recursos."

#. type: Plain text
#: upstream/_guides/transaction.adoc:304
msgid "The node name identifier plays a crucial part in the identification of a transaction.  The node name identifier is forged into the transaction id when the transaction is created.  Based on the node name identifier, the transaction manager is capable of recognizing the XA transaction counterparts created in database or JMS broker. The identifier makes possible for the transaction manager to roll back the transaction counterparts during recovery."
msgstr "O identificador do nome do nó desempenha um papel crucial na identificação de uma transação. O identificador do nome do nó é forjado na identificação da transação quando esta é criada. Com base no identificador do nome do nó, o gestor de transacções é capaz de reconhecer as contrapartidas da transação XA criadas na base de dados ou no corretor JMS. O identificador permite que o gestor de transacções reverta as contrapartes da transação durante a recuperação."

#. type: Plain text
#: upstream/_guides/transaction.adoc:307
msgid "The node name identifier needs to be unique per transaction manager deployment.  And the node identifier needs to be stable over the transaction manager restarts."
msgstr "O identificador do nome do nó tem de ser único por cada implementação do gestor de transacções. E o identificador do nó tem de ser estável durante os reinícios do gestor de transacções."

#. type: Plain text
#: upstream/_guides/transaction.adoc:309
msgid "The node name identifier may be configured via the property `quarkus.transaction-manager.node-name`."
msgstr "O identificador do nome do nó pode ser configurado através da propriedade `quarkus.transaction-manager.node-name`."

#. type: Title ==
#: upstream/_guides/transaction.adoc:311
#, no-wrap
msgid "Using `@TransactionScoped` to bind CDI beans to the transaction lifecycle"
msgstr "Utilizar `@TransactionScoped` para ligar beans CDI ao ciclo de vida da transação"

#. type: Plain text
#: upstream/_guides/transaction.adoc:315
msgid "You can define beans that live for as long as a transaction, and through CDI lifecycle events perform actions when a transaction starts and ends."
msgstr "É possível definir beans que duram tanto tempo quanto uma transação e, através de eventos de ciclo de vida CDI, executam acções quando uma transação começa e termina."

#. type: Plain text
#: upstream/_guides/transaction.adoc:317
msgid "Just assign the transaction xref:cdi.adoc#bean-scope[scope] to such beans using the `@TransactionScoped` annotation:"
msgstr "Basta atribuir o  link:cdi.html#bean-scope[âmbito] da transação a esses beans utilizando a anotação `@TransactionScoped`:"

#. type: delimited block -
#: upstream/_guides/transaction.adoc:322
#, no-wrap
msgid ""
"@TransactionScoped\n"
"public class MyTransactionScopedBean {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:326
#, no-wrap
msgid ""
"    // The bean's state is bound to a specific transaction,\n"
"    // and restored even after suspending then resuming the transaction.\n"
"    int myData;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:331
#, no-wrap
msgid ""
"    @PostConstruct\n"
"    void onBeginTransaction() {\n"
"        // This gets invoked after a transaction begins.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:337
#, no-wrap
msgid ""
"    @PreDestroy\n"
"    void onBeforeEndTransaction() {\n"
"        // This gets invoked before a transaction ends (commit or rollback).\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/transaction.adoc:342
msgid "Alternatively, if you don't necessarily need to hold state during the transaction, and just want to react to transaction start/end events, you can simply declare event listeners in a differently scoped bean:"
msgstr "Em alternativa, se não precisar necessariamente de manter o estado durante a transação e quiser apenas reagir a eventos de início/fim de transação, pode simplesmente declarar ouvintes de eventos num bean com um âmbito diferente:"

#. type: delimited block -
#: upstream/_guides/transaction.adoc:347
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class MyTransactionEventListeningBean {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:351
#, no-wrap
msgid ""
"    void onBeginTransaction(@Observes @Initialized(TransactionScoped.class) Object event) {\n"
"        // This gets invoked when a transaction begins.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:355
#, no-wrap
msgid ""
"    void onBeforeEndTransaction(@Observes @BeforeDestroyed(TransactionScoped.class) Object event) {\n"
"        // This gets invoked before a transaction ends (commit or rollback).\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/transaction.adoc:360
#, no-wrap
msgid ""
"    void onAfterEndTransaction(@Observes @Destroyed(TransactionScoped.class) Object event) {\n"
"        // This gets invoked after a transaction ends (commit or rollback).\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/transaction.adoc:363
msgid "The `event` object represents the transaction ID, and defines `toString()`/`equals()`/`hashCode()` accordingly."
msgstr "O objeto `event` representa o ID da transação e define `toString()`/ `equals()`/ `hashCode()` em conformidade."

#. type: Plain text
#: upstream/_guides/transaction.adoc:366
msgid "In listener methods, you can access more information about the transaction in progress by accessing the `TransactionManager`, which is a CDI bean and can be ``@Inject``ed."
msgstr "Nos métodos listener, é possível aceder a mais informações sobre a transação em curso, acedendo a `TransactionManager`, que é um bean CDI e pode ser `@Inject`ed."

#. type: Title ==
#: upstream/_guides/transaction.adoc:368
#, no-wrap
msgid "Configure storing of Quarkus transaction logs in a database"
msgstr "Configurar o armazenamento dos registos de transacções do Quarkus numa base de dados"

#. type: Plain text
#: upstream/_guides/transaction.adoc:371
msgid "In cloud environments where persistent storage is not available, such as when application containers are unable to use persistent volumes, you can configure the transaction management to store transaction logs in a database by using a JDBC datasource."
msgstr "Em ambientes de nuvem em que o armazenamento persistente não está disponível, como quando os contêineres de aplicativos não podem usar volumes persistentes, é possível configurar o gerenciamento de transações para armazenar logs de transações em um banco de dados usando uma fonte de dados JDBC."

#. type: Plain text
#: upstream/_guides/transaction.adoc:373
msgid "While there are several benefits to using a database to store transaction logs, you might notice a reduction in performance compared with using the file system to store the logs."
msgstr "Embora existam vários benefícios na utilização de uma base de dados para armazenar registos de transacções, poderá notar uma redução no desempenho em comparação com a utilização do sistema de ficheiros para armazenar os registos."

#. type: Plain text
#: upstream/_guides/transaction.adoc:375
msgid "Quarkus allows the following JDBC-specific configuration of the object store included in `quarkus.transaction-manager.object-store.<property>` properties, where <property> can be:"
msgstr "O Quarkus permite a seguinte configuração específica de JDBC do armazenamento de objectos incluída em `quarkus.transacion-manager.object-store.&amp;lt;property&amp;gt;` propriedades, onde &lt;property&gt; pode ser:"

#. type: Plain text
#: upstream/_guides/transaction.adoc:379
msgid "`type` (_string_): Configure this property to `jdbc` to enable usage of a Quarkus JDBC datasource for transaction logging.  The default value is `file-system`."
msgstr "`type` _(string_): Configure esta propriedade para `jdbc` para permitir a utilização de uma fonte de dados JDBC do Quarkus para registo de transacções. O valor predefinido é `file-system`."

#. type: Plain text
#: upstream/_guides/transaction.adoc:381
msgid "`datasource` (_string_): Specify the name of the datasource for the transaction log storage.  If no value is provided for the `datasource` property, Quarkus uses the xref:datasource.adoc#configure-datasources[default datasource]."
msgstr "`datasource` _(string_): Especifique o nome da fonte de dados para o armazenamento do registo de transacções. Se não for fornecido nenhum valor para a propriedade `datasource`, o Quarkus utiliza a  link:datasource.html#configure-datasources[fonte de dados predefinida]."

#. type: Plain text
#: upstream/_guides/transaction.adoc:383
msgid "`create-table` (_boolean_): When set to `true`, the transaction log table gets automatically created if it does not already exist.  The default value is `false`."
msgstr "`create-table` _(booleano_): Quando definido para `true`, a tabela do registo de transacções é criada automaticamente se ainda não existir. O valor predefinido é `false`."

#. type: Plain text
#: upstream/_guides/transaction.adoc:385
msgid "`drop-table` (_boolean_): When set to `true`, the tables are dropped on startup if they already exist.  The default value is `false`."
msgstr "`drop-table` _(booleano_): Quando definido para `true`, as tabelas são eliminadas no arranque se já existirem. O valor predefinido é `false`."

#. type: Plain text
#: upstream/_guides/transaction.adoc:387
msgid "`table-prefix` (string): Specify the prefix for a related table name.  The default value is `quarkus_`."
msgstr "`table-prefix` (string): Especifique o prefixo para um nome de tabela relacionado. O valor padrão é `quarkus_`."

#. This paragraph will differ from the RHBQ docs in the future since it is not supported in the product yet.
#. type: Plain text
#: upstream/_guides/transaction.adoc:390
msgid "Additional information:"
msgstr "Informações adicionais:"

#. type: Plain text
#: upstream/_guides/transaction.adoc:392
msgid "You can manually create the transaction log table during the initial setup by setting the `create-table` property to `true`."
msgstr "É possível criar manualmente a tabela de registro de transações durante a configuração inicial, definindo a propriedade `create-table` como `true`."

#. type: Plain text
#: upstream/_guides/transaction.adoc:394
msgid "JDBC datasources and ActiveMQ Artemis allow the enlistment and automatically register the `XAResourceRecovery`."
msgstr "Os recursos de dados JDBC e o ActiveMQ Artemis permitem a inscrição e registram automaticamente o `XAResourceRecovery`."

#. type: Plain text
#: upstream/_guides/transaction.adoc:396
msgid "JDBC datasources is part of `quarkus-agroal`, and it needs to use `quarkus.datasource.jdbc.transactions=XA`."
msgstr "Os recursos de dados JDBC fazem parte de `quarkus-agroal` e precisam ser usados em `quarkus.datasource.jdbc.transactions=XA`."

#. type: Plain text
#: upstream/_guides/transaction.adoc:397
msgid "ActiveMQ Artemis is part of `quarkus-pooled-jms`, and it needs to use `quarkus.pooled-jms.transaction=XA`."
msgstr "O ActiveMQ Artemis faz parte do `quarkus-pooled-jms` e precisa usar o `quarkus.pooled-jms.transaction=XA`."

#. type: Plain text
#: upstream/_guides/transaction.adoc:399
msgid "For more information, see link:https://issues.redhat.com/browse/CEQ-4878[CEQ-4878]."
msgstr "Para obter mais informações, consulte o link:https://issues.redhat.com/browse/CEQ-4878[CEQ-4878]."

#. type: Plain text
#: upstream/_guides/transaction.adoc:401
msgid "If your application employs eXtended Architecture (XA) transactions, enable the transaction crash recovery feature by using `quarkus.transaction-manager.enable-recovery=true`, to safeguard your data in the event of application crashes or failures. The default value for XA Recovery is `false`."
msgstr "Se seu aplicativo empregar transações XA (eXtended Architecture), habilite o recurso de recuperação de falhas de transação usando `quarkus.transaction-manager.enable-recovery=true`, para proteger seus dados em caso de falhas ou falhas do aplicativo. O valor padrão para XA Recovery é `false`."

#. type: delimited block =
#: upstream/_guides/transaction.adoc:405
msgid "To work around the current known issue of link:https://issues.redhat.com/browse/AG-209[Agroal having a different view on running transaction checks], set the datasource transaction type for the datasource responsible for writing the transaction logs to `disabled`:"
msgstr "Para contornar o problema conhecido atual de link:https://issues.redhat.com/browse/AG-209[Agroal tendo uma exibição diferente sobre a execução de verificações de transação], defina o tipo de transação de fonte de dados para a fonte de dados responsável por gravar os logs de transação como 'disabled':"

#. type: delimited block -
#: upstream/_guides/transaction.adoc:408
#, no-wrap
msgid "quarkus.datasource.TX_LOG.jdbc.transactions=disabled\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/transaction.adoc:411
msgid "This example uses TX_LOG as the datasource name."
msgstr "Este exemplo utiliza TX_LOG como o nome da fonte de dados."

#. type: Title ==
#: upstream/_guides/transaction.adoc:414
#, no-wrap
msgid "Why always having a transaction manager?"
msgstr "Por que sempre ter um gerenciador de transações?"

#. type: Labeled list
#: upstream/_guides/transaction.adoc:416
#, no-wrap
msgid "Does it work everywhere I want to?"
msgstr "Funciona em todos os lugares que eu quiser?"

#. type: delimited block =
#: upstream/_guides/transaction.adoc:423
msgid "Yep, it works in your Quarkus application, in your IDE, in your tests, because all of these are Quarkus applications.  JTA has some bad press for some people.  I don't know why.  Let's just say that this is not your grandpa's JTA implementation.  What we have is perfectly embeddable and lean."
msgstr "Sim, funciona na sua aplicação Quarkus, no seu IDE, nos seus testes, porque todas estas são aplicações Quarkus. O JTA tem má fama para algumas pessoas. Não sei porquê. Digamos apenas que esta não é a implementação JTA do seu avô. O que temos é perfeitamente incorporável e simples."

#. type: Labeled list
#: upstream/_guides/transaction.adoc:424
#, no-wrap
msgid "Does it do 2 Phase Commit and slow down my app?"
msgstr "Fazer 2 Phase Commit e torna a minha aplicação mais lenta?"

#. type: delimited block =
#: upstream/_guides/transaction.adoc:428
msgid "No, this is an old folk tale.  Let's assume it essentially comes for free and let you scale to more complex cases involving several datasources as needed."
msgstr "Não, este é um velho conto popular.  Vamos supor que ele essencialmente vem de graça e permite que você dimensione para casos mais complexos envolvendo várias fontes de dados, conforme necessário."

#. type: Labeled list
#: upstream/_guides/transaction.adoc:429
#, no-wrap
msgid "I don't need transaction when I do read only operations, it's faster."
msgstr "Não preciso de transação quando faço operações somente leitura, é mais rápido."

#. type: delimited block =
#: upstream/_guides/transaction.adoc:441
msgid "Wrong. + First off, just disable the transaction by marking your transaction boundary with `@Transactional(NOT_SUPPORTED)` (or `NEVER` or `SUPPORTS` depending on the semantic you want). + Second, it's again fairy tale that not using transaction is faster.  The answer is, it depends on your DB and how many SQL SELECTs you are making.  No transaction means the DB does have a single operation transaction context anyway. + Third, when you do several SELECTs, it's better to wrap them in a single transaction because they will all be consistent with one another.  Say your DB represents your car dashboard, you can see the number of kilometers remaining and the fuel gauge level.  By reading it in one transaction, they will be consistent.  If you read one and the other from two different transactions, then they can be inconsistent.  It can be more dramatic if you read data related to rights and access management for example."
msgstr "Errado. + Primeiro, basta desativar a transação marcando seu limite de transação com '@Transactional(NOT_SUPPORTED)' (ou ‘NEVER’ ou 'SUPPORTS', dependendo da semântica desejada). + Segundo, é novamente um conto de fadas que não usar transação é mais rápido.  A resposta é, depende do seu banco de dados e quantos SQL SELECTs você está fazendo.  Nenhuma transação significa que o banco de dados tem um único contexto de transação de operação de qualquer maneira. + Terceiro, quando você faz vários SELECTs, é melhor envolvê-los em uma única transação, porque todos eles serão consistentes uns com os outros.  Digamos que seu DB representa o painel do seu carro, você pode ver o número de quilômetros restantes e o nível do medidor de combustível.  Ao lê-lo em uma transação, eles serão consistentes.  Se você ler uma e outra de duas transações diferentes, elas podem ser inconsistentes.  Pode ser mais dramático se você ler dados relacionados a direitos e gerenciamento de acesso, por exemplo."

#. type: Labeled list
#: upstream/_guides/transaction.adoc:442
#, no-wrap
msgid "Why do you prefer JTA vs Hibernate's transaction management API"
msgstr "Por que você prefere a API de gerenciamento de transações do JTA vs Hibernate"

#. type: delimited block =
#: upstream/_guides/transaction.adoc:446
msgid "Managing the transactions manually via `entityManager.getTransaction().begin()` and friends lead to a butt ugly code with tons of try catch finally that people get wrong.  Transactions are also about JMS and other database access, so one API makes more sense."
msgstr "Gerenciar as transações manualmente via 'entityManager.getTransaction().begin()' e os amigos levam a um código feio com toneladas de tentativa de pegar finalmente que as pessoas erram.  As transações também são sobre JMS e outros acessos ao banco de dados, portanto, uma API faz mais sentido."

#. type: Labeled list
#: upstream/_guides/transaction.adoc:447
#, no-wrap
msgid "It's a mess because I don't know if my Jakarta Persistence persistence unit is using `JTA` or `Resource-level` Transaction"
msgstr "É uma bagunça porque não sei se minha unidade de persistência Jakarta Persistence está usando a transação 'JTA' ou 'Resource-level'"

#. type: delimited block =
#: upstream/_guides/transaction.adoc:452
msgid "It's not a mess in Quarkus :)  Resource-level was introduced to support Jakarta Persistence in a non managed environment.  But Quarkus is both lean and a managed environment, so we can safely always assume we are in JTA mode.  The end result is that the difficulties of running Hibernate ORM + CDI + a transaction manager in Java SE mode are solved by Quarkus."
msgstr "Não é uma confusão no Quarkus :) O Resource-level foi introduzido para suportar a Jakarta Persistence num ambiente não gerido. Mas o Quarkus é um ambiente gerido e não gerido, pelo que podemos sempre assumir que estamos em modo JTA. O resultado final é que as dificuldades de executar o Hibernate ORM + CDI + um gestor de transacções no modo Java SE são resolvidas pelo Quarkus."
