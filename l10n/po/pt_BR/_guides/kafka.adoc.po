# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-10-29 08:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/kafka.adoc:6
#, fuzzy, no-wrap
msgid "Apache Kafka Reference Guide"
msgstr "Guia de referência do Apache Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:17
#, fuzzy
msgid "This reference guide demonstrates how your Quarkus application can utilize SmallRye Reactive Messaging to interact with Apache Kafka."
msgstr "Este guia de referência demonstra como seu aplicativo Quarkus pode utilizar o SmallRye Reactive Messaging para interagir com o Apache Kafka."

#. type: Title ==
#: upstream/_guides/kafka.adoc:18
#, fuzzy, no-wrap
msgid "Introduction"
msgstr "Introdução"

#. type: Plain text
#: upstream/_guides/kafka.adoc:23
#, fuzzy
msgid "https://kafka.apache.org[Apache Kafka] is a popular open-source distributed event streaming platform.  It is used commonly for high-performance data pipelines, streaming analytics, data integration, and mission-critical applications.  Similar to a message queue, or an enterprise messaging platform, it lets you:"
msgstr "link:https://kafka.apache.org[O Apache Kafka] é uma popular plataforma de streaming de eventos distribuídos de código aberto. É normalmente utilizada para pipelines de dados de elevado desempenho, análise de fluxo contínuo, integração de dados e aplicações de missão crítica. Semelhante a uma fila de mensagens ou a uma plataforma de mensagens empresariais, permite-lhe..:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:25
#, fuzzy, no-wrap
msgid "*publish* (write) and *subscribe* to (read) streams of events, called _records_.\n"
msgstr "*publicar* (escrever) e *subscrever* (ler) fluxos de eventos, denominados _registos_."

#. type: Plain text
#: upstream/_guides/kafka.adoc:26
#, fuzzy, no-wrap
msgid "*store* streams of records durably and reliably inside _topics_.\n"
msgstr "*armazenar* fluxos de registos de forma duradoura e fiável dentro dos _tópicos_."

#. type: Plain text
#: upstream/_guides/kafka.adoc:27
#, fuzzy, no-wrap
msgid "*process* streams of records as they occur or retrospectively.\n"
msgstr "*processar* fluxos de registos à medida que estes ocorrem ou retrospetivamente."

#. type: Plain text
#: upstream/_guides/kafka.adoc:29
#, fuzzy
msgid "And all this functionality is provided in a distributed, highly scalable, elastic, fault-tolerant, and secure manner."
msgstr "E toda esta funcionalidade é fornecida de uma forma distribuída, altamente escalável, elástica, tolerante a falhas e segura."

#. type: Title ==
#: upstream/_guides/kafka.adoc:30
#, fuzzy, no-wrap
msgid "Quarkus Extension for Apache Kafka"
msgstr "Extensão Quarkus para o Apache Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:34
#, fuzzy
msgid "Quarkus provides support for Apache Kafka through https://smallrye.io/smallrye-reactive-messaging/[SmallRye Reactive Messaging] framework.  Based on Eclipse MicroProfile Reactive Messaging specification 2.0, it proposes a flexible programming model bridging CDI and event-driven."
msgstr "O Quarkus fornece suporte para o Apache Kafka através da estrutura  link:https://smallrye.io/smallrye-reactive-messaging/[de mensagens reactivas SmallRye]. Com base na especificação 2.0 do Eclipse MicroProfile Reactive Messaging, propõe um modelo de programação flexível que faz a ponte entre o CDI e o orientado para eventos."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:39
#, fuzzy
msgid "This guide provides an in-depth look on Apache Kafka and SmallRye Reactive Messaging framework.  For a quick start take a look at xref:kafka-reactive-getting-started.adoc[Getting Started to SmallRye Reactive Messaging with Apache Kafka]."
msgstr "Este guia fornece uma visão aprofundada do Apache Kafka e do SmallRye Reactive Messaging framework. Para um início rápido, dê uma olhada em  link:kafka-reactive-getting-started.html[Getting Started to SmallRye Reactive Messaging with Apache Kafka]."

#. type: Plain text
#: upstream/_guides/kafka.adoc:42
#, fuzzy
msgid "You can add the `smallrye-reactive-messaging-kafka` extensions to your project by running the following command in your project base directory:"
msgstr "Pode adicionar as extensões `smallrye-reactive-messaging-kafka` ao seu projeto executando o seguinte comando no diretório base do seu projeto:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:47
#, fuzzy
msgid "This will add the following to your build file:"
msgstr "Isto irá adicionar o seguinte ao seu ficheiro de compilação:"

#. type: Block title
#: upstream/_guides/kafka.adoc:49 upstream/_guides/kafka.adoc:1719
#: upstream/_guides/kafka.adoc:1968 upstream/_guides/kafka.adoc:2036
#, fuzzy, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:55
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-smallrye-reactive-messaging-kafka</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/kafka.adoc:58 upstream/_guides/kafka.adoc:1728
#: upstream/_guides/kafka.adoc:1977 upstream/_guides/kafka.adoc:2046
#, fuzzy, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:61
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-smallrye-reactive-messaging-kafka\")\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:66
#, fuzzy
msgid "The extension includes `kafka-clients` version 3.2.1 as a transitive dependency and is compatible with Kafka brokers version 2.x."
msgstr "A extensão inclui `kafka-clients` versão 3.2.1 como uma dependência transitiva e é compatível com os corretores Kafka versão 2.x."

#. type: Title ==
#: upstream/_guides/kafka.adoc:68
#, fuzzy, no-wrap
msgid "Configuring Smallrye Kafka Connector"
msgstr "Configuração do conetor Kafka Smallrye"

#. type: Plain text
#: upstream/_guides/kafka.adoc:71
#, fuzzy
msgid "Because Smallrye Reactive Messaging framework supports different messaging backends like Apache Kafka, AMQP, Apache Camel, JMS, MQTT, etc., it employs a generic vocabulary:"
msgstr "Como a estrutura Smallrye Reactive Messaging suporta diferentes backends de mensagens, como Apache Kafka, AMQP, Apache Camel, JMS, MQTT, etc., utiliza um vocabulário genérico:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:73
#, fuzzy
msgid "Applications send and receive *messages*. A message wraps a _payload_ and can be extended with some _metadata_. With the Kafka connector, a _message_ corresponds to a Kafka _record_."
msgstr "As aplicações enviam e recebem *mensagens*. Uma mensagem envolve uma _carga útil_ e pode ser alargada com alguns _metadados_. Com o conetor Kafka, uma _mensagem_ corresponde a um _registo_ Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:74
#, fuzzy
msgid "Messages transit on *channels*. Application components connect to channels to publish and consume messages. The Kafka connector maps _channels_ to Kafka _topics_."
msgstr "As mensagens transitam nos *canais*. Os componentes da aplicação ligam-se aos canais para publicar e consumir mensagens. O conetor Kafka mapeia _canais_ para _tópicos_ Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:75
#, fuzzy
msgid "Channels are connected to message backends using *connectors*. Connectors are configured to map incoming messages to a specific channel (consumed by the application) and collect outgoing messages sent to a specific channel. Each connector is dedicated to a specific messaging technology. For example, the connector dealing with Kafka is named `smallrye-kafka`."
msgstr "Os canais são ligados a backends de mensagens através de *conectores*. Os conectores são configurados para mapear as mensagens de entrada para um canal específico (consumido pela aplicação) e recolher as mensagens de saída enviadas para um canal específico. Cada conetor é dedicado a uma tecnologia de mensagens específica. Por exemplo, o conetor que lida com o Kafka tem o nome de `smallrye-kafka`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:77
#, fuzzy
msgid "A minimal configuration for the Kafka connector with an incoming channel looks like the following:"
msgstr "Uma configuração mínima para o conetor Kafka com um canal de entrada tem o seguinte aspeto:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:82
#, no-wrap
msgid ""
"%prod.kafka.bootstrap.servers=kafka:9092 <1>\n"
"mp.messaging.incoming.prices.connector=smallrye-kafka <2>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:86
#, fuzzy
msgid "Configure the broker location for the production profile. You can configure it globally or per channel using `mp.messaging.incoming.$channel.bootstrap.servers` property.  In dev mode and when running tests, xref:kafka-dev-services[Dev Services for Kafka] automatically starts a Kafka broker.  When not provided this property defaults to `localhost:9092`."
msgstr "Configure a localização do corretor para o perfil de produção. Pode configurá-lo globalmente ou por canal utilizando a propriedade `mp.messaging.incoming.$channel.bootstrap.servers`. No modo de desenvolvimento e ao executar testes,  link:#kafka-dev-services[os Serviços de desenvolvimento para Kafka] iniciam automaticamente um corretor Kafka. Quando não é fornecida, esta propriedade é predefinida para `localhost:9092`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:87
#, fuzzy
msgid "Configure the connector to manage the prices channel. By default, the topic name is same as the channel name. You can configure the topic attribute to override it."
msgstr "Configure o conetor para gerir o canal de preços. Por predefinição, o nome do tópico é o mesmo que o nome do canal. Pode configurar o atributo de tópico para o substituir."

#. type: Plain text
#: upstream/_guides/kafka.adoc:89
#, fuzzy
msgid "The `%prod` prefix indicates that the property is only used when the application runs in prod mode (so not in dev or test). Refer to the xref:config-reference.adoc#profiles[Profile documentation] for further details."
msgstr "O prefixo `%prod` indica que a propriedade só é utilizada quando a aplicação é executada em modo de produção (portanto, não em desenvolvimento ou teste). Consulte a  link:config-reference.html#profiles[documentação do perfil] para obter mais detalhes."

#. type: Block title
#: upstream/_guides/kafka.adoc:91
#, fuzzy, no-wrap
msgid "Connector auto-attachment"
msgstr "Fixação automática do conetor"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:96
#, fuzzy
msgid "If you have a single connector on your classpath, you can omit the `connector` attribute configuration.  Quarkus automatically associates _orphan_ channels to the (unique) connector found on the classpath.  _Orphans_ channels are outgoing channels without a downstream consumer or incoming channels without an upstream producer."
msgstr "Se tiver um único conetor no seu classpath, pode omitir a configuração do atributo `connector`. O Quarkus associa automaticamente os canais _órfãos_ ao conetor (único) encontrado no classpath. Os canais _órfãos_ são canais de saída sem um consumidor a jusante ou canais de entrada sem um produtor a montante."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:98
#, fuzzy
msgid "This auto-attachment can be disabled using:"
msgstr "Esta ligação automática pode ser desactivada utilizando:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:102
#, no-wrap
msgid "quarkus.reactive-messaging.auto-connector-attachment=false\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:105
#, fuzzy, no-wrap
msgid "Receiving messages from Kafka"
msgstr "Receber mensagens do Kafka"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:108
#, fuzzy
msgid "Continuing from the previous minimal configuration, your Quarkus application can receive message payload directly:"
msgstr "Continuando com a configuração mínima anterior, a sua aplicação Quarkus pode receber diretamente a carga útil da mensagem:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:112 upstream/_guides/kafka.adoc:2592
#: upstream/_guides/kafka.adoc:2673
#, no-wrap
msgid "import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:114 upstream/_guides/kafka.adoc:737
#: upstream/_guides/kafka.adoc:1214 upstream/_guides/kafka.adoc:1257
#: upstream/_guides/kafka.adoc:1281 upstream/_guides/kafka.adoc:1319
#: upstream/_guides/kafka.adoc:1390 upstream/_guides/kafka.adoc:1413
#: upstream/_guides/kafka.adoc:1455 upstream/_guides/kafka.adoc:1625
#, no-wrap
msgid "import jakarta.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:117
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PriceConsumer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:122
#, no-wrap
msgid ""
"    @Incoming(\"prices\")\n"
"    public void consume(double price) {\n"
"        // process your price.\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:124 upstream/_guides/kafka.adoc:270
#: upstream/_guides/kafka.adoc:604 upstream/_guides/kafka.adoc:630
#: upstream/_guides/kafka.adoc:922 upstream/_guides/kafka.adoc:1272
#: upstream/_guides/kafka.adoc:1304 upstream/_guides/kafka.adoc:1342
#: upstream/_guides/kafka.adoc:1403 upstream/_guides/kafka.adoc:1431
#: upstream/_guides/kafka.adoc:1483 upstream/_guides/kafka.adoc:1586
#: upstream/_guides/kafka.adoc:1644 upstream/_guides/kafka.adoc:2031
#: upstream/_guides/kafka.adoc:2114 upstream/_guides/kafka.adoc:2580
#: upstream/_guides/kafka.adoc:2660 upstream/_guides/kafka.adoc:2693
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:127
#, fuzzy
msgid "There are several other ways your application can consume incoming messages:"
msgstr "Existem várias outras formas de a sua aplicação consumir mensagens recebidas:"

#. type: Block title
#: upstream/_guides/kafka.adoc:128
#, fuzzy, no-wrap
msgid "Message"
msgstr "Mensagem"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:140
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public CompletionStage<Void> consume(Message<Double> msg) {\n"
"    // access record metadata\n"
"    var metadata = msg.getMetadata(IncomingKafkaRecordMetadata.class).orElseThrow();\n"
"    // process the message payload.\n"
"    double price = msg.getPayload();\n"
"    // Acknowledge the incoming message (commit the offset)\n"
"    return msg.ack();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:144
#, fuzzy
msgid "The `Message` type lets the consuming method access the incoming message metadata and handle the acknowledgment manually.  We'll explore different acknowledgment strategies in xref:commit-strategies[Commit Strategies]."
msgstr "O tipo `Message` permite que o método de consumo aceda aos metadados da mensagem recebida e trate o aviso de receção manualmente. Exploraremos diferentes estratégias de confirmação em  link:#commit-strategies[Estratégias de] confirmação."

#. type: Plain text
#: upstream/_guides/kafka.adoc:146
#, fuzzy
msgid "If you want to access the Kafka record objects directly, use:"
msgstr "Se pretender aceder diretamente aos objectos de registo do Kafka, utilize:"

#. type: Block title
#: upstream/_guides/kafka.adoc:147
#, fuzzy, no-wrap
msgid "ConsumerRecord"
msgstr "Registo do consumidor"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:158
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public void consume(ConsumerRecord<String, Double> record) {\n"
"    String key = record.key(); // Can be `null` if the incoming record has no key\n"
"    String value = record.value(); // Can be `null` if the incoming record has no value\n"
"    String topic = record.topic();\n"
"    int partition = record.partition();\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:162
#, fuzzy
msgid "`ConsumerRecord` is provided by the underlying Kafka client and can be injected directly to the consumer method.  Another simpler approach consists in using `Record`:"
msgstr "`ConsumerRecord` é fornecido pelo cliente Kafka subjacente e pode ser injetado diretamente no método do consumidor. Outra abordagem mais simples consiste em utilizar `Record`:"

#. type: Block title
#: upstream/_guides/kafka.adoc:163
#, fuzzy, no-wrap
msgid "Record"
msgstr "Registo"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:171
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public void consume(Record<String, Double> record) {\n"
"    String key = record.key(); // Can be `null` if the incoming record has no key\n"
"    String value = record.value(); // Can be `null` if the incoming record has no value\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:174
#, fuzzy
msgid "`Record` is a simple wrapper around key and payload of the incoming Kafka record."
msgstr "`Record` é um invólucro simples em torno da chave e da carga útil do registo Kafka de entrada."

#. type: Block title
#: upstream/_guides/kafka.adoc:175
#, fuzzy, no-wrap
msgid "@Channel"
msgstr "@Canal"

#. type: Plain text
#: upstream/_guides/kafka.adoc:178
#, fuzzy
msgid "Alternatively, your application can inject a `Multi` in your bean and subscribe to its events as the following example:"
msgstr "Em alternativa, a sua aplicação pode injetar um `Multi` no seu bean e subscrever os seus eventos, como no exemplo seguinte:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:183
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:190
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
"import org.jboss.resteasy.reactive.RestStreamElementType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:193 upstream/_guides/kafka.adoc:1003
#: upstream/_guides/kafka.adoc:1048 upstream/_guides/kafka.adoc:1084
#, no-wrap
msgid ""
"@Path(\"/prices\")\n"
"public class PriceResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:197
#, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"prices\")\n"
"    Multi<Double> prices;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:205
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/prices\")\n"
"    @RestStreamElementType(MediaType.TEXT_PLAIN)\n"
"    public Multi<Double> stream() {\n"
"        return prices;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:209
#, fuzzy
msgid "This is a good example of how to integrate a Kafka consumer with another downstream, in this example exposing it as a Server-Sent Events endpoint."
msgstr "Este é um bom exemplo de como integrar um consumidor Kafka com outro a jusante, neste exemplo expondo-o como um ponto de extremidade de eventos enviados pelo servidor."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:215
#, fuzzy
msgid "When consuming messages with `@Channel`, the application code is responsible for the subscription.  In the example above, the RESTEasy Reactive endpoint handles that for you."
msgstr "Ao consumir mensagens com `@Channel`, o código do aplicativo é responsável pela assinatura. No exemplo acima, o ponto de extremidade RESTEasy Reactive trata disso para você."

#. type: Plain text
#: upstream/_guides/kafka.adoc:218
#, fuzzy
msgid "Following types can be injected as channels:"
msgstr "Os seguintes tipos podem ser injectados como canais:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:222
#, no-wrap
msgid "@Inject @Channel(\"prices\") Multi<Double> streamOfPayloads;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:224
#, no-wrap
msgid "@Inject @Channel(\"prices\") Multi<Message<Double>> streamOfMessages;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:226
#, no-wrap
msgid "@Inject @Channel(\"prices\") Publisher<Double> publisherOfPayloads;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:228
#, no-wrap
msgid "@Inject @Channel(\"prices\") Publisher<Message<Double>> publisherOfMessages;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:233
#, fuzzy
msgid "As with the previous `Message` example, if your injected channel receives payloads (`Multi<T>`), it acknowledges the message automatically, and support multiple subscribers.  If you injected channel receives Message (`Multi<Message<T>>`), you will be responsible for the acknowledgment and broadcasting.  We will explore sending broadcast messages in xref:broadcasting-messages-on-multiple-consumers[Broadcasting messages on multiple consumers]."
msgstr "Tal como no exemplo anterior de `Message`, se o seu canal injetado receber payloads ( `Multi&amp;lt;T&amp;gt;`), ele reconhece a mensagem automaticamente e suporta múltiplos subscritores. Se o seu canal injetado receber uma mensagem ( `Multi&amp;lt;Message&amp;lt;T&amp;gt;&amp;gt;`), será responsável pelo reconhecimento e pela difusão. Iremos explorar o envio de mensagens de difusão em  link:#broadcasting-messages-on-multiple-consumers[Difusão de mensagens em vários consumidores]."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:238
#, fuzzy
msgid "Injecting `@Channel(\"prices\")` or having `@Incoming(\"prices\")` does not automatically configure the application to consume messages from Kafka.  You need to configure an inbound connector with `mp.messaging.incoming.prices\\...` or have an `@Outgoing(\"prices\")` method somewhere in your application (in which case, `prices` will be an in-memory channel)."
msgstr "Injetar `@Channel(\"prices\")` ou ter `@Incoming(\"prices\")` não configura automaticamente a aplicação para consumir mensagens do Kafka. Tem de configurar um conetor de entrada com `mp.messaging.incoming.prices...` ou ter um método `@Outgoing(\"prices\")` algures na sua aplicação (neste caso, `prices` será um canal na memória)."

#. type: Title ===
#: upstream/_guides/kafka.adoc:241
#, fuzzy, no-wrap
msgid "Blocking processing"
msgstr "Bloqueio do processamento"

#. type: Plain text
#: upstream/_guides/kafka.adoc:247
#, fuzzy
msgid "Reactive Messaging invokes your method on an I/O thread.  See the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation] for further details on this topic.  But, you often need to combine Reactive Messaging with blocking processing such as database interactions.  For this, you need to use the `@Blocking` annotation indicating that the processing is _blocking_ and should not be run on the caller thread."
msgstr "O Reactive Messaging invoca seu método em uma thread de E/S. Consulte a  link:quarkus-reactive-architecture.html[documentação da Arquitetura Reactiva do Quarkus] para obter mais informações sobre este tópico. Mas, muitas vezes, é necessário combinar o envio de mensagens reactivas com o processamento de bloqueio, como as interacções com a base de dados. Para isso, é necessário utilizar a anotação `@Blocking` indicando que o processamento está a _bloquear_ e não deve ser executado na thread do chamador."

#. type: Plain text
#: upstream/_guides/kafka.adoc:249
#, fuzzy
msgid "For example, The following code illustrates how you can store incoming payloads to a database using Hibernate with Panache:"
msgstr "Por exemplo, o código a seguir ilustra como é possível armazenar cargas úteis recebidas em uma base de dados usando o Hibernate com Panache:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:254
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Blocking;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:257 upstream/_guides/kafka.adoc:2590
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import jakarta.transaction.Transactional;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:260
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PriceStorage {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:268
#, no-wrap
msgid ""
"    @Incoming(\"prices\")\n"
"    @Transactional\n"
"    public void store(int priceInUsd) {\n"
"        Price price = new Price();\n"
"        price.value = priceInUsd;\n"
"        price.persist();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:273
#, fuzzy
msgid "The complete example is available in the `kafka-panache-quickstart` link:{quickstarts-tree-url}/kafka-panache-quickstart[directory]."
msgstr "O exemplo completo está disponível no  link:{quickstarts-tree-url}/kafka-panache-quickstart[diretório] `kafka-panache-quickstart`."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:277
#, fuzzy
msgid "There are 2 `@Blocking` annotations:"
msgstr "Existem 2 anotações em `@Blocking`:"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:279
#, fuzzy
msgid "`io.smallrye.reactive.messaging.annotations.Blocking`"
msgstr "`io.smallrye.reactive.messaging.annotations.Blocking`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:280
#, fuzzy
msgid "`io.smallrye.common.annotation.Blocking`"
msgstr "`io.smallrye.common.annotation.Blocking`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:285
#, fuzzy
msgid "They have the same effect.  Thus, you can use both.  The first one provides more fine-grained tuning such as the worker pool to use and whether it preserves the order.  The second one, used also with other reactive features of Quarkus, uses the default worker pool and preserves the order."
msgstr "Têm o mesmo efeito. Portanto, você pode usar ambos. O primeiro fornece uma afinação mais fina, como o conjunto de trabalhadores a utilizar e se preserva a ordem. O segundo, utilizado também com outras funcionalidades reactivas do Quarkus, utiliza o grupo de trabalhadores predefinido e preserva a ordem."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:287
#, fuzzy
msgid "Detailed information on the usage of `@Blocking` annotation can be found in https://smallrye.io/smallrye-reactive-messaging/latest/concepts/blocking/[SmallRye Reactive Messaging – Handling blocking execution]."
msgstr "Informações detalhadas sobre a utilização da anotação `@Blocking` podem ser encontradas em  link:https://smallrye.io/smallrye-reactive-messaging/latest/concepts/blocking/[SmallRye Reactive Messaging - Handling blocking execution]."

#. type: Block title
#: upstream/_guides/kafka.adoc:290
#, fuzzy, no-wrap
msgid "@RunOnVirtualThread"
msgstr "@RunOnVirtualThread"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:293
#, fuzzy
msgid "For running the blocking processing on Java _virtual threads_, see the xref:messaging-virtual-threads.adoc[Quarkus Virtual Thread support with Reactive Messaging documentation]."
msgstr "Para executar o processamento de bloqueio em _threads virtuais_ Java, consulte a  link:messaging-virtual-threads.html[documentação do Quarkus Virtual Thread support with Reactive Messaging]."

#. type: Block title
#: upstream/_guides/kafka.adoc:296
#, fuzzy, no-wrap
msgid "@Transactional"
msgstr "@Transacional"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:299
#, fuzzy
msgid "If your method is annotated with `@Transactional`, it will be considered _blocking_ automatically, even if the method is not annotated with `@Blocking`."
msgstr "Se o seu método estiver anotado com `@Transactional`, será considerado _bloqueante_ automaticamente, mesmo que o método não esteja anotado com `@Blocking`."

#. type: Title ===
#: upstream/_guides/kafka.adoc:301
#, fuzzy, no-wrap
msgid "Acknowledgment Strategies"
msgstr "Estratégias de reconhecimento"

#. type: Plain text
#: upstream/_guides/kafka.adoc:309
#, fuzzy
msgid "All messages received by a consumer must be acknowledged.  In the absence of acknowledgment, the processing is considered in error.  If the consumer method receives a `Record` or a payload, the message will be acked on method return, also known as `Strategy.POST_PROCESSING`.  If the consumer method returns another reactive stream or `CompletionStage`, the message will be acked when the downstream message is acked.  You can override the default behavior to ack the message on arrival (`Strategy.PRE_PROCESSING`), or do not ack the message at all (`Strategy.NONE`) on the consumer method as in the following example:"
msgstr "Todas as mensagens recebidas por um consumidor devem ser confirmadas. Na ausência de confirmação, o processamento é considerado um erro. Se o método do consumidor receber um `Record` ou uma carga útil, a mensagem será acusada de receção no regresso do método, também conhecido por `Strategy.POST_PROCESSING`. Se o método do consumidor devolver outro fluxo reativo ou `CompletionStage`, a mensagem será devolvida quando a mensagem a jusante for devolvida. Pode substituir o comportamento predefinido para aceitar a mensagem à chegada ( `Strategy.PRE_PROCESSING`), ou não aceitar a mensagem de todo ( `Strategy.NONE`) no método do consumidor, como no exemplo seguinte:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:317
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"@Acknowledgment(Acknowledgment.Strategy.PRE_PROCESSING)\n"
"public void process(double price) {\n"
"    // process price\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:321
#, fuzzy
msgid "If the consumer method receives a `Message`, the acknowledgment strategy is `Strategy.MANUAL` and the consumer method is in charge of ack/nack the message."
msgstr "Se o método do consumidor receber uma mensagem `Message`, a estratégia de confirmação é `Strategy.MANUAL` e o método do consumidor é responsável por aceitar ou recusar a mensagem."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:329
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public CompletionStage<Void> process(Message<Double> msg) {\n"
"    // process price\n"
"    return msg.ack();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:332
#, fuzzy
msgid "As mentioned above, the method can also override the acknowledgment strategy to `PRE_PROCESSING` or `NONE`."
msgstr "Como mencionado acima, o método também pode substituir a estratégia de confirmação por `PRE_PROCESSING` ou `NONE`."

#. type: Title ===
#: upstream/_guides/kafka.adoc:334
#, fuzzy, no-wrap
msgid "Commit Strategies"
msgstr "Estratégias de compromisso"

#. type: Plain text
#: upstream/_guides/kafka.adoc:340
#, fuzzy
msgid "When a message produced from a Kafka record is acknowledged, the connector invokes a commit strategy.  These strategies decide when the consumer offset for a specific topic/partition is committed.  Committing an offset indicates that all previous records have been processed.  It is also the position where the application would restart the processing after a crash recovery or a restart."
msgstr "Quando uma mensagem produzida a partir de um registo Kafka é confirmada, o conetor invoca uma estratégia de confirmação. Estas estratégias decidem quando o desvio do consumidor para um tópico/partição específico é confirmado. A confirmação de um desvio indica que todos os registos anteriores foram processados. É também a posição em que a aplicação reiniciaria o processamento após uma recuperação de falha ou um reinício."

#. type: Plain text
#: upstream/_guides/kafka.adoc:343
#, fuzzy
msgid "Committing every offset has performance penalties as Kafka offset management can be slow.  However, not committing the offset often enough may lead to message duplication if the application crashes between two commits."
msgstr "A confirmação de cada desvio tem penalizações de desempenho, uma vez que a gestão de desvios do Kafka pode ser lenta. No entanto, o facto de não confirmar o desvio com frequência suficiente pode levar à duplicação de mensagens se a aplicação falhar entre duas confirmações."

#. type: Plain text
#: upstream/_guides/kafka.adoc:345
#, fuzzy
msgid "The Kafka connector supports three strategies:"
msgstr "O conetor Kafka suporta três estratégias:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:354
#, fuzzy
msgid "`throttled` keeps track of received messages and commits an offset of the latest acked message in sequence (meaning, all previous messages were also acked).  This strategy guarantees at-least-once delivery even if the channel performs asynchronous processing.  The connector tracks the received records and periodically (period specified by `auto.commit.interval.ms`, default: 5000 ms) commits the highest consecutive offset.  The connector will be marked as unhealthy if a message associated with a record is not acknowledged in `throttled.unprocessed-record-max-age.ms` (default: 60000 ms).  Indeed, this strategy cannot commit the offset as soon as a single record processing fails.  If `throttled.unprocessed-record-max-age.ms` is set to less than or equal to `0`, it does not perform any health check verification.  Such a setting might lead to running out of memory if there are \"poison pill\" messages (that are never acked).  This strategy is the default if `enable.auto.commit` is not explicitly set to true."
msgstr "`throttled` mantém o registo das mensagens recebidas e envia um offset da última mensagem recebida em sequência (ou seja, todas as mensagens anteriores também foram recebidas). Esta estratégia garante a entrega pelo menos uma vez, mesmo que o canal efectue um processamento assíncrono. O conetor controla os registos recebidos e, periodicamente (período especificado por `auto.commit.interval.ms`, predefinição: 5000 ms), confirma o desvio consecutivo mais elevado. O conetor será marcado como não saudável se uma mensagem associada a um registo não for confirmada em `throttled.unprocessed-record-max-age.ms` (predefinição: 60000 ms). De facto, esta estratégia não pode confirmar o desvio logo que o processamento de um único registo falhe. Se `throttled.unprocessed-record-max-age.ms` estiver definido como inferior ou igual a `0`, não efectua qualquer verificação do estado de saúde. Esta definição pode levar a um esgotamento da memória se houver mensagens \"poison pill\" (que nunca são aceites). Esta estratégia é a predefinição se `enable.auto.commit` não estiver explicitamente definido como verdadeiro."

#. type: Plain text
#: upstream/_guides/kafka.adoc:362
#, fuzzy
msgid "`checkpoint` allows persisting consumer offsets on a **state store**, instead of committing them back to the Kafka broker.  Using the `CheckpointMetadata` API, consumer code can persist a _processing state_ with the record offset to mark the progress of a consumer.  When the processing continues from a previously persisted offset, it seeks the Kafka consumer to that offset and also restores the persisted state, continuing the stateful processing from where it left off.  The checkpoint strategy holds locally the processing state associated with the latest offset, and persists it periodically to the state store (period specified by `auto.commit.interval.ms` (default: 5000)).  The connector will be marked as unhealthy if no processing state is persisted to the state store in `checkpoint.unsynced-state-max-age.ms` (default: 10000).  If `checkpoint.unsynced-state-max-age.ms` is set to less than or equal to 0, it does not perform any health check verification.  For more information, see xref:stateful-processing-checkpointing[Stateful processing with Checkpointing]"
msgstr "`checkpoint` permite persistir os desvios do consumidor num *armazenamento de estado*, em vez de os enviar de volta para o corretor Kafka. Utilizando a API `CheckpointMetadata`, o código do consumidor pode persistir um _estado de processamento_ com o desvio de registo para marcar o progresso de um consumidor. Quando o processamento continua a partir de um offset previamente persistido, procura o consumidor Kafka para esse offset e também restaura o estado persistido, continuando o processamento com estado a partir de onde parou. A estratégia de ponto de controlo mantém localmente o estado de processamento associado ao desvio mais recente e persiste-o periodicamente no armazenamento de estados (período especificado por `auto.commit.interval.ms` (predefinição: 5000)). O conetor será marcado como não saudável se nenhum estado de processamento for persistido no armazenamento de estado em `checkpoint.unsynced-state-max-age.ms` (padrão: 10000). Se `checkpoint.unsynced-state-max-age.ms` for definido como menor ou igual a 0, ele não executará nenhuma verificação de integridade. Para obter mais informações, consulte  link:#stateful-processing-checkpointing[Processamento com estado com Checkpointing]"

#. type: Plain text
#: upstream/_guides/kafka.adoc:366
#, fuzzy
msgid "`latest` commits the record offset received by the Kafka consumer as soon as the associated message is acknowledged (if the offset is higher than the previously committed offset).  This strategy provides at-least-once delivery if the channel processes the message without performing any asynchronous processing.  This strategy should not be used in high load environment, as offset commit is expensive. However, it reduces the risk of duplicates."
msgstr "`latest` confirma o desvio do registo recebido pelo consumidor Kafka assim que a mensagem associada é confirmada (se o desvio for superior ao desvio anteriormente confirmado). Esta estratégia proporciona uma entrega pelo menos uma vez se o canal processar a mensagem sem efetuar qualquer processamento assíncrono. Esta estratégia não deve ser utilizada em ambientes de carga elevada, uma vez que a confirmação do desvio é dispendiosa. No entanto, reduz o risco de duplicados."

#. type: Plain text
#: upstream/_guides/kafka.adoc:372
#, fuzzy
msgid "`ignore` performs no commit. This strategy is the default strategy when the consumer is explicitly configured with `enable.auto.commit` to true.  It delegates the offset commit to the underlying Kafka client.  When `enable.auto.commit` is `true` this strategy **DOES NOT** guarantee at-least-once delivery.  SmallRye Reactive Messaging processes records asynchronously, so offsets may be committed for records that have been polled but not yet processed.  In case of a failure, only records that were not committed yet will be re-processed."
msgstr "`ignore` não efectua qualquer confirmação. Esta estratégia é a estratégia predefinida quando o consumidor está explicitamente configurado com `enable.auto.commit` para true. Delega a confirmação do desvio ao cliente Kafka subjacente. Quando `enable.auto.commit` é `true`, esta estratégia *NÃO* garante a entrega pelo menos uma vez. O SmallRye Reactive Messaging processa os registos de forma assíncrona, pelo que os offsets podem ser confirmados para registos que tenham sido sondados mas ainda não processados. Em caso de falha, apenas os registos que ainda não foram confirmados serão processados novamente."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:377
#, fuzzy
msgid "The Kafka connector disables the Kafka auto commit when it is not explicitly enabled. This behavior differs from the traditional Kafka consumer.  If high throughput is important for you, and you are not limited by the downstream, we recommend to either:"
msgstr "O conetor Kafka desactiva a confirmação automática do Kafka quando não está explicitamente activada. Esse comportamento difere do consumidor tradicional do Kafka. Se a alta taxa de transferência for importante para você e você não estiver limitado pelo downstream, recomendamos:"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:379
#, fuzzy
msgid "use the `throttled` policy,"
msgstr "utilizar a política `throttled`,"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:380
#, fuzzy
msgid "or set `enable.auto.commit` to true and annotate the consuming method with `@Acknowledgment(Acknowledgment.Strategy.NONE)`."
msgstr "ou definir `enable.auto.commit` como verdadeiro e anotar o método de consumo com `@Acknowledgment(Acknowledgment.Strategy.NONE)`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:384
#, fuzzy
msgid "Smallrye Reactive Messaging enables implementing custom commit strategies.  See https://smallrye.io/smallrye-reactive-messaging/latest/kafka/receiving-kafka-records/#acknowledgement[SmallRye Reactive Messaging documentation] for more information."
msgstr "O Smallrye Reactive Messaging permite a implementação de estratégias de commit personalizadas. Veja  link:https://smallrye.io/smallrye-reactive-messaging/latest/kafka/receiving-kafka-records/#acknowledgement[a documentação do SmallRye Reactive Messaging] para mais informações."

#. type: Title ===
#: upstream/_guides/kafka.adoc:386
#, fuzzy, no-wrap
msgid "Error Handling Strategies"
msgstr "Estratégias de tratamento de erros"

#. type: Plain text
#: upstream/_guides/kafka.adoc:389
#, fuzzy
msgid "If a message produced from a Kafka record is nacked, a failure strategy is applied. The Kafka connector supports three strategies:"
msgstr "Se uma mensagem produzida a partir de um registo Kafka não for enviada, é aplicada uma estratégia de falha. O conetor Kafka suporta três estratégias:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:391
#, fuzzy
msgid "`fail`: fail the application, no more records will be processed (default strategy). The offset of the record that has not been processed correctly is not committed."
msgstr "`fail`Falha na aplicação, não serão processados mais registos (estratégia predefinida). O desvio do registo que não foi processado corretamente não é confirmado."

#. type: Plain text
#: upstream/_guides/kafka.adoc:392
#, fuzzy
msgid "`ignore`: the failure is logged, but the processing continue. The offset of the record that has not been processed correctly is committed."
msgstr "`ignore`: a falha é registada, mas o processamento continua. O desvio do registo que não foi processado corretamente é confirmado."

#. type: Plain text
#: upstream/_guides/kafka.adoc:393
#, fuzzy
msgid "`dead-letter-queue`: the offset of the record that has not been processed correctly is committed, but the record is written to a Kafka dead letter topic."
msgstr "`dead-letter-queue`O offset do registo que não foi processado corretamente é confirmado, mas o registo é escrito num tópico de letra morta do Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:395
#, fuzzy
msgid "The strategy is selected using the `failure-strategy` attribute."
msgstr "A estratégia é selecionada utilizando o atributo `failure-strategy`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:397
#, fuzzy
msgid "In the case of `dead-letter-queue`, you can configure the following attributes:"
msgstr "No caso do `dead-letter-queue`, pode configurar os seguintes atributos:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:399
#, fuzzy
msgid "`dead-letter-queue.topic`: the topic to use to write the records not processed correctly, default is `dead-letter-topic-$channel`, with `$channel` being the name of the channel."
msgstr "`dead-letter-queue.topic`Tópico: o tópico a utilizar para escrever os registos não processados corretamente. A predefinição é `dead-letter-topic-$channel`, sendo `$channel` o nome do canal."

#. type: Plain text
#: upstream/_guides/kafka.adoc:400
#, fuzzy
msgid "`dead-letter-queue.key.serializer`: the serializer used to write the record key on the dead letter queue. By default, it deduces the serializer from the key deserializer."
msgstr "`dead-letter-queue.key.serializer`serializador utilizado para escrever a chave de registo na fila de letra morta. Por defeito, deduz o serializador a partir do desserializador da chave."

#. type: Plain text
#: upstream/_guides/kafka.adoc:401
#, fuzzy
msgid "`dead-letter-queue.value.serializer`: the serializer used to write the record value on the dead letter queue. By default, it deduces the serializer from the value deserializer."
msgstr "`dead-letter-queue.value.serializer`serializador utilizado para escrever o valor do registo na fila de letras mortas. Por defeito, deduz o serializador a partir do desserializador do valor."

#. type: Plain text
#: upstream/_guides/kafka.adoc:403
#, fuzzy
msgid "The record written on the dead letter queue contains a set of additional headers about the original record:"
msgstr "O registo escrito na fila de cartas mortas contém um conjunto de cabeçalhos adicionais sobre o registo original:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:405
#, fuzzy, no-wrap
msgid "*dead-letter-reason*: the reason of the failure\n"
msgstr "*dead-letter-reason*: a razão do insucesso"

#. type: Plain text
#: upstream/_guides/kafka.adoc:406
#, fuzzy, no-wrap
msgid "*dead-letter-cause*: the cause of the failure if any\n"
msgstr "*dead-letter-cause*: a causa da falha, caso exista"

#. type: Plain text
#: upstream/_guides/kafka.adoc:407
#, fuzzy, no-wrap
msgid "*dead-letter-topic*: the original topic of the record\n"
msgstr "*dead-letter-topic*: o tópico original do registo"

#. type: Plain text
#: upstream/_guides/kafka.adoc:408
#, fuzzy, no-wrap
msgid "*dead-letter-partition*: the original partition of the record (integer mapped to String)\n"
msgstr "*dead-letter-partition*: a partição original do registo (número inteiro mapeado para String)"

#. type: Plain text
#: upstream/_guides/kafka.adoc:409
#, fuzzy, no-wrap
msgid "*dead-letter-offset*: the original offset of the record (long mapped to String)\n"
msgstr "*dead-letter-offset*: o offset original do registo (long mapped to String)"

#. type: Plain text
#: upstream/_guides/kafka.adoc:412
#, fuzzy
msgid "Smallrye Reactive Messaging enables implementing custom failure strategies.  See https://smallrye.io/smallrye-reactive-messaging/latest/kafka/receiving-kafka-records/#acknowledgement[SmallRye Reactive Messaging documentation] for more information."
msgstr "O Smallrye Reactive Messaging permite implementar estratégias de falha personalizadas. Consulte  link:https://smallrye.io/smallrye-reactive-messaging/latest/kafka/receiving-kafka-records/#acknowledgement[a documentação do SmallRye Reactive Messaging] para obter mais informações."

#. type: Title ====
#: upstream/_guides/kafka.adoc:413
#, fuzzy, no-wrap
msgid "Retrying processing"
msgstr "Repetição do processamento"

#. type: Plain text
#: upstream/_guides/kafka.adoc:416
#, fuzzy
msgid "You can combine Reactive Messaging with https://github.com/smallrye/smallrye-fault-tolerance[SmallRye Fault Tolerance], and retry processing if it failed:"
msgstr "É possível combinar o Reactive Messaging com o  link:https://github.com/smallrye/smallrye-fault-tolerance[SmallRye Fault Tolerance] e tentar novamente o processamento em caso de falha:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:424
#, no-wrap
msgid ""
"@Incoming(\"kafka\")\n"
"@Retry(delay = 10, maxRetries = 5)\n"
"public void consume(String v) {\n"
"   // ... retry if this method throws an exception\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:427
#, fuzzy
msgid "You can configure the delay, the number of retries, the jitter, etc."
msgstr "Pode configurar o atraso, o número de tentativas, o jitter, etc."

#. type: Plain text
#: upstream/_guides/kafka.adoc:429
#, fuzzy
msgid "If your method returns a `Uni` or `CompletionStage`, you need to add the `@NonBlocking` annotation:"
msgstr "Se o método devolver um `Uni` ou `CompletionStage`, é necessário acrescentar a anotação `@NonBlocking`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:438
#, no-wrap
msgid ""
"@Incoming(\"kafka\")\n"
"@Retry(delay = 10, maxRetries = 5)\n"
"@NonBlocking\n"
"public Uni<String> consume(String v) {\n"
"   // ... retry if this method throws an exception or the returned Uni produce a failure\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:443
#, fuzzy
msgid "The `@NonBlocking` annotation is only required with SmallRye Fault Tolerance 5.1.0 and earlier.  Starting with SmallRye Fault Tolerance 5.2.0 (available since Quarkus 2.1.0.Final), it is not necessary.  See https://smallrye.io/docs/smallrye-fault-tolerance/5.2.0/usage/extra.html#_non_compatible_mode[SmallRye Fault Tolerance documentation] for more information."
msgstr "A anotação `@NonBlocking` só é necessária com o SmallRye Fault Tolerance 5.1.0 e versões anteriores. A partir do SmallRye Fault Tolerance 5.2.0 (disponível desde o Quarkus 2.1.0.Final), ela não é necessária. Consulte  link:https://smallrye.io/docs/smallrye-fault-tolerance/5.2.0/usage/extra.html#_non_compatible_mode[a documentação do SmallRye Fault Tolerance] para obter mais informações."

#. type: Plain text
#: upstream/_guides/kafka.adoc:447
#, fuzzy
msgid "The incoming messages are acknowledged only once the processing completes successfully.  So, it commits the offset after the successful processing.  If the processing still fails, even after all retries, the message is _nacked_ and the failure strategy is applied."
msgstr "As mensagens recebidas só são reconhecidas quando o processamento é concluído com êxito. Assim, o offset é confirmado após o processamento bem sucedido. Se o processamento continuar a falhar, mesmo depois de todas as tentativas, a mensagem é _anulada_ e é aplicada a estratégia de falha."

#. type: Title ====
#: upstream/_guides/kafka.adoc:448
#, fuzzy, no-wrap
msgid "Handling Deserialization Failures"
msgstr "Tratamento de falhas de desserialização"

#. type: Plain text
#: upstream/_guides/kafka.adoc:452
#, fuzzy
msgid "When a deserialization failure occurs, you can intercept it and provide a failure strategy.  To achieve this, you need to create a bean implementing `DeserializationFailureHandler<T>` interface:"
msgstr "Quando ocorre uma falha na desserialização, é possível interceptá-la e fornecer uma estratégia de falha. Para tal, é necessário criar um bean que implemente a interface `DeserializationFailureHandler&amp;lt;T&amp;gt;`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:459
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"@Identifier(\"failure-retry\") // Set the name of the failure handler\n"
"public class MyDeserializationFailureHandler\n"
"    implements DeserializationFailureHandler<JsonObject> { // Specify the expected type\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:468
#, no-wrap
msgid ""
"    @Override\n"
"    public JsonObject decorateDeserialization(Uni<JsonObject> deserialization, String topic, boolean isKey,\n"
"            String deserializer, byte[] data, Headers headers) {\n"
"        return deserialization\n"
"                    .onFailure().retry().atMost(3)\n"
"                    .await().atMost(Duration.ofMillis(200));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:471
#, fuzzy
msgid "To use this failure handler, the bean must be exposed with the `@Identifier` qualifier and the connector configuration must specify the attribute `mp.messaging.incoming.$channel.[key|value]-deserialization-failure-handler` (for key or value deserializers)."
msgstr "Para utilizar este manipulador de falhas, o bean deve ser exposto com o qualificador `@Identifier` e a configuração do conetor deve especificar o atributo `mp.messaging.incoming.$channel.[key|value]-deserialization-failure-handler` (para desserializadores de chave ou de valor)."

#. type: Plain text
#: upstream/_guides/kafka.adoc:474
#, fuzzy
msgid "The handler is called with details of the deserialization, including the action represented as `Uni<T>`.  On the deserialization `Uni` failure strategies like retry, providing a fallback value or applying timeout can be implemented."
msgstr "O manipulador é chamado com pormenores da desserialização, incluindo a ação representada em `Uni&amp;lt;T&amp;gt;`. Na desserialização `Uni` podem ser implementadas estratégias de falha como tentar de novo, fornecer um valor de recurso ou aplicar um tempo limite."

#. type: Title ===
#: upstream/_guides/kafka.adoc:475
#, fuzzy, no-wrap
msgid "Consumer Groups"
msgstr "Grupos de consumidores"

#. type: Plain text
#: upstream/_guides/kafka.adoc:482
#, fuzzy
msgid "In Kafka, a consumer group is a set of consumers which cooperate to consume data from a topic.  A topic is divided into a set of partitions.  The partitions of a topic are assigned among the consumers in the group, effectively allowing to scale consumption throughput.  Note that each partition is assigned to a single consumer from a group.  However, a consumer can be assigned multiple partitions if the number of partitions is greater than the number of consumer in the group."
msgstr "No Kafka, um grupo de consumidores é um conjunto de consumidores que cooperam para consumir dados de um tópico. Um tópico é dividido num conjunto de partições. As partições de um tópico são atribuídas entre os consumidores do grupo, permitindo efetivamente escalar o débito de consumo. Note-se que cada partição é atribuída a um único consumidor de um grupo. No entanto, a um consumidor podem ser atribuídas várias partições se o número de partições for superior ao número de consumidores do grupo."

#. type: Plain text
#: upstream/_guides/kafka.adoc:484
#, fuzzy
msgid "Let's explore briefly different producer/consumer patterns and how to implement them using Quarkus:"
msgstr "Vamos explorar brevemente diferentes padrões de produtor/consumidor e como implementá-los usando o Quarkus:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:486
#, fuzzy, no-wrap
msgid "*Single consumer thread inside a consumer group*\n"
msgstr "*Um único thread de consumidor dentro de um grupo de consumidores*"

#. type: Plain text
#: upstream/_guides/kafka.adoc:490
#, fuzzy
msgid "This is the default behavior of an application subscribing to a Kafka topic: Each Kafka connector will create a single consumer thread and place it inside a single consumer group.  Consumer group id defaults to the application name as set by the `quarkus.application.name` configuration property.  It can also be set using the `kafka.group.id` property."
msgstr "Este é o comportamento predefinido de uma aplicação que subscreve um tópico do Kafka: Cada conetor Kafka criará um único thread de consumidor e o colocará dentro de um único grupo de consumidores. O ID do grupo de consumidores tem como padrão o nome do aplicativo, conforme definido pela propriedade de configuração `quarkus.application.name`. Também pode ser definido usando a propriedade `kafka.group.id`."

#. type: Named 'alt' AttributeList argument for macro 'image'
#: upstream/_guides/kafka.adoc:491 upstream/_guides/kafka.adoc:499
#: upstream/_guides/kafka.adoc:506 upstream/_guides/kafka.adoc:514
#, fuzzy, no-wrap
msgid "Architecture,"
msgstr "Arquitetura,"

#. type: Target for macro image
#: upstream/_guides/kafka.adoc:491
#, no-wrap
msgid "kafka-one-app-one-consumer.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:494
#, fuzzy, no-wrap
msgid "*Multiple consumer threads inside a consumer group*\n"
msgstr "*Múltiplos threads de consumidores dentro de um grupo de consumidores*"

#. type: Plain text
#: upstream/_guides/kafka.adoc:498
#, fuzzy
msgid "For a given application instance, the number of consumers inside the consumer group can be configured using `mp.messaging.incoming.$channel.partitions` property.  The partitions of the subscribed topic will be divided among the consumer threads.  Note that if the `partitions` value exceed the number of partitions of the topic, some consumer threads won't be assigned any partitions."
msgstr "Para uma determinada instância de aplicação, o número de consumidores dentro do grupo de consumidores pode ser configurado usando a propriedade `mp.messaging.incoming.$channel.partitions`. As partições do tópico subscrito serão divididas entre os threads de consumidores. Observe que, se o valor de `partitions` exceder o número de partições do tópico, algumas threads de consumidores não receberão nenhuma partição."

#. type: Target for macro image
#: upstream/_guides/kafka.adoc:499
#, no-wrap
msgid "kafka-one-app-two-consumers.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:502
#, fuzzy, no-wrap
msgid "*Multiple consumer applications inside a consumer group*\n"
msgstr "*Múltiplas aplicações de consumo dentro de um grupo de consumidores*"

#. type: Plain text
#: upstream/_guides/kafka.adoc:505
#, fuzzy
msgid "Similar to the previous example, multiple instances of an application can subscribe to a single consumer group, configured via `mp.messaging.incoming.$channel.group.id` property, or left default to the application name.  This in turn will divide partitions of the topic among application instances."
msgstr "Semelhante ao exemplo anterior, várias instâncias de um aplicativo podem se inscrever em um único grupo de consumidores, configurado por meio da propriedade `mp.messaging.incoming.$channel.group.id` ou deixado como padrão para o nome do aplicativo. Isso, por sua vez, dividirá as partições do tópico entre as instâncias da aplicação."

#. type: Target for macro image
#: upstream/_guides/kafka.adoc:506
#, no-wrap
msgid "kafka-two-app-one-consumer-group.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:509
#, fuzzy, no-wrap
msgid "*Pub/Sub: Multiple consumer groups subscribed to a topic*\n"
msgstr "*Pub/Sub: Vários grupos de consumidores subscreveram um tópico*"

#. type: Plain text
#: upstream/_guides/kafka.adoc:513
#, fuzzy
msgid "Lastly different applications can subscribe independently to same topics using different *consumer group ids*.  For example, messages published to a topic called _orders_ can be consumed independently on two consumer applications, one with `mp.messaging.incoming.orders.group.id=invoicing` and second with `mp.messaging.incoming.orders.group.id=shipping`.  Different consumer groups can thus scale independently according to the message consumption requirements."
msgstr "Por último, diferentes aplicações podem subscrever independentemente os mesmos tópicos utilizando diferentes *ids de grupos de consumidores*. Por exemplo, as mensagens publicadas num tópico chamado _encomendas_ podem ser consumidas independentemente em duas aplicações de consumo, uma com `mp.messaging.incoming.orders.group.id=invoicing` e a outra com `mp.messaging.incoming.orders.group.id=shipping`. Diferentes grupos de consumidores podem assim escalar independentemente de acordo com os requisitos de consumo de mensagens."

#. type: Target for macro image
#: upstream/_guides/kafka.adoc:514
#, no-wrap
msgid "kafka-two-app-two-consumer-groups.png"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:522
#, fuzzy
msgid "A common business requirement is to consume and process Kafka records in order.  The Kafka broker preserves order of records inside a partition and not inside a topic.  Therefore, it is important to think about how records are partitioned inside a topic.  The default partitioner uses record key hash to compute the partition for a record, or when the key is not defined, chooses a partition randomly per batch or records."
msgstr "Um requisito comercial comum é consumir e processar registos Kafka por ordem. O corretor Kafka preserva a ordem dos registos dentro de uma partição e não dentro de um tópico. Por isso, é importante pensar na forma como os registos são particionados dentro de um tópico. O particionador predefinido utiliza o hash da chave do registo para calcular a partição de um registo ou, quando a chave não está definida, escolhe uma partição aleatoriamente por lote ou registos."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:525
#, fuzzy
msgid "During normal operation, a Kafka consumer preserves the order of records inside each partition assigned to it.  Smallrye Reactive Messaging keeps this order for processing, unless `@Blocking(ordered = false)` is used (see xref:blocking-processing[Blocking processing])."
msgstr "Durante a operação normal, um consumidor Kafka preserva a ordem dos registros dentro de cada partição atribuída a ele. O Smallrye Reactive Messaging mantém essa ordem para processamento, a menos que `@Blocking(ordered = false)` seja usado (consulte  link:#blocking-processing[Bloqueio de processamento])."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:527
#, fuzzy
msgid "Note that due to consumer rebalances, Kafka consumers only guarantee at-least-once processing of single records, meaning that uncommitted records _can_ be processed again by consumers."
msgstr "Note-se que, devido aos reequilíbrios dos consumidores, os consumidores Kafka apenas garantem o processamento pelo menos uma vez de registos individuais, o que significa que os registos não confirmados _podem_ ser processados novamente pelos consumidores."

#. type: Title ====
#: upstream/_guides/kafka.adoc:529
#, fuzzy, no-wrap
msgid "Consumer Rebalance Listener"
msgstr "Ouvinte de reequilíbrio do consumidor"

#. type: Plain text
#: upstream/_guides/kafka.adoc:536
#, fuzzy
msgid "Inside a consumer group, as new group members arrive and old members leave, the partitions are re-assigned so that each member receives a proportional share of the partitions.  This is known as rebalancing the group.  To handle offset commit and assigned partitions yourself, you can provide a consumer rebalance listener.  To achieve this, implement the `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` interface and expose it as a CDI bean with the `@Idenfier` qualifier.  A common use case is to store offset in a separate data store to implement exactly-once semantic, or starting the processing at a specific offset."
msgstr "Dentro de um grupo de consumidores, à medida que novos membros do grupo chegam e membros antigos saem, as partições são reatribuídas para que cada membro receba uma parte proporcional das partições. Isso é conhecido como rebalanceamento do grupo. Para lidar com o commit de offset e as partições atribuídas, pode fornecer um ouvinte de rebalanceamento do consumidor. Para isso, implemente a interface `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` e exponha-a como um bean CDI com o qualificador `@Idenfier`. Um caso de utilização comum é armazenar a deslocação num armazenamento de dados separado para implementar a semântica exactly-once ou iniciar o processamento numa deslocação específica."

#. type: Plain text
#: upstream/_guides/kafka.adoc:540
#, fuzzy
msgid "The listener is invoked every time the consumer topic/partition assignment changes.  For example, when the application starts, it invokes the `partitionsAssigned` callback with the initial set of topics/partitions associated with the consumer.  If, later, this set changes, it calls the `partitionsRevoked` and `partitionsAssigned` callbacks again, so you can implement custom logic."
msgstr "O ouvinte é invocado sempre que a atribuição de tópico/partição do consumidor é alterada. Por exemplo, quando a aplicação é iniciada, invoca a chamada de retorno `partitionsAssigned` com o conjunto inicial de tópicos/partições associados ao consumidor. Se, mais tarde, este conjunto for alterado, chama novamente as chamadas de retorno `partitionsRevoked` e `partitionsAssigned`, para que possa implementar uma lógica personalizada."

#. type: Plain text
#: upstream/_guides/kafka.adoc:543
#, fuzzy
msgid "Note that the rebalance listener methods are called from the Kafka polling thread and **will** block the caller thread until completion.  That’s because the rebalance protocol has synchronization barriers, and using asynchronous code in a rebalance listener may be executed after the synchronization barrier."
msgstr "Observe que os métodos do ouvinte de rebalanceamento são chamados a partir da thread de sondagem do Kafka e *bloquearão* a thread do chamador até a conclusão. Isso ocorre porque o protocolo de rebalanceamento tem barreiras de sincronização, e o uso de código assíncrono em um ouvinte de rebalanceamento pode ser executado após a barreira de sincronização."

#. type: Plain text
#: upstream/_guides/kafka.adoc:545
#, fuzzy
msgid "When topics/partitions are assigned or revoked from a consumer, it pauses the message delivery and resumes once the rebalance completes."
msgstr "Quando os tópicos/partições são atribuídos ou revogados por um consumidor, o envio de mensagens é interrompido e retomado após a conclusão do reequilíbrio."

#. type: Plain text
#: upstream/_guides/kafka.adoc:549
#, fuzzy
msgid "If the rebalance listener handles offset commit on behalf of the user (using the `NONE` commit strategy), the rebalance listener must commit the offset synchronously in the partitionsRevoked callback.  We also recommend applying the same logic when the application stops."
msgstr "Se o ouvinte de rebalanceamento lidar com o commit de offset em nome do usuário (usando a estratégia de commit `NONE` ), o ouvinte de rebalanceamento deve confirmar o offset de forma síncrona na chamada de retorno partitionsRevoked. Também recomendamos aplicar a mesma lógica quando a aplicação pára."

#. type: Plain text
#: upstream/_guides/kafka.adoc:551
#, fuzzy
msgid "Unlike the `ConsumerRebalanceListener` from Apache Kafka, the `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` methods pass the Kafka Consumer and the set of topics/partitions."
msgstr "Ao contrário dos métodos `ConsumerRebalanceListener` do Apache Kafka, os métodos `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` transmitem o consumidor Kafka e o conjunto de tópicos/partições."

#. type: Plain text
#: upstream/_guides/kafka.adoc:555
#, fuzzy
msgid "In the following example we set up a consumer that always starts on messages from at most 10 minutes ago (or offset 0).  First we need to provide a bean that implements `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` and is annotated with `io.smallrye.common.annotation.Identifier`.  We then must configure our inbound connector to use this bean."
msgstr "No exemplo seguinte, configuramos um consumidor que começa sempre com mensagens de, no máximo, 10 minutos atrás (ou offset 0). Primeiro, precisamos de fornecer um bean que implemente `io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener` e seja anotado com `io.smallrye.common.annotation.Identifier`. De seguida, temos de configurar o nosso conetor de entrada para utilizar este bean."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:559 upstream/_guides/kafka.adoc:609
#, no-wrap
msgid "package inbound;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:565
#, no-wrap
msgid ""
"import io.smallrye.common.annotation.Identifier;\n"
"import io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener;\n"
"import org.apache.kafka.clients.consumer.Consumer;\n"
"import org.apache.kafka.clients.consumer.OffsetAndTimestamp;\n"
"import org.apache.kafka.clients.consumer.TopicPartition;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:571
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import java.util.Collection;\n"
"import java.util.HashMap;\n"
"import java.util.Map;\n"
"import java.util.logging.Logger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:575
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"@Identifier(\"rebalanced-example.rebalancer\")\n"
"public class KafkaRebalancedConsumerRebalanceListener implements KafkaConsumerRebalanceListener {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:577
#, no-wrap
msgid "    private static final Logger LOGGER = Logger.getLogger(KafkaRebalancedConsumerRebalanceListener.class.getName());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:589
#, no-wrap
msgid ""
"    /**\n"
"     * When receiving a list of partitions, will search for the earliest offset within 10 minutes\n"
"     * and seek the consumer to it.\n"
"     *\n"
"     * @param consumer   underlying consumer\n"
"     * @param partitions set of assigned topic partitions\n"
"     */\n"
"    @Override\n"
"    public void onPartitionsAssigned(Consumer<?, ?> consumer, Collection<TopicPartition> partitions) {\n"
"        long now = System.currentTimeMillis();\n"
"        long shouldStartAt = now - 600_000L; //10 minute ago\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:602
#, no-wrap
msgid ""
"        Map<TopicPartition, Long> request = new HashMap<>();\n"
"        for (TopicPartition partition : partitions) {\n"
"            LOGGER.info(\"Assigned \" + partition);\n"
"            request.put(partition, shouldStartAt);\n"
"        }\n"
"        Map<TopicPartition, OffsetAndTimestamp> offsets = consumer.offsetsForTimes(request);\n"
"        for (Map.Entry<TopicPartition, OffsetAndTimestamp> position : offsets.entrySet()) {\n"
"            long target = position.getValue() == null ? 0L : position.getValue().offset();\n"
"            LOGGER.info(\"Seeking position \" + target + \" for \" + position.getKey());\n"
"            consumer.seek(position.getKey(), target);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:613
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.kafka.IncomingKafkaRecord;\n"
"import org.eclipse.microprofile.reactive.messaging.Acknowledgment;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:617
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import java.util.concurrent.CompletableFuture;\n"
"import java.util.concurrent.CompletionStage;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:620
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class KafkaRebalancedConsumer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:628
#, no-wrap
msgid ""
"    @Incoming(\"rebalanced-example\")\n"
"    @Acknowledgment(Acknowledgment.Strategy.NONE)\n"
"    public CompletionStage<Void> consume(IncomingKafkaRecord<Integer, String> message) {\n"
"        // We don't need to ACK messages because in this example,\n"
"        // we set offset during consumer rebalance\n"
"        return CompletableFuture.completedFuture(null);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:634
#, fuzzy
msgid "To configure the inbound connector to use the provided listener, we either set the consumer rebalance listener’s identifier: `mp.messaging.incoming.rebalanced-example.consumer-rebalance-listener.name=rebalanced-example.rebalancer`"
msgstr "Para configurar o conetor de entrada para utilizar o ouvinte fornecido, definimos o identificador do ouvinte de reequilíbrio do consumidor: `mp.messaging.incoming.rebalanced-example.consumer-rebalance-listener.name=rebalanced-example.rebalancer`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:636
#, fuzzy
msgid "Or have the listener’s name be the same as the group id:"
msgstr "Ou fazer com que o nome do ouvinte seja o mesmo que o ID do grupo:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:638
#, fuzzy
msgid "`mp.messaging.incoming.rebalanced-example.group.id=rebalanced-example.rebalancer`"
msgstr "`mp.messaging.incoming.rebalanced-example.group.id=rebalanced-example.rebalancer`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:640
#, fuzzy
msgid "Setting the consumer rebalance listener’s name takes precedence over using the group id."
msgstr "A definição do nome do ouvinte de reequilíbrio do consumidor tem precedência sobre a utilização do ID do grupo."

#. type: Title ====
#: upstream/_guides/kafka.adoc:641
#, fuzzy, no-wrap
msgid "Using unique consumer groups"
msgstr "Utilizar grupos de consumidores únicos"

#. type: Plain text
#: upstream/_guides/kafka.adoc:644
#, fuzzy
msgid "If you want to process all the records from a topic (from its beginning), you need:"
msgstr "Para processar todos os registos de um tópico (desde o seu início), é necessário:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:646
#, fuzzy
msgid "to set `auto.offset.reset = earliest`"
msgstr "para definir `auto.offset.reset = earliest`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:647
#, fuzzy
msgid "assign your consumer to a consumer group not used by any other application."
msgstr "atribuir o seu consumidor a um grupo de consumidores não utilizado por nenhuma outra aplicação."

#. type: Plain text
#: upstream/_guides/kafka.adoc:650
#, fuzzy
msgid "Quarkus generates a UUID that changes between two executions (including in dev mode).  So, you are sure no other consumer uses it, and you receive a new unique group id every time your application starts."
msgstr "O Quarkus gera um UUID que muda entre duas execuções (inclusive no modo de desenvolvimento). Assim, tem a certeza de que nenhum outro consumidor o utiliza e recebe um novo ID de grupo único sempre que a sua aplicação é iniciada."

#. type: Plain text
#: upstream/_guides/kafka.adoc:652
#, fuzzy
msgid "You can use that generated UUID as the consumer group as follows:"
msgstr "Pode utilizar esse UUID gerado como o grupo de consumidores da seguinte forma:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:657
#, no-wrap
msgid ""
"mp.messaging.incoming.your-channel.auto.offset.reset=earliest\n"
"mp.messaging.incoming.your-channel.group.id=${quarkus.uuid}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:660
#, fuzzy
msgid "If the `group.id` attribute is not set, it defaults the `quarkus.application.name` configuration property."
msgstr "Se o atributo `group.id` não estiver definido, a propriedade de configuração `quarkus.application.name` é utilizada por defeito."

#. type: Title ===
#: upstream/_guides/kafka.adoc:661
#, fuzzy, no-wrap
msgid "Receiving Kafka Records in Batches"
msgstr "Receber registos Kafka em lotes"

#. type: Plain text
#: upstream/_guides/kafka.adoc:665
#, fuzzy
msgid "By default, incoming methods receive each Kafka record individually.  Under the hood, Kafka consumer clients poll the broker constantly and receive records in batches, presented inside the `ConsumerRecords` container."
msgstr "Por predefinição, os métodos de entrada recebem cada registo Kafka individualmente. No entanto, os clientes consumidores do Kafka pesquisam constantemente o corretor e recebem registos em lotes, apresentados no contentor `ConsumerRecords`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:667
#, fuzzy
msgid "In *batch* mode, your application can receive all the records returned by the consumer *poll* in one go."
msgstr "No modo *batch*, a sua aplicação pode receber todos os registos devolvidos pela *sondagem* do consumidor de uma só vez."

#. type: Plain text
#: upstream/_guides/kafka.adoc:669
#, fuzzy
msgid "To achieve this you need to specify a compatible container type to receive all the data:"
msgstr "Para tal, é necessário especificar um tipo de contentor compatível para receber todos os dados:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:678
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public void consume(List<Double> prices) {\n"
"    for (double price : prices) {\n"
"        // process price\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:682
#, fuzzy
msgid "The incoming method can also receive `Message<List<Payload>>`, `KafkaRecordBatch<Key, Payload>`, and `ConsumerRecords<Key, Payload>` types.  They give access to record details such as offset or timestamp:"
msgstr "O método de entrada também pode receber os tipos `Message&amp;lt;List&amp;lt;Payload&amp;gt;&amp;gt;`, `KafkaRecordBatch&amp;lt;Key, Payload&amp;gt;` `ConsumerRecords&amp;lt;Key, Payload&amp;gt;` . Estes tipos dão acesso aos detalhes do registo, como o deslocamento ou o carimbo de data/hora:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:695
#, no-wrap
msgid ""
"@Incoming(\"prices\")\n"
"public CompletionStage<Void> consumeMessage(KafkaRecordBatch<String, Double> records) {\n"
"    for (KafkaRecord<String, Double> record : records) {\n"
"        String payload = record.getPayload();\n"
"        String topic = record.getTopic();\n"
"        // process messages\n"
"    }\n"
"    // ack will commit the latest offsets (per partition) of the batch.\n"
"    return records.ack();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:700
#, fuzzy
msgid "Note that the successful processing of the incoming record batch will commit the latest offsets for each partition received inside the batch.  The configured commit strategy will be applied for these records only."
msgstr "Note que o processamento bem sucedido do lote de registos de entrada irá confirmar os últimos offsets para cada partição recebida dentro do lote. A estratégia de confirmação configurada será aplicada apenas a estes registos."

#. type: Plain text
#: upstream/_guides/kafka.adoc:702
#, fuzzy
msgid "Conversely, if the processing throws an exception, all messages are _nacked_, applying the failure strategy for all the records inside the batch."
msgstr "Inversamente, se o processamento lançar uma exceção, todas as mensagens são _empacotadas_, aplicando a estratégia de falha a todos os registos dentro do lote."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:707
#, fuzzy
msgid "Quarkus autodetects batch types for incoming channels and sets batch configuration automatically.  You can configure batch mode explicitly with `mp.messaging.incoming.$channel.batch` property."
msgstr "O Quarkus detecta automaticamente os tipos de lote para os canais de entrada e define automaticamente a configuração do lote. Pode configurar explicitamente o modo de lote com a propriedade `mp.messaging.incoming.$channel.batch`."

#. type: Title ===
#: upstream/_guides/kafka.adoc:710
#, fuzzy, no-wrap
msgid "Stateful processing with Checkpointing"
msgstr "Processamento com estado com Checkpointing"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:715
#, fuzzy
msgid "The `checkpoint` commit strategy is an experimental feature and can change in the future."
msgstr "A estratégia de submissão `checkpoint` é uma funcionalidade experimental e pode ser alterada no futuro."

#. type: Plain text
#: upstream/_guides/kafka.adoc:722
#, fuzzy
msgid "Smallrye Reactive Messaging `checkpoint` commit strategy allows consumer applications to process messages in a stateful manner, while also respecting Kafka consumer scalability.  An incoming channel with `checkpoint` commit strategy persists consumer offsets on an external xref:state-stores[state store], such as a relational database or a key-value store.  As a result of processing consumed records, the consumer application can accumulate an internal state for each topic-partition assigned to the Kafka consumer.  This local state will be periodically persisted to the state store and will be associated with the offset of the record that produced it."
msgstr "Smallrye Reactive Messaging `checkpoint` A estratégia de confirmação permite que as aplicações do consumidor processem mensagens de uma forma com estado, respeitando simultaneamente a escalabilidade do consumidor Kafka. Um canal de entrada com a estratégia de confirmação `checkpoint` persiste os offsets do consumidor num  link:#state-stores[armazenamento de estado] externo, como uma base de dados relacional ou um armazenamento de valores chave. Como resultado do processamento dos registos consumidos, a aplicação do consumidor pode acumular um estado interno para cada partição de tópico atribuída ao consumidor Kafka. Este estado local será periodicamente persistido no armazenamento de estados e será associado ao desvio do registo que o produziu."

#. type: Plain text
#: upstream/_guides/kafka.adoc:726
#, fuzzy
msgid "This strategy does not commit any offsets to the Kafka broker, so when new partitions get assigned to the consumer, i.e. consumer restarts or consumer group instances scale, the consumer resumes the processing from the latest _checkpointed_ offset with its saved state."
msgstr "Esta estratégia não compromete quaisquer desvios para o corretor Kafka, pelo que quando novas partições são atribuídas ao consumidor, ou seja, o consumidor reinicia ou as instâncias do grupo de consumidores são escaladas, o consumidor retoma o processamento a partir do último desvio _do ponto de controlo_ com o seu estado guardado."

#. type: Plain text
#: upstream/_guides/kafka.adoc:729
#, fuzzy
msgid "The `@Incoming` channel consumer code can manipulate the processing state through the `CheckpointMetadata` API.  For example, a consumer calculating the moving average of prices received on a Kafka topic would look the following:"
msgstr "O código do consumidor do canal `@Incoming` pode manipular o estado de processamento através da API `CheckpointMetadata`. Por exemplo, um consumidor que calcula a média móvel dos preços recebidos num tópico Kafka teria o seguinte aspeto:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:733 upstream/_guides/kafka.adoc:833
#: upstream/_guides/kafka.adoc:2480 upstream/_guides/kafka.adoc:2528
#: upstream/_guides/kafka.adoc:2569 upstream/_guides/kafka.adoc:2587
#: upstream/_guides/kafka.adoc:2617 upstream/_guides/kafka.adoc:2649
#: upstream/_guides/kafka.adoc:2668 upstream/_guides/kafka.adoc:2713
#: upstream/_guides/kafka.adoc:2756 upstream/_guides/kafka.adoc:2798
#: upstream/_guides/kafka.adoc:2905
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:735 upstream/_guides/kafka.adoc:2482
#: upstream/_guides/kafka.adoc:2530 upstream/_guides/kafka.adoc:2758
#, no-wrap
msgid "import java.util.concurrent.CompletionStage;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:740
#, no-wrap
msgid ""
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Message;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:743
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.kafka.KafkaRecord;\n"
"import io.smallrye.reactive.messaging.kafka.commit.CheckpointMetadata;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:746
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class MeanCheckpointConsumer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:751
#, no-wrap
msgid ""
"    @Incoming(\"prices\")\n"
"    public CompletionStage<Void> consume(Message<Double> record) {\n"
"        // Get the `CheckpointMetadata` from the incoming message\n"
"        CheckpointMetadata<AveragePrice> checkpoint = CheckpointMetadata.fromMessage(record);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:755
#, no-wrap
msgid ""
"        // `CheckpointMetadata` allows transforming the processing state\n"
"        // Applies the given function, starting from the value `0.0` when no previous state exists\n"
"        checkpoint.transform(new AveragePrice(), average -> average.update(record.getPayload()), /* persistOnAck */ true);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:760
#, no-wrap
msgid ""
"        // `persistOnAck` flag set to true, ack will persist the processing state\n"
"        // associated with the latest offset (per partition).\n"
"        return record.ack();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:764
#, no-wrap
msgid ""
"    static class AveragePrice {\n"
"        long count;\n"
"        double mean;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:771
#, no-wrap
msgid ""
"        AveragePrice update(double newPrice) {\n"
"            mean += ((newPrice - mean) / ++count);\n"
"            return this;\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:777
#, fuzzy
msgid "The `transform` method applies the transformation function to the current state, producing a changed state and registering it locally for checkpointing.  By default, the local state is persisted to the state store periodically, period specified by `auto.commit.interval.ms`, (default: 5000).  If `persistOnAck` flag is given, the latest state is persisted to the state store eagerly on message acknowledgment.  The `setNext` method works similarly directly setting the latest state."
msgstr "O método `transform` aplica a função de transformação ao estado atual, produzindo um estado alterado e registando-o localmente para o checkpointing. Por defeito, o estado local é persistido no armazenamento de estados periodicamente, período especificado por `auto.commit.interval.ms`, (predefinição: 5000). Se o sinalizador `persistOnAck` for fornecido, o estado mais recente é persistido para o armazenamento de estado ansiosamente na confirmação da mensagem. O método `setNext` funciona de forma semelhante, definindo diretamente o estado mais recente."

#. type: Plain text
#: upstream/_guides/kafka.adoc:780
#, fuzzy
msgid "The checkpoint commit strategy tracks when a processing state is last persisted for each topic-partition.  If an outstanding state change can not be persisted for `checkpoint.unsynced-state-max-age.ms` (default: 10000), the channel is marked unhealthy."
msgstr "A estratégia de confirmação de ponto de verificação rastreia quando um estado de processamento foi persistido pela última vez para cada partição de tópico. Se uma alteração de estado pendente não puder ser mantida por `checkpoint.unsynced-state-max-age.ms` (padrão: 10000), o canal será marcado como não saudável."

#. type: Title ====
#: upstream/_guides/kafka.adoc:782
#, fuzzy, no-wrap
msgid "State stores"
msgstr "Lojas do Estado"

#. type: Plain text
#: upstream/_guides/kafka.adoc:788
#, fuzzy
msgid "State store implementations determine where and how the processing states are persisted.  This is configured by the `mp.messaging.incoming.[channel-name].checkpoint.state-store` property.  The serialization of state objects depends on the state store implementation.  In order to instruct state stores for serialization can require configuring the class name of state objects using `mp.messaging.incoming.[channel-name].checkpoint.state-type` property."
msgstr "As implementações do armazenamento de estados determinam onde e como os estados de processamento são persistidos. Isso é configurado pela propriedade `mp.messaging.incoming.[channel-name].checkpoint.state-store`. A serialização de objectos de estado depende da implementação do armazenamento de estados. Para instruir os armazenamentos de estados para serialização, pode ser necessário configurar o nome da classe dos objectos de estado utilizando a propriedade `mp.messaging.incoming.[channel-name].checkpoint.state-type`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:790
#, fuzzy
msgid "Quarkus provides following state store implementations:"
msgstr "O Quarkus fornece as seguintes implementações de armazenamento de estado:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:795
#, fuzzy
msgid "`quarkus-redis`: Uses the xref:redis-reference.adoc[`quarkus-redis-client`] extension to persist processing states.  Jackson is used to serialize processing state in Json. For complex objects it is required to configure the `checkpoint.state-type` property with the class name of the object.  By default, the state store uses the default redis client, but if a xref:redis-reference.adoc#default-and-named-clients[named client] is to be used, the client name can be specified using the `mp.messaging.incoming.[channel-name].checkpoint.quarkus-redis.client-name` property.  Processing states will be stored in Redis using the key naming scheme `[consumer-group-id]:[topic]:[partition]`."
msgstr "`quarkus-redis`: Utiliza a extensão  link:redis-reference.html[`quarkus-redis-client`] para persistir estados de processamento. Jackson é utilizado para serializar o estado de processamento em Json. Para objetos complexos, é necessário configurar a propriedade `checkpoint.state-type` com o nome da classe do objeto. Por predefinição, o armazenamento de estados utiliza o cliente Redis predefinido, mas se for necessário utilizar um  link:redis-reference.html#default-and-named-clients[cliente nomeado], o nome do cliente pode ser especificado utilizando a propriedade `mp.messaging.incoming.[channel-name].checkpoint.quarkus-redis.client-name`. Os estados de processamento serão armazenados no Redis usando o esquema de nomenclatura de chaves `[consumer-group-id]:[topic]:[partition]`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:797 upstream/_guides/kafka.adoc:818
#, fuzzy
msgid "For example the configuration of the previous code would be the following:"
msgstr "Por exemplo, a configuração do código anterior seria a seguinte:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:810
#, no-wrap
msgid ""
"mp.messaging.incoming.prices.group.id=prices-checkpoint\n"
"# ...\n"
"mp.messaging.incoming.prices.commit-strategy=checkpoint\n"
"mp.messaging.incoming.prices.checkpoint.state-store=quarkus-redis\n"
"mp.messaging.incoming.prices.checkpoint.state-type=org.acme.MeanCheckpointConsumer.AveragePrice\n"
"# ...\n"
"# if using a named redis client\n"
"mp.messaging.incoming.prices.checkpoint.quarkus-redis.client-name=my-redis\n"
"quarkus.redis.my-redis.hosts=redis://localhost:7000\n"
"quarkus.redis.my-redis.password=<redis-pwd>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:816
#, fuzzy
msgid "`quarkus-hibernate-reactive`: Uses the xref:hibernate-reactive.adoc[`quarkus-hibernate-reactive`] extension to persist processing states.  Processing state objects are required to be a Jakarta Persistence entity and extend the `CheckpointEntity` class, which handles object identifiers composed of the consumer group id, topic and partition.  Therefore, the class name of the entity needs to be configured using the `checkpoint.state-type` property."
msgstr "`quarkus-hibernate-reactive`: Utiliza a extensão  link:hibernate-reactive.html[`quarkus-hibernate-reactive`] para persistir estados de processamento. Os objectos de estado de processamento têm de ser uma entidade Jakarta Persistence e estender a classe `CheckpointEntity`, que lida com identificadores de objectos compostos pelo ID do grupo de consumidores, tópico e partição. Por conseguinte, o nome da classe da entidade tem de ser configurado utilizando a propriedade `checkpoint.state-type`."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:826
#, no-wrap
msgid ""
"mp.messaging.incoming.prices.group.id=prices-checkpoint\n"
"# ...\n"
"mp.messaging.incoming.prices.commit-strategy=checkpoint\n"
"mp.messaging.incoming.prices.checkpoint.state-store=quarkus-hibernate-reactive\n"
"mp.messaging.incoming.prices.checkpoint.state-type=org.acme.AveragePriceEntity\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:829
#, fuzzy
msgid "With `AveragePriceEntity` being a Jakarta Persistence entity extending `CheckpointEntity`:"
msgstr "Sendo `AveragePriceEntity` uma entidade da Jakarta Persistence que alarga `CheckpointEntity`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:835 upstream/_guides/kafka.adoc:2571
#: upstream/_guides/kafka.adoc:2651
#, no-wrap
msgid "import jakarta.persistence.Entity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:837
#, no-wrap
msgid "import io.quarkus.smallrye.reactivemessaging.kafka.CheckpointEntity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:842
#, no-wrap
msgid ""
"@Entity\n"
"public class AveragePriceEntity extends CheckpointEntity {\n"
"    public long count;\n"
"    public double mean;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:848
#, no-wrap
msgid ""
"    public AveragePriceEntity update(double newPrice) {\n"
"        mean += ((newPrice - mean) / ++count);\n"
"        return this;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:852
#, fuzzy
msgid "`quarkus-hibernate-orm`: Uses the xref:hibernate-orm.adoc[`quarkus-hibernate-orm`] extension to persist processing states.  It is similar to the previous state store, but it uses Hibernate ORM instead of Hibernate Reactive."
msgstr "`quarkus-hibernate-orm`: Utiliza a extensão  link:hibernate-orm.html[`quarkus-hibernate-orm`] para manter os estados de processamento. É semelhante ao armazenamento de estados anterior, mas utiliza o Hibernate ORM em vez do Hibernate Reactive."

#. type: Plain text
#: upstream/_guides/kafka.adoc:854
#, fuzzy
msgid "When configured, it can use a named `persistence-unit` for the checkpointing state store:"
msgstr "Quando configurado, ele pode usar um `persistence-unit` nomeado para o armazenamento de estado de checkpointing:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:868
#, no-wrap
msgid ""
"mp.messaging.incoming.prices.commit-strategy=checkpoint\n"
"mp.messaging.incoming.prices.checkpoint.state-store=quarkus-hibernate-orm\n"
"mp.messaging.incoming.prices.checkpoint.state-type=org.acme.AveragePriceEntity\n"
"mp.messaging.incoming.prices.checkpoint.quarkus-hibernate-orm.persistence-unit=prices\n"
"# ... Setup \"prices\" persistence unit\n"
"quarkus.datasource.\"prices\".db-kind=postgresql\n"
"quarkus.datasource.\"prices\".username=<your username>\n"
"quarkus.datasource.\"prices\".password=<your password>\n"
"quarkus.datasource.\"prices\".jdbc.url=jdbc:postgresql://localhost:5432/hibernate_orm_test\n"
"quarkus.hibernate-orm.\"prices\".datasource=prices\n"
"quarkus.hibernate-orm.\"prices\".packages=org.acme\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:872
#, fuzzy
msgid "For instructions on how to implement custom state stores, see https://smallrye.io/smallrye-reactive-messaging/3.22.0/kafka/receiving-kafka-records/#implementing-state-stores[Implementing State Stores]."
msgstr "Para obter instruções sobre como implementar armazenamentos de estado personalizados, consulte  link:https://smallrye.io/smallrye-reactive-messaging/3.22.0/kafka/receiving-kafka-records/#implementing-state-stores[Implementação de armazenamentos de estado]."

#. type: Title ==
#: upstream/_guides/kafka.adoc:873
#, fuzzy, no-wrap
msgid "Sending messages to Kafka"
msgstr "Envio de mensagens para o Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:876
#, fuzzy
msgid "Configuration for the Kafka connector outgoing channels is similar to that of incoming:"
msgstr "A configuração dos canais de saída do conetor Kafka é semelhante à dos canais de entrada:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:882
#, no-wrap
msgid ""
"%prod.kafka.bootstrap.servers=kafka:9092 <1>\n"
"mp.messaging.outgoing.prices-out.connector=smallrye-kafka <2>\n"
"mp.messaging.outgoing.prices-out.topic=prices <3>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:887
#, fuzzy
msgid "Configure the broker location for the production profile. You can configure it globally or per channel using `mp.messaging.outgoing.$channel.bootstrap.servers` property.  In dev mode and when running tests, xref:kafka-dev-services[Dev Services for Kafka] automatically starts a Kafka broker.  When not provided, this property defaults to `localhost:9092`."
msgstr "Configure a localização do corretor para o perfil de produção. Pode configurá-lo globalmente ou por canal utilizando a propriedade `mp.messaging.outgoing.$channel.bootstrap.servers`. No modo de desenvolvimento e ao executar testes,  link:#kafka-dev-services[os Serviços de desenvolvimento para Kafka] iniciam automaticamente um corretor Kafka. Quando não é fornecida, esta propriedade é predefinida para `localhost:9092`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:888
#, fuzzy
msgid "Configure the connector to manage the `prices-out` channel."
msgstr "Configurar o conetor para gerir o canal `prices-out`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:889
#, fuzzy
msgid "By default, the topic name is same as the channel name. You can configure the topic attribute to override it."
msgstr "Por defeito, o nome do tópico é igual ao nome do canal. Pode configurar o atributo de tópico para o substituir."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:894
#, fuzzy
msgid "Inside application configuration, channel names are unique.  Therefore, if you'd like to configure an incoming and outgoing channel on the same topic, you will need to name channels differently (like in the examples of this guide, `mp.messaging.incoming.prices` and `mp.messaging.outgoing.prices-out`)."
msgstr "Dentro da configuração do aplicativo, os nomes dos canais são exclusivos. Por conseguinte, se pretender configurar um canal de entrada e de saída no mesmo tópico, terá de atribuir nomes diferentes aos canais (como nos exemplos deste guia, `mp.messaging.incoming.prices` e `mp.messaging.outgoing.prices-out`)."

#. type: Plain text
#: upstream/_guides/kafka.adoc:898
#, fuzzy
msgid "Then, your application can generate messages and publish them to the `prices-out` channel.  It can use `double` payloads as in the following snippet:"
msgstr "Em seguida, a sua aplicação pode gerar mensagens e publicá-las no canal `prices-out`. Pode utilizar cargas úteis `double` como no seguinte excerto:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:903
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Multi;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:907
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import java.time.Duration;\n"
"import java.util.Random;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:910
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class KafkaPriceProducer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:912 upstream/_guides/kafka.adoc:1224
#: upstream/_guides/kafka.adoc:1264
#, no-wrap
msgid "    private final Random random = new Random();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:920
#, no-wrap
msgid ""
"    @Outgoing(\"prices-out\")\n"
"    public Multi<Double> generate() {\n"
"        // Build an infinite stream of random prices\n"
"        // It emits a price every second\n"
"        return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n"
"            .map(x -> random.nextDouble());\n"
"    }\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:927
#, fuzzy
msgid "You should not call methods annotated with `@Incoming` and/or `@Outgoing` directly from your code. They are invoked by the framework. Having user code invoking them would not have the expected outcome."
msgstr "Não deve chamar métodos anotados com `@Incoming` e/ou `@Outgoing` diretamente a partir do seu código. Eles são invocados pela estrutura. O facto de o código do utilizador os invocar não teria o resultado esperado."

#. type: Plain text
#: upstream/_guides/kafka.adoc:931
#, fuzzy
msgid "Note that the `generate` method returns a `Multi<Double>`, which implements the Reactive Streams `Publisher` interface.  This publisher will be used by the framework to generate messages and send them to the configured Kafka topic."
msgstr "Observe que o método `generate` retorna um `Multi&amp;lt;Double&amp;gt;`, que implementa a interface Reactive Streams `Publisher`. Esse publicador será usado pelo framework para gerar mensagens e enviá-las para o tópico Kafka configurado."

#. type: Plain text
#: upstream/_guides/kafka.adoc:933
#, fuzzy
msgid "Instead of returning a payload, you can return a `io.smallrye.reactive.messaging.kafka.Record` to send key/value pairs:"
msgstr "Em vez de devolver uma carga útil, pode devolver um `io.smallrye.reactive.messaging.kafka.Record` para enviar pares de chave/valor:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:941
#, no-wrap
msgid ""
"@Outgoing(\"out\")\n"
"public Multi<Record<String, Double>> generate() {\n"
"    return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n"
"        .map(x -> Record.of(\"my-key\", random.nextDouble()));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:944
#, fuzzy
msgid "Payload can be wrapped inside `org.eclipse.microprofile.reactive.messaging.Message` to have more control on the written records:"
msgstr "A carga útil pode ser envolvida em `org.eclipse.microprofile.reactive.messaging.Message` para ter mais controlo sobre os registos escritos:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:957
#, no-wrap
msgid ""
"@Outgoing(\"generated-price\")\n"
"public Multi<Message<Double>> generate() {\n"
"    return Multi.createFrom().ticks().every(Duration.ofSeconds(1))\n"
"            .map(x -> Message.of(random.nextDouble())\n"
"                    .addMetadata(OutgoingKafkaRecordMetadata.<String>builder()\n"
"                            .withKey(\"my-key\")\n"
"                            .withTopic(\"my-key-prices\")\n"
"                            .withHeaders(new RecordHeaders().add(\"my-header\", \"value\".getBytes()))\n"
"                            .build()));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:962
#, fuzzy
msgid "`OutgoingKafkaRecordMetadata` allows to set metadata attributes of the Kafka record, such as `key`, `topic`, `partition` or `timestamp`.  One use case is to dynamically select the destination topic of a message.  In this case, instead of configuring the topic inside your application configuration file, you need to use the outgoing metadata to set the name of the topic."
msgstr "`OutgoingKafkaRecordMetadata` permite definir atributos de metadados do registo Kafka, como `key`, `topic`, `partition` ou `timestamp`. Um caso de utilização é selecionar dinamicamente o tópico de destino de uma mensagem. Neste caso, em vez de configurar o tópico no ficheiro de configuração da aplicação, é necessário utilizar os metadados de saída para definir o nome do tópico."

#. type: Plain text
#: upstream/_guides/kafka.adoc:965
#, fuzzy
msgid "Other than method signatures returning a Reactive Stream `Publisher` (`Multi` being an implementation of `Publisher`), outgoing method can also return single message.  In this case the producer will use this method as generator to create an infinite stream."
msgstr "Para além das assinaturas de métodos que devolvem um fluxo reativo `Publisher` (sendo `Multi` uma implementação de `Publisher`), o método de saída também pode devolver uma única mensagem. Neste caso, o produtor utilizará este método como gerador para criar um fluxo infinito."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:969
#, no-wrap
msgid "@Outgoing(\"prices-out\") T generate(); // T excluding void\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:971
#, no-wrap
msgid "@Outgoing(\"prices-out\") Message<T> generate();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:973
#, no-wrap
msgid "@Outgoing(\"prices-out\") Uni<T> generate();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:975
#, no-wrap
msgid "@Outgoing(\"prices-out\") Uni<Message<T>> generate();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:977
#, no-wrap
msgid "@Outgoing(\"prices-out\") CompletionStage<T> generate();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:979
#, no-wrap
msgid "@Outgoing(\"prices-out\") CompletionStage<Message<T>> generate();\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/kafka.adoc:981
#, fuzzy, no-wrap
msgid "Sending messages with @Emitter"
msgstr "Enviar mensagens com @Emitter"

#. type: Plain text
#: upstream/_guides/kafka.adoc:984
#, fuzzy
msgid "Sometimes, you need to have an imperative way of sending messages."
msgstr "Por vezes, é necessário ter uma forma imperativa de enviar mensagens."

#. type: Plain text
#: upstream/_guides/kafka.adoc:987
#, fuzzy
msgid "For example, if you need to send a message to a stream when receiving a POST request inside a REST endpoint.  In this case, you cannot use `@Outgoing` because your method has parameters."
msgstr "Por exemplo, se precisar de enviar uma mensagem para um fluxo ao receber um pedido POST dentro de um ponto final REST. Neste caso, não pode utilizar `@Outgoing` porque o seu método tem parâmetros."

#. type: Plain text
#: upstream/_guides/kafka.adoc:989
#, fuzzy
msgid "For this, you can use an `Emitter`."
msgstr "Para tal, pode utilizar um `Emitter`."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:994 upstream/_guides/kafka.adoc:2490
#: upstream/_guides/kafka.adoc:2538 upstream/_guides/kafka.adoc:2765
#, no-wrap
msgid ""
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Emitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1000 upstream/_guides/kafka.adoc:1045
#: upstream/_guides/kafka.adoc:1079
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import jakarta.ws.rs.POST;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Consumes;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1007
#, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"price-create\")\n"
"    Emitter<Double> priceEmitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1014
#, no-wrap
msgid ""
"    @POST\n"
"    @Consumes(MediaType.TEXT_PLAIN)\n"
"    public void addPrice(Double price) {\n"
"        CompletionStage<Void> ack = priceEmitter.send(price);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1017
#, fuzzy
msgid "Sending a payload returns a `CompletionStage`, completed when the message is acked. If the message transmission fails, the `CompletionStage` is completed exceptionally with the reason of the nack."
msgstr "O envio de uma carga útil devolve um `CompletionStage`, concluído quando a mensagem é recebida. Se a transmissão da mensagem falhar, o `CompletionStage` é completado excecionalmente com a razão do nack."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1021
#, fuzzy
msgid "The `Emitter` configuration is done the same way as the other stream configuration used by `@Incoming` and `@Outgoing`."
msgstr "A configuração de `Emitter` é efectuada da mesma forma que a outra configuração de fluxo utilizada por `@Incoming` e `@Outgoing`."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1030
#, fuzzy
msgid "Using the `Emitter` you are sending messages from your imperative code to reactive messaging.  These messages are stored in a queue until they are sent.  If the Kafka producer client can't keep up with messages trying to be sent over to Kafka, this queue can become a memory hog and you may even run out of memory.  You can use `@OnOverflow` to configure back-pressure strategy.  It lets you configure the size of the queue (default is 256) and the strategy to apply when the buffer size is reached. Available strategies are `DROP`, `LATEST`, `FAIL`, `BUFFER`, `UNBOUNDED_BUFFER` and `NONE`."
msgstr "Utilizando o `Emitter` está a enviar mensagens do seu código imperativo para o sistema de mensagens reativo. Essas mensagens são armazenadas em uma fila até serem enviadas. Se o cliente produtor do Kafka não conseguir acompanhar as mensagens que estão a ser enviadas para o Kafka, esta fila pode tornar-se um consumidor de memória e pode mesmo ficar sem memória. É possível usar `@OnOverflow` para configurar a estratégia de contrapressão. Ele permite configurar o tamanho da fila (o padrão é 256) e a estratégia a ser aplicada quando o tamanho do buffer for atingido. As estratégias disponíveis são `DROP`, `LATEST`, `FAIL`, `BUFFER`, `UNBOUNDED_BUFFER` e `NONE`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1033
#, fuzzy
msgid "With the `Emitter` API, you can also encapsulate the outgoing payload inside `Message<T>`. As with the previous examples, `Message` lets you handle the ack/nack cases differently."
msgstr "Com a API `Emitter`, pode também encapsular o payload de saída dentro de `Message&amp;lt;T&amp;gt;`. Tal como nos exemplos anteriores, `Message` permite-lhe tratar os casos de ack/nack de forma diferente."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1039
#, no-wrap
msgid ""
"import java.util.concurrent.CompletableFuture;\n"
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Emitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1050
#, no-wrap
msgid "    @Inject @Channel(\"price-create\") Emitter<Double> priceEmitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1065
#, no-wrap
msgid ""
"    @POST\n"
"    @Consumes(MediaType.TEXT_PLAIN)\n"
"    public void addPrice(Double price) {\n"
"        priceEmitter.send(Message.of(price)\n"
"            .withAck(() -> {\n"
"                // Called when the message is acked\n"
"                return CompletableFuture.completedFuture(null);\n"
"            })\n"
"            .withNack(throwable -> {\n"
"                // Called when the message is nacked\n"
"                return CompletableFuture.completedFuture(null);\n"
"            }));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1069
#, fuzzy
msgid "If you prefer using Reactive Stream APIs, you can use `MutinyEmitter` that will return `Uni<Void>` from the `send` method.  You can therefore use Mutiny APIs for handling downstream messages and errors."
msgstr "Se preferir utilizar APIs de fluxo reativo, pode utilizar `MutinyEmitter` que devolverá `Uni&amp;lt;Void&amp;gt;` a partir do método `send`. Por conseguinte, pode utilizar as API Mutiny para tratar mensagens e erros a jusante."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1073 upstream/_guides/kafka.adoc:1321
#: upstream/_guides/kafka.adoc:2803
#, no-wrap
msgid "import org.eclipse.microprofile.reactive.messaging.Channel;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1081
#, no-wrap
msgid "import io.smallrye.reactive.messaging.MutinyEmitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1088
#, no-wrap
msgid ""
"    @Inject\n"
"    @Channel(\"price-create\")\n"
"    MutinyEmitter<Double> priceEmitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1097
#, no-wrap
msgid ""
"    @POST\n"
"    @Consumes(MediaType.TEXT_PLAIN)\n"
"    public Uni<String> addPrice(Double price) {\n"
"        return quoteRequestEmitter.send(price)\n"
"                .map(x -> \"ok\")\n"
"                .onFailure().recoverWithItem(\"ko\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1101
#, fuzzy
msgid "It is also possible to block on sending the event to the emitter with the `sendAndAwait` method.  It will only return from the method when the event is acked or nacked by the receiver."
msgstr "Também é possível bloquear o envio do evento para o emissor com o método `sendAndAwait`. Só regressará do método quando o evento for aceite ou anulado pelo recetor."

#. type: Block title
#: upstream/_guides/kafka.adoc:1103
#, fuzzy, no-wrap
msgid "Deprecation"
msgstr "Depreciação"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1106
#, fuzzy
msgid "The `io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye.reactive.messaging.annotations.Channel` and `io.smallrye.reactive.messaging.annotations.OnOverflow` classes are now deprecated and replaced by:"
msgstr "As classes `io.smallrye.reactive.messaging.annotations.Emitter`, `io.smallrye.reactive.messaging.annotations.Channel` e `io.smallrye.reactive.messaging.annotations.OnOverflow` são agora obsoletas e substituídas por:"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1108
#, fuzzy
msgid "`org.eclipse.microprofile.reactive.messaging.Emitter`"
msgstr "`org.eclipse.microprofile.reactive.messaging.Emitter`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1109
#, fuzzy
msgid "`org.eclipse.microprofile.reactive.messaging.Channel`"
msgstr "`org.eclipse.microprofile.reactive.messaging.Channel`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1110
#, fuzzy
msgid "`org.eclipse.microprofile.reactive.messaging.OnOverflow`"
msgstr "`org.eclipse.microprofile.reactive.messaging.OnOverflow`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1112
#, fuzzy
msgid "The new `Emitter.send` method returns a `CompletionStage` completed when the produced message is acknowledged."
msgstr "O novo método `Emitter.send` devolve um `CompletionStage` concluído quando a mensagem produzida é confirmada."

#. type: Block title
#: upstream/_guides/kafka.adoc:1115
#, fuzzy, no-wrap
msgid "Depreciation"
msgstr "Depreciação"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1118
#, fuzzy
msgid "`MutinyEmitter#send(Message msg)` method is deprecated in favor of following methods receiving `Message` for emitting:"
msgstr "`MutinyEmitter#send(Message msg)` está obsoleto em favor dos seguintes métodos que recebem `Message` para emitir:"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1120
#, fuzzy
msgid "`<M extends Message<? extends T>> Uni<Void> sendMessage(M msg)`"
msgstr "`&amp;lt;M extends Message&amp;lt;? extends T&amp;gt;&amp;gt; Uni&amp;lt;Void&amp;gt; sendMessage(M msg)`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1121
#, fuzzy
msgid "`<M extends Message<? extends T>> void sendMessageAndAwait(M msg)`"
msgstr "`&amp;lt;M extends Message&amp;lt;? extends T&amp;gt;&amp;gt; void sendMessageAndAwait(M msg)`"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1122
#, fuzzy
msgid "`<M extends Message<? extends T>> Cancellable sendMessageAndForget(M msg)`"
msgstr "`&amp;lt;M extends Message&amp;lt;? extends T&amp;gt;&amp;gt; Cancellable sendMessageAndForget(M msg)`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1126
#, fuzzy
msgid "More information on how to use `Emitter` can be found in https://smallrye.io/smallrye-reactive-messaging/latest/concepts/emitter/[SmallRye Reactive Messaging – Emitters and Channels]"
msgstr "Mais informações sobre como usar `Emitter` podem ser encontradas em  link:https://smallrye.io/smallrye-reactive-messaging/latest/concepts/emitter/[SmallRye Reactive Messaging - Emitters and Channels]"

#. type: Title ===
#: upstream/_guides/kafka.adoc:1127
#, fuzzy, no-wrap
msgid "Write Acknowledgement"
msgstr "Escrever confirmação"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1131
#, fuzzy
msgid "When Kafka broker receives a record, its acknowledgement can take time depending on the configuration.  Also, it stores in-memory the records that cannot be written."
msgstr "Quando o corretor Kafka recebe um registo, o seu aviso de receção pode demorar algum tempo, dependendo da configuração. Além disso, armazena na memória os registos que não podem ser escritos."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1134
#, fuzzy
msgid "By default, the connector does wait for Kafka to acknowledge the record to continue the processing (acknowledging the received Message).  You can disable this by setting the `waitForWriteCompletion` attribute to `false`."
msgstr "Por predefinição, o conetor espera que o Kafka confirme o registo para continuar o processamento (confirmando a mensagem recebida). Pode desativar esta opção definindo o atributo `waitForWriteCompletion` para `false`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1136
#, fuzzy
msgid "Note that the `acks` attribute has a huge impact on the record acknowledgement."
msgstr "Note-se que o atributo `acks` tem um enorme impacto na confirmação do registo."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1138
#, fuzzy
msgid "If a record cannot be written, the message is nacked."
msgstr "Se não for possível escrever um registo, a mensagem é anulada."

#. type: Title ===
#: upstream/_guides/kafka.adoc:1139
#, fuzzy, no-wrap
msgid "Backpressure"
msgstr "Contrapressão"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1143
#, fuzzy
msgid "The Kafka outbound connector handles back-pressure, monitoring the number of in-flight messages waiting to be written to the Kafka broker.  The number of in-flight messages is configured using the `max-inflight-messages` attribute and defaults to 1024."
msgstr "O conetor de saída do Kafka lida com a contrapressão, monitorizando o número de mensagens em curso à espera de serem escritas no corretor Kafka. O número de mensagens em trânsito é configurado com o atributo `max-inflight-messages` e a predefinição é 1024."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1148
#, fuzzy
msgid "The connector only sends that amount of messages concurrently.  No other messages will be sent until at least one in-flight message gets acknowledged by the broker.  Then, the connector writes a new message to Kafka when one of the broker’s in-flight messages get acknowledged.  Be sure to configure Kafka’s `batch.size` and `linger.ms` accordingly."
msgstr "O conetor apenas envia essa quantidade de mensagens em simultâneo. Nenhuma outra mensagem será enviada até que pelo menos uma mensagem em curso seja confirmada pelo corretor. Em seguida, o conetor escreve uma nova mensagem no Kafka quando uma das mensagens em andamento do broker é confirmada. Certifique-se de configurar o `batch.size` e o `linger.ms` do Kafka de acordo."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1151
#, fuzzy
msgid "You can also remove the limit of in-flight messages by setting `max-inflight-messages` to `0`.  However, note that the Kafka producer may block if the number of requests reaches `max.in.flight.requests.per.connection`."
msgstr "Também pode remover o limite de mensagens em curso, definindo `max-inflight-messages` para `0`. No entanto, tenha em atenção que o produtor Kafka pode bloquear se o número de pedidos atingir `max.in.flight.requests.per.connection`."

#. type: Title ===
#: upstream/_guides/kafka.adoc:1152
#, fuzzy, no-wrap
msgid "Retrying message dispatch"
msgstr "Nova tentativa de envio de mensagens"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1157
#, fuzzy
msgid "When the Kafka producer receives an error from the server, if it is a transient, recoverable error, the client will retry sending the batch of messages.  This behavior is controlled by `retries` and `retry.backoff.ms` parameters.  In addition to this, SmallRye Reactive Messaging will retry individual messages on recoverable errors, depending on the `retries` and `delivery.timeout.ms` parameters."
msgstr "Quando o produtor Kafka recebe um erro do servidor, se se tratar de um erro transitório e recuperável, o cliente volta a tentar enviar o lote de mensagens. Esse comportamento é controlado pelos parâmetros `retries` e `retry.backoff.ms`. Além disso, o SmallRye Reactive Messaging repetirá mensagens individuais em erros recuperáveis, dependendo dos parâmetros `retries` e `delivery.timeout.ms`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1160
#, fuzzy
msgid "Note that while having retries in a reliable system is a best practice, the `max.in.flight.requests.per.connection` parameter defaults to `5`, meaning that the order of the messages is not guaranteed.  If the message order is a must for your use case, setting `max.in.flight.requests.per.connection` to `1` will make sure a single batch of messages is sent at a time, in the expense of limiting the throughput of the producer."
msgstr "Note-se que, embora a existência de novas tentativas num sistema fiável seja uma boa prática, o parâmetro `max.in.flight.requests.per.connection` é predefinido para `5`, o que significa que a ordem das mensagens não é garantida. Se a ordem das mensagens for imprescindível para o seu caso de utilização, definir `max.in.flight.requests.per.connection` para `1` garantirá o envio de um único lote de mensagens de cada vez, à custa de limitar o rendimento do produtor."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1162
#, fuzzy
msgid "For applying retry mechanism on processing errors, see the section on xref:retrying-processing[Retrying processing]."
msgstr "Para aplicar o mecanismo de repetição aos erros de processamento, ver a secção \"  link:#retrying-processing[Repetição do processamento]\"."

#. type: Title ===
#: upstream/_guides/kafka.adoc:1163
#, fuzzy, no-wrap
msgid "Handling Serialization Failures"
msgstr "Tratamento de falhas de serialização"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1167
#, fuzzy
msgid "For Kafka producer client serialization failures are not recoverable, thus the message dispatch is not retried. In these cases you may need to apply a failure strategy for the serializer.  To achieve this, you need to create a bean implementing `SerializationFailureHandler<T>` interface:"
msgstr "Para o cliente produtor Kafka, as falhas de serialização não são recuperáveis, pelo que o envio da mensagem não é repetido. Nestes casos, pode ser necessário aplicar uma estratégia de falha para o serializador. Para o efeito, é necessário criar um bean que implemente a interface `SerializationFailureHandler&amp;lt;T&amp;gt;`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1174
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"@Identifier(\"failure-fallback\") // Set the name of the failure handler\n"
"public class MySerializationFailureHandler\n"
"    implements SerializationFailureHandler<JsonObject> { // Specify the expected type\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1183
#, no-wrap
msgid ""
"    @Override\n"
"    public byte[] decorateSerialization(Uni<byte[]> serialization, String topic, boolean isKey,\n"
"        String serializer, Object data, Headers headers) {\n"
"        return serialization\n"
"                    .onFailure().retry().atMost(3)\n"
"                    .await().indefinitely();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1186
#, fuzzy
msgid "To use this failure handler, the bean must be exposed with the `@Identifier` qualifier and the connector configuration must specify the attribute `mp.messaging.outgoing.$channel.[key|value]-serialization-failure-handler` (for key or value serializers)."
msgstr "Para utilizar este manipulador de falhas, o bean deve ser exposto com o qualificador `@Identifier` e a configuração do conetor deve especificar o atributo `mp.messaging.outgoing.$channel.[key|value]-serialization-failure-handler` (para serializadores de chave ou de valor)."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1189
#, fuzzy
msgid "The handler is called with details of the serialization, including the action represented as `Uni<byte[]>`.  Note that the method must await on the result and return the serialized byte array."
msgstr "O manipulador é chamado com detalhes da serialização, incluindo a ação representada como `Uni&amp;lt;byte[]&amp;gt;`. Note-se que o método deve aguardar o resultado e devolver a matriz de bytes serializada."

#. type: Title ===
#: upstream/_guides/kafka.adoc:1190
#, fuzzy, no-wrap
msgid "In-memory channels"
msgstr "Canais na memória"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1195
#, fuzzy
msgid "In some use cases, it is convenient to use the messaging patterns to transfer messages inside the same application.  When you don't connect a channel to a messaging backend like Kafka, everything happens in-memory, and the streams are created by chaining methods together.  Each chain is still a reactive stream and enforces the back-pressure protocol."
msgstr "Em alguns casos de utilização, é conveniente utilizar os padrões de mensagens para transferir mensagens dentro da mesma aplicação. Quando você não conecta um canal a um backend de mensagens como o Kafka, tudo acontece na memória e os fluxos são criados encadeando métodos. Cada cadeia continua a ser um fluxo reativo e aplica o protocolo de contrapressão."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1199
#, fuzzy
msgid "The framework verifies that the producer/consumer chain is complete, meaning that if the application writes messages into an in-memory channel (using a method with only `@Outgoing`, or an `Emitter`), it must also consume the messages from within the application (using a method with only `@Incoming` or using an unmanaged stream)."
msgstr "O quadro verifica se a cadeia produtor/consumidor está completa, o que significa que se a aplicação escreve mensagens num canal na memória (utilizando um método com apenas `@Outgoing`, ou um `Emitter`), deve também consumir as mensagens a partir da aplicação (utilizando um método com apenas `@Incoming` ou utilizando um fluxo não gerido)."

#. type: Title ===
#: upstream/_guides/kafka.adoc:1201
#, fuzzy, no-wrap
msgid "Broadcasting messages on multiple consumers"
msgstr "Difusão de mensagens em vários consumidores"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1206
#, fuzzy
msgid "By default, a channel can be linked to a single consumer, using `@Incoming` method or `@Channel` reactive stream.  At application startup, channels are verified to form a chain of consumers and producers with single consumer and producer.  You can override this behavior by setting `mp.messaging.$channel.broadcast=true` on a channel."
msgstr "Por predefinição, um canal pode ser ligado a um único consumidor, utilizando o método `@Incoming` ou o fluxo reativo `@Channel`. No arranque da aplicação, os canais são verificados para formar uma cadeia de consumidores e produtores com um único consumidor e produtor. Pode anular este comportamento definindo `mp.messaging.$channel.broadcast=true` num canal."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1208
#, fuzzy
msgid "In case of in-memory channels, `@Broadcast` annotation can be used on the `@Outgoing` method. For example,"
msgstr "No caso dos canais na memória, a anotação `@Broadcast` pode ser utilizada no método `@Outgoing`. Por exemplo,"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1212 upstream/_guides/kafka.adoc:1255
#, no-wrap
msgid "import java.util.Random;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1217 upstream/_guides/kafka.adoc:1284
#: upstream/_guides/kafka.adoc:1388 upstream/_guides/kafka.adoc:1416
#, no-wrap
msgid ""
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1219
#, no-wrap
msgid "import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1222
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class MultipleConsumer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1230
#, no-wrap
msgid ""
"    @Outgoing(\"in-memory-channel\")\n"
"    @Broadcast\n"
"    double generate() {\n"
"        return random.nextDouble();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1235
#, no-wrap
msgid ""
"    @Incoming(\"in-memory-channel\")\n"
"    void consumeAndLog(double price) {\n"
"        System.out.println(price);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1242
#, no-wrap
msgid ""
"    @Incoming(\"in-memory-channel\")\n"
"    @Outgoing(\"prices2\")\n"
"    double consumeAndSend(double price) {\n"
"        return price;\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1248
#, fuzzy
msgid "Reciprocally, multiple producers on the same channel can be merged by setting `mp.messaging.incoming.$channel.merge=true`.  On the `@Incoming` methods, you can control how multiple channels are merged using the `@Merge` annotation."
msgstr "Reciprocamente, vários produtores no mesmo canal podem ser fundidos definindo `mp.messaging.incoming.$channel.merge=true`. Nos métodos `@Incoming`, pode controlar a forma como vários canais são combinados utilizando a anotação `@Merge`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1251
#, fuzzy
msgid "Repeating the `@Outgoing` annotation on outbound or processing methods allows another way of dispatching messages to multiple outgoing channels:"
msgstr "A repetição da anotação `@Outgoing` nos métodos de saída ou de processamento permite outra maneira de enviar mensagens para vários canais de saída:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1259
#, fuzzy, no-wrap
msgid "import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr "`org.eclipse.microprofile.reactive.messaging.Emitter`"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1262
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class MultipleProducers {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1270
#, no-wrap
msgid ""
"    @Outgoing(\"generated\")\n"
"    @Outgoing(\"generated-2\")\n"
"    double priceBroadcast() {\n"
"        return random.nextDouble();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1277
#, fuzzy
msgid "In the previous example generated price will be broadcast to both outbound channels.  The following example selectively sends messages to multiple outgoing channels using the `Targeted` container object, containing key as channel name and value as message payload."
msgstr "No exemplo anterior, o preço gerado será transmitido para ambos os canais de saída. O exemplo a seguir envia seletivamente mensagens para vários canais de saída usando o objeto de contêiner `Targeted`, contendo key como nome do canal e value como carga útil da mensagem."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1286
#, fuzzy, no-wrap
msgid "import io.smallrye.reactive.messaging.Targeted;\n"
msgstr "`io.smallrye.reactive.messaging.annotations.Blocking`"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1289
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class TargetedProducers {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1302
#, no-wrap
msgid ""
"    @Incoming(\"in\")\n"
"    @Outgoing(\"out1\")\n"
"    @Outgoing(\"out2\")\n"
"    @Outgoing(\"out3\")\n"
"    public Targeted process(double price) {\n"
"        Targeted targeted = Targeted.of(\"out1\", \"Price: \" + price,\n"
"                \"out2\", \"Quote: \" + price);\n"
"        if (price > 90.0) {\n"
"            return targeted.with(\"out3\", price);\n"
"        }\n"
"        return targeted;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1307
#, fuzzy
msgid "Note that xref:serialization-autodetection[the auto-detection for Kafka serializers] doesn't work for signatures using the `Targeted`."
msgstr "Observe que  link:#serialization-autodetection[a detecção automática de serializadores do Kafka] não funciona para assinaturas que usam o `Targeted`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1309
#, fuzzy
msgid "For more details on using multiple outgoings, please refer to the http://smallrye.io/smallrye-reactive-messaging/4.10.0/concepts/outgoings/[SmallRye Reactive Messaging documentation]."
msgstr "Informações detalhadas sobre a utilização da anotação `@Blocking` podem ser encontradas em  link:https://smallrye.io/smallrye-reactive-messaging/latest/concepts/blocking/[SmallRye Reactive Messaging - Handling blocking execution]."

#. type: Title ===
#: upstream/_guides/kafka.adoc:1310
#, fuzzy, no-wrap
msgid "Kafka Transactions"
msgstr "Transacções Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1315
#, fuzzy
msgid "Kafka transactions enable atomic writes to multiple Kafka topics and partitions.  The Kafka connector provides `KafkaTransactions` custom emitter for writing Kafka records inside a transaction.  It can be injected as a regular emitter `@Channel`:"
msgstr "As transacções Kafka permitem escritas atómicas em vários tópicos e partições Kafka. O conetor Kafka fornece `KafkaTransactions` emissor personalizado para escrever registos Kafka dentro de uma transação. Ele pode ser injetado como um emissor regular `@Channel`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1325
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.smallrye.reactive.messaging.kafka.KafkaRecord;\n"
"import io.smallrye.reactive.messaging.kafka.transactions.KafkaTransactions;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1328
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class KafkaTransactionalProducer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1331
#, no-wrap
msgid ""
"    @Channel(\"tx-out-example\")\n"
"    KafkaTransactions<String> txProducer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1340
#, no-wrap
msgid ""
"    public Uni<Void> emitInTransaction() {\n"
"        return txProducer.withTransaction(emitter -> {\n"
"            emitter.send(KafkaRecord.of(1, \"a\"));\n"
"            emitter.send(KafkaRecord.of(2, \"b\"));\n"
"            emitter.send(KafkaRecord.of(3, \"c\"));\n"
"            return Uni.createFrom().voidItem();\n"
"        });\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1345
#, fuzzy
msgid "The function given to the `withTransaction` method receives a `TransactionalEmitter` for producing records, and returns a `Uni` that provides the result of the transaction."
msgstr "A função dada ao método `withTransaction` recebe um `TransactionalEmitter` para produzir registos e devolve um `Uni` que fornece o resultado da transação."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1347
#, fuzzy
msgid "If the processing completes successfully, the producer is flushed and the transaction is committed."
msgstr "Se o processamento for concluído com êxito, o produtor é descarregado e a transação é confirmada."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1348
#, fuzzy
msgid "If the processing throws an exception, returns a failing `Uni`, or marks the `TransactionalEmitter` for abort, the transaction is aborted."
msgstr "Se o processamento lançar uma exceção, devolver uma falha `Uni`, ou marcar o `TransactionalEmitter` para abortar, a transação é abortada."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1352
#, fuzzy
msgid "Kafka transactional producers require configuring `acks=all` client property, and a unique id for `transactional.id`, which implies `enable.idempotence=true`.  When Quarkus detects the use of `KafkaTransactions` for an outgoing channel it configures these properties on the channel, providing a default value of `\"${quarkus.application.name}-${channelName}\"` for `transactional.id` property."
msgstr "Os produtores transaccionais Kafka requerem a configuração da propriedade de cliente `acks=all` e uma identificação única para `transactional.id`, o que implica `enable.idempotence=true`. Quando o Quarkus detecta a utilização de `KafkaTransactions` para um canal de saída, configura estas propriedades no canal, fornecendo um valor predefinido de `\"${quarkus.application.name}-${channelName}\"` para a propriedade `transactional.id`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1354
#, fuzzy
msgid "Note that for production use the `transactional.id` must be unique across all application instances."
msgstr "Note-se que, para utilização em produção, o endereço `transactional.id` deve ser único em todas as instâncias da aplicação."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1362
#, fuzzy
msgid "While a normal message emitter would support concurrent calls to `send` methods and consequently queues outgoing messages to be written to Kafka, a `KafkaTransactions` emitter only supports one transaction at a time.  A transaction is considered in progress from the call to the `withTransaction` until the returned `Uni` results in success or failure.  While a transaction is in progress, subsequent calls to the `withTransaction`, including nested ones inside the given function, will throw `IllegalStateException`."
msgstr "Enquanto um emissor de mensagens normal suportaria chamadas simultâneas para os métodos `send` e, consequentemente, colocaria em fila as mensagens de saída a serem escritas no Kafka, um emissor `KafkaTransactions` suporta apenas uma transação de cada vez. Uma transação é considerada em curso desde a chamada para o `withTransaction` até que o `Uni` devolvido resulte em sucesso ou falha. Enquanto uma transação estiver em curso, as chamadas subsequentes a `withTransaction`, incluindo as aninhadas dentro da função dada, lançarão `IllegalStateException`."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1366
#, fuzzy
msgid "Note that in Reactive Messaging, the execution of processing methods, is already serialized, unless `@Blocking(ordered = false)` is used.  If `withTransaction` can be called concurrently, for example from a REST endpoint, it is recommended to limit the concurrency of the execution.  This can be done using the `@Bulkhead` annotation from xref:smallrye-fault-tolerance.adoc[_Microprofile Fault Tolerance_]."
msgstr "Note-se que, no sistema de mensagens reactivas, a execução dos métodos de processamento já está serializada, a menos que seja utilizado `@Blocking(ordered = false)`. Se `withTransaction` puder ser chamado simultaneamente, por exemplo, a partir de um ponto de extremidade REST, recomenda-se limitar a simultaneidade da execução. Isto pode ser feito utilizando a anotação `@Bulkhead` do  link:smallrye-fault-tolerance.html[_Microprofile Fault Tolerance_]."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1368
#, fuzzy
msgid "An example usage can be found in xref:chaining-kafka-transactions-with-hibernate-reactive-transactions[Chaining Kafka Transactions with Hibernate Reactive transactions]."
msgstr "Um exemplo de utilização pode ser encontrado em  link:#chaining-kafka-transactions-with-hibernate-reactive-transactions[Encadeamento de transacções Kafka com transacções reactivas do Hibernate]."

#. type: Title ====
#: upstream/_guides/kafka.adoc:1370
#, fuzzy, no-wrap
msgid "Transaction-aware consumers"
msgstr "Consumidores conscientes das transacções"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1373
#, fuzzy
msgid "If you'd like to consume records only written and committed inside a Kafka transaction you need to configure the `isolation.level` property on the incoming channel as such:"
msgstr "Se pretender consumir apenas registos escritos e confirmados no âmbito de uma transação Kafka, terá de configurar a propriedade `isolation.level` no canal de entrada como tal:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1377
#, no-wrap
msgid "mp.messaging.incoming.prices-in.isolation.level=read_committed\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:1379
#, fuzzy, no-wrap
msgid "Processing Messages"
msgstr "Processamento de mensagens"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1383
#, fuzzy
msgid "Applications streaming data often need to consume some events from a topic, process them and publish the result to a different topic.  A processor method can be simply implemented using both the `@Incoming` and `@Outgoing` annotations:"
msgstr "As aplicações que transmitem dados em fluxo contínuo precisam frequentemente de consumir alguns eventos de um tópico, processá-los e publicar o resultado num tópico diferente. Um método de processador pode ser simplesmente implementado utilizando as anotações `@Incoming` e `@Outgoing`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1393 upstream/_guides/kafka.adoc:1421
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PriceProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1395 upstream/_guides/kafka.adoc:1423
#: upstream/_guides/kafka.adoc:1634
#, no-wrap
msgid "    private static final double CONVERSION_RATE = 0.88;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1401
#, no-wrap
msgid ""
"    @Incoming(\"price-in\")\n"
"    @Outgoing(\"price-out\")\n"
"    public double process(double price) {\n"
"        return price * CONVERSION_RATE;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1407
#, fuzzy
msgid "The parameter of the `process` method is the incoming message payload, whereas the return value will be used as the outgoing message payload.  Previously mentioned signatures for parameter and return types are also supported, such as `Message<T>`, `Record<K, V>`, etc."
msgstr "O parâmetro do método `process` é a carga útil da mensagem de entrada, enquanto o valor de retorno será utilizado como carga útil da mensagem de saída. As assinaturas anteriormente mencionadas para os tipos de parâmetro e de retorno também são suportadas, como `Message&amp;lt;T&amp;gt;`, `Record&amp;lt;K, V&amp;gt;`, etc."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1409
#, fuzzy
msgid "You can apply asynchronous stream processing by consuming and returning reactive stream `Multi<T>` type:"
msgstr "É possível aplicar o processamento assíncrono de fluxos consumindo e devolvendo o tipo de fluxo reativo `Multi&amp;lt;T&amp;gt;`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1418
#, no-wrap
msgid "import io.smallrye.mutiny.Multi;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1429
#, no-wrap
msgid ""
"    @Incoming(\"price-in\")\n"
"    @Outgoing(\"price-out\")\n"
"    public Multi<Double> process(Multi<Integer> prices) {\n"
"        return prices.filter(p -> p > 100).map(p -> p * CONVERSION_RATE);\n"
"    }\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/kafka.adoc:1433
#, fuzzy, no-wrap
msgid "Propagating Record Key"
msgstr "Chave de registo de propagação"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1436
#, fuzzy
msgid "When processing messages, you can propagate incoming record key to the outgoing record."
msgstr "Ao processar mensagens, é possível propagar a chave do registo de entrada para o registo de saída."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1439
#, fuzzy
msgid "Enabled with `mp.messaging.outgoing.$channel.propagate-record-key=true` configuration, record key propagation produces the outgoing record with the same _key_ as the incoming record."
msgstr "Activada com a configuração `mp.messaging.outgoing.$channel.propagate-record-key=true`, a propagação da chave de registo produz o registo de saída com a mesma _chave_ que o registo de entrada."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1442
#, fuzzy
msgid "If the outgoing record already contains a _key_, it *won't be overridden* by the incoming record key.  If the incoming record does have a _null_ key, the `mp.messaging.outgoing.$channel.key` property is used."
msgstr "Se o registo de saída já contiver uma _chave_, esta não *será substituída* pela chave do registo de entrada. Se o registo de entrada tiver uma chave _nula_, é utilizada a propriedade `mp.messaging.outgoing.$channel.key`."

#. type: Title ===
#: upstream/_guides/kafka.adoc:1443
#, fuzzy, no-wrap
msgid "Exactly-Once Processing"
msgstr "Processamento exatamente uma vez"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1447
#, fuzzy
msgid "Kafka Transactions allows managing consumer offsets inside a transaction, together with produced messages.  This enables coupling a consumer with a transactional producer in a _consume-transform-produce_ pattern, also known as *exactly-once processing*."
msgstr "O Kafka Transactions permite gerir os offsets do consumidor dentro de uma transação, juntamente com as mensagens produzidas. Isto permite acoplar um consumidor a um produtor transacional num padrão _consumir-transformar-produzir_, também conhecido como *processamento exatamente único*."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1449
#, fuzzy
msgid "The `KafkaTransactions` custom emitter provides a way to apply exactly-once processing to an incoming Kafka message inside a transaction."
msgstr "O emissor personalizado `KafkaTransactions` fornece uma forma de aplicar um processamento exatamente único a uma mensagem Kafka de entrada dentro de uma transação."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1451
#, fuzzy
msgid "The following example includes a batch of Kafka records inside a transaction."
msgstr "O exemplo seguinte inclui um lote de registos Kafka dentro de uma transação."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1459
#, no-wrap
msgid ""
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.OnOverflow;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1464
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.smallrye.reactive.messaging.kafka.KafkaRecord;\n"
"import io.smallrye.reactive.messaging.kafka.KafkaRecordBatch;\n"
"import io.smallrye.reactive.messaging.kafka.transactions.KafkaTransactions;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1467
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class KafkaExactlyOnceProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1471
#, no-wrap
msgid ""
"    @Channel(\"prices-out\")\n"
"    @OnOverflow(value = OnOverflow.Strategy.BUFFER, bufferSize = 500) // <3>\n"
"    KafkaTransactions<Integer> txProducer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1481
#, no-wrap
msgid ""
"    @Incoming(\"prices-in\")\n"
"    public Uni<Void> emitInTransaction(KafkaRecordBatch<String, Integer> batch) { // <1>\n"
"        return txProducer.withTransactionAndAck(batch, emitter -> { // <2>\n"
"            for (KafkaRecord<String, Integer> record : batch) {\n"
"                emitter.send(KafkaRecord.of(record.getKey(), record.getPayload() + 1)); // <3>\n"
"            }\n"
"            return Uni.createFrom().voidItem();\n"
"        });\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1487
#, fuzzy
msgid "It is recommended to use exactly-once processing along with the batch consumption mode.  While it is possible to use it with a single Kafka message, it'll have a significant performance impact."
msgstr "Recomenda-se usar o processamento exatamente uma vez junto com o modo de consumo em lote. Embora seja possível utilizá-lo com uma única mensagem Kafka, isso terá um impacto significativo no desempenho."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1488
#, fuzzy
msgid "The consumed `KafkaRecordBatch` message is passed to the `KafkaTransactions#withTransactionAndAck` in order to handle the offset commits and message acks."
msgstr "A mensagem consumida em `KafkaRecordBatch` é transmitida a `KafkaTransactions#withTransactionAndAck` para tratar os commits de offset e os acks de mensagens."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1491
#, fuzzy
msgid "The `send` method writes records to Kafka inside the transaction, without waiting for send receipt from the broker.  Messages pending to be written to Kafka will be buffered, and flushed before committing the transaction.  It is therefore recommended configuring the `@OnOverflow` `bufferSize` in order to fit enough messages, for example the `max.poll.records`, maximum amount of records returned in a batch."
msgstr "O método `send` escreve registos no Kafka dentro da transação, sem esperar pela receção do envio do corretor. As mensagens pendentes de serem escritas no Kafka serão armazenadas em buffer e descarregadas antes de confirmar a transação. Recomenda-se, por conseguinte, a configuração do método `@OnOverflow` `bufferSize` para que caibam mensagens suficientes, por exemplo, o método `max.poll.records`, quantidade máxima de registos devolvidos num lote."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1493
#, fuzzy
msgid "If the processing completes successfully, _before committing the transaction_, the topic partition offsets of the given batch message will be committed to the transaction."
msgstr "Se o processamento for concluído com êxito, _antes de confirmar a transação_, os desvios da partição de tópicos da mensagem de lote indicada serão confirmados na transação."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1494
#, fuzzy
msgid "If the processing needs to abort, _after aborting the transaction_, the consumer's position is reset to the last committed offset, effectively resuming the consumption from that offset. If no consumer offset has been committed to a topic-partition, the consumer's position is reset to the beginning of the topic-partition, _even if the offset reset policy is `latest`_."
msgstr "Se o processamento precisar de ser abortado, _depois de abortar a transação_, a posição do consumidor é reposta para o último offset confirmado, retomando efetivamente o consumo a partir desse offset. Se nenhum offset do consumidor tiver sido comprometido com uma topic-partition, a posição do consumidor é redefinida para o início da topic-partition, _mesmo que a política de redefinição de offset seja `latest`_."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1497
#, fuzzy
msgid "When using exactly-once processing, consumed message offset commits are handled by the transaction and therefore the application should not commit offsets through other means.  The consumer should have `enable.auto.commit=false` (the default) and set explicitly `commit-strategy=ignore`:"
msgstr "Quando se utiliza o processamento exatamente único, as confirmações do desvio da mensagem consumida são tratadas pela transação e, por conseguinte, a aplicação não deve confirmar os desvios através de outros meios. O consumidor deve ter `enable.auto.commit=false` (a predefinição) e definir explicitamente `commit-strategy=ignore`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1502
#, no-wrap
msgid ""
"mp.messaging.incoming.prices-in.commit-strategy=ignore\n"
"mp.messaging.incoming.prices-in.failure-strategy=ignore\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/kafka.adoc:1504
#, fuzzy, no-wrap
msgid "Error handling for the exactly-once processing"
msgstr "Tratamento de erros para o processamento exatamente igual"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1508
#, fuzzy
msgid "The `Uni` returned from the `KafkaTransactions#withTransaction` will yield a failure if the transaction fails and is aborted.  The application can choose to handle the error case, but if a failing `Uni` is returned from the `@Incoming` method, the incoming channel will effectively fail and stop the reactive stream."
msgstr "O `Uni` devolvido do `KafkaTransactions#withTransaction` produzirá uma falha se a transação falhar e for abortada. A aplicação pode optar por tratar o caso de erro, mas se for devolvido um `Uni` falhado do método `@Incoming`, o canal de entrada falhará efetivamente e interromperá o fluxo reativo."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1512
#, fuzzy
msgid "The `KafkaTransactions#withTransactionAndAck` method acks and nacks the message but will *not* return a failing `Uni`.  Nacked messages will be handled by the failure strategy of the incoming channel, (see xref:error-handling[Error Handling Strategies]).  Configuring `failure-strategy=ignore` simply resets the Kafka consumer to the last committed offsets and resumes the consumption from there."
msgstr "O método `KafkaTransactions#withTransactionAndAck` acks e nacks a mensagem, mas *não* devolverá uma falha `Uni`. As mensagens com nack serão tratadas pela estratégia de falha do canal de entrada (consulte  link:#error-handling[Estratégias de tratamento de erros]). A configuração de `failure-strategy=ignore` simplesmente redefine o consumidor do Kafka para os últimos offsets confirmados e retoma o consumo a partir daí."

#. type: Title ==
#: upstream/_guides/kafka.adoc:1515
#, fuzzy, no-wrap
msgid "Accessing Kafka clients directly"
msgstr "Aceder diretamente a clientes Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1519
#, fuzzy
msgid "In rare cases, you may need to access the underlying Kafka clients.  `KafkaClientService` provides thread-safe access to `Producer` and `Consumer`."
msgstr "Em casos raros, poderá ser necessário aceder aos clientes Kafka subjacentes. `KafkaClientService` fornece acesso thread-safe a `Producer` e `Consumer`."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1525
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import jakarta.enterprise.event.Observes;\n"
"import jakarta.inject.Inject;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1527
#, no-wrap
msgid "import org.apache.kafka.clients.producer.ProducerRecord;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1532
#, no-wrap
msgid ""
"import io.quarkus.runtime.StartupEvent;\n"
"import io.smallrye.reactive.messaging.kafka.KafkaClientService;\n"
"import io.smallrye.reactive.messaging.kafka.KafkaConsumer;\n"
"import io.smallrye.reactive.messaging.kafka.KafkaProducer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1535
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class PriceSender {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1538
#, no-wrap
msgid ""
"    @Inject\n"
"    KafkaClientService clientService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1545
#, no-wrap
msgid ""
"    void onStartup(@Observes StartupEvent startupEvent) {\n"
"        KafkaProducer<String, Double> producer = clientService.getProducer(\"generated-price\");\n"
"        producer.runOnSendingThread(client -> client.send(new ProducerRecord<>(\"prices\", 2.4)))\n"
"            .await().indefinitely();\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:1550
#, fuzzy
msgid "The `KafkaClientService` is an experimental API and can change in the future."
msgstr "A `KafkaClientService` é uma API experimental e pode sofrer alterações no futuro."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1553
#, fuzzy
msgid "You can also get the Kafka configuration injected to your application and create Kafka producer, consumer and admin clients directly:"
msgstr "Também pode obter a configuração do Kafka injectada na sua aplicação e criar diretamente clientes produtores, consumidores e administradores do Kafka:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1560
#, no-wrap
msgid ""
"import io.smallrye.common.annotation.Identifier;\n"
"import org.apache.kafka.clients.admin.AdminClient;\n"
"import org.apache.kafka.clients.admin.AdminClientConfig;\n"
"import org.apache.kafka.clients.admin.KafkaAdminClient;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1566
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import jakarta.enterprise.inject.Produces;\n"
"import jakarta.inject.Inject;\n"
"import java.util.HashMap;\n"
"import java.util.Map;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1569
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class KafkaClients {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1573
#, no-wrap
msgid ""
"    @Inject\n"
"    @Identifier(\"default-kafka-broker\")\n"
"    Map<String, Object> config;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1584
#, no-wrap
msgid ""
"    @Produces\n"
"    AdminClient getAdmin() {\n"
"        Map<String, Object> copy = new HashMap<>();\n"
"        for (Map.Entry<String, Object> entry : config.entrySet()) {\n"
"            if (AdminClientConfig.configNames().contains(entry.getKey())) {\n"
"                copy.put(entry.getKey(), entry.getValue());\n"
"            }\n"
"        }\n"
"        return KafkaAdminClient.create(copy);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1591
#, fuzzy
msgid "The `default-kafka-broker` configuration map contains all application properties prefixed with `kafka.` or `KAFKA_`.  For more configuration options check out xref:kafka-configuration-resolution[Kafka Configuration Resolution]."
msgstr "O mapa de configuração `default-kafka-broker` contém todas as propriedades da aplicação prefixadas com `kafka.` ou `KAFKA_`. Para obter mais opções de configuração, consulte  link:#kafka-configuration-resolution[Resolução de configuração do Kafka]."

#. type: Title ==
#: upstream/_guides/kafka.adoc:1593
#, fuzzy, no-wrap
msgid "JSON serialization"
msgstr "Serialização JSON"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1596
#, fuzzy
msgid "Quarkus has built-in capabilities to deal with JSON Kafka messages."
msgstr "O Quarkus tem capacidades incorporadas para lidar com mensagens JSON Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1598
#, fuzzy
msgid "Imagine we have a `Fruit` data class as follows:"
msgstr "Imagine que temos uma classe de dados `Fruit` da seguinte forma:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1602
#, no-wrap
msgid "public class Fruit {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1605
#, no-wrap
msgid ""
"    public String name;\n"
"    public int price;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1608
#, no-wrap
msgid ""
"    public Fruit() {\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1614
#, no-wrap
msgid ""
"    public Fruit(String name, int price) {\n"
"        this.name = name;\n"
"        this.price = price;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1617
#, fuzzy
msgid "And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka."
msgstr "E queremos utilizá-lo para receber mensagens do Kafka, fazer alguma transformação de preços e enviar mensagens de volta para o Kafka."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1623
#, no-wrap
msgid ""
"import io.smallrye.reactive.messaging.annotations.Broadcast;\n"
"import org.eclipse.microprofile.reactive.messaging.Incoming;\n"
"import org.eclipse.microprofile.reactive.messaging.Outgoing;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1632
#, no-wrap
msgid ""
"/**\n"
"* A bean consuming data from the \"fruit-in\" channel and applying some price conversion.\n"
"* The result is pushed to the \"fruit-out\" channel.\n"
"*/\n"
"@ApplicationScoped\n"
"public class FruitProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1642
#, no-wrap
msgid ""
"    @Incoming(\"fruit-in\")\n"
"    @Outgoing(\"fruit-out\")\n"
"    @Broadcast\n"
"    public Fruit process(Fruit fruit) {\n"
"        fruit.price = fruit.price * CONVERSION_RATE;\n"
"        return fruit;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1647
#, fuzzy
msgid "To do this, we will need to set up JSON serialization with Jackson or JSON-B."
msgstr "Para isso, precisamos de configurar a serialização JSON com Jackson ou JSON-B."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1649
#, fuzzy
msgid "With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`."
msgstr "Com a serialização JSON corretamente configurada, também é possível utilizar `Publisher&amp;lt;Fruit&amp;gt;` e `Emitter&amp;lt;Fruit&amp;gt;`."

#. type: Title ===
#: upstream/_guides/kafka.adoc:1651
#, fuzzy, no-wrap
msgid "Serializing via Jackson"
msgstr "Serialização via Jackson"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1656
#, fuzzy
msgid "Quarkus has built-in support for JSON serialization and deserialization based on Jackson.  It will also xref:serialization-generation[generate] the serializer and deserializer for you, so you do not have to configure anything.  When generation is disabled, you can use the provided `ObjectMapperSerializer` and `ObjectMapperDeserializer` as explained below."
msgstr "O Quarkus tem suporte integrado para serialização e desserialização de JSON com base no Jackson. Também  link:#serialization-generation[gera] o serializador e o desserializador por si, pelo que não tem de configurar nada. Quando a geração está desactivada, pode utilizar os sites `ObjectMapperSerializer` e `ObjectMapperDeserializer` fornecidos, conforme explicado abaixo."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1659
#, fuzzy
msgid "There is an existing `ObjectMapperSerializer` that can be used to serialize all data objects via Jackson.  You may create an empty subclass if you want to use xref:serialization-autodetection[Serializer/deserializer autodetection]."
msgstr "Existe um `ObjectMapperSerializer` que pode ser utilizado para serializar todos os objectos de dados através do Jackson. Pode criar uma subclasse vazia se pretender utilizar  link:#serialization-autodetection[a deteção automática do serializador/desserializador]."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1663
#, fuzzy
msgid "By default, the `ObjectMapperSerializer` serializes null as the `\"null\"` String, this can be customized by setting the Kafka configuration property `json.serialize.null-as-null=true` which will serialize null as `null`.  This is handy when using a compacted topic, as `null` is used as a tombstone to know which messages delete during compaction phase."
msgstr "Por padrão, o `ObjectMapperSerializer` serializa null como a cadeia de caracteres `\"null\"`. Isso pode ser personalizado definindo a propriedade de configuração do Kafka `json.serialize.null-as-null=true`, que serializará null como `null`. Isso é útil quando se usa um tópico compactado, pois `null` é usado como uma lápide para saber quais mensagens são excluídas durante a fase de compactação."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1666
#, fuzzy
msgid "The corresponding deserializer class needs to be subclassed.  So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`."
msgstr "A classe desserializadora correspondente precisa de ser subclasse. Então, vamos criar um `FruitDeserializer` que estende o `ObjectMapperDeserializer`."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1670 upstream/_guides/kafka.adoc:1701
#, no-wrap
msgid "package com.acme.fruit.jackson;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1672 upstream/_guides/kafka.adoc:2619
#: upstream/_guides/kafka.adoc:2715
#, no-wrap
msgid "import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1678 upstream/_guides/kafka.adoc:2625
#: upstream/_guides/kafka.adoc:2721
#, no-wrap
msgid ""
"public class FruitDeserializer extends ObjectMapperDeserializer<Fruit> {\n"
"    public FruitDeserializer() {\n"
"        super(Fruit.class);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1681
#, fuzzy
msgid "Finally, configure your channels to use the Jackson serializer and deserializer."
msgstr "Por fim, configure os seus canais para utilizarem o serializador e desserializador Jackson."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1687
#, no-wrap
msgid ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.fruit-in.topic=fruit-in\n"
"mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1691
#, no-wrap
msgid ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.fruit-out.topic=fruit-out\n"
"mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1695
#, fuzzy
msgid "Now, your Kafka messages will contain a Jackson serialized representation of your `Fruit` data object.  In this case, the `deserializer` configuration is not necessary as the xref:serialization-autodetection[Serializer/deserializer autodetection] is enabled by default."
msgstr "Agora, suas mensagens Kafka conterão uma representação serializada Jackson do seu objeto de dados `Fruit`. Nesse caso, a configuração `deserializer` não é necessária, pois a  link:#serialization-autodetection[autodetecção do serializador/desserializador] está ativada por padrão."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1697
#, fuzzy
msgid "If you want to deserialize a list of fruits, you need to create a deserializer with a Jackson `TypeReference` denoted the generic collection used."
msgstr "Se pretender desserializar uma lista de frutos, tem de criar um desserializador com um Jackson `TypeReference` denotando a coleção genérica utilizada."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1705
#, no-wrap
msgid ""
"import java.util.List;\n"
"import com.fasterxml.jackson.core.type.TypeReference;\n"
"import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1711
#, no-wrap
msgid ""
"public class ListOfFruitDeserializer extends ObjectMapperDeserializer<List<Fruit>> {\n"
"    public ListOfFruitDeserializer() {\n"
"        super(new TypeReference<List<Fruit>>() {});\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/kafka.adoc:1714
#, fuzzy, no-wrap
msgid "Serializing via JSON-B"
msgstr "Serialização via JSON-B"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1717
#, fuzzy
msgid "First, you need to include the `quarkus-jsonb` extension."
msgstr "Em primeiro lugar, é necessário incluir a extensão `quarkus-jsonb`."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1725
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-jsonb</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1731
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-jsonb\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1735
#, fuzzy
msgid "There is an existing `JsonbSerializer` that can be used to serialize all data objects via JSON-B.  You may create an empty subclass if you want to use xref:serialization-autodetection[Serializer/deserializer autodetection]."
msgstr "Existe um `JsonbSerializer` que pode ser utilizado para serializar todos os objectos de dados através de JSON-B. Pode criar uma subclasse vazia se pretender utilizar  link:#serialization-autodetection[a deteção automática do serializador/desserializador]."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1739
#, fuzzy
msgid "By default, the `JsonbSerializer` serializes null as the `\"null\"` String, this can be customized by setting the Kafka configuration property `json.serialize.null-as-null=true` which will serialize null as `null`.  This is handy when using a compacted topic, as `null` is used as a tombstone to know which messages delete during compaction phase."
msgstr "Por padrão, o `JsonbSerializer` serializa null como a cadeia de caracteres `\"null\"`. Isso pode ser personalizado definindo a propriedade de configuração do Kafka `json.serialize.null-as-null=true`, que serializará null como `null`. Isso é útil quando se usa um tópico compactado, pois `null` é usado como uma lápide para saber quais mensagens são excluídas durante a fase de compactação."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1742
#, fuzzy
msgid "The corresponding deserializer class needs to be subclassed.  So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`."
msgstr "A classe desserializadora correspondente precisa de ser subclasse. Então, vamos criar um `FruitDeserializer` que estende o genérico `JsonbDeserializer`."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1746
#, no-wrap
msgid "package com.acme.fruit.jsonb;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1748
#, no-wrap
msgid "import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1754
#, no-wrap
msgid ""
"public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n"
"    public FruitDeserializer() {\n"
"        super(Fruit.class);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1757
#, fuzzy
msgid "Finally, configure your channels to use the JSON-B serializer and deserializer."
msgstr "Por fim, configure os seus canais para utilizarem o serializador e desserializador JSON-B."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1764
#, no-wrap
msgid ""
"# Configure the Kafka source (we read from it)\n"
"mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n"
"mp.messaging.incoming.fruit-in.topic=fruit-in\n"
"mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1769
#, no-wrap
msgid ""
"# Configure the Kafka sink (we write to it)\n"
"mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n"
"mp.messaging.outgoing.fruit-out.topic=fruit-out\n"
"mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1772
#, fuzzy
msgid "Now, your Kafka messages will contain a JSON-B serialized representation of your `Fruit` data object."
msgstr "Agora, as suas mensagens Kafka conterão uma representação serializada JSON-B do seu objeto de dados `Fruit`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1774
#, fuzzy
msgid "If you want to deserialize a list of fruits, you need to create a deserializer with a `Type` denoted the generic collection used."
msgstr "Para desserializar uma lista de frutas, é necessário criar um desserializador com um `Type` denotando a coleção genérica utilizada."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1782
#, no-wrap
msgid ""
"package com.acme.fruit.jsonb;\n"
"import java.lang.reflect.Type;\n"
"import java.util.ArrayList;\n"
"import java.util.List;\n"
"import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1788
#, no-wrap
msgid ""
"public class ListOfFruitDeserializer extends JsonbDeserializer<List<Fruit>> {\n"
"    public ListOfFruitDeserializer() {\n"
"        super(new ArrayList<MyEntity>() {}.getClass().getGenericSuperclass());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1792
#, fuzzy
msgid "If you don't want to create a deserializer for each data object, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer` that will deserialize to a `io.vertx.core.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`."
msgstr "Se não quiser criar um desserializador para cada objeto de dados, pode utilizar o genérico `io.vertx.kafka.client.serialization.JsonObjectDeserializer` que desserializará para um `io.vertx.core.json.JsonObject`. O serializador correspondente também pode ser utilizado: `io.vertx.kafka.client.serialization.JsonObjectSerializer`."

#. type: Title ==
#: upstream/_guides/kafka.adoc:1793
#, fuzzy, no-wrap
msgid "Avro Serialization"
msgstr "Serialização Avro"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1796 upstream/_guides/kafka.adoc:1890
#, fuzzy
msgid "This is described in a dedicated guide: xref:kafka-schema-registry-avro.adoc[Using Apache Kafka with Schema Registry and Avro]."
msgstr "Isso é descrito em um guia dedicado:  link:kafka-schema-registry-avro.html[Utilização do Apache Kafka com o Schema Registry e o Avro]."

#. type: Title ==
#: upstream/_guides/kafka.adoc:1798
#, fuzzy, no-wrap
msgid "Serializer/deserializer autodetection"
msgstr "Deteção automática de serializador/desserializador"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1802
#, fuzzy
msgid "When using SmallRye Reactive Messaging with Kafka (`io.quarkus:quarkus-smallrye-reactive-messaging-kafka`), Quarkus can often automatically detect the correct serializer and deserializer class.  This autodetection is based on declarations of `@Incoming` and `@Outgoing` methods, as well as injected ``@Channel``s."
msgstr "Ao utilizar o SmallRye Reactive Messaging with Kafka ( `io.quarkus:quarkus-smallrye-reactive-messaging-kafka`), o Quarkus pode frequentemente detetar automaticamente a classe correcta de serializador e desserializador. Esta deteção automática baseia-se em declarações de métodos `@Incoming` e `@Outgoing`, bem como em `@Channel`s injectados."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1804
#, fuzzy
msgid "For example, if you declare"
msgstr "Por exemplo, se declarar"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1811
#, no-wrap
msgid ""
"@Outgoing(\"generated-price\")\n"
"public Multi<Integer> generate() {\n"
"    ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1814
#, fuzzy
msgid "and your configuration indicates that the `generated-price` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `value.serializer` to Kafka's built-in `IntegerSerializer`."
msgstr "e a sua configuração indicar que o canal `generated-price` utiliza o conetor `smallrye-kafka`, o Quarkus definirá automaticamente o `value.serializer` para o `IntegerSerializer` incorporado no Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1816
#, fuzzy
msgid "Similarly, if you declare"
msgstr "Da mesma forma, se declarar"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1823
#, no-wrap
msgid ""
"@Incoming(\"my-kafka-records\")\n"
"public void consume(KafkaRecord<Long, byte[]> record) {\n"
"    ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1826
#, fuzzy
msgid "and your configuration indicates that the `my-kafka-records` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `key.deserializer` to Kafka's built-in `LongDeserializer`, as well as the `value.deserializer` to `ByteArrayDeserializer`."
msgstr "e a sua configuração indicar que o canal `my-kafka-records` utiliza o conetor `smallrye-kafka`, então o Quarkus definirá automaticamente o `key.deserializer` para o `LongDeserializer` incorporado no Kafka, bem como o `value.deserializer` para `ByteArrayDeserializer`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1828
#, fuzzy
msgid "Finally, if you declare"
msgstr "Finalmente, se declarar"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1834
#, no-wrap
msgid ""
"@Inject\n"
"@Channel(\"price-create\")\n"
"Emitter<Double> priceEmitter;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1837
#, fuzzy
msgid "and your configuration indicates that the `price-create` channel uses the `smallrye-kafka` connector, then Quarkus will automatically set the `value.serializer` to Kafka's built-in `DoubleSerializer`."
msgstr "e a sua configuração indicar que o canal `price-create` utiliza o conetor `smallrye-kafka`, o Quarkus definirá automaticamente o `value.serializer` para o `DoubleSerializer` incorporado no Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1839
#, fuzzy
msgid "The full set of types supported by the serializer/deserializer autodetection is:"
msgstr "O conjunto completo de tipos suportados pela autodetecção do serializador/desserializador é:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1841
#, fuzzy
msgid "`short` and `java.lang.Short`"
msgstr "`short` e `java.lang.Short`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1842
#, fuzzy
msgid "`int` and `java.lang.Integer`"
msgstr "`int` e `java.lang.Integer`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1843
#, fuzzy
msgid "`long` and `java.lang.Long`"
msgstr "`long` e `java.lang.Long`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1844
#, fuzzy
msgid "`float` and `java.lang.Float`"
msgstr "`float` e `java.lang.Float`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1845
#, fuzzy
msgid "`double` and `java.lang.Double`"
msgstr "`double` e `java.lang.Double`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1846
#, fuzzy
msgid "`byte[]`"
msgstr "`byte[]`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1847
#, fuzzy
msgid "`java.lang.String`"
msgstr "`java.lang.String`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1848
#, fuzzy
msgid "`java.util.UUID`"
msgstr "`java.util.UUID`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1849
#, fuzzy
msgid "`java.nio.ByteBuffer`"
msgstr "`java.nio.ByteBuffer`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1850
#, fuzzy
msgid "`org.apache.kafka.common.utils.Bytes`"
msgstr "`org.apache.kafka.common.utils.Bytes`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1851
#, fuzzy
msgid "`io.vertx.core.buffer.Buffer`"
msgstr "`io.vertx.core.buffer.Buffer`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1852
#, fuzzy
msgid "`io.vertx.core.json.JsonObject`"
msgstr "`io.vertx.core.json.JsonObject`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1853
#, fuzzy
msgid "`io.vertx.core.json.JsonArray`"
msgstr "`io.vertx.core.json.JsonArray`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1854
#, fuzzy
msgid "classes for which a direct implementation of `org.apache.kafka.common.serialization.Serializer<T>` / `org.apache.kafka.common.serialization.Deserializer<T>` is present."
msgstr "classes para as quais existe uma implementação direta de `org.apache.kafka.common.serialization.Serializer&amp;lt;T&amp;gt;` / `org.apache.kafka.common.serialization.Deserializer&amp;lt;T&amp;gt;`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1855
#, fuzzy
msgid "the implementation needs to specify the type argument `T` as the (de-)serialized type."
msgstr "a implementação tem de especificar o argumento do tipo `T` como o tipo (des)serializado."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1856
#, fuzzy
msgid "classes generated from Avro schemas, as well as Avro `GenericRecord`, if Confluent or Apicurio Registry _serde_ is present"
msgstr "classes geradas a partir de esquemas Avro, bem como Avro `GenericRecord`, se o Confluent ou o Apicurio Registry _serde_ estiver presente"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1857
#, fuzzy
msgid "in case multiple Avro serdes are present, serializer/deserializer must be configured manually for Avro-generated classes, because autodetection is impossible"
msgstr "no caso de existirem vários serdes Avro, o serializador/desserializador deve ser configurado manualmente para as classes geradas pelo Avro, uma vez que a deteção automática é impossível"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1858
#, fuzzy
msgid "see xref:kafka-schema-registry-avro.adoc[Using Apache Kafka with Schema Registry and Avro] for more information about using Confluent or Apicurio Registry libraries"
msgstr "Consulte  link:kafka-schema-registry-avro.html[Utilizar o Apache Kafka com o Schema Registry e o Avro] para obter mais informações sobre a utilização das bibliotecas Confluent ou Apicurio Registry"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1859
#, fuzzy
msgid "classes for which a subclass of `ObjectMapperSerializer` / `ObjectMapperDeserializer` is present, as described in xref:jackson-serialization[Serializing via Jackson]"
msgstr "classes para as quais está presente uma subclasse de `ObjectMapperSerializer` / `ObjectMapperDeserializer`, tal como descrito em  link:#jackson-serialization[Serialização via Jackson]"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1860
#, fuzzy
msgid "it is technically not needed to subclass `ObjectMapperSerializer`, but in such case, autodetection isn't possible"
msgstr "tecnicamente não é necessário subclasse `ObjectMapperSerializer`, mas, nesse caso, a deteção automática não é possível"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1861
#, fuzzy
msgid "classes for which a subclass of `JsonbSerializer` / `JsonbDeserializer` is present, as described in xref:jsonb-serialization[Serializing via JSON-B]"
msgstr "classes para as quais está presente uma subclasse de `JsonbSerializer` / `JsonbDeserializer`, tal como descrito em  link:#jsonb-serialization[Serialização via JSON-B]"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1862
#, fuzzy
msgid "it is technically not needed to subclass `JsonbSerializer`, but in such case, autodetection isn't possible"
msgstr "tecnicamente não é necessário subclasse `JsonbSerializer`, mas, nesse caso, a deteção automática não é possível"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1864
#, fuzzy
msgid "If a serializer/deserializer is set by configuration, it won't be replaced by the autodetection."
msgstr "Se um serializador/desserializador for definido pela configuração, não será substituído pela deteção automática."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1867
#, fuzzy
msgid "In case you have any issues with serializer autodetection, you can switch it off completely by setting `quarkus.reactive-messaging.kafka.serializer-autodetection.enabled=false`.  If you find you need to do this, please file a bug in the link:https://github.com/quarkusio/quarkus/issues[Quarkus issue tracker] so we can fix whatever problem you have."
msgstr "Caso tenha algum problema com a deteção automática do serializador, pode desligá-la completamente definindo `quarkus.reactive-messaging.kafka.serializer-autodetection.enabled=false`. Se achar que precisa de fazer isto, registe um erro no  link:https://github.com/quarkusio/quarkus/issues[rastreador de problemas do Quarkus] para que possamos resolver o seu problema."

#. type: Title ==
#: upstream/_guides/kafka.adoc:1869
#, fuzzy, no-wrap
msgid "JSON Serializer/deserializer generation"
msgstr "Geração de serializador/desserializador JSON"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1871
#, fuzzy
msgid "Quarkus automatically generates serializers and deserializers for channels where:"
msgstr "O Quarkus gera automaticamente serializadores e desserializadores para canais onde:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1873
#, fuzzy
msgid "the serializer/deserializer is not configured"
msgstr "o serializador/desserializador não está configurado"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1874
#, fuzzy
msgid "the auto-detection did not find a matching serializer/deserializer"
msgstr "a deteção automática não encontrou um serializador/desserializador correspondente"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1876
#, fuzzy
msgid "It uses Jackson underneath."
msgstr "Utiliza Jackson por baixo."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1878
#, fuzzy
msgid "This generation can be disabled using:"
msgstr "Esta geração pode ser desactivada utilizando:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1882
#, no-wrap
msgid "quarkus.reactive-messaging.kafka.serializer-generation.enabled=false\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1886
#, fuzzy
msgid "Generation does not support collections such as `List<Fruit>`.  Refer to xref:jackson-serialization[Serializing via Jackson] to write your own serializer/deserializer for this case."
msgstr "Generation não suporta colecções como `List&amp;lt;Fruit&amp;gt;`. Consulte  link:#jackson-serialization[Serialização via Jackson] para escrever seu próprio serializador/desserializador para este caso."

#. type: Title ==
#: upstream/_guides/kafka.adoc:1887
#, fuzzy, no-wrap
msgid "Using Schema Registry"
msgstr "Utilização do registo de esquemas"

#. type: Title ==
#: upstream/_guides/kafka.adoc:1892
#, fuzzy, no-wrap
msgid "Health Checks"
msgstr "Controlos de saúde"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1896
#, fuzzy
msgid "Quarkus provides several health checks for Kafka.  These checks are used in combination with the `quarkus-smallrye-health` extension."
msgstr "O Quarkus fornece vários controlos de saúde para o Kafka. Estes controlos são utilizados em combinação com a extensão `quarkus-smallrye-health`."

#. type: Title ===
#: upstream/_guides/kafka.adoc:1897
#, fuzzy, no-wrap
msgid "Kafka Broker Readiness Check"
msgstr "Verificação de prontidão do corretor Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1902
#, fuzzy
msgid "When using the `quarkus-kafka-client` extension, you can enable _readiness_ health check by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.  This check reports the status of the interaction with a _default_ Kafka broker (configured using `kafka.bootstrap.servers`).  It requires an _admin connection_ with the Kafka broker, and it is disabled by default.  If enabled, when you access the `/q/health/ready` endpoint of your application, you will have information about the connection validation status."
msgstr "Ao utilizar a extensão `quarkus-kafka-client`, pode ativar a verificação da _prontidão_ definindo a propriedade `quarkus.kafka.health.enabled` para `true` no seu `application.properties`. Esta verificação informa o estado da interação com um corretor Kafka _predefinido_ (configurado com `kafka.bootstrap.servers`). Requer uma _ligação de administrador_ com o corretor Kafka e está desactivada por predefinição. Se estiver activada, quando aceder ao ponto de extremidade `/q/health/ready` da sua aplicação, terá informações sobre o estado de validação da ligação."

#. type: Title ===
#: upstream/_guides/kafka.adoc:1903
#, fuzzy, no-wrap
msgid "Kafka Reactive Messaging Health Checks"
msgstr "Verificações de integridade de mensagens reactivas Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1905
#, fuzzy
msgid "When using Reactive Messaging and the Kafka connector, each configured channel (incoming or outgoing) provides _startup_, _liveness_ and _readiness_ checks."
msgstr "Ao utilizar o serviço de mensagens reactivas e o conetor Kafka, cada canal configurado (de entrada ou de saída) fornece verificações _de arranque_, de _atividade_ e de _prontidão_."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1907
#, fuzzy
msgid "The _startup_ check verifies that the communication with Kafka cluster is established."
msgstr "A verificação de _arranque_ verifica se a comunicação com o cluster Kafka está estabelecida."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1908
#, fuzzy
msgid "The _liveness_ check captures any unrecoverable failure happening during the communication with Kafka."
msgstr "A verificação _da vivacidade_ capta qualquer falha irrecuperável que ocorra durante a comunicação com o Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1909
#, fuzzy
msgid "The _readiness_ check verifies that the Kafka connector is ready to consume/produce messages to the configured Kafka topics."
msgstr "A verificação de _prontidão_ verifica se o conetor Kafka está pronto para consumir/produzir mensagens para os tópicos Kafka configurados."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1911
#, fuzzy
msgid "For each channel, you can disable the checks using:"
msgstr "Para cada canal, é possível desativar as verificações utilizando:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1915
#, no-wrap
msgid "# Disable both liveness and readiness checks with `health-enabled=false`:\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1920
#, no-wrap
msgid ""
"# Incoming channel (receiving records form Kafka)\n"
"mp.messaging.incoming.your-channel.health-enabled=false\n"
"# Outgoing channel (writing records to Kafka)\n"
"mp.messaging.outgoing.your-channel.health-enabled=false\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1922
#, no-wrap
msgid "# Disable only the readiness check with `health-readiness-enabled=false`:\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1925
#, no-wrap
msgid ""
"mp.messaging.incoming.your-channel.health-readiness-enabled=false\n"
"mp.messaging.outgoing.your-channel.health-readiness-enabled=false\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1929
#, fuzzy
msgid "You can configure the `bootstrap.servers` for each channel using `mp.messaging.incoming|outgoing.$channel.bootstrap.servers` property.  Default is `kafka.bootstrap.servers`."
msgstr "Pode configurar o `bootstrap.servers` para cada canal utilizando a propriedade `mp.messaging.incoming|outgoing.$channel.bootstrap.servers`. A predefinição é `kafka.bootstrap.servers`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1933
#, fuzzy
msgid "Reactive Messaging _startup_ and _readiness_ checks offer two strategies.  The default strategy verifies that an active connection is established with the broker.  This approach is not intrusive as it's based on built-in Kafka client metrics."
msgstr "As verificações de _arranque_ e _prontidão_ do Reactive Messaging oferecem duas estratégias. A estratégia padrão verifica se uma conexão ativa foi estabelecida com o corretor. Esta abordagem não é intrusiva, uma vez que se baseia em métricas de cliente Kafka incorporadas."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1937
#, fuzzy
msgid "Using the `health-topic-verification-enabled=true` attribute, _startup_ probe uses an _admin client_ to check for the list of topics.  Whereas the _readiness_ probe for an incoming channel checks that at least one partition is assigned for consumption, and for an outgoing channel checks that the topic used by the producer exist in the broker."
msgstr "Utilizando o atributo `health-topic-verification-enabled=true`, a sonda _de arranque_ utiliza um _cliente administrativo_ para verificar a lista de tópicos. Já a sonda de _prontidão_ para um canal de entrada verifica se pelo menos uma partição está atribuída para consumo e, para um canal de saída, verifica se o tópico utilizado pelo produtor existe no corretor."

#. type: Plain text
#: upstream/_guides/kafka.adoc:1940
#, fuzzy
msgid "Note that to achieve this, an _admin connection_ is required.  You can adjust the timeout for topic verification calls to the broker using the `health-topic-verification-timeout` configuration."
msgstr "Observe que, para isso, é necessária uma _conexão de administrador_. É possível ajustar o tempo limite para chamadas de verificação de tópicos para o intermediário usando a configuração `health-topic-verification-timeout`."

#. type: Title ==
#: upstream/_guides/kafka.adoc:1941
#, fuzzy, no-wrap
msgid "Kafka Streams"
msgstr "Fluxos Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1944
#, fuzzy
msgid "This is described in a dedicated guide: xref:kafka-streams.adoc[Using Apache Kafka Streams]."
msgstr "Isso é descrito em um guia dedicado:  link:kafka-streams.html[Utilização do Apache Kafka Streams]."

#. type: Title ==
#: upstream/_guides/kafka.adoc:1945
#, fuzzy, no-wrap
msgid "Using Snappy for message compression"
msgstr "Utilização do Snappy para compressão de mensagens"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1948
#, fuzzy
msgid "On _outgoing_ channels, you can enable Snappy compression by setting the `compression.type` attribute to `snappy`:"
msgstr "Nos canais _de saída_, pode ativar a compressão Snappy definindo o atributo `compression.type` para `snappy`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1952
#, no-wrap
msgid "mp.messaging.outgoing.fruit-out.compression.type=snappy\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1956
#, fuzzy
msgid "In JVM mode, it will work out of the box.  However, to compile your application to a native executable, you need to:"
msgstr "No modo JVM, ele funcionará imediatamente. No entanto, para compilar a aplicação para um executável nativo, é necessário:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1958
#, fuzzy
msgid "Uses GraalVM 21.+"
msgstr "Usa GraalVM 21.+"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1959
#, fuzzy
msgid "Add `quarkus.kafka.snappy.enabled=true` to your `application.properties`"
msgstr "Adicionar `quarkus.kafka.snappy.enabled=true` ao seu `application.properties`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1961
#, fuzzy
msgid "In native mode, Snappy is disabled by default as the use of Snappy requires embedding a native library and unpacking it when the application starts."
msgstr "No modo nativo, o Snappy está desativado por predefinição, uma vez que a utilização do Snappy requer a incorporação de uma biblioteca nativa e a sua descompactação quando a aplicação é iniciada."

#. type: Title ==
#: upstream/_guides/kafka.adoc:1962
#, fuzzy, no-wrap
msgid "Authentication with OAuth"
msgstr "Autenticação com OAuth"

#. type: Plain text
#: upstream/_guides/kafka.adoc:1966
#, fuzzy
msgid "If your Kafka broker uses OAuth as authentication mechanism, you need to configure the Kafka consumer to enable this authentication process.  First, add the following dependency to your application:"
msgstr "Se o seu corretor Kafka utiliza o OAuth como mecanismo de autenticação, é necessário configurar o consumidor Kafka para ativar este processo de autenticação. Primeiro, adicione a seguinte dependência à sua aplicação:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1974
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.strimzi</groupId>\n"
"    <artifactId>kafka-oauth-client</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1980
#, no-wrap
msgid "implementation(\"io.strimzi:kafka-oauth-client\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1984
#, fuzzy
msgid "This dependency provides the callback handler required to handle the OAuth workflow.  Then, in the `application.properties`, add:"
msgstr "Essa dependência fornece o manipulador de retorno de chamada necessário para lidar com o fluxo de trabalho do OAuth. Em seguida, no site `application.properties`, adicione:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1994
#, no-wrap
msgid ""
"mp.messaging.connector.smallrye-kafka.security.protocol=SASL_PLAINTEXT\n"
"mp.messaging.connector.smallrye-kafka.sasl.mechanism=OAUTHBEARER\n"
"mp.messaging.connector.smallrye-kafka.sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n"
"  oauth.client.id=\"team-a-client\" \\\n"
"  oauth.client.secret=\"team-a-client-secret\" \\\n"
"  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n"
"mp.messaging.connector.smallrye-kafka.sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:1996
#, no-wrap
msgid "quarkus.ssl.native=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:1999
#, fuzzy
msgid "Update the `oauth.client.id`, `oauth.client.secret` and `oauth.token.endpoint.uri` values."
msgstr "Atualizar os valores `oauth.client.id`, `oauth.client.secret` e `oauth.token.endpoint.uri`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2001
#, fuzzy
msgid "OAuth authentication works for both JVM and native modes. Since SSL in not enabled by default in native mode, `quarkus.ssl.native=true` must be added to support JaasClientOauthLoginCallbackHandler, which uses SSL. (See the xref:native-and-ssl.adoc[Using SSL with Native Executables] guide for more details.)"
msgstr "A autenticação OAuth funciona nos modos JVM e nativo. Como o SSL não é habilitado por padrão no modo nativo, `quarkus.ssl.native=true` deve ser adicionado para dar suporte ao JaasClientOauthLoginCallbackHandler, que usa SSL. (Consulte o guia  link:native-and-ssl.html[Usando SSL com executáveis nativos] para obter mais detalhes)."

#. type: Title ==
#: upstream/_guides/kafka.adoc:2002
#, fuzzy, no-wrap
msgid "Testing a Kafka application"
msgstr "Testar uma aplicação Kafka"

#. type: Title ===
#: upstream/_guides/kafka.adoc:2004
#, fuzzy, no-wrap
msgid "Testing without a broker"
msgstr "Testar sem um corretor"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2008
#, fuzzy
msgid "It can be useful to test the application without having to start a Kafka broker.  To achieve this, you can _switch_ the channels managed by the Kafka connector to _in-memory_."
msgstr "Pode ser útil testar a aplicação sem ter de iniciar um corretor Kafka. Para o conseguir, pode _mudar_ os canais geridos pelo conetor Kafka para a _memória_."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2010
#, fuzzy
msgid "This approach only works for JVM tests. It cannot be used for native tests (because they do not support injection)."
msgstr "Esta abordagem só funciona para testes JVM. Não pode ser utilizada para testes nativos (porque estes não suportam a injeção)."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2012
#, fuzzy
msgid "Let's say we want to test the following processor application:"
msgstr "Digamos que queremos testar a seguinte aplicação de processador:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2017 upstream/_guides/kafka.adoc:2130
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class BeverageProcessor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2029
#, no-wrap
msgid ""
"    @Incoming(\"orders\")\n"
"    @Outgoing(\"beverages\")\n"
"    Beverage process(Order order) {\n"
"        System.out.println(\"Order received \" + order.getProduct());\n"
"        Beverage beverage = new Beverage();\n"
"        beverage.setBeverage(order.getProduct());\n"
"        beverage.setCustomer(order.getCustomer());\n"
"        beverage.setOrderId(order.getOrderId());\n"
"        beverage.setPreparationState(\"RECEIVED\");\n"
"        return beverage;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2034
#, fuzzy
msgid "First, add the following test dependency to your application:"
msgstr "Em primeiro lugar, adicione a seguinte dependência de teste à sua aplicação:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2043
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.smallrye.reactive</groupId>\n"
"    <artifactId>smallrye-reactive-messaging-in-memory</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2049
#, no-wrap
msgid "testImplementation(\"io.smallrye.reactive:smallrye-reactive-messaging-in-memory\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2052
#, fuzzy
msgid "Then, create a Quarkus Test Resource as follows:"
msgstr "Em seguida, crie um recurso de teste Quarkus da seguinte forma:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2056
#, no-wrap
msgid "public class KafkaTestResourceLifecycleManager implements QuarkusTestResourceLifecycleManager {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2066
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        Map<String, String> env = new HashMap<>();\n"
"        Map<String, String> props1 = InMemoryConnector.switchIncomingChannelsToInMemory(\"orders\");     // <1>\n"
"        Map<String, String> props2 = InMemoryConnector.switchOutgoingChannelsToInMemory(\"beverages\");  // <2>\n"
"        env.putAll(props1);\n"
"        env.putAll(props2);\n"
"        return env;  // <3>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2072
#, no-wrap
msgid ""
"    @Override\n"
"    public void stop() {\n"
"        InMemoryConnector.clear();  // <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2074
#, fuzzy
msgid "Switch the incoming channel `orders` (expecting messages from Kafka) to in-memory."
msgstr "Muda o canal de entrada `orders` (esperando mensagens do Kafka) para na memória."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2075
#, fuzzy
msgid "Switch the outgoing channel `beverages` (writing messages to Kafka) to in-memory."
msgstr "Mudar o canal de saída `beverages` (escrever mensagens para o Kafka) para na memória."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2076
#, fuzzy
msgid "Builds and returns a `Map` containing all the properties required to configure the application to use in-memory channels."
msgstr "Constrói e devolve um `Map` que contém todas as propriedades necessárias para configurar a aplicação para utilizar canais na memória."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2077
#, fuzzy
msgid "When the test stops, clear the `InMemoryConnector` (discard all the received and sent messages)"
msgstr "Quando o teste parar, limpe o sítio `InMemoryConnector` (elimine todas as mensagens recebidas e enviadas)"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2079
#, fuzzy
msgid "Create a Quarkus Test using the test resource created above:"
msgstr "Crie um teste Quarkus utilizando o recurso de teste criado acima:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2083 upstream/_guides/kafka.adoc:2142
#, no-wrap
msgid "import static org.awaitility.Awaitility.await;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2087 upstream/_guides/kafka.adoc:2146
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@QuarkusTestResource(KafkaTestResourceLifecycleManager.class)\n"
"class BaristaTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2091
#, no-wrap
msgid ""
"    @Inject\n"
"    @Connector(\"smallrye-in-memory\")\n"
"    InMemoryConnector connector; // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2096
#, no-wrap
msgid ""
"    @Test\n"
"    void testProcessOrder() {\n"
"        InMemorySource<Order> ordersIn = connector.source(\"orders\");     // <2>\n"
"        InMemorySink<Beverage> beveragesOut = connector.sink(\"beverages\");  // <3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2101
#, no-wrap
msgid ""
"        Order order = new Order();\n"
"        order.setProduct(\"coffee\");\n"
"        order.setName(\"Coffee lover\");\n"
"        order.setOrderId(\"1234\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2103
#, no-wrap
msgid "        ordersIn.send(order);  // <4>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2105
#, no-wrap
msgid "        await().<List<? extends Message<Beverage>>>until(beveragesOut::received, t -> t.size() == 1); // <5>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2112
#, no-wrap
msgid ""
"        Beverage queuedBeverage = beveragesOut.received().get(0).getPayload();\n"
"        Assertions.assertEquals(Beverage.State.READY, queuedBeverage.getPreparationState());\n"
"        Assertions.assertEquals(\"coffee\", queuedBeverage.getBeverage());\n"
"        Assertions.assertEquals(\"Coffee lover\", queuedBeverage.getCustomer());\n"
"        Assertions.assertEquals(\"1234\", queuedBeverage.getOrderId());\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2116
#, fuzzy
msgid "Inject the in-memory connector in your test class."
msgstr "Injecte o conetor na memória na sua classe de teste."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2117
#, fuzzy
msgid "Retrieve the incoming channel (`orders`) - the channel must have been switched to in-memory in the test resource."
msgstr "Recuperar o canal de entrada ( `orders`) - o canal deve ter sido mudado para a memória no recurso de teste."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2118
#, fuzzy
msgid "Retrieve the outgoing channel (`beverages`) - the channel must have been switched to in-memory in the test resource."
msgstr "Recuperar o canal de saída ( `beverages`) - o canal deve ter sido mudado para a memória no recurso de teste."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2120
#, fuzzy
msgid "Use the `send` method to send a message to the `orders` channel.  The application will process this message and send a message to `beverages` channel."
msgstr "Utilize o método `send` para enviar uma mensagem para o canal `orders`. A aplicação processará esta mensagem e enviará uma mensagem para o canal `beverages`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2121
#, fuzzy
msgid "Use the `received` method on `beverages` channel to check the messages produced by the application."
msgstr "Utilize o método `received` no canal `beverages` para verificar as mensagens produzidas pela aplicação."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2123
#, fuzzy
msgid "If your Kafka consumer is batch based, you will need to send a batch of messages to the channel as by creating them manually."
msgstr "Se o seu consumidor Kafka for baseado em lotes, você precisará enviar um lote de mensagens para o canal, criando-as manualmente."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2125
#, fuzzy
msgid "For instance:"
msgstr "Por exemplo:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2137
#, no-wrap
msgid ""
"    @Incoming(\"orders\")\n"
"    CompletionStage<Void> process(KafkaRecordBatch<String, Order> orders) {\n"
"        System.out.println(\"Order received \" + orders.getPayload().size());\n"
"        return orders.ack();\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2149
#, no-wrap
msgid ""
"    @Inject\n"
"    @Connector(\"smallrye-in-memory\")\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2151
#, no-wrap
msgid "    InMemoryConnector connector;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2169
#, no-wrap
msgid ""
"    @Test\n"
"    void testProcessOrder() {\n"
"        InMemorySource<IncomingKafkaRecordBatch<String, Order>> ordersIn = connector.source(\"orders\");\n"
"        var committed = new AtomicBoolean(false);  // <1>\n"
"        var commitHandler = new KafkaCommitHandler() {\n"
"            @Override\n"
"            public <K, V> Uni<Void> handle(IncomingKafkaRecord<K, V> record) {\n"
"                committed.set(true);  // <2>\n"
"                return null;\n"
"            }\n"
"        };\n"
"        var failureHandler = new KafkaFailureHandler() {\n"
"            @Override\n"
"            public <K, V> Uni<Void> handle(IncomingKafkaRecord<K, V> record, Throwable reason, Metadata metadata) {\n"
"                return null;\n"
"            }\n"
"        };\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2178
#, no-wrap
msgid ""
"        Order order = new Order();\n"
"        order.setProduct(\"coffee\");\n"
"        order.setName(\"Coffee lover\");\n"
"        order.setOrderId(\"1234\");\n"
"        var record = new ConsumerRecord<>(\"topic\", 0, 0, \"key\", order);\n"
"        var records = new ConsumerRecords<>(Map.of(new TopicPartition(\"topic\", 1), List.of(record)));\n"
"        var batch = new IncomingKafkaRecordBatch<>(\n"
"            records, \"kafka\", 0, commitHandler, failureHandler, false, false);  // <3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2180
#, no-wrap
msgid "        ordersIn.send(batch);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2184
#, no-wrap
msgid ""
"        await().until(committed::get);  // <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2186
#, fuzzy
msgid "Create an `AtomicBoolean` to track if the batch has been committed."
msgstr "Crie um `AtomicBoolean` para rastrear se o lote foi confirmado."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2187
#, fuzzy
msgid "Update `committed` when the batch is committed."
msgstr "Atualize `committed` quando o lote for confirmado."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2188
#, fuzzy
msgid "Create a `IncomingKafkaRecordBatch` with a single record."
msgstr "Crie um `IncomingKafkaRecordBatch` com um único registro."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2189
#, fuzzy
msgid "Wait until the batch is committed."
msgstr "Aguarde até que o lote seja confirmado."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:2194
#, fuzzy
msgid "With in-memory channels we were able to test application code processing messages without starting a Kafka broker.  Note that different in-memory channels are independent, and switching channel connector to in-memory does not simulate message delivery between channels configured to the same Kafka topic."
msgstr "Com os canais na memória, pudemos testar o código do aplicativo processando mensagens sem iniciar um corretor Kafka. Observe que diferentes canais na memória são independentes e a mudança do conetor do canal para a memória não simula a entrega de mensagens entre canais configurados para o mesmo tópico do Kafka."

#. type: Title ===
#: upstream/_guides/kafka.adoc:2196
#, fuzzy, no-wrap
msgid "Testing using a Kafka broker"
msgstr "Testar utilizando um corretor Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2201
#, fuzzy
msgid "If you are using xref:kafka-dev-services[Dev Services for Kafka], a Kafka broker will be started and available throughout the tests, unless it is disabled in `%test` profile.  While it is possible to connect to this broker using Kafka Clients API, https://smallrye.io/smallrye-reactive-messaging/latest/kafka/test-companion/[Kafka Companion Library] proposes an easier way of interacting with a Kafka broker and, creating consumer, producer and admin actions inside tests."
msgstr "Se estiver a utilizar Dev  link:#kafka-dev-services[Services for Kafka], um corretor Kafka será iniciado e estará disponível durante os testes, a menos que esteja desativado no perfil `%test`. Embora seja possível ligar-se a este corretor utilizando a API de clientes Kafka,  link:https://smallrye.io/smallrye-reactive-messaging/latest/kafka/test-companion/[a biblioteca Kafka Companion] propõe uma forma mais fácil de interagir com um corretor Kafka e criar acções de consumidor, produtor e administrador dentro dos testes."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2203
#, fuzzy
msgid "For using `KafkaCompanion` API in tests, start by adding the following dependency:"
msgstr "Para utilizar a API `KafkaCompanion` nos testes, comece por adicionar a seguinte dependência:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2211
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-test-kafka-companion</artifactId>\n"
"    <scope>test</scope>\n"
"</dependency>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2214
#, fuzzy
msgid "which provides `io.quarkus.test.kafka.KafkaCompanionResource` - an implementation of `io.quarkus.test.common.QuarkusTestResourceLifecycleManager`."
msgstr "que fornece `io.quarkus.test.kafka.KafkaCompanionResource` - uma implementação de `io.quarkus.test.common.QuarkusTestResourceLifecycleManager`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2216
#, fuzzy
msgid "Then use `@QuarkusTestResource` to configure the Kafka Companion in tests, for example:"
msgstr "Em seguida, utilize `@QuarkusTestResource` para configurar o Kafka Companion em testes, por exemplo:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2220
#, no-wrap
msgid "import static org.junit.jupiter.api.Assertions.assertEquals;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2222
#, no-wrap
msgid "import java.util.UUID;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2225
#, no-wrap
msgid ""
"import org.apache.kafka.clients.producer.ProducerRecord;\n"
"import org.junit.jupiter.api.Test;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2232
#, no-wrap
msgid ""
"import io.quarkus.test.common.QuarkusTestResource;\n"
"import io.quarkus.test.junit.QuarkusTest;\n"
"import io.quarkus.test.kafka.InjectKafkaCompanion;\n"
"import io.quarkus.test.kafka.KafkaCompanionResource;\n"
"import io.smallrye.reactive.messaging.kafka.companion.ConsumerTask;\n"
"import io.smallrye.reactive.messaging.kafka.companion.KafkaCompanion;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2236
#, no-wrap
msgid ""
"@QuarkusTest\n"
"@QuarkusTestResource(KafkaCompanionResource.class)\n"
"public class OrderProcessorTest {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2239
#, no-wrap
msgid ""
"    @InjectKafkaCompanion // <1>\n"
"    KafkaCompanion companion;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2243
#, no-wrap
msgid ""
"    @Test\n"
"    void testProcessor() {\n"
"        companion.produceStrings().usingGenerator(i -> new ProducerRecord<>(\"orders\", UUID.randomUUID().toString())); // <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2245
#, no-wrap
msgid "        // Expect that the tested application processes orders from 'orders' topic and write to 'orders-processed' topic\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2251
#, no-wrap
msgid ""
"        ConsumerTask<String, String> orders = companion.consumeStrings().fromTopics(\"orders-processed\", 10); // <3>\n"
"        orders.awaitCompletion(); // <4>\n"
"        assertEquals(10, orders.count());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2254
#, fuzzy
msgid "`@InjectKafkaCompanion` injects the `KafkaCompanion` instance, configured to access the Kafka broker created for tests."
msgstr "`@InjectKafkaCompanion` injecta a instância `KafkaCompanion`, configurada para aceder ao corretor Kafka criado para os testes."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2255
#, fuzzy
msgid "Use `KafkaCompanion` to create producer task which writes 10 records to 'orders' topic."
msgstr "Utilize `KafkaCompanion` para criar uma tarefa de produção que escreva 10 registos no tópico \"encomendas\"."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2256
#, fuzzy
msgid "Create consumer task which subscribes to 'orders-processed' topic and consumes 10 records."
msgstr "Crie uma tarefa de consumidor que subscreva o tópico 'orders-processed' e consuma 10 registos."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2257
#, fuzzy
msgid "Await completion of the consumer task."
msgstr "Aguardar a conclusão da tarefa do consumidor."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:2261
#, fuzzy
msgid "If the Kafka Dev Service is available during tests, `KafkaCompanionResource` uses the created Kafka broker, otherwise it creates a Kafka broker using https://github.com/strimzi/test-container[Strimzi Test Container]."
msgstr "Se o Kafka Dev Service estiver disponível durante os testes, `KafkaCompanionResource` utiliza o corretor Kafka criado, caso contrário cria um corretor Kafka utilizando o  link:https://github.com/strimzi/test-container[Strimzi Test Container]."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:2263
#, fuzzy
msgid "The configuration of the created Kafka broker can be customized using `@ResourceArg`, for example:"
msgstr "A configuração do corretor Kafka criado pode ser personalizada utilizando `@ResourceArg`, por exemplo:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2274
#, no-wrap
msgid ""
"@QuarkusTestResource(value = KafkaCompanionResource.class, initArgs = {\n"
"        @ResourceArg(name = \"strimzi.kafka.image\", value = \"quay.io/strimzi/kafka:0.28.0-kafka-3.0.0\"), // Image name\n"
"        @ResourceArg(name = \"kafka.port\", value = \"9092\"), // Fixed port for kafka, by default it will be exposed on a random port\n"
"        @ResourceArg(name = \"kraft\", value = \"true\"), // Enable Kraft mode\n"
"        @ResourceArg(name = \"num.partitions\", value = \"3\"), // Other custom broker configurations\n"
"})\n"
"public class OrderProcessorTest {\n"
"    // ...\n"
"}\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/kafka.adoc:2277
#, fuzzy, no-wrap
msgid "Custom test resource"
msgstr "Recurso de teste personalizado"

#. type: delimited block =
#: upstream/_guides/kafka.adoc:2281
#, fuzzy
msgid "Alternatively, you can start a Kafka broker in a test resource.  The following snippet shows a test resource starting a Kafka broker using https://www.testcontainers.org/modules/kafka/[Testcontainers]:"
msgstr "Em alternativa, pode iniciar um corretor Kafka num recurso de teste. O snippet a seguir mostra um recurso de teste iniciando um corretor do Kafka usando  link:https://www.testcontainers.org/modules/kafka/[Testcontainers]:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2285
#, no-wrap
msgid "public class KafkaResource implements QuarkusTestResourceLifecycleManager {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2287
#, no-wrap
msgid "    private final KafkaContainer kafka = new KafkaContainer();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2293
#, no-wrap
msgid ""
"    @Override\n"
"    public Map<String, String> start() {\n"
"        kafka.start();\n"
"        return Collections.singletonMap(\"kafka.bootstrap.servers\", kafka.getBootstrapServers());  // <1>\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2299
#, no-wrap
msgid ""
"    @Override\n"
"    public void stop() {\n"
"        kafka.close();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2301
#, fuzzy
msgid "Configure the Kafka bootstrap location, so the application connects to this broker."
msgstr "Configure a localização do Kafka bootstrap, para que a aplicação se ligue a este corretor."

#. type: Title ==
#: upstream/_guides/kafka.adoc:2308
#, fuzzy, no-wrap
msgid "Kubernetes Service Bindings"
msgstr "Ligações de serviços Kubernetes"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2313
#, fuzzy
msgid "Quarkus Kafka extension supports xref:deploying-to-kubernetes.adoc[Service Binding Specification for Kubernetes].  You can enable this by adding the `quarkus-kubernetes-service-binding` extension to your application."
msgstr "A extensão Quarkus Kafka suporta a  link:deploying-to-kubernetes.html[Especificação de Ligação de Serviço para Kubernetes]. Pode activá-la adicionando a extensão `quarkus-kubernetes-service-binding` à sua aplicação."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2315
#, fuzzy
msgid "When running in appropriately configured Kubernetes clusters, Kafka extension will pull its Kafka broker connection configuration from the service binding available inside the cluster, without the need for user configuration."
msgstr "Quando executada em clusters Kubernetes configurados adequadamente, a extensão Kafka extrairá sua configuração de conexão do broker Kafka da associação de serviços disponível dentro do cluster, sem a necessidade de configuração do usuário."

#. type: Title ==
#: upstream/_guides/kafka.adoc:2316
#, fuzzy, no-wrap
msgid "Execution model"
msgstr "Modelo de execução"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2321
#, fuzzy
msgid "Reactive Messaging invokes user's methods on an I/O thread.  Thus, by default, the methods must not block.  As described in xref:blocking-processing[Blocking processing], you need to add the `@Blocking` annotation on the method if this method will block the caller thread."
msgstr "O envio de mensagens reactivas invoca os métodos do utilizador numa thread de E/S. Assim, por defeito, os métodos não devem bloquear. Tal como descrito em  link:#blocking-processing[Processamento de bloqueio], é necessário adicionar a anotação `@Blocking` ao método se este método bloquear a thread do chamador."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2323
#, fuzzy
msgid "See the xref:quarkus-reactive-architecture.adoc[Quarkus Reactive Architecture documentation] for further details on this topic."
msgstr "Consulte a  link:quarkus-reactive-architecture.html[documentação da Arquitetura Reactiva do Quarkus] para obter mais informações sobre este tópico."

#. type: Title ==
#: upstream/_guides/kafka.adoc:2324
#, fuzzy, no-wrap
msgid "Channel Decorators"
msgstr "Decoradores de canais"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2327
#, fuzzy
msgid "SmallRye Reactive Messaging supports decorating incoming and outgoing channels for implementing cross-cutting concerns such as monitoring, tracing or message interception. For more information on implementing decorators and message interceptors see the http://smallrye.io/smallrye-reactive-messaging/latest/concepts/decorators/[SmallRye Reactive Messaging documentation]."
msgstr "SmallRye Reactive Messaging suporta a decoração de canais de entrada e saída para implementar preocupações transversais, como monitoramento, rastreamento ou intercetação de mensagens. Para mais informações sobre a implementação de decoradores e interceptadores de mensagens, veja a  link:http://smallrye.io/smallrye-reactive-messaging/3.19.1/concepts/decorators/[documentação do SmallRye Reactive Messaging]."

#. type: Title ==
#: upstream/_guides/kafka.adoc:2329
#, fuzzy, no-wrap
msgid "Configuration Reference"
msgstr "Referência de configuração"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2332
#, fuzzy
msgid "More details about the SmallRye Reactive Messaging configuration can be found in the https://smallrye.io/smallrye-reactive-messaging/latest/kafka/kafka/#using-the-kafka-connector[SmallRye Reactive Messaging - Kafka Connector Documentation]."
msgstr "Mais detalhes sobre a configuração do SmallRye Reactive Messaging podem ser encontrados na  link:https://smallrye.io/smallrye-reactive-messaging/latest/kafka/kafka/#using-the-kafka-connector[documentação do SmallRye Reactive Messaging - Kafka Connector]."

#. type: delimited block =
#: upstream/_guides/kafka.adoc:2336
#, fuzzy
msgid "Each channel can be disabled via configuration using:"
msgstr "Cada canal pode ser desativado através da configuração utilizando:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2340
#, no-wrap
msgid "mp.messaging.[incoming|outgoing].[channel].enabled=false\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/kafka.adoc:2344
#, fuzzy
msgid "The most important attributes are listed in the tables below:"
msgstr "Os atributos mais importantes são enumerados nos quadros seguintes:"

#. type: Title ===
#: upstream/_guides/kafka.adoc:2345
#, fuzzy, no-wrap
msgid "Incoming channel configuration (polling from Kafka)"
msgstr "Configuração do canal de entrada (sondagem a partir do Kafka)"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2348 upstream/_guides/kafka.adoc:2387
#, fuzzy
msgid "The following attributes are configured using:"
msgstr "Os seguintes atributos são configurados utilizando:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2352
#, no-wrap
msgid "mp.messaging.incoming.your-channel-name.attribute=value\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2355 upstream/_guides/kafka.adoc:2394
#, fuzzy
msgid "Some properties have aliases which can be configured globally:"
msgstr "Algumas propriedades têm pseudónimos que podem ser configurados globalmente:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2359 upstream/_guides/kafka.adoc:2398
#, no-wrap
msgid "kafka.bootstrap.servers=...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2362
#, fuzzy
msgid "You can also pass any property supported by the underlying https://kafka.apache.org/documentation/#consumerconfigs[Kafka consumer]."
msgstr "Também pode passar qualquer propriedade suportada pelo  link:https://kafka.apache.org/documentation/#consumerconfigs[consumidor Kafka] subjacente."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2364
#, fuzzy
msgid "For example, to configure the `max.poll.records` property, use:"
msgstr "Por exemplo, para configurar a propriedade `max.poll.records`, utilize:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2368
#, no-wrap
msgid "mp.messaging.incoming.[channel].max.poll.records=1000\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2371
#, fuzzy
msgid "Some consumer client properties are configured to sensible default values:"
msgstr "Algumas propriedades do cliente consumidor são configuradas com valores predefinidos sensíveis:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2373 upstream/_guides/kafka.adoc:2412
#, fuzzy
msgid "If not set, `reconnect.backoff.max.ms` is set to `10000` to avoid high load on disconnection."
msgstr "Se não estiver definido, `reconnect.backoff.max.ms` é definido para `10000` para evitar uma carga elevada aquando da desconexão."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2375
#, fuzzy
msgid "If not set, `key.deserializer` is set to `org.apache.kafka.common.serialization.StringDeserializer`."
msgstr "Se não for definido, `key.deserializer` é definido como `org.apache.kafka.common.serialization.StringDeserializer`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2377
#, fuzzy
msgid "The consumer `client.id` is configured according to the number of clients to create using `mp.messaging.incoming.[channel].partitions` property."
msgstr "O consumidor `client.id` é configurado de acordo com o número de clientes a criar utilizando a propriedade `mp.messaging.incoming.[channel].partitions`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2379
#, fuzzy
msgid "If a `client.id` is provided, it is used as-is or suffixed with client index if `partitions` property is set."
msgstr "Se for fornecido um `client.id`, este é utilizado tal e qual ou sufixado com o índice do cliente se a propriedade `partitions` estiver definida."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2380
#, fuzzy
msgid "If a `client.id` is not provided, it is generated as `[client-id-prefix][channel-name][-index]`."
msgstr "Se não for fornecido um `client.id`, este é gerado como `[client-id-prefix][channel-name][-index]`."

#. type: Title ===
#: upstream/_guides/kafka.adoc:2384
#, fuzzy, no-wrap
msgid "Outgoing channel configuration (writing to Kafka)"
msgstr "Configuração do canal de saída (escrita no Kafka)"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2391
#, no-wrap
msgid "mp.messaging.outgoing.your-channel-name.attribute=value\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2401
#, fuzzy
msgid "You can also pass any property supported by the underlying https://kafka.apache.org/documentation/#producerconfigs[Kafka producer]."
msgstr "Também pode passar qualquer propriedade suportada pelo  link:https://kafka.apache.org/documentation/#producerconfigs[produtor Kafka] subjacente."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2403
#, fuzzy
msgid "For example, to configure the `max.block.ms` property, use:"
msgstr "Por exemplo, para configurar a propriedade `max.block.ms`, utilize:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2407
#, no-wrap
msgid "mp.messaging.incoming.[channel].max.block.ms=10000\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2410
#, fuzzy
msgid "Some producer client properties are configured to sensible default values:"
msgstr "Algumas propriedades do cliente produtor são configuradas para valores predefinidos sensíveis:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2414
#, fuzzy
msgid "If not set, `key.serializer` is set to `org.apache.kafka.common.serialization.StringSerializer`."
msgstr "Se não for definido, `key.serializer` é definido como `org.apache.kafka.common.serialization.StringSerializer`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2416
#, fuzzy
msgid "If not set, producer `client.id` is generated as `[client-id-prefix][channel-name]`."
msgstr "Se não for definido, o produtor `client.id` é gerado como `[client-id-prefix][channel-name]`."

#. type: Title ===
#: upstream/_guides/kafka.adoc:2420
#, fuzzy, no-wrap
msgid "Kafka Configuration Resolution"
msgstr "Resolução de configuração do Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2424
#, fuzzy
msgid "Quarkus exposes all Kafka related application properties, prefixed with `kafka.` or `KAFKA_` inside a configuration map with `default-kafka-broker` name.  This configuration is used to establish the connection with the Kafka broker."
msgstr "O Quarkus expõe todas as propriedades da aplicação relacionadas com o Kafka, prefixadas com `kafka.` ou `KAFKA_` dentro de um mapa de configuração com o nome `default-kafka-broker`. Esta configuração é utilizada para estabelecer a ligação com o corretor Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2426
#, fuzzy
msgid "In addition to this default configuration, you can configure the name of the `Map` producer using the `kafka-configuration` attribute:"
msgstr "Para além desta configuração predefinida, pode configurar o nome do produtor `Map` utilizando o atributo `kafka-configuration`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2431
#, no-wrap
msgid ""
"mp.messaging.incoming.my-channel.connector=smallrye-kafka\n"
"mp.messaging.incoming.my-channel.kafka-configuration=my-configuration\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2435
#, fuzzy
msgid "In this case, the connector looks for the `Map` associated with the `my-configuration` name.  If `kafka-configuration` is not set, an optional lookup for a `Map` exposed with the channel name (`my-channel` in the previous example) is done."
msgstr "Neste caso, o conetor procura o `Map` associado ao nome `my-configuration`. Se `kafka-configuration` não estiver definido, é efectuada uma pesquisa opcional de um `Map` exposto com o nome do canal ( `my-channel` no exemplo anterior)."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2446
#, no-wrap
msgid ""
"@Produces\n"
"@ApplicationScoped\n"
"@Identifier(\"my-configuration\")\n"
"Map<String, Object> outgoing() {\n"
"    return Map.ofEntries(\n"
"            Map.entry(\"value.serializer\", ObjectMapperSerializer.class.getName())\n"
"    );\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2449
#, fuzzy
msgid "If `kafka-configuration` is set and no `Map` can be found, the deployment fails."
msgstr "Se `kafka-configuration` estiver definido e não for possível encontrar `Map`, a implantação falha."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2451
#, fuzzy
msgid "Attribute values are resolved as follows:"
msgstr "Os valores dos atributos são resolvidos da seguinte forma:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2453
#, fuzzy
msgid "the attribute is set directly on the channel configuration (`mp.messaging.incoming.my-channel.attribute=value`),"
msgstr "o atributo é definido diretamente na configuração do canal ( `mp.messaging.incoming.my-channel.attribute=value`),"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2454
#, fuzzy
msgid "if not set, the connector looks for a `Map` with the channel name or the configured `kafka-configuration` (if set) and the value is retrieved from that `Map`"
msgstr "Se não estiver definido, o conetor procura um `Map` com o nome do canal ou o `kafka-configuration` configurado (se definido) e o valor é obtido a partir desse `Map`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2455
#, fuzzy
msgid "If the resolved `Map` does not contain the value the default `Map` is used (exposed with the `default-kafka-broker` name)"
msgstr "Se o `Map` resolvido não contiver o valor, é utilizado o `Map` predefinido (exposto com o nome `default-kafka-broker` )"

#. type: Title ===
#: upstream/_guides/kafka.adoc:2456
#, fuzzy, no-wrap
msgid "Conditionally configure channels"
msgstr "Configurar canais condicionalmente"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2460
#, fuzzy
msgid "You can configure the channels using a specific profile.  Thus, the channels are only configured (and added to the application) when the specified profile is enabled."
msgstr "Pode configurar os canais utilizando um perfil específico. Assim, os canais só são configurados (e adicionados à aplicação) quando o perfil especificado está ativado."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2462
#, fuzzy
msgid "To achieve this, you need:"
msgstr "Para o conseguir, é necessário:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2464
#, fuzzy
msgid "Prefix the `mp.messaging.[incoming|outgoing].$channel` entries with `%my-profile` such as `%my-profile.mp.messaging.[incoming|outgoing].$channel.key=value`"
msgstr "Prefixar as entradas `mp.messaging.[incoming|outgoing].$channel` com `%my-profile` tal como `%my-profile.mp.messaging.[incoming|outgoing].$channel.key=value`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2465
#, fuzzy
msgid "Use the `@IfBuildProfile(\"my-profile\")` on the CDI beans containing `@Incoming(channel)` and `@Outgoing(channel)` annotations that need only to be enabled when the profile is enabled."
msgstr "Utilize o `@IfBuildProfile(\"my-profile\")` nos beans CDI que contêm anotações `@Incoming(channel)` e `@Outgoing(channel)` que só precisam de ser activadas quando o perfil é ativado."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2468
#, fuzzy
msgid "Note that reactive messaging verifies that the graph is complete.  So, when using such a conditional configuration, ensure the application works with and without the profile enabled."
msgstr "Note que o envio de mensagens reactivas verifica se o gráfico está completo. Assim, ao utilizar uma configuração condicional deste tipo, certifique-se de que a aplicação funciona com e sem o perfil ativado."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2470
#, fuzzy
msgid "Note that this approach can also be used to change the channel configuration based on a profile."
msgstr "Note-se que esta abordagem também pode ser utilizada para alterar a configuração do canal com base num perfil."

#. type: Title ==
#: upstream/_guides/kafka.adoc:2471
#, fuzzy, no-wrap
msgid "Integrating with Kafka - Common patterns"
msgstr "Integração com o Kafka - Padrões comuns"

#. type: Title ===
#: upstream/_guides/kafka.adoc:2473
#, fuzzy, no-wrap
msgid "Writing to Kafka from an HTTP endpoint"
msgstr "Escrever no Kafka a partir de um ponto de extremidade HTTP"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2476
#, fuzzy
msgid "To send messages to Kafka from an HTTP endpoint, inject an `Emitter` (or a `MutinyEmitter`) in your endpoint:"
msgstr "Para enviar mensagens para o Kafka a partir de um ponto de extremidade HTTP, injecte um `Emitter` (ou um `MutinyEmitter`) no seu ponto de extremidade:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2487 upstream/_guides/kafka.adoc:2535
#, no-wrap
msgid ""
"import jakarta.ws.rs.POST;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2493 upstream/_guides/kafka.adoc:2543
#: upstream/_guides/kafka.adoc:2768
#, no-wrap
msgid ""
"@Path(\"/\")\n"
"public class ResourceSendingToKafka {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2495
#, no-wrap
msgid "    @Channel(\"kafka\") Emitter<String> emitter;          // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2502
#, no-wrap
msgid ""
"    @POST\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public CompletionStage<Void> send(String payload) { // <2>\n"
"        return emitter.send(payload);                   // <3>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2504
#, fuzzy
msgid "Inject an `Emitter<String>`"
msgstr "Injetar um `Emitter&amp;lt;String&amp;gt;`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2505
#, fuzzy
msgid "The HTTP method receives the payload and returns a `CompletionStage` completed when the message is written to Kafka"
msgstr "O método HTTP recebe o payload e devolve um `CompletionStage` concluído quando a mensagem é escrita no Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2506
#, fuzzy
msgid "Send the message to Kafka, the `send` method returns a `CompletionStage`"
msgstr "Enviar a mensagem para o Kafka, o método `send` devolve um `CompletionStage`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2509
#, fuzzy
msgid "The endpoint sends the passed payload (from a `POST` HTTP request) to the emitter.  The emitter's channel is mapped to a Kafka topic in the `application.properties` file:"
msgstr "O ponto de extremidade envia a carga útil passada (de um pedido HTTP `POST` ) para o emissor. O canal do emissor é mapeado para um tópico Kafka no ficheiro `application.properties`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2514
#, no-wrap
msgid ""
"mp.messaging.outgoing.kafka.connector=smallrye-kafka\n"
"mp.messaging.outgoing.kafka.topic=my-topic\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2520
#, fuzzy
msgid "The endpoint returns a `CompletionStage` indicating the asynchronous nature of the method.  The `emitter.send` method returns a `CompletionStage<Void>` .  The returned future is completed when the message has been written to Kafka.  If the writing fails, the returned `CompletionStage` is completed exceptionally."
msgstr "O ponto final devolve um `CompletionStage` indicando a natureza assíncrona do método. O método `emitter.send` devolve um `CompletionStage&amp;lt;Void&amp;gt;`. O futuro devolvido é concluído quando a mensagem tiver sido escrita no Kafka. Se a escrita falhar, o `CompletionStage` devolvido é concluído excecionalmente."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2522
#, fuzzy
msgid "If the endpoint does not return a `CompletionStage`, the HTTP response may be written before the message is sent to Kafka, and so failures won't be reported to the user."
msgstr "Se o ponto final não devolver um `CompletionStage`, a resposta HTTP pode ser escrita antes de a mensagem ser enviada para o Kafka, pelo que as falhas não serão comunicadas ao utilizador."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2524
#, fuzzy
msgid "If you need to send a Kafka record, use:"
msgstr "Se precisar de enviar um registo Kafka, utilize:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2540
#, no-wrap
msgid "import io.smallrye.reactive.messaging.kafka.Record;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2545
#, no-wrap
msgid "    @Channel(\"kafka\") Emitter<Record<String,String>> emitter;  // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2553
#, no-wrap
msgid ""
"    @POST\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public CompletionStage<Void> send(String payload) {\n"
"        return emitter.send(Record.of(\"my-key\", payload));    // <2>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2555
#, fuzzy
msgid "Note the usage of an `Emitter<Record<K, V>>`"
msgstr "Note-se a utilização de um `Emitter&amp;lt;Record&amp;lt;K, V&amp;gt;&amp;gt;`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2556
#, fuzzy
msgid "Create the record using `Record.of(k, v)`"
msgstr "Criar o registo utilizando `Record.of(k, v)`"

#. type: Title ===
#: upstream/_guides/kafka.adoc:2557
#, fuzzy, no-wrap
msgid "Persisting Kafka messages with Hibernate with Panache"
msgstr "Persistência de mensagens Kafka com o Hibernate com Panache"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2560
#, fuzzy
msgid "To persist objects received from Kafka into a database, you can use Hibernate with Panache."
msgstr "Para persistir objectos recebidos do Kafka numa base de dados, pode utilizar o Hibernate com o Panache."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2562
#, fuzzy
msgid "If you use Hibernate Reactive, look at xref:persisting-kafka-messages-with-hibernate-reactive[Persisting Kafka messages with Hibernate Reactive]."
msgstr "Se utilizar o Hibernate Reactive, consulte  link:#persisting-kafka-messages-with-hibernate-reactive[Persisting Kafka messages with Hibernate Reactive]."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2565 upstream/_guides/kafka.adoc:2645
#, fuzzy
msgid "Let's imagine you receive `Fruit` objects.  For simplicity purposes, our `Fruit` class is pretty simple:"
msgstr "Imaginemos que recebe objectos `Fruit`. Para simplificar, a nossa classe `Fruit` é bastante simples:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2573
#, no-wrap
msgid "import io.quarkus.hibernate.orm.panache.PanacheEntity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2576 upstream/_guides/kafka.adoc:2656
#, no-wrap
msgid ""
"@Entity\n"
"public class Fruit extends PanacheEntity {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2578 upstream/_guides/kafka.adoc:2658
#, no-wrap
msgid "    public String name;\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2583 upstream/_guides/kafka.adoc:2664
#, fuzzy
msgid "To consume `Fruit` instances stored on a Kafka topic, and persist them into a database, you can use the following approach:"
msgstr "Para consumir instâncias do `Fruit` armazenadas num tópico do Kafka e mantê-las numa base de dados, pode utilizar a seguinte abordagem:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2594
#, no-wrap
msgid "import io.smallrye.common.annotation.Blocking;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2597
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class FruitConsumer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2604
#, no-wrap
msgid ""
"    @Incoming(\"fruits\")                                     // <1>\n"
"    @Transactional                                          // <2>\n"
"    public void persistFruits(Fruit fruit) {                // <3>\n"
"        fruit.persist();                                    // <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2606
#, fuzzy
msgid "Configuring the incoming channel. This channel reads from Kafka."
msgstr "Configuração do canal de entrada. Este canal lê a partir do Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2608
#, fuzzy
msgid "As we are writing in a database, we must be in a transaction. This annotation starts a new transaction and commits it when the method returns.  Quarkus automatically considers the method as _blocking_. Indeed, writing to a database using classic Hibernate is blocking. So, Quarkus calls the method on a worker thread you can block (and not an I/O thread)."
msgstr "Como estamos a escrever numa base de dados, temos de estar numa transação. Esta anotação inicia uma nova transação e confirma-a quando o método regressa. O Quarkus considera automaticamente o método como _bloqueante_. De facto, escrever numa base de dados utilizando o Hibernate clássico é bloqueante. Assim, o Quarkus chama o método numa thread de trabalho que pode bloquear (e não numa thread de E/S)."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2609
#, fuzzy
msgid "The method receives each Fruit. Note that you would need a deserializer to reconstruct the Fruit instances from the Kafka records."
msgstr "O método recebe cada Fruit. Note-se que seria necessário um desserializador para reconstruir as instâncias Fruit a partir dos registos Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2610
#, fuzzy
msgid "Persist the received `fruit` object."
msgstr "Persiste o objeto `fruit` recebido."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2613
#, fuzzy
msgid "As mentioned in <4>, you need a deserializer that can create a `Fruit` from the record.  This can be done using a Jackson deserializer:"
msgstr "Como mencionado em &lt;4&gt;, é necessário um desserializador que possa criar um `Fruit` a partir do registo. Isso pode ser feito usando um desserializador Jackson:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2628 upstream/_guides/kafka.adoc:2724
#, fuzzy
msgid "The associated configuration would be:"
msgstr "A configuração associada seria:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2633 upstream/_guides/kafka.adoc:2729
#, no-wrap
msgid ""
"mp.messaging.incoming.fruits.connector=smallrye-kafka\n"
"mp.messaging.incoming.fruits.value.deserializer=org.acme.FruitDeserializer\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2637 upstream/_guides/kafka.adoc:2733
#, fuzzy
msgid "Check xref:jackson-serialization[Serializing via Jackson] for more detail about the usage of Jackson with Kafka.  You can also use Avro."
msgstr "Consulte  link:#jackson-serialization[Serialização via Jackson] para obter mais detalhes sobre a utilização do Jackson com o Kafka. Também é possível usar o Avro."

#. type: Title ===
#: upstream/_guides/kafka.adoc:2639
#, fuzzy, no-wrap
msgid "Persisting Kafka messages with Hibernate Reactive"
msgstr "Persistência de mensagens Kafka com o Hibernate Reactive"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2642
#, fuzzy
msgid "To persist objects received from Kafka into a database, you can use Hibernate Reactive with Panache."
msgstr "Para persistir objectos recebidos do Kafka numa base de dados, pode utilizar o Hibernate Reactive com o Panache."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2653
#, no-wrap
msgid "import io.quarkus.hibernate.reactive.panache.PanacheEntity;  // <1>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2662
#, fuzzy
msgid "Make sure to use the reactive variant"
msgstr "Certifique-se de que utiliza a variante reactiva"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2671
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import jakarta.enterprise.context.control.ActivateRequestContext;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2676
#, no-wrap
msgid ""
"import io.quarkus.hibernate.reactive.panache.Panache;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2679
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class FruitStore {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2682
#, no-wrap
msgid ""
"    @Inject\n"
"    Mutiny.Session session;                    // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2691
#, no-wrap
msgid ""
"    @Incoming(\"in\")\n"
"    @ActivateRequestContext // <2>\n"
"    public Uni<Void> consume(Fruit entity) {\n"
"        return session.withTransaction(t -> {  // <3>\n"
"            return entity.persistAndFlush()    // <4>\n"
"                    .replaceWithVoid();        // <5>\n"
"        }).onTermination().call(() -> session.close()); // <6>\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2695
#, fuzzy
msgid "Inject the Hibernate Reactive `Session`"
msgstr "Injetar o Hibernate Reactive `Session`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2698
#, fuzzy
msgid "Hibernate Reactive `Session` and `Panache` APIs require an active CDI Request context.  `@ActivateRequestContext` annotation creates a new request context and destroys it when the `Uni` returned from the method completes.  If `Panache` is not used, `Mutiny.SessionFactory` can be injected and used similarly without the need of activating the request context or closing the session manually."
msgstr "As APIs Hibernate Reactive `Session` e `Panache` requerem um contexto de pedido CDI ativo. A anotação `@ActivateRequestContext` cria um novo contexto de pedido e destrói-o quando o `Uni` devolvido do método é concluído. Se `Panache` não for utilizada, `Mutiny.SessionFactory` pode ser injectada e utilizada de forma semelhante, sem necessidade de ativar o contexto de pedido ou fechar a sessão manualmente."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2699
#, fuzzy
msgid "Requests a new transaction. The transaction completes when the passed action completes."
msgstr "Solicita uma nova transação. A transação é concluída quando a ação passada é concluída."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2700
#, fuzzy
msgid "Persist the entity. It returns a `Uni<Fruit>`."
msgstr "Persiste a entidade. Devolve um `Uni&amp;lt;Fruit&amp;gt;`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2701
#, fuzzy
msgid "Switch back to a `Uni<Void>`."
msgstr "Voltar a mudar para um `Uni&amp;lt;Void&amp;gt;`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2702
#, fuzzy
msgid "Close the session - this is close the connection with the database. The connection can then be recycled."
msgstr "Fechar a sessão - isto é, fechar a ligação com a base de dados. A ligação pode então ser reciclada."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2706
#, fuzzy
msgid "Unlike with _classic_ Hibernate, you can't use `@Transactional`.  Instead, we use `session.withTransaction` and persist our entity.  The `map` is used to return a `Uni<Void>` and not a `Uni<Fruit>`."
msgstr "Ao contrário do Hibernate _clássico_, não é possível utilizar `@Transactional`. Em vez disso, usamos `session.withTransaction` e persistimos a nossa entidade. O `map` é utilizado para devolver um `Uni&amp;lt;Void&amp;gt;` e não um `Uni&amp;lt;Fruit&amp;gt;`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2709
#, fuzzy
msgid "You need a deserializer that can create a `Fruit` from the record.  This can be done using a Jackson deserializer:"
msgstr "É necessário um desserializador que possa criar um `Fruit` a partir do registo. Isto pode ser feito utilizando um desserializador Jackson:"

#. type: Title ===
#: upstream/_guides/kafka.adoc:2734
#, fuzzy, no-wrap
msgid "Writing entities managed by Hibernate to Kafka"
msgstr "Escrever entidades geridas pelo Hibernate no Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2737
#, fuzzy
msgid "Let's imagine the following process:"
msgstr "Imaginemos o seguinte processo:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2739
#, fuzzy
msgid "You receive an HTTP request with a payload,"
msgstr "Recebe um pedido HTTP com uma carga útil,"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2740
#, fuzzy
msgid "You create an Hibernate entity instance from this payload,"
msgstr "Cria-se uma instância de entidade Hibernate a partir deste payload,"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2741
#, fuzzy
msgid "You persist that entity into a database,"
msgstr "Persiste-se essa entidade numa base de dados,"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2742
#, fuzzy
msgid "You send the entity to a Kafka topic"
msgstr "Envia-se a entidade para um tópico do Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2744
#, fuzzy
msgid "If you use Hibernate Reactive, look at xref:writing-entities-managed-by-hibernate-reactive-to-kafka[Writing entities managed by Hibernate Reactive to Kafka]."
msgstr "Se utilizar o Hibernate Reactive, consulte  link:#writing-entities-managed-by-hibernate-reactive-to-kafka[Escrever entidades geridas pelo Hibernate Reactive no Kafka]."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2750
#, fuzzy
msgid "Because we write to a database, we must run this method in a transaction.  Yet, sending the entity to Kafka happens asynchronously.  The operation returns a `CompletionStage` (or a `Uni` if you use a `MutinyEmitter`) reporting when the operation completes.  We must be sure that the transaction is still running until the object is written.  Otherwise, you may access the object outside the transaction, which is not allowed."
msgstr "Como escrevemos em um banco de dados, devemos executar esse método em uma transação. No entanto, o envio da entidade para o Kafka acontece de forma assíncrona. A operação retorna um relatório `CompletionStage` (ou um `Uni` se você usar um `MutinyEmitter`) quando a operação for concluída. Devemos ter certeza de que a transação ainda está em execução até que o objeto seja escrito. Caso contrário, é possível aceder ao objeto fora da transação, o que não é permitido."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2752
#, fuzzy
msgid "To implement this process, you need the following approach:"
msgstr "Para implementar este processo, é necessária a seguinte abordagem:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2762
#, no-wrap
msgid ""
"import jakarta.transaction.Transactional;\n"
"import jakarta.ws.rs.POST;\n"
"import jakarta.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2770
#, no-wrap
msgid "    @Channel(\"kafka\") Emitter<Fruit> emitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2779
#, no-wrap
msgid ""
"    @POST\n"
"    @Path(\"/fruits\")\n"
"    @Transactional                                                      // <1>\n"
"    public CompletionStage<Void> storeAndSendToKafka(Fruit fruit) {     // <2>\n"
"        fruit.persist();\n"
"        return emitter.send(new FruitDto(fruit));                       // <3>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2781
#, fuzzy
msgid "As we are writing to the database, make sure we run inside a transaction"
msgstr "Como estamos a escrever para a base de dados, certifique-se de que corremos dentro de uma transação"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2782
#, fuzzy
msgid "The method receives the fruit instance to persist. It returns a `CompletionStage` which is used for the transaction demarcation. The transaction is committed when the return `CompletionStage` completes. In our case, it's when the message is written to Kafka."
msgstr "O método recebe a instância do fruto a persistir. Devolve um `CompletionStage` que é utilizado para a demarcação da transação. A transação é confirmada quando o retorno `CompletionStage` é concluído. No nosso caso, é quando a mensagem é escrita no Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2784
#, fuzzy
msgid "Wrap the managed entity inside a Data transfer object and send it to Kafka.  This makes sure that managed entity is not impacted by the Kafka serialization."
msgstr "Envolva a entidade gerenciada em um objeto de transferência de dados e envie-a para o Kafka. Isso garante que a entidade gerenciada não seja afetada pela serialização do Kafka."

#. type: Title ===
#: upstream/_guides/kafka.adoc:2786
#, fuzzy, no-wrap
msgid "Writing entities managed by Hibernate Reactive to Kafka"
msgstr "Escrever entidades geridas pelo Hibernate Reactive no Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2789
#, fuzzy
msgid "To send to Kafka entities managed by Hibernate Reactive, we recommend using:"
msgstr "Para enviar para entidades Kafka geridas pelo Hibernate Reactive, recomendamos a utilização de:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2791
#, fuzzy
msgid "RESTEasy Reactive to serve HTTP requests"
msgstr "RESTEasy Reactive para servir pedidos HTTP"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2792
#, fuzzy
msgid "A `MutinyEmitter` to send message to a channel, so it can be easily integrated with the Mutiny API exposed by Hibernate Reactive or Hibernate Reactive with Panache."
msgstr "Um `MutinyEmitter` para enviar mensagens para um canal, para que possa ser facilmente integrado com a API Mutiny exposta pelo Hibernate Reactive ou Hibernate Reactive with Panache."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2794
#, fuzzy
msgid "The following example demonstrates how to receive a payload, store it in the database using Hibernate Reactive with Panache, and send the persisted entity to Kafka:"
msgstr "O exemplo seguinte demonstra como receber uma carga útil, armazená-la na base de dados utilizando o Hibernate Reactive com Panache e enviar a entidade persistente para o Kafka:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2801
#, no-wrap
msgid ""
"import jakarta.ws.rs.POST;\n"
"import jakarta.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2807
#, no-wrap
msgid ""
"import io.quarkus.hibernate.reactive.panache.Panache;\n"
"import io.smallrye.mutiny.Uni;\n"
"import io.smallrye.reactive.messaging.MutinyEmitter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2810
#, no-wrap
msgid ""
"@Path(\"/\")\n"
"public class ReactiveGreetingResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2812
#, no-wrap
msgid "    @Channel(\"kafka\") MutinyEmitter<Fruit> emitter;     // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2822
#, no-wrap
msgid ""
"    @POST\n"
"    @Path(\"/fruits\")\n"
"    public Uni<Void> sendToKafka(Fruit fruit) {         // <2>\n"
"        return Panache.withTransaction(() ->            // <3>\n"
"            fruit.<Fruit>persist()\n"
"        )\n"
"            .chain(f -> emitter.send(f));               // <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2824
#, fuzzy
msgid "Inject a `MutinyEmitter` which exposes a Mutiny API. It simplifies the integration with the Mutiny API exposed by Hibernate Reactive with Panache."
msgstr "Injecta um `MutinyEmitter` que expõe uma API Mutiny. Simplifica a integração com a API Mutiny exposta pelo Hibernate Reactive com Panache."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2825
#, fuzzy
msgid "The HTTP method receiving the payload returns a `Uni<Void>`. The HTTP response is written when the operation completes (the entity is persisted and written to Kafka)."
msgstr "O método HTTP que recebe o payload devolve um `Uni&amp;lt;Void&amp;gt;`. A resposta HTTP é escrita quando a operação é concluída (a entidade é persistida e escrita no Kafka)."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2826
#, fuzzy
msgid "We need to write the entity into the database in a transaction."
msgstr "Temos de escrever a entidade na base de dados numa transação."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2827
#, fuzzy
msgid "Once the persist operation completes, we send the entity to Kafka. The `send` method returns a `Uni<Void>`."
msgstr "Uma vez concluída a operação de persistência, enviamos a entidade para o Kafka. O método `send` devolve um `Uni&amp;lt;Void&amp;gt;`."

#. type: Title ===
#: upstream/_guides/kafka.adoc:2829
#, fuzzy, no-wrap
msgid "Streaming Kafka topics as server-sent events"
msgstr "Transmissão de tópicos do Kafka como eventos enviados pelo servidor"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2832
#, fuzzy
msgid "Streaming a Kafka topic as server-sent events (SSE) is straightforward:"
msgstr "O streaming de um tópico do Kafka como eventos enviados pelo servidor (SSE) é simples:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2834
#, fuzzy
msgid "You inject the channel representing the Kafka topic in your HTTP endpoint"
msgstr "Injecta o canal que representa o tópico Kafka no seu ponto de extremidade HTTP"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2835
#, fuzzy
msgid "You return that channel as a `Publisher` or a `Multi` from the HTTP method"
msgstr "Devolve-se esse canal como `Publisher` ou `Multi` a partir do método HTTP"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2837
#, fuzzy
msgid "The following code provides an example:"
msgstr "O código seguinte apresenta um exemplo:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2842 upstream/_guides/kafka.adoc:2857
#, no-wrap
msgid ""
"@Channel(\"fruits\")\n"
"Multi<Fruit> fruits;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2848
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.SERVER_SENT_EVENTS)\n"
"public Multi<Fruit> stream() {\n"
"    return fruits;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2852
#, fuzzy
msgid "Some environment cuts the SSE connection when there is not enough activity.  The workaround consists of sending _ping_ messages (or empty objects) periodically."
msgstr "Alguns ambientes cortam a ligação SSE quando não há atividade suficiente. A solução consiste em enviar mensagens _ping_ (ou objectos vazios) periodicamente."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2860
#, no-wrap
msgid ""
"@Inject\n"
"ObjectMapper mapper;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2870
#, no-wrap
msgid ""
"@GET\n"
"@Produces(MediaType.SERVER_SENT_EVENTS)\n"
"public Multi<String> stream() {\n"
"    return Multi.createBy().merging()\n"
"            .streams(\n"
"                    fruits.map(this::toJson),\n"
"                    emitAPeriodicPing()\n"
"            );\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2875
#, no-wrap
msgid ""
"Multi<String> emitAPeriodicPing() {\n"
"    return Multi.createFrom().ticks().every(Duration.ofSeconds(10))\n"
"            .onItem().transform(x -> \"{}\");\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2883
#, no-wrap
msgid ""
"private String toJson(Fruit f) {\n"
"    try {\n"
"        return mapper.writeValueAsString(f);\n"
"    } catch (JsonProcessingException e) {\n"
"        throw new RuntimeException(e);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2887
#, fuzzy
msgid "The workaround is a bit more complex as besides sending the fruits coming from Kafka, we need to send pings periodically.  To achieve this we merge the stream coming from Kafka and a periodic stream emitting `{}` every 10 seconds."
msgstr "A solução alternativa é um pouco mais complexa, uma vez que, para além de enviar os frutos provenientes do Kafka, precisamos de enviar pings periodicamente. Para o conseguir, juntamos o fluxo proveniente do Kafka e um fluxo periódico que emite `{}` a cada 10 segundos."

#. type: Title ===
#: upstream/_guides/kafka.adoc:2889
#, fuzzy, no-wrap
msgid "Chaining Kafka Transactions with Hibernate Reactive transactions"
msgstr "Encadeamento de transacções Kafka com transacções reactivas do Hibernate"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2893
#, fuzzy
msgid "By chaining a Kafka transaction with a Hibernate Reactive transaction you can send records to a Kafka transaction, perform database updates and commit the Kafka transaction only if the database transaction is successful."
msgstr "Ao encadear uma transação Kafka com uma transação reactiva do Hibernate, pode enviar registos para uma transação Kafka, efetuar actualizações da base de dados e confirmar a transação Kafka apenas se a transação da base de dados for bem sucedida."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2895
#, fuzzy
msgid "The following example demonstrates:"
msgstr "O exemplo seguinte demonstra-o:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2897
#, fuzzy
msgid "Receive a payload by serving HTTP requests using RESTEasy Reactive,"
msgstr "Receber uma carga útil servindo pedidos HTTP utilizando o RESTEasy Reactive,"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2898
#, fuzzy
msgid "Limit concurrency of that HTTP endpoint using Smallrye Fault Tolerance,"
msgstr "Limitar a simultaneidade desse ponto de extremidade HTTP usando Smallrye Fault Tolerance,"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2899
#, fuzzy
msgid "Start a Kafka transaction and send the payload to Kafka record,"
msgstr "Iniciar uma transação Kafka e enviar a carga útil para o registo Kafka,"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2900
#, fuzzy
msgid "Store the payload in the database using Hibernate Reactive with Panache,"
msgstr "Armazene a carga útil na base de dados utilizando Hibernate Reactive com Panache,"

#. type: Plain text
#: upstream/_guides/kafka.adoc:2901
#, fuzzy
msgid "Commit the Kafka transaction only if the entity is persisted successfully."
msgstr "Confirmar a transação Kafka apenas se a entidade for persistida com êxito."

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2910
#, no-wrap
msgid ""
"import jakarta.ws.rs.Consumes;\n"
"import jakarta.ws.rs.POST;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2914 upstream/_guides/kafka.adoc:2964
#, no-wrap
msgid ""
"import org.eclipse.microprofile.faulttolerance.Bulkhead;\n"
"import org.eclipse.microprofile.reactive.messaging.Channel;\n"
"import org.hibernate.reactive.mutiny.Mutiny;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2918
#, no-wrap
msgid ""
"import io.quarkus.hibernate.reactive.panache.Panache;\n"
"import io.smallrye.mutiny.Uni;\n"
"import io.smallrye.reactive.messaging.kafka.transactions.KafkaTransactions;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2921 upstream/_guides/kafka.adoc:2972
#, no-wrap
msgid ""
"@Path(\"/\")\n"
"public class FruitProducer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2923
#, no-wrap
msgid "    @Channel(\"kafka\") KafkaTransactions<Fruit> kafkaTx; // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2937
#, no-wrap
msgid ""
"    @POST\n"
"    @Path(\"/fruits\")\n"
"    @Consumes(MediaType.APPLICATION_JSON)\n"
"    @Bulkhead(1) // <2>\n"
"    public Uni<Void> post(Fruit fruit) { // <3>\n"
"        return kafkaTx.withTransaction(emitter -> { // <4>\n"
"            emitter.send(fruit); // <5>\n"
"            return Panache.withTransaction(() -> { // <6>\n"
"                return fruit.<Fruit>persist(); // <7>\n"
"            });\n"
"        }).replaceWithVoid();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2940
#, fuzzy
msgid "Inject a `KafkaTransactions` which exposes a Mutiny API. It allows the integration with the Mutiny API exposed by Hibernate Reactive with Panache."
msgstr "Injecta um `KafkaTransactions` que expõe uma API Mutiny. Permite a integração com a API Mutiny exposta pelo Hibernate Reactive com Panache."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2941
#, fuzzy
msgid "Limit the concurrency of the HTTP endpoint to \"1\", preventing starting multiple transactions at a given time."
msgstr "Limitar a concorrência do ponto de extremidade HTTP a \"1\", impedindo o início de várias transacções num determinado momento."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2942
#, fuzzy
msgid "The HTTP method receiving the payload returns a `Uni<Void>`. The HTTP response is written when the operation completes (the entity is persisted and Kafka transaction is committed)."
msgstr "O método HTTP que recebe o payload devolve um `Uni&amp;lt;Void&amp;gt;`. A resposta HTTP é escrita quando a operação é concluída (a entidade é persistida e a transação Kafka é confirmada)."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2943 upstream/_guides/kafka.adoc:2996
#, fuzzy
msgid "Begin a Kafka transaction."
msgstr "Iniciar uma transação Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2944
#, fuzzy
msgid "Send the payload to Kafka inside the Kafka transaction."
msgstr "Enviar o payload para o Kafka dentro da transação Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2945
#, fuzzy
msgid "Persist the entity into the database in a Hibernate Reactive transaction."
msgstr "Persistir a entidade na base de dados numa transação reactiva do Hibernate."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2947
#, fuzzy
msgid "Once the persist operation completes, and there is no errors, the Kafka transaction is committed.  The result is omitted and returned as the HTTP response."
msgstr "Quando a operação de persistência estiver concluída e não existirem erros, a transação Kafka é confirmada. O resultado é omitido e devolvido como resposta HTTP."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2950
#, fuzzy
msgid "In the previous example the database transaction (inner) will commit followed by the Kafka transaction (outer).  If you wish to commit the Kafka transaction first and the database transaction second, you need to nest them in the reverse order."
msgstr "No exemplo anterior, a transação da base de dados (interna) será confirmada, seguida da transação Kafka (externa). Se pretender confirmar a transação Kafka em primeiro lugar e a transação da base de dados em segundo, tem de as aninhar pela ordem inversa."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2952
#, fuzzy
msgid "The next example demonstrates that using the Hibernate Reactive API (without Panache):"
msgstr "O próximo exemplo demonstra isso utilizando a API reactiva do Hibernate (sem o Panache):"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2960
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import jakarta.ws.rs.Consumes;\n"
"import jakarta.ws.rs.POST;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2969
#, no-wrap
msgid ""
"import io.smallrye.mutiny.Uni;\n"
"import io.smallrye.reactive.messaging.kafka.transactions.KafkaTransactions;\n"
"import io.vertx.mutiny.core.Context;\n"
"import io.vertx.mutiny.core.Vertx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2974
#, no-wrap
msgid "    @Channel(\"kafka\") KafkaTransactions<Fruit> kafkaTx;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2976
#, no-wrap
msgid "    @Inject Mutiny.SessionFactory sf; // <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:2990
#, no-wrap
msgid ""
"    @POST\n"
"    @Path(\"/fruits\")\n"
"    @Consumes(MediaType.APPLICATION_JSON)\n"
"    @Bulkhead(1)\n"
"    public Uni<Void> post(Fruit fruit) {\n"
"        Context context = Vertx.currentContext(); // <2>\n"
"        return sf.withTransaction(session -> // <3>\n"
"                kafkaTx.withTransaction(emitter -> // <4>\n"
"                        session.persist(fruit).invoke(() -> emitter.send(fruit)) // <5>\n"
"                ).emitOn(context::runOnContext) // <6>\n"
"        );\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:2993
#, fuzzy
msgid "Inject the Hibernate Reactive `SessionFactory`."
msgstr "Injetar o Hibernate Reactive `SessionFactory`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2994
#, fuzzy
msgid "Capture the caller Vert.x context."
msgstr "Captura o contexto Vert.x do chamador."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2995
#, fuzzy
msgid "Begin a Hibernate Reactive transaction."
msgstr "Iniciar uma transação reactiva do Hibernate."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2997
#, fuzzy
msgid "Persist the payload and send the entity to Kafka."
msgstr "Persiste a carga útil e envia a entidade para o Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:2999
#, fuzzy
msgid "The Kafka transaction terminates on the Kafka producer sender thread.  We need to switch to the Vert.x context previously captured in order to terminate the Hibernate Reactive transaction on the same context we started it."
msgstr "A transação do Kafka é encerrada na thread do emissor do produtor do Kafka. Temos de mudar para o contexto Vert.x capturado anteriormente para terminar a transação reactiva do Hibernate no mesmo contexto em que a iniciámos."

#. type: Title ==
#: upstream/_guides/kafka.adoc:3000
#, fuzzy, no-wrap
msgid "Logging"
msgstr "Registo"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3003
#, fuzzy
msgid "To reduce the amount of log written by the Kafka client, Quarkus sets the level of the following log categories to `WARNING`:"
msgstr "Para reduzir a quantidade de registos escritos pelo cliente Kafka, o Quarkus define o nível das seguintes categorias de registos para `WARNING`:"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3005
#, fuzzy
msgid "`org.apache.kafka.clients`"
msgstr "`org.apache.kafka.clients`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3006
#, fuzzy
msgid "`org.apache.kafka.common.utils`"
msgstr "`org.apache.kafka.common.utils`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3007
#, fuzzy
msgid "`org.apache.kafka.common.metrics`"
msgstr "`org.apache.kafka.common.metrics`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3009
#, fuzzy
msgid "You can override the configuration by adding the following lines to the `application.properties`:"
msgstr "É possível substituir a configuração adicionando as seguintes linhas ao ficheiro `application.properties`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3015
#, no-wrap
msgid ""
"quarkus.log.category.\"org.apache.kafka.clients\".level=INFO\n"
"quarkus.log.category.\"org.apache.kafka.common.utils\".level=INFO\n"
"quarkus.log.category.\"org.apache.kafka.common.metrics\".level=INFO\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/kafka.adoc:3017
#, fuzzy, no-wrap
msgid "Connecting to Managed Kafka clusters"
msgstr "Ligação a clusters do Kafka geridos"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3020
#, fuzzy
msgid "This section explains how to connect to notorious Kafka Cloud Services."
msgstr "Esta secção explica como se ligar aos notórios Kafka Cloud Services."

#. type: Title ===
#: upstream/_guides/kafka.adoc:3021
#, fuzzy, no-wrap
msgid "Azure Event Hub"
msgstr "Centro de Eventos do Azure"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3024
#, fuzzy
msgid "https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview[Azure Event Hub] provides an endpoint compatible with Apache Kafka."
msgstr "link:https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview[O Hub de Eventos do Azure] fornece um ponto de extremidade compatível com o Apache Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3028
#, fuzzy
msgid "Azure Event Hubs for Kafka is not available in the _basic_ tier.  You need at least the _standard_ tier to use Kafka.  See https://azure.microsoft.com/en-us/pricing/details/event-hubs/[Azure Event Hubs Pricing] to see the other options."
msgstr "Os Hubs de Eventos do Azure para Kafka não estão disponíveis na camada _básica_. Você precisa de pelo menos a camada _padrão_ para usar o Kafka. Consulte  link:https://azure.microsoft.com/en-us/pricing/details/event-hubs/[Preços dos Hubs de Eventos do Az] ure para ver as outras opções."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3030
#, fuzzy
msgid "To connect to Azure Event Hub, using the Kafka protocol with TLS, you need the following configuration:"
msgstr "Para se ligar ao Hub de Eventos do Azure, utilizando o protocolo Kafka com TLS, necessita da seguinte configuração:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3039
#, no-wrap
msgid ""
"kafka.bootstrap.servers=my-event-hub.servicebus.windows.net:9093 # <1>\n"
"kafka.security.protocol=SASL_SSL\n"
"kafka.sasl.mechanism=PLAIN\n"
"kafka.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required \\ # <2>\n"
"    username=\"$ConnectionString\" \\ # <3>\n"
"    password=\"<YOUR.EVENTHUBS.CONNECTION.STRING>\"; # <4>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:3041
#, fuzzy
msgid "The port is `9093`."
msgstr "O porto é `9093`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3042
#, fuzzy
msgid "You need to use the JAAS `PlainLoginModule`."
msgstr "É necessário utilizar o JAAS `PlainLoginModule`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3043
#, fuzzy
msgid "The username is the `$ConnectionString` string."
msgstr "O nome de utilizador é a cadeia de caracteres `$ConnectionString`."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3044
#, fuzzy
msgid "The Event Hub connection string given by Azure."
msgstr "A cadeia de ligação do Centro de Eventos fornecida pelo Azure."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3048
#, fuzzy
msgid "Replace `<YOUR.EVENTHUBS.CONNECTION.STRING>` with the connection string for your Event Hubs namespace.  For instructions on getting the connection string, see https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-get-connection-string[Get an Event Hubs connection string].  The result would be something like:"
msgstr "Substitua `&amp;lt;YOUR.EVENTHUBS.CONNECTION.STRING&amp;gt;` pela cadeia de ligação do seu espaço de nomes de Hubs de Eventos. Para obter instruções sobre como obter a cadeia de conexão, consulte  link:https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-get-connection-string[Obter uma cadeia de conexão de Hubs de Eventos]. O resultado seria algo como:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3054
#, no-wrap
msgid ""
"kafka.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required \\\n"
"    username=\"$ConnectionString\" \\\n"
"    password=\"Endpoint=sb://my-event-hub.servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=XXXXXXXXXXXXXXXX\";\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:3057
#, fuzzy
msgid "This configuration can be global (as above), or set in the channel configuration:"
msgstr "Esta configuração pode ser global (como acima), ou definida na configuração do canal:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3066
#, no-wrap
msgid ""
"mp.messaging.incoming.$channel.bootstrap.servers=my-event-hub.servicebus.windows.net:9093\n"
"mp.messaging.incoming.$channel.security.protocol=SASL_SSL\n"
"mp.messaging.incoming.$channel.sasl.mechanism=PLAIN\n"
"mp.messaging.incoming.$channel.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required \\\n"
"    username=\"$ConnectionString\" \\\n"
"    password=\"Endpoint=sb://my-event-hub.servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=...\";\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/kafka.adoc:3068
#, fuzzy, no-wrap
msgid "Red Hat OpenShift Streams for Apache Kafka"
msgstr "Red Hat OpenShift Streams para Apache Kafka"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3073
#, fuzzy
msgid "https://cloud.redhat.com/[Red Hat OpenShift Streams for Apache Kafka] provides managed Kafka brokers.  First, follow the instructions from https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[Getting started with the `rhoas` CLI for Red Hat OpenShift Streams for Apache Kafka] to create your Kafka broker instance.  Make sure you copied the client id and client secret associated with the _ServiceAccount_ you created."
msgstr "link:https://cloud.redhat.com/[O Red Hat OpenShift Streams para Apache Kafka] fornece corretores Kafka gerenciados. Primeiro, siga as instruções de  link:https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[Introdução à CLI `rhoas` para o Red Hat OpenShift Streams for Apache Kafka] para criar sua instância do broker do Kafka. Certifique-se de que copiou o ID do cliente e o segredo do cliente associados à _ServiceAccount_ que criou."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3075
#, fuzzy
msgid "Then, you can configure the Quarkus application to connect to the broker as follows:"
msgstr "Em seguida, pode configurar a aplicação Quarkus para se ligar ao corretor da seguinte forma:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3084
#, no-wrap
msgid ""
"kafka.bootstrap.servers=<connection url> # <1>\n"
"kafka.security.protocol=SASL_SSL\n"
"kafka.sasl.mechanism=PLAIN\n"
"kafka.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required \\\n"
"  username=\"${KAFKA_USERNAME}\" \\ # <2>\n"
"  password=\"${KAFKA_PASSWORD}\"; # <3>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:3086
#, fuzzy
msgid "The connection string, given on the admin console, such as `demo-c--bjsv-ldd-cvavkc-a.bf2.kafka.rhcloud.com:443`"
msgstr "A cadeia de ligação, fornecida na consola de administração, tal como `demo-c—​bjsv-ldd-cvavkc-a.bf2.kafka.rhcloud.com:443`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3087
#, fuzzy
msgid "The kafka username (the client id from the service account)"
msgstr "O nome de utilizador kafka (o ID do cliente da conta de serviço)"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3088
#, fuzzy
msgid "the kafka password (the client secret from the service account)"
msgstr "a palavra-passe kafka (o segredo do cliente da conta de serviço)"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3090
#, fuzzy
msgid "In general, these properties are prefixed using `%prod` to enable them only when running in production mode."
msgstr "Em geral, estas propriedades são prefixadas com `%prod` para as ativar apenas quando são executadas em modo de produção."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3093
#, fuzzy
msgid "As explained in https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[Getting started with the rhoas CLI for Red Hat OpenShift Streams for Apache Kafka], to use Red Hat OpenShift Streams for Apache Kafka, you must create the topic beforehand, create a _Service Account_, and provide permissions to read and write to your topic from that service account.  The authentication data (client id and secret) relates to the service account, which means you can implement fine-grain permissions and restrict access to the topic."
msgstr "Conforme explicado em  link:https://access.redhat.com/documentation/en-us/red_hat_openshift_streams_for_apache_kafka/1/guide/88e1487a-2a14-4b35-85b9-a7a2d67a37f3[Introdução ao rhoas CLI para o Red Hat OpenShift Streams para Apache Kafka], para usar o Red Hat OpenShift Streams para Apache Kafka, você deve criar o tópico antecipadamente, criar uma _conta de serviço_ e fornecer permissões para ler e gravar no seu tópico a partir dessa conta de serviço. Os dados de autenticação (id do cliente e segredo) estão relacionados com a conta de serviço, o que significa que pode implementar permissões de grão fino e restringir o acesso ao tópico."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3095
#, fuzzy
msgid "When using Kubernetes, it is recommended to set the client id and secret in a Kubernetes secret:"
msgstr "Ao utilizar o Kubernetes, recomenda-se que defina o ID do cliente e o segredo num segredo do Kubernetes:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3105
#, no-wrap
msgid ""
"apiVersion: v1\n"
"kind: Secret\n"
"metadata:\n"
"  name: kafka-credentials\n"
"stringData:\n"
"  KAFKA_USERNAME: \"...\"\n"
"  KAFKA_PASSWORD: \"...\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:3108
#, fuzzy
msgid "To allow your Quarkus application to use that secret, add the following line to the `application.properties` file:"
msgstr "Para permitir que a sua aplicação Quarkus utilize esse segredo, adicione a seguinte linha ao ficheiro `application.properties`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3112
#, no-wrap
msgid "%prod.quarkus.openshift.env.secrets=kafka-credentials\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/kafka.adoc:3114
#, fuzzy, no-wrap
msgid "Red Hat OpenShift Service Registry"
msgstr "Registo de Serviços Red Hat OpenShift"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3118
#, fuzzy
msgid "https://www.redhat.com/en/technologies/cloud-computing/openshift/openshift-service-registry[Red Hat OpenShift Service Registry] provides fully managed service registry for handling Kafka schemas."
msgstr "O  link:https://www.redhat.com/en/technologies/cloud-computing/openshift/openshift-service-registry[Red Hat OpenShift Service Registry] fornece um registo de serviço totalmente gerido para lidar com esquemas Kafka."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3122
#, fuzzy
msgid "You can follow the instructions from https://access.redhat.com/documentation/en-us/red_hat_openshift_service_registry/1/guide/ab1894d1-cae0-4d11-b185-81d62b4aabc7#_60472331-fa00-48ec-a621-bbd039500c7d[Getting started with Red Hat OpenShift Service Registry], or use the `rhoas` CLI to create a new service registry instance:"
msgstr "Pode seguir as instruções de  link:https://access.redhat.com/documentation/en-us/red_hat_openshift_service_registry/1/guide/ab1894d1-cae0-4d11-b185-81d62b4aabc7#_60472331-fa00-48ec-a621-bbd039500c7d[Introdução ao Red Hat OpenShift Service Registry] ou utilizar o `rhoas` CLI para criar uma nova instância de registo de serviço:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3126
#, no-wrap
msgid "rhoas service-registry create --name my-schema-registry\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:3131
#, fuzzy
msgid "Make sure to note the _Registry URL_ of the instance created.  For authentication, you can use the same _ServiceAccount_ you created previously.  You need to make sure that it has the necessary permissions to access the service registry."
msgstr "Certifique-se de que anota o _URL de registo_ da instância criada. Para autenticação, pode utilizar a mesma _ServiceAccount_ que criou anteriormente. Tem de se certificar de que esta tem as permissões necessárias para aceder ao registo de serviços."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3133
#, fuzzy
msgid "For example, using the `rhoas` CLI, you can grant the `MANAGER` role to the service account:"
msgstr "Por exemplo, usando a CLI `rhoas`, é possível conceder a função `MANAGER` à conta de serviço:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3137
#, no-wrap
msgid "rhoas service-registry role add --role manager --service-account [SERVICE_ACCOUNT_CLIENT_ID]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:3140
#, fuzzy
msgid "Then, you can configure the Quarkus application to connect to the schema registry as follows:"
msgstr "Em seguida, pode configurar a aplicação Quarkus para se ligar ao registo de esquemas da seguinte forma:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3147
#, no-wrap
msgid ""
"mp.messaging.connector.smallrye-kafka.apicurio.registry.url=${RHOAS_SERVICE_REGISTRY_URL} <1>\n"
"mp.messaging.connector.smallrye-kafka.apicurio.auth.service.token.endpoint=${RHOAS_OAUTH_TOKEN_ENDPOINT} <2>\n"
"mp.messaging.connector.smallrye-kafka.apicurio.auth.client.id=${RHOAS_CLIENT_ID} <3>\n"
"mp.messaging.connector.smallrye-kafka.apicurio.auth.client.secret=${RHOAS_CLIENT_ID} <4>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:3149
#, fuzzy
msgid "The service registry URL, given on the admin console, such as `https://bu98.serviceregistry.rhcloud.com/t/0e95af2c-6e11-475e-82ee-f13bd782df24/apis/registry/v2`"
msgstr "O URL do registo de serviços, fornecido na consola de administração, tal como `&lt;a href=\"https://bu98.serviceregistry.rhcloud.com/t/0e95af2c-6e11-475e-82ee-f13bd782df24/apis/registry/v2\" class=\"bare\"&gt;https://bu98.serviceregistry.rhcloud.com/t/0e95af2c-6e11-475e-82ee-f13bd782df24/apis/registry/v2&lt;/a&gt;`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3150
#, fuzzy
msgid "The OAuth token endpoint URL, such as `https://identity.api.openshift.com/auth/realms/rhoas/protocol/openid-connect/token`"
msgstr "O URL do ponto de extremidade do token OAuth, como `&lt;a href=\"https://identity.api.openshift.com/auth/realms/rhoas/protocol/openid-connect/token\" class=\"bare\"&gt;https://identity.api.openshift.com/auth/realms/rhoas/protocol/openid-connect/token&lt;/a&gt;`"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3151
#, fuzzy
msgid "The client id (from the service account)"
msgstr "O ID do cliente (da conta de serviço)"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3152
#, fuzzy
msgid "The client secret (from the service account)"
msgstr "O segredo do cliente (da conta de serviço)"

#. type: Title ====
#: upstream/_guides/kafka.adoc:3153
#, fuzzy, no-wrap
msgid "Binding Red Hat OpenShift managed services to Quarkus application using the Service Binding Operator"
msgstr "Vinculação de serviços gerenciados do Red Hat OpenShift ao aplicativo Quarkus usando o Operador de vinculação de serviço"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3157
#, fuzzy
msgid "If your Quarkus application is deployed on a Kubernetes or OpenShift cluster with link:https://github.com/redhat-developer/service-binding-operator[Service Binding Operator] and link:https://github.com/redhat-developer/app-services-operator/tree/main/docs[OpenShift Application Services] operators installed, configurations necessary to access Red Hat OpenShift Streams for Apache Kafka and Service Registry can be injected to the application using xref:deploying-to-kubernetes.adoc#service_binding[Kubernetes Service Binding]."
msgstr "Se o seu aplicativo Quarkus for implantado em um cluster Kubernetes ou OpenShift com o  link:https://github.com/redhat-developer/service-binding-operator[Service Binding Operator] e os operadores do  link:https://github.com/redhat-developer/app-services-operator/tree/main/docs[OpenShift Application Services] instalados, as configurações necessárias para acessar o Red Hat OpenShift Streams para Apache Kafka e o Service Registry podem ser injetadas no aplicativo usando o  link:deploying-to-kubernetes.html#service_binding[Kubernetes Service Binding]."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3160
#, fuzzy
msgid "In order to set up the Service Binding, you need first to connect OpenShift managed services to your cluster.  For an OpenShift cluster you can follow the instructions from link:https://github.com/redhat-developer/app-services-guides/tree/main/docs/registry/service-binding-registry#connecting-a-kafka-and-service-registry-instance-to-your-openshift-cluster[Connecting a Kafka and Service Registry instance to your OpenShift cluster]."
msgstr "Para configurar o Service Binding, você precisa primeiro conectar os serviços gerenciados do OpenShift ao seu cluster. Para um cluster OpenShift, você pode seguir as instruções de  link:https://github.com/redhat-developer/app-services-guides/tree/main/docs/registry/service-binding-registry#connecting-a-kafka-and-service-registry-instance-to-your-openshift-cluster[Conectando uma instância do Kafka e do Registro de Serviço ao seu cluster OpenShift]."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3162
#, fuzzy
msgid "Once you've connected your cluster with the RHOAS Kafka and Service Registry instances, make sure you've granted necessary permissions to the newly created service account."
msgstr "Depois de ligar o seu cluster às instâncias do RHOAS Kafka e do Service Registry, certifique-se de que concedeu as permissões necessárias à conta de serviço recém-criada."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3165
#, fuzzy
msgid "Then, using the xref:deploying-to-kubernetes.adoc#service_binding[Kubernetes Service Binding] extension, you can configure the Quarkus application to generate `ServiceBinding` resources for those services:"
msgstr "Em seguida, usando a extensão  link:deploying-to-kubernetes.html#service_binding[Kubernetes Service Binding], pode configurar a aplicação Quarkus para gerar `ServiceBinding` recursos para esses serviços:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3169
#, no-wrap
msgid "quarkus.kubernetes-service-binding.detect-binding-resources=true\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3173
#, no-wrap
msgid ""
"quarkus.kubernetes-service-binding.services.kafka.api-version=rhoas.redhat.com/v1alpha1\n"
"quarkus.kubernetes-service-binding.services.kafka.kind=KafkaConnection\n"
"quarkus.kubernetes-service-binding.services.kafka.name=my-kafka\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3177
#, no-wrap
msgid ""
"quarkus.kubernetes-service-binding.services.serviceregistry.api-version=rhoas.redhat.com/v1alpha1\n"
"quarkus.kubernetes-service-binding.services.serviceregistry.kind=ServiceRegistryConnection\n"
"quarkus.kubernetes-service-binding.services.serviceregistry.name=my-schema-registry\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:3180
#, fuzzy
msgid "For this example Quarkus build will generate the following `ServiceBinding` resources:"
msgstr "Para este exemplo, a compilação do Quarkus irá gerar os seguintes recursos `ServiceBinding`:"

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3200
#, no-wrap
msgid ""
"apiVersion: binding.operators.coreos.com/v1alpha1\n"
"kind: ServiceBinding\n"
"metadata:\n"
"  name: my-app-kafka\n"
"spec:\n"
"  application:\n"
"    group: apps.openshift.io\n"
"    name: my-app\n"
"    version: v1\n"
"    kind: DeploymentConfig\n"
"  services:\n"
"    - group: rhoas.redhat.com\n"
"      version: v1alpha1\n"
"      kind: KafkaConnection\n"
"      name: my-kafka\n"
"  detectBindingResources: true\n"
"  bindAsFiles: true\n"
"---\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/kafka.adoc:3218
#, no-wrap
msgid ""
"apiVersion: binding.operators.coreos.com/v1alpha1\n"
"kind: ServiceBinding\n"
"metadata:\n"
"  name: my-app-serviceregistry\n"
"spec:\n"
"  application:\n"
"    group: apps.openshift.io\n"
"    name: my-app\n"
"    version: v1\n"
"    kind: DeploymentConfig\n"
"  services:\n"
"    - group: rhoas.redhat.com\n"
"      version: v1alpha1\n"
"      kind: ServiceRegistryConnection\n"
"      name: my-schema-registry\n"
"  detectBindingResources: true\n"
"  bindAsFiles: true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/kafka.adoc:3222
#, fuzzy
msgid "You can follow xref:deploying-to-kubernetes.adoc#openshift[Deploying to OpenShift] to deploy your application, including generated `ServiceBinding` resources.  The configuration properties necessary to access the Kafka and Schema Registry instances will be injected to the application automatically at deployment."
msgstr "Você pode seguir  link:deploying-to-kubernetes.html#openshift[Implantando no OpenShift] para implantar seu aplicativo, incluindo os recursos `ServiceBinding` gerados. As propriedades de configuração necessárias para acessar as instâncias do Kafka e do Schema Registry serão injetadas no aplicativo automaticamente na implantação."

#. type: Title ==
#: upstream/_guides/kafka.adoc:3223
#, fuzzy, no-wrap
msgid "Going further"
msgstr "Ir mais longe"

#. type: Plain text
#: upstream/_guides/kafka.adoc:3227
#, fuzzy
msgid "This guide has shown how you can interact with Kafka using Quarkus.  It utilizes SmallRye Reactive Messaging to build data streaming applications."
msgstr "Este guia mostrou como é possível interagir com o Kafka usando o Quarkus. Ele utiliza o SmallRye Reactive Messaging para criar aplicativos de streaming de dados."

#. type: Plain text
#: upstream/_guides/kafka.adoc:3228
#, fuzzy
msgid "If you want to go further, check the documentation of https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], the implementation used in Quarkus."
msgstr "Se quiser ir mais longe, consulte a documentação do  link:https://smallrye.io/smallrye-reactive-messaging[SmallRye Reactive Messaging], a implementação utilizada no Quarkus."
