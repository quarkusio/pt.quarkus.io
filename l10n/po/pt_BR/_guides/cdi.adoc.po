# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-10-29 08:10+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/cdi.adoc:6
#, fuzzy, no-wrap
msgid "Introduction to Contexts and Dependency Injection (CDI)"
msgstr "Introdução a contextos e injeção de dependência (CDI)"

#. type: Plain text
#: upstream/_guides/cdi.adoc:18
#, fuzzy
msgid "In this guide we're going to describe the basic principles of the Quarkus programming model that is based on the https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html[Jakarta Contexts and Dependency Injection 4.0, window=\"_blank\"] specification."
msgstr "Neste guia, vamos descrever os princípios básicos do modelo de programação Quarkus, que se baseia na especificação  link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html[Jakarta Contexts e Dependency Injection 4.0, window=_blank]."

#. type: Title ==
#: upstream/_guides/cdi.adoc:19
#, fuzzy, no-wrap
msgid "OK. Let's start simple. What is a bean?"
msgstr "MUITO BEM. Vamos começar de forma simples. O que é um feijão?"

#. type: Plain text
#: upstream/_guides/cdi.adoc:22
#, fuzzy
msgid "Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors."
msgstr "Bem, um bean é um objeto _gerido por um contentor_ que suporta um conjunto de serviços básicos, como a injeção de dependências, as chamadas de retorno do ciclo de vida e os interceptores."

#. type: Title ==
#: upstream/_guides/cdi.adoc:23
#, fuzzy, no-wrap
msgid "Wait a minute. What does \"container-managed\" mean?"
msgstr "Espera um pouco. O que significa \"gerido por contentores\"?"

#. type: Plain text
#: upstream/_guides/cdi.adoc:29
#, fuzzy
msgid "Simply put, you don't control the lifecycle of the object instance directly.  Instead, you can affect the lifecycle through declarative means, such as annotations, configuration, etc.  The container is the _environment_ where your application runs.  It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans."
msgstr "Em termos simples, não se controla diretamente o ciclo de vida da instância do objeto. Em vez disso, pode afetar o ciclo de vida através de meios declarativos, como anotações, configuração, etc. O contentor é o _ambiente_ onde a sua aplicação é executada. Cria e destrói as instâncias dos beans, associa as instâncias a um contexto designado e injecta-as noutros beans."

#. type: Title ==
#: upstream/_guides/cdi.adoc:30
#, fuzzy, no-wrap
msgid "What is it good for?"
msgstr "Para que é que serve?"

#. type: Plain text
#: upstream/_guides/cdi.adoc:33
#, fuzzy
msgid "An application developer can focus on the business logic rather than finding out \"where and how\" to obtain a fully initialized component with all of its dependencies."
msgstr "Um programador de aplicações pode concentrar-se na lógica empresarial em vez de descobrir \"onde e como\" obter um componente totalmente inicializado com todas as suas dependências."

#. type: Plain text
#: upstream/_guides/cdi.adoc:35
#, fuzzy
msgid "You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC."
msgstr "Provavelmente já ouviu falar do princípio de programação da _inversão de controlo_ (IoC). A injeção de dependências é uma das técnicas de implementação da IoC."

#. type: Title ==
#: upstream/_guides/cdi.adoc:36
#, fuzzy, no-wrap
msgid "What does a bean look like?"
msgstr "Qual é o aspeto de um feijão?"

#. type: Plain text
#: upstream/_guides/cdi.adoc:40
#, fuzzy
msgid "There are several kinds of beans.  The most common ones are class-based beans:"
msgstr "Existem vários tipos de beans. Os mais comuns são os beans baseados em classes:"

#. type: Block title
#: upstream/_guides/cdi.adoc:41
#, fuzzy, no-wrap
msgid "Simple Bean Example"
msgstr "Exemplo de feijão simples"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:47
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import org.eclipse.microprofile.metrics.annotation.Counted;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:50
#, no-wrap
msgid ""
"@ApplicationScoped <1>\n"
"public class Translator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:53
#, no-wrap
msgid ""
"    @Inject\n"
"    Dictionary dictionary; <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:59
#, no-wrap
msgid ""
"    @Counted  <3>\n"
"    String translate(String sentence) {\n"
"      // ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:61
#, fuzzy
msgid "This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all other beans that inject `Translator`."
msgstr "Esta é uma anotação de âmbito. Diz ao contentor a que contexto deve associar a instância do bean. Neste caso específico, uma *única instância de bean* é criada para a aplicação e utilizada por todos os outros beans que injectam `Translator`."

#. type: Plain text
#: upstream/_guides/cdi.adoc:62
#, fuzzy
msgid "This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails."
msgstr "Este é um ponto de injeção de campo. Diz ao contentor que `Translator` depende do bean `Dictionary`. Se não houver um bean correspondente, a compilação falha."

#. type: Plain text
#: upstream/_guides/cdi.adoc:63
#, fuzzy
msgid "This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics. We will talk about xref:interceptors[interceptors] later."
msgstr "Esta é uma anotação de ligação de intercetor. Neste caso, a anotação vem do MicroProfile Metrics. O intercetor relevante intercepta a invocação e atualiza as métricas relevantes. Falaremos sobre  link:#interceptors[interceptores] mais tarde."

#. type: Title ==
#: upstream/_guides/cdi.adoc:65
#, fuzzy, no-wrap
msgid "Nice. How does the dependency resolution work? I see no names or identifiers."
msgstr "Ótimo. Como é que a resolução de dependências funciona? Não vejo nomes ou identificadores."

#. type: Plain text
#: upstream/_guides/cdi.adoc:74
#, fuzzy
msgid "That's a good question.  In CDI the process of matching a bean to an injection point is *type-safe*.  Each bean declares a set of bean types.  In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.  Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.  We'll talk about qualifiers later.  For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`."
msgstr "Essa é uma boa pergunta. No CDI, o processo de correspondência entre um bean e um ponto de injeção é *seguro em termos de tipo*. Cada bean declara um conjunto de tipos de bean. No nosso exemplo acima, o bean `Translator` tem dois tipos de bean: `Translator` e `java.lang.Object`. Subsequentemente, um bean é atribuível a um ponto de injeção se o bean tiver um tipo de bean que corresponda ao _tipo necessário_ e tenha todos os _qualificadores necessários_. Falaremos sobre qualificadores mais tarde. Por agora, basta saber que o bean acima é atribuível a um ponto de injeção do tipo `Translator` e `java.lang.Object`."

#. type: Title ==
#: upstream/_guides/cdi.adoc:75
#, fuzzy, no-wrap
msgid "Hm, wait a minute. What happens if multiple beans declare the same type?"
msgstr "Espere um minuto. O que acontece se vários beans declararem o mesmo tipo?"

#. type: Plain text
#: upstream/_guides/cdi.adoc:81
#, fuzzy
msgid "There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.  If none is assignable the build fails with `UnsatisfiedResolutionException`.  If multiple are assignable the build fails with `AmbiguousResolutionException`.  This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point."
msgstr "Existe uma regra simples: *exatamente um bean tem de ser atribuível a um ponto de injeção, caso contrário a construção falha*. Se nenhum for atribuível, a compilação falha com `UnsatisfiedResolutionException`. Se vários forem atribuíveis, a compilação falha com `AmbiguousResolutionException`. Isto é muito útil porque a sua aplicação falha rapidamente sempre que o contentor não consegue encontrar uma dependência inequívoca para qualquer ponto de injeção."

#. type: delimited block =
#: upstream/_guides/cdi.adoc:85
#, fuzzy
msgid "Your can use programmatic lookup via `jakarta.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:"
msgstr "Pode utilizar a pesquisa programática através de `jakarta.enterprise.inject.Instance` para resolver ambiguidades em tempo de execução e até iterar sobre todos os beans que implementam um determinado tipo:"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:89
#, no-wrap
msgid "public class Translator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:92
#, no-wrap
msgid ""
"    @Inject\n"
"    Instance<Dictionary> dictionaries; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:99
#, no-wrap
msgid ""
"    String translate(String sentence) {\n"
"      for (Dictionary dict : dictionaries) { <2>\n"
"         // ...\n"
"      }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:101
#, fuzzy
msgid "This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type."
msgstr "Este ponto de injeção não resultará numa dependência ambígua, mesmo que existam vários beans que implementem o tipo `Dictionary`."

#. type: Plain text
#: upstream/_guides/cdi.adoc:102
#, fuzzy
msgid "`jakarta.enterprise.inject.Instance` extends `Iterable`."
msgstr "`jakarta.enterprise.inject.Instance` estende-se a `Iterable`."

#. type: Title ==
#: upstream/_guides/cdi.adoc:104
#, fuzzy, no-wrap
msgid "Can I use setter and constructor injection?"
msgstr "Posso utilizar a injeção de setter e de construtor?"

#. type: delimited block =
#: upstream/_guides/cdi.adoc:109
#, fuzzy
msgid "Yes, you can.  In fact, in CDI the \"setter injection\" is superseded by more powerful https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#initializer_methods[initializer methods, window=\"_blank\"].  Initializers may accept multiple parameters and don't have to follow the JavaBean naming conventions."
msgstr "Sim, é possível. De facto, em CDI, a \"injeção de setter\" é substituída por  link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#initializer_methods[métodos inicializadores, window=_blank] mais poderosos. Os inicializadores podem aceitar múltiplos parâmetros e não precisam seguir as convenções de nomenclatura do JavaBean."

#. type: Block title
#: upstream/_guides/cdi.adoc:110
#, fuzzy, no-wrap
msgid "Initialized and Constructor Injection Example"
msgstr "Exemplo de injeção de inicialização e de construtor"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:115 upstream/_guides/cdi.adoc:331
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class Translator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:117
#, no-wrap
msgid "    private final TranslatorHelper helper;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:121
#, no-wrap
msgid ""
"    Translator(TranslatorHelper helper) { <1>\n"
"       this.helper = helper;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:127
#, no-wrap
msgid ""
"    @Inject <2>\n"
"    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n"
"      / ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:132
#, fuzzy
msgid "This is a constructor injection.  In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor and the bean constructor must be annotated with `@Inject`.  However, in Quarkus we detect the absence of no-args constructor and \"add\" it directly in the bytecode.  It's also not necessary to add `@Inject` if there is only one constructor present."
msgstr "Trata-se de uma injeção de construtor. De facto, este código não funcionaria em implementações CDI normais, em que um bean com um âmbito normal deve sempre declarar um construtor no-args e o construtor do bean deve ser anotado com `@Inject`. No entanto, no Quarkus detectamos a ausência de um construtor no-args e \"adicionamo-lo\" diretamente no bytecode. Também não é necessário adicionar `@Inject` se houver apenas um construtor presente."

#. type: Plain text
#: upstream/_guides/cdi.adoc:133
#, fuzzy
msgid "An initializer method must be annotated with `@Inject`."
msgstr "Um método inicializador deve ser anotado com `@Inject`."

#. type: Plain text
#: upstream/_guides/cdi.adoc:134
#, fuzzy
msgid "An initializer may accept multiple parameters - each one is an injection point."
msgstr "Um inicializador pode aceitar vários parâmetros - cada um deles é um ponto de injeção."

#. type: Title ==
#: upstream/_guides/cdi.adoc:135
#, fuzzy, no-wrap
msgid "You talked about some qualifiers?"
msgstr "Falou de alguns qualificadores?"

#. type: Plain text
#: upstream/_guides/cdi.adoc:140
#, fuzzy
msgid "https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.  As we already said a bean is assignable to an injection point if it has all the required qualifiers.  If you declare no qualifier at an injection point the `@Default` qualifier is assumed."
msgstr "link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#qualifiers[Os qualificadores, window=_blank] são anotações que ajudam o contentor a distinguir os beans que implementam o mesmo tipo. Como já dissemos, um bean pode ser atribuído a um ponto de injeção se tiver todos os qualificadores necessários. Se não declarar nenhum qualificador num ponto de injeção, assume-se o qualificador `@Default`."

#. type: Plain text
#: upstream/_guides/cdi.adoc:142
#, fuzzy
msgid "A qualifier type is a Java annotation defined as `@Retention(RUNTIME)` and annotated with the `@jakarta.inject.Qualifier` meta-annotation:"
msgstr "Um tipo de qualificador é uma anotação Java definida como `@Retention(RUNTIME)` e anotada com a meta-anotação `@jakarta.inject.Qualifier`:"

#. type: Block title
#: upstream/_guides/cdi.adoc:143
#, fuzzy, no-wrap
msgid "Qualifier Example"
msgstr "Exemplo de qualificador"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:150
#, no-wrap
msgid ""
"@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({METHOD, FIELD, PARAMETER, TYPE})\n"
"public @interface Superior {}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:153
#, fuzzy
msgid "The qualifiers of a bean are declared by annotating the bean class or producer method or field with the qualifier types:"
msgstr "Os qualificadores de um bean são declarados através da anotação da classe do bean ou do método ou campo produtor com os tipos de qualificadores:"

#. type: Block title
#: upstream/_guides/cdi.adoc:154
#, fuzzy, no-wrap
msgid "Bean With Custom Qualifier Example"
msgstr "Exemplo de feijão com qualificador personalizado"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:160
#, no-wrap
msgid ""
"@Superior <1>\n"
"@ApplicationScoped\n"
"public class SuperiorTranslator extends Translator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:165 upstream/_guides/cdi.adoc:235
#, no-wrap
msgid ""
"    String translate(String sentence) {\n"
"      // ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:167
#, fuzzy
msgid "`@Superior` is a https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"]."
msgstr "`@Superior` é uma  link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#defining_qualifier_types[anotação de qualificador, window=_blank]."

#. type: Plain text
#: upstream/_guides/cdi.adoc:171
#, fuzzy
msgid "This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not to `@Inject Translator`.  The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.  And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable."
msgstr "Este bean seria atribuível a `@Inject @Superior Translator` e `@Inject @Superior SuperiorTranslator`, mas não a `@Inject Translator`. A razão é que `@Inject Translator` é automaticamente transformado em `@Inject @Default Translator` durante a resolução de typesafe. E como o nosso `SuperiorTranslator` não declara `@Default`, apenas o bean `Translator` original é atribuível."

#. type: Title ==
#: upstream/_guides/cdi.adoc:173
#, fuzzy, no-wrap
msgid "Looks good. What is the bean scope?"
msgstr "Parece-me bem. Qual é o alcance do feijão?"

#. type: Plain text
#: upstream/_guides/cdi.adoc:176
#, fuzzy
msgid "The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed."
msgstr "O âmbito de um bean determina o ciclo de vida das suas instâncias, ou seja, quando e onde uma instância deve ser criada e destruída."

#. type: Plain text
#: upstream/_guides/cdi.adoc:178
#, fuzzy
msgid "Every bean has exactly one scope."
msgstr "Cada bean tem exatamente um âmbito."

#. type: Title ==
#: upstream/_guides/cdi.adoc:180
#, fuzzy, no-wrap
msgid "What scopes can I actually use in my Quarkus application?"
msgstr "Que âmbitos posso efetivamente utilizar na minha aplicação Quarkus?"

#. type: Plain text
#: upstream/_guides/cdi.adoc:183
#, fuzzy
msgid "You can use all the built-in scopes mentioned by the specification except for `jakarta.enterprise.context.ConversationScoped`."
msgstr "É possível utilizar todos os âmbitos de aplicação incorporados mencionados na especificação, exceto `jakarta.enterprise.context.ConversationScoped`."

#. type: Table
#: upstream/_guides/cdi.adoc:186
#, fuzzy, no-wrap
msgid "Annotation"
msgstr "Anotação"

#. type: Table
#: upstream/_guides/cdi.adoc:188
#, fuzzy, no-wrap
msgid ""
"Description\n"
"//----------------------"
msgstr "Descrição"

#. type: Table
#: upstream/_guides/cdi.adoc:188
#, fuzzy, no-wrap
msgid "`@jakarta.enterprise.context.ApplicationScoped`"
msgstr "`@jakarta.enterprise.context.ApplicationScoped`"

#. type: Table
#: upstream/_guides/cdi.adoc:189
#, fuzzy, no-wrap
msgid "A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the xref:client_proxies[client proxy]."
msgstr "É utilizada uma única instância de bean para a aplicação e partilhada entre todos os pontos de injeção. A instância é criada de forma preguiçosa, ou seja, assim que um método é invocado no  link:#client_proxies[proxy do cliente]."

#. type: Table
#: upstream/_guides/cdi.adoc:189
#, fuzzy, no-wrap
msgid "`@jakarta.inject.Singleton`"
msgstr "`@jakarta.inject.Singleton`"

#. type: Table
#: upstream/_guides/cdi.adoc:190
#, fuzzy, no-wrap
msgid "Just like `@ApplicationScoped` except that no client proxy is used. The instance is created when an injection point that resolves to a @Singleton bean is being injected."
msgstr "Tal como em `@ApplicationScoped`, exceto que não é utilizado um proxy de cliente. A instância é criada quando é injetado um ponto de injeção que resolve para um bean @Singleton."

#. type: Table
#: upstream/_guides/cdi.adoc:190
#, fuzzy, no-wrap
msgid "`@jakarta.enterprise.context.RequestScoped`"
msgstr "`@jakarta.enterprise.context.RequestScoped`"

#. type: Table
#: upstream/_guides/cdi.adoc:191
#, fuzzy, no-wrap
msgid "The bean instance is associated with the current _request_ (usually an HTTP request)."
msgstr "A instância do bean está associada ao _pedido_ atual (normalmente um pedido HTTP)."

#. type: Table
#: upstream/_guides/cdi.adoc:191
#, fuzzy, no-wrap
msgid "`@jakarta.enterprise.context.Dependent`"
msgstr "`@jakarta.enterprise.context.Dependent`"

#. type: Table
#: upstream/_guides/cdi.adoc:192
#, fuzzy, no-wrap
msgid "This is a pseudo-scope. The instances are not shared and every injection point spawns a new instance of the dependent bean. The lifecycle of dependent bean is bound to the bean injecting it - it will be created and destroyed along with the bean injecting it."
msgstr "Trata-se de um pseudo-escopo. As instâncias não são partilhadas e cada ponto de injeção gera uma nova instância do bean dependente. O ciclo de vida do bean dependente está ligado ao bean que o injecta - será criado e destruído juntamente com o bean que o injecta."

#. type: Table
#: upstream/_guides/cdi.adoc:192
#, fuzzy, no-wrap
msgid "`@jakarta.enterprise.context.SessionScoped`"
msgstr "`@jakarta.enterprise.context.SessionScoped`"

#. type: Table
#: upstream/_guides/cdi.adoc:193
#, fuzzy, no-wrap
msgid "This scope is backed by a `jakarta.servlet.http.HttpSession` object. It's only available if the `quarkus-undertow` extension is used."
msgstr "Este âmbito é suportado por um objeto `jakarta.servlet.http.HttpSession`. Só está disponível se for utilizada a extensão `quarkus-undertow`."

#. type: Plain text
#: upstream/_guides/cdi.adoc:196
#, fuzzy
msgid "There can be other custom scopes provided by Quarkus extensions. For example, xref:transaction.adoc[`quarkus-narayana-jta`] provides xref:transaction.adoc#transaction-scope[`jakarta.transaction.TransactionScoped`]."
msgstr "Podem existir outros âmbitos de aplicação personalizados fornecidos pelas extensões Quarkus. Por exemplo,  link:transaction.html[`quarkus-narayana-jta`] fornece  link:transaction.html#transaction-scope[`jakarta.transaction.TransactionScoped`]."

#. type: Title ==
#: upstream/_guides/cdi.adoc:197
#, fuzzy, no-wrap
msgid "`@ApplicationScoped` and `@Singleton` look very similar. Which one should I choose for my Quarkus application?"
msgstr "`@ApplicationScoped` e `@Singleton` são muito semelhantes. Qual deles devo escolher para a minha aplicação Quarkus?"

#. type: Plain text
#: upstream/_guides/cdi.adoc:200
#, fuzzy
msgid "It depends ;-)."
msgstr "Depende ;-)."

#. type: Plain text
#: upstream/_guides/cdi.adoc:203
#, fuzzy
msgid "A `@Singleton` bean has no xref:client_proxies[client proxy] and hence an instance is _created eagerly_ when the bean is injected. By contrast, an instance of an `@ApplicationScoped` bean is _created lazily_, i.e.  when a method is invoked upon an injected instance for the first time."
msgstr "Um bean `@Singleton` não tem  link:#client_proxies[proxy de cliente] e, por isso, uma instância é _criada avidamente_ quando o bean é injetado. Em contrapartida, uma instância de um bean `@ApplicationScoped` é _criada lentamente_, ou seja, quando um método é invocado pela primeira vez numa instância injectada."

#. type: Plain text
#: upstream/_guides/cdi.adoc:206
#, fuzzy
msgid "Furthermore, client proxies only delegate method invocations and thus you should never read/write fields of an injected `@ApplicationScoped` bean directly.  You can read/write fields of an injected `@Singleton` safely."
msgstr "Além disso, os proxies do cliente apenas delegam invocações de métodos e, por isso, nunca deve ler/escrever diretamente os campos de um bean `@ApplicationScoped` injetado. Pode ler/escrever campos de um `@Singleton` injetado com segurança."

#. type: Plain text
#: upstream/_guides/cdi.adoc:208
#, fuzzy
msgid "`@Singleton` should have a slightly better performance because the is no indirection (no proxy that delegates to the current instance from the context)."
msgstr "`@Singleton` deve ter um desempenho ligeiramente melhor porque não há indirecção (nenhum proxy que delegue a instância atual a partir do contexto)."

#. type: Plain text
#: upstream/_guides/cdi.adoc:210
#, fuzzy
msgid "On the other hand, you cannot mock `@Singleton` beans using xref:getting-started-testing.adoc#quarkus_mock[QuarkusMock]."
msgstr "Por outro lado, não é possível simular `@Singleton` beans utilizando  link:getting-started-testing.html#quarkus_mock[o QuarkusMock]."

#. type: Plain text
#: upstream/_guides/cdi.adoc:213
#, fuzzy
msgid "`@ApplicationScoped` beans can be also destroyed and recreated at runtime.  Existing injection points just work because the injected proxy delegates to the current instance."
msgstr "`@ApplicationScoped` também podem ser destruídos e recriados em tempo de execução. Os pontos de injeção existentes apenas funcionam porque o proxy injetado delega na instância atual."

#. type: Plain text
#: upstream/_guides/cdi.adoc:215
#, fuzzy
msgid "Therefore, we recommend to stick with `@ApplicationScoped` by default unless there's a good reason to use `@Singleton`."
msgstr "Por conseguinte, recomendamos a utilização de `@ApplicationScoped` por defeito, exceto se houver uma boa razão para utilizar `@Singleton`."

#. type: Title ==
#: upstream/_guides/cdi.adoc:217
#, fuzzy, no-wrap
msgid "I don't understand the concept of client proxies."
msgstr "Não percebo o conceito de proxies de cliente."

#. type: Plain text
#: upstream/_guides/cdi.adoc:222
#, fuzzy
msgid "Indeed, the https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp, but they provide some useful functionality.  A client proxy is basically an object that delegates all method invocations to a target bean instance.  It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class."
msgstr "De facto, os  link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#client_proxies[proxies de cliente, window=_blank] podem ser difíceis de compreender, mas fornecem algumas funcionalidades úteis. Um proxy de cliente é basicamente um objeto que delega todas as invocações de métodos a uma instância do bean de destino. Trata-se de uma construção de contentor que implementa `io.quarkus.arc.ClientProxy` e estende a classe do bean."

#. type: Plain text
#: upstream/_guides/cdi.adoc:224
#, fuzzy
msgid "Client proxies only delegate method invocations. So never read or write a field of a normal scoped bean, otherwise you will work with non-contextual or stale data."
msgstr "Os proxies de cliente apenas delegam invocações de métodos. Por isso, nunca leia ou escreva um campo de um bean com um âmbito normal, caso contrário trabalhará com dados não contextuais ou obsoletos."

#. type: Block title
#: upstream/_guides/cdi.adoc:225
#, fuzzy, no-wrap
msgid "Generated Client Proxy Example"
msgstr "Exemplo de Proxy de Cliente Gerado"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:230
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"class Translator {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:238
#, no-wrap
msgid ""
"// The client proxy class is generated and looks like...\n"
"class Translator_ClientProxy extends Translator { <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:246
#, no-wrap
msgid ""
"    String translate(String sentence) {\n"
"      // Find the correct translator instance...\n"
"      Translator translator = getTranslatorInstanceFromTheApplicationContext();\n"
"      // And delegate the method invocation...\n"
"      return translator.translate(sentence);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:248
#, fuzzy
msgid "The `Translator_ClientProxy` instance is always injected instead of a direct reference to a https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#contextual_instance[contextual instance, window=\"_blank\"] of the `Translator` bean."
msgstr "A instância `Translator_ClientProxy` é sempre injectada em vez de uma referência direta a uma  link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#contextual_instance[instância contextual, window=_blank] do bean `Translator`."

#. type: Plain text
#: upstream/_guides/cdi.adoc:250
#, fuzzy
msgid "Client proxies allow for:"
msgstr "Os proxies de cliente permitem:"

#. type: Plain text
#: upstream/_guides/cdi.adoc:252
#, fuzzy
msgid "Lazy instantiation - the instance is created once a method is invoked upon the proxy."
msgstr "Instanciação preguiçosa - a instância é criada assim que um método é invocado no proxy."

#. type: Plain text
#: upstream/_guides/cdi.adoc:253
#, fuzzy
msgid "Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean."
msgstr "Capacidade de injetar um bean com um âmbito \"mais restrito\" num bean com um âmbito \"mais alargado\"; ou seja, pode injetar um bean `@RequestScoped` num bean `@ApplicationScoped`."

#. type: Plain text
#: upstream/_guides/cdi.adoc:254
#, fuzzy
msgid "Circular dependencies in the dependency graph. Having circular dependencies is often an indication that a redesign should be considered, but sometimes it's inevitable."
msgstr "Dependências circulares no gráfico de dependências. A existência de dependências circulares é frequentemente uma indicação de que deve ser considerada uma nova conceção, mas por vezes é inevitável."

#. type: Plain text
#: upstream/_guides/cdi.adoc:255
#, fuzzy
msgid "In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance."
msgstr "Em casos raros, é prático destruir os beans manualmente. Uma referência injectada diretamente conduziria a uma instância de feijão obsoleta."

#. type: Title ==
#: upstream/_guides/cdi.adoc:257
#, fuzzy, no-wrap
msgid "OK. You said that there are several kinds of beans?"
msgstr "MUITO BEM. Disseste que há vários tipos de feijão?"

#. type: Plain text
#: upstream/_guides/cdi.adoc:260
#, fuzzy
msgid "Yes. In general, we distinguish:"
msgstr "Sim. Em geral, distinguimos:"

#. type: Plain text
#: upstream/_guides/cdi.adoc:262
#, fuzzy
msgid "Class beans"
msgstr "Feijões de classe"

#. type: Plain text
#: upstream/_guides/cdi.adoc:263
#, fuzzy
msgid "Producer methods"
msgstr "Métodos do produtor"

#. type: Plain text
#: upstream/_guides/cdi.adoc:264
#, fuzzy
msgid "Producer fields"
msgstr "Campos de produtores"

#. type: Plain text
#: upstream/_guides/cdi.adoc:265
#, fuzzy
msgid "Synthetic beans"
msgstr "Feijões sintéticos"

#. type: Plain text
#: upstream/_guides/cdi.adoc:267
#, fuzzy
msgid "Synthetic beans are usually provided by extensions. Therefore, we are not going to cover them in this guide."
msgstr "Os beans sintéticos são normalmente fornecidos por extensões. Por conseguinte, não os iremos abordar neste guia."

#. type: Plain text
#: upstream/_guides/cdi.adoc:270
#, fuzzy
msgid "Producer methods and fields are useful if you need additional control over instantiation of a bean.  They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc."
msgstr "Os métodos e campos de produtor são úteis se necessitar de controlo adicional sobre a instanciação de um bean. Também são úteis quando se integram bibliotecas de terceiros em que não se controla a origem da classe e não se podem acrescentar anotações adicionais, etc."

#. type: Block title
#: upstream/_guides/cdi.adoc:271
#, fuzzy, no-wrap
msgid "Producers Example"
msgstr "Exemplo de produtores"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:276
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class Producers {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:279
#, no-wrap
msgid ""
"    @Produces <1>\n"
"    double pi = Math.PI; <2>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:289
#, no-wrap
msgid ""
"    @Produces <3>\n"
"    List<String> names() {\n"
"       List<String> names = new ArrayList<>();\n"
"       names.add(\"Andy\");\n"
"       names.add(\"Adalbert\");\n"
"       names.add(\"Joachim\");\n"
"       return names; <4>\n"
"    }\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:292
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class Consumer {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:295
#, no-wrap
msgid ""
"   @Inject\n"
"   double pi;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:298
#, no-wrap
msgid ""
"   @Inject\n"
"   List<String> names;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:301
#, no-wrap
msgid ""
"   // ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:306
#, fuzzy
msgid "The container analyses the field annotations to build a bean metadata.  The _type_ is used to build the set of bean types.  In this case, it will be `double` and `java.lang.Object`.  No scope annotation is declared and so it's defaulted to `@Dependent`."
msgstr "O contentor analisa as anotações de campo para criar metadados de um bean. O _tipo_ é utilizado para criar o conjunto de tipos de feijão. Neste caso, será `double` e `java.lang.Object`. Não é declarada qualquer anotação de âmbito, pelo que a predefinição é `@Dependent`."

#. type: Plain text
#: upstream/_guides/cdi.adoc:307
#, fuzzy
msgid "The container will read this field when creating the bean instance."
msgstr "O contentor lerá este campo quando criar a instância do bean."

#. type: Plain text
#: upstream/_guides/cdi.adoc:311
#, fuzzy
msgid "The container analyses the method annotations to build a bean metadata.  The _return type_ is used to build the set of bean types.  In this case, it will be `List<String>`, `Collection<String>`, `Iterable<String>` and `java.lang.Object`.  No scope annotation is declared and so it's defaulted to `@Dependent`."
msgstr "O contentor analisa as anotações do método para criar metadados de um bean. O _tipo de retorno_ é utilizado para criar o conjunto de tipos de bean. Neste caso, será `List&amp;lt;String&amp;gt;`, `Collection&amp;lt;String&amp;gt;`, `Iterable&amp;lt;String&amp;gt;` e `java.lang.Object`. Não é declarada qualquer anotação de âmbito e, por isso, a predefinição é `@Dependent`."

#. type: Plain text
#: upstream/_guides/cdi.adoc:312
#, fuzzy
msgid "The container will call this method when creating the bean instance."
msgstr "O contentor chamará este método quando criar a instância do bean."

#. type: Plain text
#: upstream/_guides/cdi.adoc:316
#, fuzzy
msgid "There's more about producers.  You can declare qualifiers, inject dependencies into the producer methods parameters, etc.  You can read more about producers for example in the https://docs.jboss.org/weld/reference/latest/en-US/html/producermethods.html[Weld docs, window=\"_blank\"]."
msgstr "Há mais sobre os produtores. Pode declarar qualificadores, injetar dependências nos parâmetros dos métodos produtores, etc. Pode ler mais sobre produtores, por exemplo, na  link:https://docs.jboss.org/weld/reference/latest/en-US/html/producermethods.html[documentação do Weld, window=_blank]."

#. type: Title ==
#: upstream/_guides/cdi.adoc:317
#, fuzzy, no-wrap
msgid "OK, injection looks cool. What other services are provided?"
msgstr "OK, a injeção parece fixe. Que outros serviços são prestados?"

#. type: Title ===
#: upstream/_guides/cdi.adoc:319
#, fuzzy, no-wrap
msgid "Lifecycle Callbacks"
msgstr "Chamadas de retorno do ciclo de vida"

#. type: Plain text
#: upstream/_guides/cdi.adoc:322
#, fuzzy
msgid "A bean class may declare lifecycle `@PostConstruct` and `@PreDestroy` callbacks:"
msgstr "Uma classe bean pode declarar o ciclo de vida `@PostConstruct` e `@PreDestroy` callbacks:"

#. type: Block title
#: upstream/_guides/cdi.adoc:323
#, fuzzy, no-wrap
msgid "Lifecycle Callbacks Example"
msgstr "Exemplo de chamadas de retorno do ciclo de vida"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:328
#, no-wrap
msgid ""
"import jakarta.annotation.PostConstruct;\n"
"import jakarta.annotation.PreDestroy;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:336
#, no-wrap
msgid ""
"    @PostConstruct <1>\n"
"    void init() {\n"
"       // ...\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:342
#, no-wrap
msgid ""
"    @PreDestroy <2>\n"
"    void destroy() {\n"
"      // ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:344
#, fuzzy
msgid "This callback is invoked before the bean instance is put into service. It is safe to perform some initialization here."
msgstr "Esta chamada de retorno é invocada antes de a instância do bean ser colocada em serviço. É seguro efetuar alguma inicialização aqui."

#. type: Plain text
#: upstream/_guides/cdi.adoc:345
#, fuzzy
msgid "This callback is invoked before the bean instance is destroyed. It is safe to perform some cleanup tasks here."
msgstr "Esta chamada de retorno é invocada antes de a instância do bean ser destruída. É seguro efetuar aqui algumas tarefas de limpeza."

#. type: Plain text
#: upstream/_guides/cdi.adoc:347
#, fuzzy
msgid "It's a good practice to keep the logic in the callbacks \"without side effects\", i.e. you should avoid calling other beans inside the callbacks."
msgstr "É uma boa prática manter a lógica nas callbacks \"sem efeitos secundários\", ou seja, deve evitar chamar outros beans dentro das callbacks."

#. type: Title ===
#: upstream/_guides/cdi.adoc:349
#, fuzzy, no-wrap
msgid "Interceptors"
msgstr "Interceptores"

#. type: Plain text
#: upstream/_guides/cdi.adoc:353
#, fuzzy
msgid "Interceptors are used to separate cross-cutting concerns from business logic.  There is a separate specification - Java Interceptors - that defines the basic programming model and semantics."
msgstr "Os interceptores são utilizados para separar as preocupações transversais da lógica empresarial. Existe uma especificação separada - Interceptores Java - que define o modelo básico de programação e a semântica."

#. type: Block title
#: upstream/_guides/cdi.adoc:354
#, fuzzy, no-wrap
msgid "Simple Interceptor Binding Example"
msgstr "Exemplo simples de ligação a um intercetor"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:363
#, no-wrap
msgid ""
"import java.lang.annotation.ElementType;\n"
"import java.lang.annotation.Inherited;\n"
"import java.lang.annotation.Retention;\n"
"import java.lang.annotation.RetentionPolicy;\n"
"import java.lang.annotation.Target;\n"
"import jakarta.interceptor.InterceptorBinding;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:370
#, no-wrap
msgid ""
"@InterceptorBinding // <1>\n"
"@Retention(RetentionPolicy.RUNTIME)\n"
"@Target({ElementType.TYPE, ElementType.METHOD, ElementType.CONSTRUCTOR}) // <2>\n"
"@Inherited // <3>\n"
"public @interface Logged {\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:372
#, fuzzy
msgid "This is an interceptor binding annotation. See the following examples for how it's used."
msgstr "Esta é uma anotação de ligação de intercetor. Veja os exemplos seguintes para saber como é utilizada."

#. type: Plain text
#: upstream/_guides/cdi.adoc:373
#, fuzzy
msgid "An interceptor binding annotation is always put on the interceptor type, and may be put on target types or methods."
msgstr "Uma anotação de ligação de intercetor é sempre colocada no tipo de intercetor e pode ser colocada em tipos ou métodos de destino."

#. type: Plain text
#: upstream/_guides/cdi.adoc:374
#, fuzzy
msgid "Interceptor bindings are often `@Inherited`, but don't have to be."
msgstr "As ligações Intercetor são frequentemente `@Inherited`, mas não têm de o ser."

#. type: Block title
#: upstream/_guides/cdi.adoc:375
#, fuzzy, no-wrap
msgid "Simple Interceptor Example"
msgstr "Exemplo de intercetor simples"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:382
#, no-wrap
msgid ""
"import jakarta.annotation.Priority;\n"
"import jakarta.interceptor.AroundInvoke;\n"
"import jakarta.interceptor.Interceptor;\n"
"import jakarta.interceptor.InvocationContext;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:387
#, no-wrap
msgid ""
"@Logged // <1>\n"
"@Priority(2020) // <2>\n"
"@Interceptor // <3>\n"
"public class LoggingInterceptor {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:390
#, no-wrap
msgid ""
"   @Inject // <4>\n"
"   Logger logger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:398
#, no-wrap
msgid ""
"   @AroundInvoke // <5>\n"
"   Object logInvocation(InvocationContext context) {\n"
"      // ...log before\n"
"      Object ret = context.proceed(); // <6>\n"
"      // ...log after\n"
"      return ret;\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:400 upstream/_guides/cdi.adoc:466
#: upstream/_guides/cdi.adoc:502 upstream/_guides/cdi.adoc:511
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:402
#, fuzzy
msgid "The interceptor binding annotation is used to bind our interceptor to a bean. Simply annotate a bean class with `@Logged`, as in the following example."
msgstr "A anotação de ligação do intercetor é utilizada para ligar o nosso intercetor a um bean. Basta anotar uma classe de bean com `@Logged`, como no exemplo seguinte."

#. type: Plain text
#: upstream/_guides/cdi.adoc:403
#, fuzzy
msgid "`Priority` enables the interceptor and affects the interceptor ordering. Interceptors with smaller priority values are called first."
msgstr "`Priority` ativa o intercetor e afecta a ordem dos interceptores. Os interceptores com valores de prioridade mais baixos são chamados primeiro."

#. type: Plain text
#: upstream/_guides/cdi.adoc:404
#, fuzzy
msgid "Marks an interceptor component."
msgstr "Marca um componente intercetor."

#. type: Plain text
#: upstream/_guides/cdi.adoc:405
#, fuzzy
msgid "An interceptor may inject dependencies."
msgstr "Um intercetor pode injetar dependências."

#. type: Plain text
#: upstream/_guides/cdi.adoc:406
#, fuzzy
msgid "`AroundInvoke` denotes a method that interposes on business methods."
msgstr "`AroundInvoke` designa um método que se interpõe aos métodos empresariais."

#. type: Plain text
#: upstream/_guides/cdi.adoc:407
#, fuzzy
msgid "Proceed to the next interceptor in the interceptor chain or invoke the intercepted business method."
msgstr "Avançar para o intercetor seguinte na cadeia de interceptores ou invocar o método comercial intercetado."

#. type: Plain text
#: upstream/_guides/cdi.adoc:409
#, fuzzy
msgid "Instances of interceptors are dependent objects of the bean instance they intercept, i.e. a new interceptor instance is created for each intercepted bean."
msgstr "As instâncias de interceptores são objectos dependentes da instância do bean que interceptam, ou seja, é criada uma nova instância de intercetor para cada bean intercetado."

#. type: Block title
#: upstream/_guides/cdi.adoc:410
#, fuzzy, no-wrap
msgid "Simple Example of Interceptor Usage"
msgstr "Exemplo simples de utilização de interceptores"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:414
#, no-wrap
msgid "import jakarta.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:422
#, no-wrap
msgid ""
"@Logged // <1> <2>\n"
"@ApplicationScoped\n"
"public class MyService {\n"
"   void doSomething() {\n"
"       ...\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:425
#, fuzzy
msgid "The interceptor binding annotation is put on a bean class so that all business methods are intercepted.  The annotation can also be put on individual methods, in which case, only the annotated methods are intercepted."
msgstr "A anotação de ligação do intercetor é colocada numa classe bean para que todos os métodos empresariais sejam interceptados. A anotação também pode ser colocada em métodos individuais e, nesse caso, apenas os métodos anotados são interceptados."

#. type: Plain text
#: upstream/_guides/cdi.adoc:427
#, fuzzy
msgid "Remember that the `@Logged` annotation is `@Inherited`.  If there's a bean class that inherits from `MyService`, the `LoggingInterceptor` will also apply to it."
msgstr "Lembre-se de que a anotação `@Logged` é `@Inherited`. Se houver uma classe de feijão que herda de `MyService`, a anotação `LoggingInterceptor` também se aplicará a ela."

#. type: Title ===
#: upstream/_guides/cdi.adoc:429
#, fuzzy, no-wrap
msgid "Decorators"
msgstr "Decoradores"

#. type: Plain text
#: upstream/_guides/cdi.adoc:432
#, fuzzy
msgid "Decorators are similar to interceptors, but because they implement interfaces with business semantics, they are able to implement business logic."
msgstr "Os decoradores são semelhantes aos interceptores, mas como implementam interfaces com semântica comercial, podem implementar a lógica comercial."

#. type: Block title
#: upstream/_guides/cdi.adoc:433
#, fuzzy, no-wrap
msgid "Simple Decorator Example"
msgstr "Exemplo de Decorador Simples"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:441
#, no-wrap
msgid ""
"import jakarta.decorator.Decorator;\n"
"import jakarta.decorator.Delegate;\n"
"import jakarta.annotation.Priority;\n"
"import jakarta.inject.Inject;\n"
"import jakarta.enterprise.inject.Any;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:445
#, no-wrap
msgid ""
"public interface Account {\n"
"   void withdraw(BigDecimal amount);\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:449
#, no-wrap
msgid ""
"@Priority(10) <1>\n"
"@Decorator <2>\n"
"public class LargeTxAccount implements Account { <3>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:454
#, no-wrap
msgid ""
"   @Inject\n"
"   @Any\n"
"   @Delegate\n"
"   Account delegate; <4>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:457
#, no-wrap
msgid ""
"   @Inject\n"
"   LogService logService; <5>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:464
#, no-wrap
msgid ""
"   void withdraw(BigDecimal amount) {\n"
"      delegate.withdraw(amount); <6>\n"
"      if (amount.compareTo(1000) > 0) {\n"
"         logService.logWithdrawal(delegate, amount);\n"
"      }\n"
"   }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:468
#, fuzzy
msgid "`@Priority` enables the decorator. Decorators with smaller priority values are called first."
msgstr "`@Priority` ativa o decorador. Os decoradores com valores de prioridade mais pequenos são chamados primeiro."

#. type: Plain text
#: upstream/_guides/cdi.adoc:469
#, fuzzy
msgid "`@Decorator` marks a decorator component."
msgstr "`@Decorator` marca um componente decorador."

#. type: Plain text
#: upstream/_guides/cdi.adoc:470
#, fuzzy
msgid "The set of decorated types includes all bean types which are Java interfaces, except for `java.io.Serializable`."
msgstr "O conjunto de tipos decorados inclui todos os tipos de feijões que são interfaces Java, exceto `java.io.Serializable`."

#. type: Plain text
#: upstream/_guides/cdi.adoc:471
#, fuzzy
msgid "Each decorator must declare exactly one _delegate injection point_. The decorator applies to beans that are assignable to this delegate injection point."
msgstr "Cada decorador deve declarar exatamente um _ponto de injeção de delegados_. O decorador aplica-se aos beans que são atribuíveis a este ponto de injeção de delegados."

#. type: Plain text
#: upstream/_guides/cdi.adoc:472
#, fuzzy
msgid "Decorators can inject other beans."
msgstr "Os decoradores podem injetar outros feijões."

#. type: Plain text
#: upstream/_guides/cdi.adoc:473
#, fuzzy
msgid "The decorator may invoke any method of the delegate object. And the container invokes either the next decorator in the chain or the business method of the intercepted instance."
msgstr "O decorador pode invocar qualquer método do objeto delegado. E o contentor invoca o decorador seguinte na cadeia ou o método comercial da instância interceptada."

#. type: Plain text
#: upstream/_guides/cdi.adoc:475
#, fuzzy
msgid "Instances of decorators are dependent objects of the bean instance they intercept, i.e. a new decorator instance is created for each intercepted bean."
msgstr "As instâncias de decoradores são objectos dependentes da instância do bean que interceptam, ou seja, é criada uma nova instância de decorador para cada bean intercetado."

#. type: Title ===
#: upstream/_guides/cdi.adoc:476
#, fuzzy, no-wrap
msgid "Events and Observers"
msgstr "Eventos e observadores"

#. type: Plain text
#: upstream/_guides/cdi.adoc:481
#, fuzzy
msgid "Beans may also produce and consume events to interact in a completely decoupled fashion.  Any Java object can serve as an event payload.  The optional qualifiers act as topic selectors."
msgstr "Os feijões também podem produzir e consumir eventos para interagir de uma forma completamente desacoplada. Qualquer objeto Java pode servir como uma carga útil de evento. Os qualificadores opcionais funcionam como selectores de tópicos."

#. type: Block title
#: upstream/_guides/cdi.adoc:482
#, fuzzy, no-wrap
msgid "Simple Event Example"
msgstr "Exemplo de evento simples"

#. type: delimited block -
#: upstream/_guides/cdi.adoc:489
#, no-wrap
msgid ""
"class TaskCompleted {\n"
"  // ...\n"
"}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:492
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"class ComplicatedService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:495
#, no-wrap
msgid ""
"   @Inject\n"
"   Event<TaskCompleted> event; <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:500
#, no-wrap
msgid ""
"   void doSomething() {\n"
"      // ...\n"
"      event.fire(new TaskCompleted()); <2>\n"
"   }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:505
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"class Logger {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi.adoc:509
#, no-wrap
msgid ""
"   void onTaskCompleted(@Observes TaskCompleted task) { <3>\n"
"      // ...log the task\n"
"   }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi.adoc:513
#, fuzzy
msgid "`jakarta.enterprise.event.Event` is used to fire events."
msgstr "`jakarta.enterprise.event.Event` é utilizado para ativar eventos."

#. type: Plain text
#: upstream/_guides/cdi.adoc:514
#, fuzzy
msgid "Fire the event synchronously."
msgstr "Dispara o evento de forma síncrona."

#. type: Plain text
#: upstream/_guides/cdi.adoc:515
#, fuzzy
msgid "This method is notified when a `TaskCompleted` event is fired."
msgstr "Este método é notificado quando um evento `TaskCompleted` é acionado."

#. type: Plain text
#: upstream/_guides/cdi.adoc:517
#, fuzzy
msgid "For more info about events/observers visit https://docs.jboss.org/weld/reference/latest/en-US/html/events.html[Weld docs, window=\"_blank\"]."
msgstr "Para mais informações sobre eventos/observadores, visite  link:https://docs.jboss.org/weld/reference/latest/en-US/html/events.html[Weld docs, window=_blank]."

#. type: Title ==
#: upstream/_guides/cdi.adoc:518
#, fuzzy, no-wrap
msgid "Conclusion"
msgstr "Conclusão"

#. type: Plain text
#: upstream/_guides/cdi.adoc:524
#, fuzzy
msgid "In this guide, we've covered some basic topics of the Quarkus programming model that is based on the https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html[Jakarta Contexts and Dependency Injection 4.0, window=\"_blank\"] specification.  Quarkus implements the CDI Lite specification, but not CDI Full.  See also xref:cdi-reference.adoc#supported_features[the list of supported features] and xref:cdi-reference.adoc#limitations[the list of limitations].  There are also quite a few xref:cdi-reference.adoc#nonstandard_features[non-standard features] and xref:cdi-reference.adoc#build_time_apis[Quarkus-specific APIs]."
msgstr "Neste guia, abordamos alguns tópicos básicos do modelo de programação Quarkus, que é baseado na especificação  link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html[Jakarta Contexts and Dependency Injection 4.0, window=_blank]. O Quarkus implementa a especificação CDI Lite, mas não a CDI Full. Veja também  link:cdi-reference.html#supported_features[a lista de recursos suportados] e  link:cdi-reference.html#limitations[a lista de limitações]. Há também alguns  link:cdi-reference.html#nonstandard_features[recursos não-padrão] e  link:cdi-reference.html#build_time_apis[APIs específicas do Quarkus]."

#. type: Plain text
#: upstream/_guides/cdi.adoc:526
#, fuzzy
msgid "If you wish to learn more about Quarkus-specific features and limitations there is a Quarkus xref:cdi-reference.adoc[CDI Reference Guide].  We also recommend you to read the https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html[CDI specification] and the https://docs.jboss.org/weld/reference/latest/en-US/html/[Weld documentation] (Weld is a CDI Reference Implementation) to get acquainted with more complex topics."
msgstr "Se quiser saber mais sobre as características e limitações específicas do Quarkus, existe um  link:cdi-reference.html[Guia de Referência CDI] do Quarkus. Recomendamos também a leitura da  link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html[especificação CDI] e da  link:https://docs.jboss.org/weld/reference/latest/en-US/html/[documentação Weld] (Weld é uma implementação de referência CDI) para se familiarizar com tópicos mais complexos."
