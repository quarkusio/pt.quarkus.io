# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2023-09-21 08:24+0900\n"
"PO-Revision-Date: 2023-09-25 23:21-0300\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: pt\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.3.2\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/aws-lambda-http.adoc:6
#, fuzzy, no-wrap
msgid "AWS Lambda with RESTEasy Reactive, Undertow, or Reactive Routes"
msgstr "AWS Lambda com RESTEasy Reactive, Undertow ou Reactive Routes"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:16
msgid "With Quarkus you can deploy your favorite Java HTTP frameworks as AWS Lambda's using either the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[AWS Gateway HTTP API] or https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[AWS Gateway REST API].  This means that you can deploy your microservices written with RESTEasy Reactive (our Jakarta REST implementation), Undertow (servlet), Reactive Routes, xref:funqy-http.adoc[Funqy HTTP] or any other Quarkus HTTP framework as an AWS Lambda."
msgstr "Com o Quarkus, é possível fazer o deploy de seu framework Java HTTP favorito como AWS Lambdas usando a  link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[API HTTP do AWS Gateway] ou a  link:https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[API REST do AWS Gateway]. Isto significa que você pode fazer o deploy dos seus microsserviços escritos com RESTEasy Reactive (a nossa implementação Jakarta REST), Undertow (servlet), Reactive Routes,  link:funqy-http.html[Funqy HTTP] ou qualquer outra estrutura HTTP Quarkus como um AWS Lambda."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:19
msgid "You can deploy your Lambda as a pure Java jar, or you can compile your project to a native image and deploy that for a smaller memory footprint and startup time.  Our integration also generates SAM deployment files that can be consumed by https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html[Amazon's SAM framework]."
msgstr "Você pode fazer o deploy da sua Lambda como um jar Java puro, ou pode compilar o seu projeto para uma imagem nativa e implementá-la para um menor consumo de memória e um tempo de inicialização mais rápido. A nossa integração também gera arquivos de implementação SAM que podem ser consumidos pela  link:https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html[estrutura SAM da Amazon]."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:23
msgid "Quarkus has a different extension for each Gateway API.  The HTTP Gateway API is implemented within the `quarkus-amazon-lambda-http` extension.  The REST Gateway API is implemented within the `quarkus-amazon-lambda-rest` extension.  If you are confused on which Gateway product to use, Amazon has a https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[great guide] to help you navigate this decision."
msgstr "O Quarkus tem uma extensão diferente para cada API de gateway. A API de Gateway HTTP é implementada na extensão `quarkus-amazon-lambda-http`. A API do Gateway REST é implementada na extensão `quarkus-amazon-lambda-rest`. Se estiver confuso quanto a qual Gateway utilizar, a Amazon tem um  link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[excelente guia] para ajudar você a tomar esta decisão."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:25
msgid "Like most Quarkus extensions, the Quarkus AWS Lambda HTTP/REST extensions support Live Coding."
msgstr "Tal como a maioria das extensões Quarkus, as extensões Quarkus AWS Lambda HTTP/REST suportam Live Coding."

#. type: Title ==
#: upstream/_guides/aws-lambda-http.adoc:28
#, no-wrap
msgid "Prerequisites"
msgstr "Pré-requisitos"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:33
msgid "https://aws.amazon.com[An Amazon AWS account]"
msgstr "link:https://aws.amazon.com[Uma conta Amazon AWS]"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:34
msgid "https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]"
msgstr "link:https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[CLI DO AWS SAM]"

#. type: Title ==
#: upstream/_guides/aws-lambda-http.adoc:35
#, no-wrap
msgid "Getting Started"
msgstr "Iniciando"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:39
msgid "This guide walks you through generating an example Java project via a Maven archetype.  Later on, it walks through the structure of the project so you can adapt any existing projects you have to use AWS Lambda."
msgstr "Este guia vai orientar você  na geração de um projeto Java de exemplo por meio de um arquétipo Maven. Posteriormente, ele percorre a estrutura do projeto para que você possa adaptar qualquer projeto existente para usar o AWS Lambda."

#. type: Title ==
#: upstream/_guides/aws-lambda-http.adoc:40
#, no-wrap
msgid "Installing AWS bits"
msgstr "Instalando os componentes AWS"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:44
msgid "Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps for installing AWS SAM CLI."
msgstr "A instalação de todos os componentes AWS é provavelmente a parte mais difícil deste guia. Certifique-se de que ter seguido todos os passos para instalar o AWS SAM CLI."

#. type: Title ==
#: upstream/_guides/aws-lambda-http.adoc:45
#, no-wrap
msgid "Creating the Maven Deployment Project"
msgstr "Criando o Maven Deployment Project"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:48
msgid "Create the Quarkus AWS Lambda Maven project using our Maven Archetype."
msgstr "Crie o projeto Quarkus AWS Lambda Maven utilizando o nosso Arquétipo Maven."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:50
msgid "If you want to use the AWS Gateway HTTP API, generate your project with this script:"
msgstr "Se você quiser utilizar a API HTTP do AWS Gateway, gere o seu projeto com este script:"

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:56
#, no-wrap
msgid ""
"mvn archetype:generate \\\n"
"       -DarchetypeGroupId=io.quarkus \\\n"
"       -DarchetypeArtifactId=quarkus-amazon-lambda-http-archetype \\\n"
"       -DarchetypeVersion={quarkus-version}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:59
msgid "If you want to use the AWS Gateway REST API, generate your project with this script:"
msgstr "Se você quiser utilizar a API REST do AWS Gateway, gere o seu projeto com este script:"

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:65
#, no-wrap
msgid ""
"mvn archetype:generate \\\n"
"       -DarchetypeGroupId=io.quarkus \\\n"
"       -DarchetypeArtifactId=quarkus-amazon-lambda-rest-archetype \\\n"
"       -DarchetypeVersion={quarkus-version}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/aws-lambda-http.adoc:68
#, no-wrap
msgid "Build and Deploy"
msgstr "Build e Deploy"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:71
msgid "Build the project:"
msgstr "Compile o projeto:"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:77
msgid "This will compile the code and run the unit tests included within the generated project.  Unit testing is the same as any other Java project and does not require running on Amazon.  Quarkus dev mode is also available with this extension."
msgstr "Isto irá compilar o código e executar os testes de unitários incluídos no projeto gerado. O teste unitário é o mesmo que qualquer outro projeto Java e não requer a execução na Amazon. O _dev_ _mode_ do Quarkus também está disponível com esta extensão."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:80
msgid "If you want to build a native executable, make sure you have GraalVM installed correctly and just add a `native` property to the build"
msgstr "Se você quiser construir um executável nativo, certifique-se de que tem o GraalVM instalado corretamente e adicione uma propriedade `native` à construção"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:86
msgid "If you are building on a non-Linux system, you will need to also pass in a property instructing quarkus to use a Docker build as Amazon Lambda requires Linux binaries.  You can do this by passing `-Dquarkus.native.container-build=true` to your build command.  This requires you to have Docker installed locally, however."
msgstr "Se voê estiver construindo em um sistema que não seja Linux, terá de passar também uma propriedade que instrua o quarkus a utilizar uma compilação Docker, uma vez que o Amazon Lambda requer binários Linux. Você pode fazer isso passando `-Dquarkus.native.container-build=true` para o seu comando de compilação. No entanto, isso requer que você tenha o Docker instalado localmente."

#. type: Title ==
#: upstream/_guides/aws-lambda-http.adoc:89
#, no-wrap
msgid "Extra Build Generated Files"
msgstr "Arquivos extras gerados pela compilação"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:93
msgid "After you run the build, there are a few extra files generated by the Quarkus lambda extension you are using.  These files are in the build directory: `target/` for Maven, `build/` for Gradle."
msgstr "Depois de executar a compilação, existem alguns arquivos extras gerados pela extensão lambda Quarkus que você esta usando. Estes arquivos encontram-se no diretório de compilação: `target/` para Maven, `build/` para Gradle."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:95
msgid "`function.zip` - lambda deployment file"
msgstr "`function.zip` - arquivo de deployment lambda"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:96
msgid "`sam.jvm.yaml` - sam cli deployment script"
msgstr "`sam.jvm.yaml` - script de deployment do sam cli"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:97
msgid "`sam.native.yaml` - sam cli deployment script for native"
msgstr "`sam.native.yaml` - script de deployment do sam cli para nativo"

#. type: Title ==
#: upstream/_guides/aws-lambda-http.adoc:98
#, no-wrap
msgid "Live Coding and Simulating AWS Lambda Environment Locally"
msgstr "Live Coding e simulação local do ambiente AWS Lambda"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:104
msgid "In dev and test mode, Quarkus will start a mock AWS Lambda event server that will convert HTTP requests to the corresponding API Gateway event types and post them to the underlying Quarkus HTTP lambda environment for processing.  This simulates the AWS Lambda environment as much as possible locally without requiring tools like Docker and SAM CLI."
msgstr "No modo de desenvolvimento e teste, o Quarkus iniciará um servidor de eventos AWS Lambda simulado que converterá solicitações HTTP para os tipos de eventos correspondentes do API Gateway e os publicará no ambiente lambda HTTP subjacente do Quarkus para processamento. Isso simula o ambiente do AWS Lambda o máximo possível localmente sem exigir ferramentas como Docker e SAM CLI."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:108
msgid "When using Quarkus Dev Mode just invoke HTTP requests on `http://localhost:8080` as you normally would when testing your REST endpoints.  This request will hit the Mock Event Server and will be converted to the API Gateway json message that is consumed by the Quarkus Lambda Poll loop."
msgstr "Ao usar o _dev_ _mode_ do Quarkus, basta invocar pedidos HTTP em `&lt;a href=\"http://localhost:8080\" class=\"bare\"&gt;http://localhost:8080&lt;/a&gt;` como você faria normalmente ao testar seus endpoints REST. Este pedido chegará ao Mock Event Server e será convertido na mensagem json do API Gateway que é consumida pelo Quarkus Lambda Poll loop."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:111
msgid "For testing, Quarkus starts up a separate Mock Event server under port 8081.  The default port for Rest Assured is automatically set to 8081 by Quarkus, so you don't have to worry about setting this up."
msgstr "Para testes, o Quarkus inicia um servidor Mock Event separado na porta 8081. A porta predefinida para o Rest Assured é automaticamente definida para 8081 pelo Quarkus, para que você não tenha que se preocupar configurando isto."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:116
msgid "If you want to simulate more complex API Gateway events in your tests, then manually do an HTTP POST to `http://localhost:8080/\\_lambda_` (port 8081 in test mode) with the raw API Gateway json events.  These events will be placed directly on the Quarkus Lambda poll loop for processing.  Here's an example of that:"
msgstr "Se você quiser simular eventos mais complexos do API Gateway em seus testes, faça manualmente um HTTP POST para `&lt;a href=\"http://localhost:8080/_lambda_\" class=\"bare\"&gt;http://localhost:8080/_lambda_&lt;/a&gt;` (porta 8081 no modo de teste) com os eventos json brutos do API Gateway. Esses eventos serão colocados diretamente no Quarkus Lambda poll loop  para processamento. Aqui está um exemplo disso:"

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:121
#, no-wrap
msgid ""
"import static io.restassured.RestAssured.given;\n"
"import static org.hamcrest.CoreMatchers.equalTo;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:123
#: upstream/_guides/aws-lambda-http.adoc:476
#: upstream/_guides/aws-lambda-http.adoc:517
#, no-wrap
msgid "import com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:125
#, no-wrap
msgid "import io.quarkus.test.junit.QuarkusTest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:135
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class AmazonLambdaSimpleTestCase {\n"
"    @Test\n"
"    public void testJaxrsCognitoJWTSecurityContext() throws Exception {\n"
"        APIGatewayV2HTTPEvent request = request(\"/security/username\");\n"
"        request.getRequestContext().setAuthorizer(new APIGatewayV2HTTPEvent.RequestContext.Authorizer());\n"
"        request.getRequestContext().getAuthorizer().setJwt(new APIGatewayV2HTTPEvent.RequestContext.Authorizer.JWT());\n"
"        request.getRequestContext().getAuthorizer().getJwt().setClaims(new HashMap<>());\n"
"        request.getRequestContext().getAuthorizer().getJwt().getClaims().put(\"cognito:username\", \"Bill\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:146
#, no-wrap
msgid ""
"        given()\n"
"                .contentType(\"application/json\")\n"
"                .accept(\"application/json\")\n"
"                .body(request)\n"
"                .when()\n"
"                .post(\"/_lambda_\")\n"
"                .then()\n"
"                .statusCode(200)\n"
"                .body(\"body\", equalTo(\"Bill\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:149
msgid "The above example simulates sending a Cognito principal with an HTTP request to your HTTP Lambda."
msgstr "O exemplo acima simula o envio de uma entidade Cognito com um pedido HTTP para o seu HTTP Lambda."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:154
msgid "If you want to hand code raw events for the AWS HTTP API, the AWS Lambda library has the request event type which is `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` and the response event type of `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse`.  This corresponds to the `quarkus-amazon-lambda-http` extension and the AWS HTTP API."
msgstr "Se você quiser codificar manualmente eventos brutos para a API HTTP da AWS, a biblioteca Lambda da AWS tem o tipo de evento de request que é `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` e o tipo de evento de response de `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse`. Isto corresponde à extensão `quarkus-amazon-lambda-http` e à API HTTP da AWS."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:158
msgid "If you want to hand code raw events for the AWS REST API, Quarkus has its own implementation: `io.quarkus.amazon.lambda.http.model.AwsProxyRequest` and `io.quarkus.amazon.lambda.http.model.AwsProxyResponse`.  This corresponds to `quarkus-amazon-lambda-rest` extension and the AWS REST API."
msgstr "Se você quiser codificar manualmente eventos brutos para a API REST do AWS, o Quarkus tem a sua própria implementação: `io.quarkus.amazon.lambda.http.model.AwsProxyRequest` e `io.quarkus.amazon.lambda.http.model.AwsProxyResponse`. Isto corresponde à extensão `quarkus-amazon-lambda-rest` e à API REST da AWS."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:161
msgid "The mock event server is also started for `@QuarkusIntegrationTest` tests so will work with native binaries too.  All this provides similar functionality to the SAM CLI local testing, without the overhead of Docker."
msgstr "O mock event server também é iniciado para os testes `@QuarkusIntegrationTest`, pelo que também funcionará com binários nativos. Tudo isso fornece uma funcionalidade semelhante ao teste local do SAM CLI, sem a sobrecarga do Docker."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:164
msgid "Finally, if port 8080 or port 8081 is not available on your computer, you can modify the dev and test mode ports with application.properties"
msgstr "Finalmente, se a porta 8080 ou a porta 8081 não estiver disponível no seu computador, pode modificar as portas dos modos dev e test usando o application.properties"

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:169
#, no-wrap
msgid ""
"quarkus.lambda.mock-event-server.dev-port=8082\n"
"quarkus.lambda.mock-event-server.test-port=8083\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:172
msgid "A port value of zero will result in a randomly assigned port."
msgstr "Um valor de porta zero resultará numa porta atribuída aleatoriamente."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:174
msgid "To turn off the mock event server:"
msgstr "Para desativar o mock event server:"

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:177
#, no-wrap
msgid "quarkus.lambda.mock-event-server.enabled=false\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/aws-lambda-http.adoc:180
#, no-wrap
msgid "Simulate AWS Lambda Deployment with SAM CLI"
msgstr "Simular o AWS Lambda Deployment com a CLI do SAM"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:184
msgid "The AWS SAM CLI allows you to run your lambda's locally on your laptop in a simulated Lambda environment.  This requires Docker to be installed.  After you have built your Maven project, execute this command:"
msgstr "O AWS SAM CLI permite que você execute seus lambda's localmente no seu laptop em um ambiente Lambda simulado. Para isso, é necessário que o Docker esteja instalado. Depois de criar seu projeto Maven, execute este comando:"

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:188
#, no-wrap
msgid "sam local start-api --template target/sam.jvm.yaml\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:192
msgid "This will start a Docker container that mimics Amazon's Lambda's deployment environment. Once the environment is started you can invoke the example lambda in your browser by going to:"
msgstr "Isso iniciará um container Docker que imita o ambiente de deployment do Lambda da Amazon. Depois que o ambiente for iniciado, você poderá invocar o lambda de exemplo no seu navegador acessando:"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:194
msgid "http://127.0.0.1:3000/hello"
msgstr "http://127.0.0.1:3000/hello"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:197
msgid "In the console you'll see startup messages from the lambda.  This particular deployment starts a JVM and loads your lambda as pure Java."
msgstr "No console, você verá mensagens de inicialização do lambda. Esse deployment específico inicia uma JVM e carrega seu lambda como Java puro."

#. type: Title ==
#: upstream/_guides/aws-lambda-http.adoc:199
#, no-wrap
msgid "Deploy to AWS"
msgstr "Deploy na AWS"

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:204
#, no-wrap
msgid "sam deploy -t target/sam.jvm.yaml -g\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:208
msgid "Answer all the questions and your lambda will be deployed and the necessary hooks to the API Gateway will be set up. If everything deploys successfully, the root URL of your microservice will be output to the console.  Something like this:"
msgstr "Responda a todas as perguntas e seu lambda será implantado e os hooks necessários para o API Gateway serão configurados. Se tudo for implantado com sucesso, o URL raiz do seu microsserviço será enviado para o console. Algo parecido com isto:"

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:213
#, no-wrap
msgid ""
"Key                 LambdaHttpApi\n"
"Description         URL for application\n"
"Value               https://234asdf234as.execute-api.us-east-1.amazonaws.com/\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:216
msgid "The `Value` attribute is the root URL for your lambda. Copy it to your browser and add `hello` at the end."
msgstr "O atributo `Value` é o URL raiz do seu lambda. Copie-o para o seu navegador e adicione `hello` no final."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:222
msgid "Responses for binary types will be automatically encoded with base64.  This is different from the behavior using `quarkus:dev` which will return the raw bytes.  Amazon's API has additional restrictions requiring the base64 encoding.  In general, client code will automatically handle this encoding but in certain custom situations, you should be aware you may need to manually manage that encoding."
msgstr "As respostas para tipos binários serão automaticamente codificadas com base64. Isso é diferente do comportamento usando `quarkus:dev`, que retornará os bytes brutos. A API da Amazon tem restrições adicionais que exigem a codificação base64. Em geral, o código do cliente tratará automaticamente desta codificação, mas em determinadas situações personalizadas, deve estar ciente de que poderá ter de gerir manualmente essa codificação."

#. type: Title ==
#: upstream/_guides/aws-lambda-http.adoc:223
#, no-wrap
msgid "Deploying a native executable"
msgstr "Deploy de um executável nativo"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:226
msgid "To deploy a native executable, you must build it with GraalVM."
msgstr "Para fazer o deploy de um executável nativo, é necessário compilá-lo com o GraalVM."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:230
msgid "You can then test the executable locally with sam local"
msgstr "Você pode então testar o executável localmente com sam local"

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:234
#, no-wrap
msgid "sam local start-api --template target/sam.native.yaml\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:237
msgid "To deploy to AWS Lambda:"
msgstr "Para fazer o deploy no AWS Lambda:"

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:240
#, no-wrap
msgid "sam deploy -t target/sam.native.yaml -g\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/aws-lambda-http.adoc:242
#, no-wrap
msgid "Examine the POM"
msgstr "Examinando o POM"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:247
msgid "There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda-http` extension (if you are deploying an AWS Gateway HTTP API) or the `quarkus-amazon-lambda-rest` extension (if you are deploying an AWS Gateway REST API).  These extensions automatically generate everything you might need for your lambda deployment."
msgstr "Não há nada de especial no POM além da inclusão da extensão `quarkus-amazon-lambda-http` (se estiver implantando uma API HTTP do AWS Gateway) ou da extensão `quarkus-amazon-lambda-rest` (se estiver implantando uma API REST do AWS Gateway). Essas extensões geram automaticamente tudo o que pode ser necessário para o deploy do lambda."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:251
msgid "Also, at least in the generated Maven archetype `pom.xml`, the `quarkus-resteasy-reactive`, `quarkus-reactive-routes`, and `quarkus-undertow` dependencies are all optional.  Pick which HTTP framework(s) you want to use (Jakarta REST, Reactive Routes, and/or Servlet) and remove the other dependencies to shrink your deployment."
msgstr "Além disso, pelo menos no arquétipo Maven gerado `pom.xml`, as dependências `quarkus-resteasy-reactive`, `quarkus-reactive-routes` e `quarkus-undertow` são todas opcionais. Escolha o(s) framework(s) HTTP que deseja usar (Jakarta REST, Rotas Reativas e/ou Servlet) e remova as outras dependências para reduzir sua implantação."

#. type: Title ===
#: upstream/_guides/aws-lambda-http.adoc:252
#, no-wrap
msgid "Examine sam.yaml"
msgstr "Examinando o sam.yaml"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:256
msgid "The `sam.yaml` syntax is beyond the scope of this document.  There's a couple of things that must be highlighted just in case you are going to craft your own custom `sam.yaml` deployment files."
msgstr "A sintaxe do `sam.yaml` está além do escopo deste documento. Há alguns aspectos que devem ser destacados, caso pretenda criar os seus próprios arquivos de deployment `sam.yaml` personalizados."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:259
msgid "The first thing to note is that for pure Java lambda deployments require a specific handler class.  Do not change the Lambda handler name."
msgstr "A primeira coisa a observar é que, para deployments lambda Java puros, é necessário um handler class específico. Não altere o nome do handler Lambda."

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:265
#, no-wrap
msgid ""
"     Properties:\n"
"        Handler: io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest\n"
"        Runtime: java11\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:268
msgid "This handler is a bridge between the lambda runtime and the Quarkus HTTP framework you are using (Jakarta REST, Servlet, etc.)"
msgstr "Este handler é uma ponte entre o tempo de execução do lambda e a estrutura HTTP do Quarkus que está a utilizando (Jakarta REST, Servlet, etc.)"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:271
msgid "If you want to go native, there's an environment variable that must be set for native GraalVM deployments.  If you look at `sam.native.yaml` you'll see this:"
msgstr "Se você deseja usar uma compilação nativa, há uma variável de ambiente que deve ser definida para deployments nativos do GraalVM. Se olhares para `sam.native.yaml` verás isto:"

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:277
#, no-wrap
msgid ""
"        Environment:\n"
"          Variables:\n"
"            DISABLE_SIGNAL_HANDLERS: true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:280
msgid "This environment variable resolves some incompatibilities between Quarkus and the AWS Lambda Custom Runtime environment."
msgstr "Esta variável de ambiente resolve algumas incompatibilidades entre o Quarkus e o ambiente AWS Lambda Custom Runtime."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:285
msgid "Finally, there is one specific thing for AWS Gateway REST API deployments.  That API assumes that HTTP response bodies are text unless you explicitly tell it which media types are binary through configuration.  To make things easier, the Quarkus extension forces a binary (base 64) encoding of all HTTP response messages and the `sam.yaml` file must configure the API Gateway to assume all media types are binary:"
msgstr "Por fim, há um aspeto específico para o deploy da API REST do AWS Gateway. Essa API assume que os corpos de resposta HTTP são texto, a menos que se diga explicitamente quais tipos de mídia são binários por meio de configuração. Para facilitar as coisas, a extensão Quarkus obriga a uma codificação binária (base 64) de todas as mensagens de resposta HTTP e o ficheiro `sam.yaml` tem de configurar a API Gateway para assumir que todos os tipos de media são binários:"

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:293
#, no-wrap
msgid ""
"  Globals:\n"
"    Api:\n"
"      EndpointConfiguration: REGIONAL\n"
"      BinaryMediaTypes:\n"
"        - \"*/*\"\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/aws-lambda-http.adoc:295
#, no-wrap
msgid "Injectable AWS Context Variables"
msgstr "Variáveis de contexto AWS injetáveis"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:299
msgid "If you are using RESTEasy Reactive and Jakarta REST, you can inject various AWS Context variables into your Jakarta REST resource classes using the Jakarta REST `@Context` annotation or anywhere else with the CDI `@Inject` annotation."
msgstr "Se estiver utilizando o RESTEasy Reactive e o Jakarta REST, pode injetar várias variáveis de contexto AWS nas suas resource classes Jakarta REST utilizando a anotação Jakarta REST `@Context` ou em qualquer outro lugar com a anotação CDI `@Inject`."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:302
msgid "For the AWS HTTP API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent`.  Here is an example:"
msgstr "Para a API HTTP do AWS, você pode injetar as variáveis do AWS `com.amazonaws.services.lambda.runtime.Context` e `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent`. Eis um exemplo:"

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:307
#, no-wrap
msgid ""
"import jakarta.ws.rs.core.Context;\n"
"import com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:313
#: upstream/_guides/aws-lambda-http.adoc:338
#, no-wrap
msgid ""
"@Path(\"/myresource\")\n"
"public class MyResource {\n"
"    @GET\n"
"    public String ctx(@Context com.amazonaws.services.lambda.runtime.Context ctx) { }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:316
#, no-wrap
msgid ""
"    @GET\n"
"    public String event(@Context APIGatewayV2HTTPEvent event) { }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:319
#, no-wrap
msgid ""
"    @GET\n"
"    public String requestContext(@Context APIGatewayV2HTTPEvent.RequestContext req) { }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:322
#: upstream/_guides/aws-lambda-http.adoc:346
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:326
msgid "For the AWS REST API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext`.  Here is an example:"
msgstr "Para a API REST do AWS, você pode injetar as variáveis do AWS `com.amazonaws.services.lambda.runtime.Context` e `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext`. Eis um exemplo:"

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:332
#, no-wrap
msgid ""
"import jakarta.ws.rs.core.Context;\n"
"import io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext;\n"
"import io.quarkus.amazon.lambda.http.model.AwsProxyRequest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:341
#, no-wrap
msgid ""
"    @GET\n"
"    public String reqContext(@Context AwsProxyRequestContext req) { }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:344
#, no-wrap
msgid ""
"    @GET\n"
"    public String req(@Context AwsProxyRequest req) { }\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/aws-lambda-http.adoc:348
#, no-wrap
msgid "Tracing with AWS XRay and GraalVM"
msgstr "Tracing com AWS XRay e GraalVM"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:353
msgid "If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray library is not fully compatible with GraalVM, so we had to do some integration work to make this work."
msgstr "Se você estiver compilando imagens nativas e quiser utilizar o  link:https://aws.amazon.com/xray[AWS X-Ray Tracing] com o seu lambda, terá de incluir `quarkus-amazon-lambda-xray` como uma dependência no seu pom. A biblioteca AWS X-Ray não é totalmente compatível com o GraalVM, então nós tivemos que fazer algum trabalho de integração para que isso funcionasse."

#. type: Title ==
#: upstream/_guides/aws-lambda-http.adoc:354
#, no-wrap
msgid "Security Integration"
msgstr "Integração da segurança"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:359
msgid "When you invoke an HTTP request on the API Gateway, the Gateway turns that HTTP request into a JSON event document that is forwarded to a Quarkus Lambda.  The Quarkus Lambda parses this json and converts in into an internal representation of an HTTP request that can be consumed by any HTTP framework Quarkus supports (Jakarta REST, servlet, Reactive Routes)."
msgstr "Quando você invoca um pedido HTTP no API Gateway, o Gateway transforma esse pedido HTTP num documento de evento JSON que é reencaminhado para um Quarkus Lambda. O Quarkus Lambda analisa este json e o converte em uma representação interna de um pedido HTTP que pode ser consumido por qualquer estrutura HTTP suportada pelo Quarkus (Jakarta REST, servlet, Reactive Routes)."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:366
msgid "API Gateway supports many ways to securely invoke on your HTTP endpoints that are backed by Lambda and Quarkus.  If you enable it, Quarkus will automatically parse relevant parts of the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html[event json document] and look for security based metadata and register a `java.security.Principal` internally that can be looked up in Jakarta REST by injecting a `jakarta.ws.rs.core.SecurityContext`, via `HttpServletRequest.getUserPrincipal()` in servlet, and `RouteContext.user()` in Reactive Routes.  If you want more security information, the `Principal` object can be typecast to a class that will give you more information."
msgstr "O API Gateway suporta muitas formas de invocar com segurança os seus endpoints HTTP que são apoiados pelo Lambda e pelo Quarkus. Se o ativar, o Quarkus analisará automaticamente as partes relevantes do  link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html[documento json do evento] e procurará metadados baseados na segurança e registará internamente um `java.security.Principal` que pode ser consultado no Jakarta REST injectando um `jakarta.ws.rs.core.SecurityContext`, através de `HttpServletRequest.getUserPrincipal()` no servlet e `RouteContext.user()` nas rotas reactivas. Se quiser mais informações de segurança, o objeto `Principal` pode ser convertido para uma classe que lhe dará mais informações."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:368
msgid "To enable this security feature, add this to your `application.properties` file:"
msgstr "Para ativar esta funcionalidade de segurança, adicione isto ao seu arquivo `application.properties`:"

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:370
#, no-wrap
msgid "quarkus.lambda-http.enable-security=true\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:374
msgid "Here's how its mapped:"
msgstr "Eis o seu mapa:"

#. type: Block title
#: upstream/_guides/aws-lambda-http.adoc:375
#: upstream/_guides/aws-lambda-http.adoc:427
#, no-wrap
msgid "HTTP `quarkus-amazon-lambda-http`"
msgstr "HTTP `quarkus-amazon-lambda-http`"

#. type: Table
#: upstream/_guides/aws-lambda-http.adoc:378
#: upstream/_guides/aws-lambda-http.adoc:388
#, no-wrap
msgid "Auth Type"
msgstr "Auth Type"

#. type: Table
#: upstream/_guides/aws-lambda-http.adoc:378
#: upstream/_guides/aws-lambda-http.adoc:388
#, no-wrap
msgid "Principal Class"
msgstr "Classe principal"

#. type: Table
#: upstream/_guides/aws-lambda-http.adoc:379
#: upstream/_guides/aws-lambda-http.adoc:389
#, no-wrap
msgid "Json path of Principal Name"
msgstr "Caminho Json do nome principal"

#. type: Table
#: upstream/_guides/aws-lambda-http.adoc:379
#, no-wrap
msgid "Cognito JWT"
msgstr "Cognito JWT"

#. type: Table
#: upstream/_guides/aws-lambda-http.adoc:379
#: upstream/_guides/aws-lambda-http.adoc:389
#, no-wrap
msgid "`io.quarkus.amazon.lambda.http.CognitoPrincipal`"
msgstr "`io.quarkus.amazon.lambda.http.CognitoPrincipal`"

#. type: Table
#: upstream/_guides/aws-lambda-http.adoc:380
#, no-wrap
msgid "`requestContext.authorizer.jwt.claims.cognito:username`"
msgstr "`requestContext.authorizer.jwt.claims.cognito:username`"

#. type: Table
#: upstream/_guides/aws-lambda-http.adoc:380
#: upstream/_guides/aws-lambda-http.adoc:390
#, no-wrap
msgid "IAM"
msgstr "IAM"

#. type: Table
#: upstream/_guides/aws-lambda-http.adoc:380
#: upstream/_guides/aws-lambda-http.adoc:390
#, no-wrap
msgid "`io.quarkus.amazon.lambda.http.IAMPrincipal`"
msgstr "`io.quarkus.amazon.lambda.http.IAMPrincipal`"

#. type: Table
#: upstream/_guides/aws-lambda-http.adoc:381
#, no-wrap
msgid "`requestContext.authorizer.iam.userId`"
msgstr "`requestContext.authorizer.iam.userId`"

#. type: Table
#: upstream/_guides/aws-lambda-http.adoc:381
#: upstream/_guides/aws-lambda-http.adoc:391
#, no-wrap
msgid "Custom Lambda"
msgstr "Lambda personalizado"

#. type: Table
#: upstream/_guides/aws-lambda-http.adoc:381
#: upstream/_guides/aws-lambda-http.adoc:391
#, no-wrap
msgid "`io.quarkus.amazon.lambda.http.CustomPrincipal`"
msgstr "`io.quarkus.amazon.lambda.http.CustomPrincipal`"

#. type: Table
#: upstream/_guides/aws-lambda-http.adoc:383
#, no-wrap
msgid "`requestContext.authorizer.lambda.principalId`"
msgstr "`requestContext.authorizer.lambda.principalId`"

#. type: Block title
#: upstream/_guides/aws-lambda-http.adoc:385
#: upstream/_guides/aws-lambda-http.adoc:468
#, no-wrap
msgid "REST `quarkus-amazon-lambda-rest`"
msgstr "REST `quarkus-amazon-lambda-rest`"

#. type: Table
#: upstream/_guides/aws-lambda-http.adoc:389
#, no-wrap
msgid "Cognito"
msgstr "Cognito"

#. type: Table
#: upstream/_guides/aws-lambda-http.adoc:390
#, no-wrap
msgid "`requestContext.authorizer.claims.cognito:username`"
msgstr "`requestContext.authorizer.claims.cognito:username`"

#. type: Table
#: upstream/_guides/aws-lambda-http.adoc:391
#, fuzzy, no-wrap
msgid "`requestContext.identity.user`"
msgstr "`requestContext.identity.user`"

#. type: Table
#: upstream/_guides/aws-lambda-http.adoc:393
#, fuzzy, no-wrap
msgid "`requestContext.authorizer.principalId`"
msgstr "`requestContext.authorizer.principalId`"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:399
msgid "If the `cognito:groups` claim is present, then Quarkus will extract and map those groups to Quarkus roles which can then be used in authorization with annotations like `@RolesAllowed`.  If you do not want to map `cognito:groups` to Quarkus roles, then you must explicitly disable it in configuration:"
msgstr "Se a reivindicação `cognito:groups` estiver presente, o Quarkus extrairá e mapeará esses grupos para as funções do Quarkus que podem então ser utilizadas na autorização com anotações como `@RolesAllowed`. Se não pretender mapear `cognito:groups` para as funções do Quarkus, você terá que desativar explicitamente na configuração:"

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:402
#, no-wrap
msgid "quarkus.lambda-http.map-cognito-to-roles=false\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:405
msgid "You can also specify a different Cognito claim to extract roles from:"
msgstr "Você também pode especificar uma reivindicação do Cognito diferente para extrair funções:"

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:408
#, no-wrap
msgid "quarkus.lambda-http.cognito-role-claim=cognito:roles\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:412
msgid "By default, it expects roles in a space delimited list enclosed in brackets i.e. `[ user admin ]`.  You can specify the regular expression to use to find individual roles in the claim string too:"
msgstr "Por padrão, ele espera funções numa lista delimitada por espaços entre parênteses, ou seja, `[ user admin ]`. Também pode especificar a expressão regular a utilizar para encontrar funções individuais na cadeia de reivindicação:"

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:415
#, no-wrap
msgid "quarkus.lambda-http.cognito-claim-matcher=[^\\[\\] \\t]+\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/aws-lambda-http.adoc:418
#, no-wrap
msgid "Custom Security Integration"
msgstr "Integração de segurança personalizada"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:426
msgid "The default support for AWS security only maps the principal name to Quarkus security APIs and does nothing to map claims or roles or permissions.  You have full control on how security metadata in the lambda HTTP event is mapped to Quarkus Security APIs using implementations of the `io.quarkus.amazon.lambda.http.LambdaIdentityProvider` interface.  By implementing this interface, you can do things like define role mappings for your principal or publish additional attributes provided by IAM or Cognito or your Custom Lambda security integration."
msgstr "O suporte padrão para a segurança AWS apenas mapeia o nome principal para as APIs de segurança do Quarkus e não faz nada para mapear reivindicações, funções ou permissões. Você tem total controle sobre a forma como os metadados de segurança no evento HTTP lambda são mapeados para as APIs de segurança do Quarkus utilizando implementações da interface `io.quarkus.amazon.lambda.http.LambdaIdentityProvider`. Ao implementar esta interface, pode fazer coisas como definir mapeamentos de funções para o seu principal ou publicar atributos adicionais fornecidos pelo IAM ou Cognito ou pela sua integração de segurança Lambda personalizada."

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:431
#: upstream/_guides/aws-lambda-http.adoc:472
#, no-wrap
msgid "package io.quarkus.amazon.lambda.http;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:441
#, no-wrap
msgid ""
"/**\n"
" * Helper interface that removes some boilerplate for creating\n"
" * an IdentityProvider that processes APIGatewayV2HTTPEvent\n"
" */\n"
"public interface LambdaIdentityProvider extends IdentityProvider<LambdaAuthenticationRequest> {\n"
"    @Override\n"
"    default public Class<LambdaAuthenticationRequest> getRequestType() {\n"
"        return LambdaAuthenticationRequest.class;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:451
#, no-wrap
msgid ""
"    @Override\n"
"    default Uni<SecurityIdentity> authenticate(LambdaAuthenticationRequest request, AuthenticationRequestContext context) {\n"
"        APIGatewayV2HTTPEvent event = request.getEvent();\n"
"        SecurityIdentity identity = authenticate(event);\n"
"        if (identity == null) {\n"
"            return Uni.createFrom().optional(Optional.empty());\n"
"        }\n"
"        return Uni.createFrom().item(identity);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:463
#, no-wrap
msgid ""
"    /**\n"
"     * You must override this method unless you directly override\n"
"     * IdentityProvider.authenticate\n"
"     *\n"
"     * @param event\n"
"     * @return\n"
"     */\n"
"    default SecurityIdentity authenticate(APIGatewayV2HTTPEvent event) {\n"
"        throw new IllegalStateException(\"You must override this method or IdentityProvider.authenticate\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:467
msgid "For HTTP, the important method to override is `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)`.  From this you will allocate a SecurityIdentity based on how you want to map security data from `APIGatewayV2HTTPEvent`"
msgstr "Para HTTP, o método importante para ser substituído é o `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)`. A partir daí, atribuirá uma SecurityIdentity com base na forma como pretende mapear os dados de segurança de `APIGatewayV2HTTPEvent`"

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:474
#, no-wrap
msgid "import java.util.Optional;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:482
#, no-wrap
msgid ""
"import io.quarkus.amazon.lambda.http.model.AwsProxyRequest;\n"
"import io.quarkus.security.identity.AuthenticationRequestContext;\n"
"import io.quarkus.security.identity.IdentityProvider;\n"
"import io.quarkus.security.identity.SecurityIdentity;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:489
#, no-wrap
msgid ""
"/**\n"
" * Helper interface that removes some boilerplate for creating\n"
" * an IdentityProvider that processes APIGatewayV2HTTPEvent\n"
" */\n"
"public interface LambdaIdentityProvider extends IdentityProvider<LambdaAuthenticationRequest> {\n"
"...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:501
#, no-wrap
msgid ""
"    /**\n"
"     * You must override this method unless you directly override\n"
"     * IdentityProvider.authenticate\n"
"     *\n"
"     * @param event\n"
"     * @return\n"
"     */\n"
"    default SecurityIdentity authenticate(AwsProxyRequest event) {\n"
"        throw new IllegalStateException(\"You must override this method or IdentityProvider.authenticate\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:505
msgid "For REST, the important method to override is `LambdaIdentityProvider.authenticate(AwsProxyRequest event)`.  From this you will allocate a SecurityIdentity based on how you want to map security data from `AwsProxyRequest`."
msgstr "Para REST, o método importante para ser substituído é o `LambdaIdentityProvider.authenticate(AwsProxyRequest event)`. A partir daí, atribuirá uma SecurityIdentity com base na forma como pretende mapear os dados de segurança de `AwsProxyRequest`."

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:507
msgid "Your implemented provider must be a CDI bean.  Here's an example:"
msgstr "O seu provider implementado deve ser um bean CDI. Eis um exemplo:"

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:511
#: upstream/_guides/aws-lambda-http.adoc:542
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:513
#: upstream/_guides/aws-lambda-http.adoc:544
#, no-wrap
msgid "import java.security.Principal;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:515
#: upstream/_guides/aws-lambda-http.adoc:546
#, no-wrap
msgid "import jakarta.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:522
#: upstream/_guides/aws-lambda-http.adoc:553
#, no-wrap
msgid ""
"import io.quarkus.amazon.lambda.http.LambdaIdentityProvider;\n"
"import io.quarkus.security.identity.SecurityIdentity;\n"
"import io.quarkus.security.runtime.QuarkusPrincipal;\n"
"import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:535
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class CustomSecurityProvider implements LambdaIdentityProvider {\n"
"    @Override\n"
"    public SecurityIdentity authenticate(APIGatewayV2HTTPEvent event) {\n"
"        if (event.getHeaders() == null || !event.getHeaders().containsKey(\"x-user\"))\n"
"            return null;\n"
"        Principal principal = new QuarkusPrincipal(event.getHeaders().get(\"x-user\"));\n"
"        QuarkusSecurityIdentity.Builder builder = QuarkusSecurityIdentity.builder();\n"
"        builder.setPrincipal(principal);\n"
"        return builder.build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:538
msgid "Here's the same example, but with the AWS Gateway REST API:"
msgstr "Aqui está o mesmo exemplo, mas com a API REST do AWS Gateway:"

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:548
#, no-wrap
msgid "import io.quarkus.amazon.lambda.http.model.AwsProxyRequest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/aws-lambda-http.adoc:566
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class CustomSecurityProvider implements LambdaIdentityProvider {\n"
"    @Override\n"
"    public SecurityIdentity authenticate(AwsProxyRequest event) {\n"
"        if (event.getMultiValueHeaders() == null || !event.getMultiValueHeaders().containsKey(\"x-user\"))\n"
"            return null;\n"
"        Principal principal = new QuarkusPrincipal(event.getMultiValueHeaders().getFirst(\"x-user\"));\n"
"        QuarkusSecurityIdentity.Builder builder = QuarkusSecurityIdentity.builder();\n"
"        builder.setPrincipal(principal);\n"
"        return builder.build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:570
msgid "Quarkus should automatically discover this implementation and use it instead of the default implementation discussed earlier."
msgstr "O Quarkus deve descobrir automaticamente esta implementação e utilizá-la em vez da implementação padrão referida anteriormente."

#. type: Title ==
#: upstream/_guides/aws-lambda-http.adoc:571
#, no-wrap
msgid "Simple SAM Local Principal"
msgstr "Principal local SAM simples"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:576
msgid "If you are testing your application with `sam local` you can hardcode a principal name to use when your application runs by setting the `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME` environment variable"
msgstr "Se você estiver testando a sua aplicação com `sam local`, pode definir um nome principal para utilizar quando a sua aplicação for executada, definindo a variável de ambiente `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME`"

#. type: Title ==
#: upstream/_guides/aws-lambda-http.adoc:577
#, no-wrap
msgid "SnapStart"
msgstr "SnapStart"

#. type: Plain text
#: upstream/_guides/aws-lambda-http.adoc:579
msgid "To optimize your application for Lambda SnapStart, check xref:amazon-snapstart.adoc[the SnapStart Configuration Documentation]."
msgstr "Para otimizar a sua aplicação para o Lambda SnapStart, consulte  link:amazon-snapstart.html[a documentação de configuração do SnapStart]."
