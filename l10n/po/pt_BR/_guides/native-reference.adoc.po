# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-09-21 08:24+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title =
#: upstream/_guides/native-reference.adoc:7
#, fuzzy, no-wrap
msgid "Native Reference Guide"
msgstr "Guia de referência nativo"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:19
#, fuzzy
msgid "This guide is a companion to the xref:building-native-image.adoc[Building a Native Executable], xref:native-and-ssl.adoc[Using SSL With Native Images], and xref:writing-native-applications-tips.adoc[Writing Native Applications], guides.  It explores advanced topics that help users diagnose issues, increase the reliability and improve the runtime performance of native executables.  These are the high level sections to be found in this guide:"
msgstr "Este guia é um complemento dos guias  link:building-native-image.html[Criando um executável nativo],  link:native-and-ssl.html[Usando SSL com imagens nativas] e  link:writing-native-applications-tips.html[Escrevendo aplicativos nativos]. Ele explora tópicos avançados que ajudam os usuários a diagnosticar problemas, aumentar a confiabilidade e melhorar o desempenho do tempo de execução de executáveis nativos. Estas são as secções de alto nível que podem ser encontradas neste guia:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:21
#, fuzzy
msgid "xref:native-memory-management[Native Memory Management]"
msgstr "link:#native-memory-management[Gestão de memória nativa]"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:22
#, fuzzy
msgid "xref:inspecting-and-debugging[Inspecting and Debugging Native Executables]"
msgstr "link:#inspecting-and-debugging[Inspeção e depuração de executáveis nativos]"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:23
#, fuzzy
msgid "xref:native-faq[Frequently Asked Questions]"
msgstr "link:#native-faq[Perguntas mais frequentes]"

#. type: Title ==
#: upstream/_guides/native-reference.adoc:25
#, fuzzy, no-wrap
msgid "Native Memory Management"
msgstr "Gestão de memória nativa"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:27
#, fuzzy
msgid "Memory management for Quarkus native executables is enabled by GraalVM’s SubstrateVM runtime system."
msgstr "O gerenciamento de memória para executáveis nativos do Quarkus é habilitado pelo sistema de tempo de execução SubstrateVM do GraalVM."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:29
#, fuzzy
msgid "For detailed explanations about the memory management component in GraalVM, see the link:https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/MemoryManagement[GraalVM Memory Management] guide."
msgstr "Para explicações detalhadas sobre o componente de gerenciamento de memória no GraalVM, consulte o guia de  link:https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/MemoryManagement[Gerenciamento de Memória do GraalVM]."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:31
#, fuzzy
msgid "This guide complements the information available in the GraalVM website with further observations particularly relevant to Quarkus applications."
msgstr "Este guia complementa as informações disponíveis no site do GraalVM com observações adicionais particularmente relevantes para as aplicações Quarkus."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:32
#, fuzzy, no-wrap
msgid "Garbage Collectors"
msgstr "Colectores de lixo"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:34
#, fuzzy
msgid "The garbage collectors available for Quarkus users are currently Serial GC and Epsilon GC."
msgstr "Os colectores de lixo disponíveis para os utilizadores do Quarkus são atualmente o Serial GC e o Epsilon GC."

#. type: Title ====
#: upstream/_guides/native-reference.adoc:35
#, fuzzy, no-wrap
msgid "Serial GC"
msgstr "Série GC"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:39
#, fuzzy
msgid "Serial GC, the default option in GraalVM and Quarkus, is a single-threaded non-concurrent GC, just like HotSpot’s Serial GC.  The implementation in GraalVM however is different from the HotSpot one, and there can be significant differences in the runtime behavior."
msgstr "Serial GC, a opção padrão no GraalVM e Quarkus, é um GC não-concorrente de thread único, assim como o Serial GC do HotSpot. A implementação no GraalVM, no entanto, é diferente da do HotSpot, e pode haver diferenças significativas no comportamento em tempo de execução."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:50
#, fuzzy
msgid "One of the key differences between HotSpot’s Serial GC and GraalVM’s Serial GC is the way they perform full GC cycles.  In HotSpot the algorithm used is mark-sweep-compact whereas in GraalVM it is mark-copy.  Both need to traverse all live objects, but in mark-copy this traversal is also used to copy live objects to a secondary space or semi-space.  As objects are copied from one semi-space to another they’re also compacted.  In mark-sweep-compact, the compacting requires a second pass on the live objects.  This makes full GCs in mark-copy more time efficient (in terms of time spent in each GC cycle) than mark-sweep-compact.  The tradeoff mark-copy makes in order to make individual full GC cycles shorter is space.  The use of semi-spaces means that for an application to maintain the same GC performance that mark-sweep achieves (in terms of allocated MB per second), it requires double the amount of memory."
msgstr "Uma das principais diferenças entre o Serial GC do HotSpot e o Serial GC do GraalVM é a forma como eles executam ciclos completos de GC. No HotSpot o algoritmo usado é mark-sweep-compact enquanto no GraalVM é mark-copy. Ambos precisam de atravessar todos os objectos vivos, mas no mark-copy esta travessia é também utilizada para copiar objectos vivos para um espaço secundário ou semi-espaço. À medida que os objectos são copiados de um semi-espaço para outro, são também compactados. Em mark-sweep-compact, a compactação requer uma segunda passagem nos objectos vivos. Isso torna os GCs completos em mark-copy mais eficientes em termos de tempo (em termos de tempo gasto em cada ciclo de GC) do que mark-sweep-compact. A troca que o mark-copy faz para tornar os ciclos de GC completos individuais mais curtos é o espaço. O uso de semi-espaços significa que para uma aplicação manter o mesmo desempenho de GC que o mark-sweep alcança (em termos de MB alocados por segundo), é necessário o dobro da quantidade de memória."

#. type: Title =====
#: upstream/_guides/native-reference.adoc:51
#, fuzzy, no-wrap
msgid "GC Collection Policy"
msgstr "Política de recolha de CG"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:54
#, fuzzy
msgid "GraalVM's Serial GC implementation offers a choice between two different collection policies, the default is called \"adaptive\" and the alternative is called \"space/time\"."
msgstr "A implementação do Serial GC do GraalVM oferece uma escolha entre duas políticas de coleta diferentes, a padrão é chamada de \"adaptativa\" e a alternativa é chamada de \"espaço/tempo\"."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:58
#, fuzzy
msgid "The “adaptive” collection policy is based on HotSpot's ParallelGC adaptive size policy.  The main difference with HotSpot is GraalVM's focus on memory footprint.  This means that GraalVM’s adaptive GC policy tries to aggressively trigger GCs in order to keep memory consumption down."
msgstr "A política de recolha \"adaptativa\" é baseada na política de tamanho adaptativo ParallelGC do HotSpot. A principal diferença com o HotSpot é o foco do GraalVM na pegada de memória. Isto significa que a política de GC adaptável do GraalVM tenta ativar agressivamente os GCs de forma a manter o consumo de memória baixo."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:66
#, fuzzy
msgid "Up to version 2.13, Quarkus used the “space/time” GC collection policy by default, but starting with version 2.14, it switched to using the “adaptive” policy instead.  The reason why Quarkus initially chose to use \"space/time\" is because at that time it had considerable performance improvements over \"adaptive\".  Recent performance experiments, however, indicate that the \"space/time\" policy can result in worse out-of-the-box experience compared to the \"adaptive\" policy, while at the same time the benefits it used to offer have diminished considerably after improvements made to the \"adaptive\" policy.  As a result, the \"adaptive\" policy appears to be the best option for most, if not all, Quarkus applications.  Full details on this switch can be read in link:https://github.com/quarkusio/quarkus/issues/28267[this issue]."
msgstr "Até à versão 2.13, o Quarkus utilizava a política de recolha de GC \"espaço/tempo\" por predefinição, mas a partir da versão 2.14, passou a utilizar a política \"adaptativa\". A razão pela qual o Quarkus inicialmente escolheu usar \"espaço/tempo\" é porque naquela época ele tinha melhorias consideráveis de desempenho sobre \"adaptativo\". No entanto, experiências de desempenho recentes indicam que a política \"espaço/tempo\" pode resultar numa pior experiência imediata em comparação com a política \"adaptativa\", ao mesmo tempo que os benefícios que costumava oferecer diminuíram consideravelmente após as melhorias efectuadas na política \"adaptativa\". Como resultado, a política \"adaptativa\" parece ser a melhor opção para a maioria, se não todas, as aplicações Quarkus. Mais pormenores sobre esta mudança podem ser lidos  link:https://github.com/quarkusio/quarkus/issues/28267[nesta edição]."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:69
#, fuzzy
msgid "It is still possible to change the GC collection policy using GraalVM’s `-H:InitialCollectionPolicy` flag.  Switching to the \"space/time\" policy can be done by passing the following via command line:"
msgstr "Ainda é possível mudar a política de coleta do GC usando a flag `-H:InitialCollectionPolicy` do GraalVM. Mudar para a política \"espaço/tempo\" pode ser feito passando o seguinte via linha de comando:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:73
#, no-wrap
msgid "-Dquarkus.native.additional-build-args=-H:InitialCollectionPolicy=com.oracle.svm.core.genscavenge.CollectionPolicy\\$BySpaceAndTime\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:76
#, fuzzy
msgid "Or adding this to the `application.properties` file:"
msgstr "Ou adicionar isto ao ficheiro `application.properties`:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:80
#, no-wrap
msgid "quarkus.native.additional-build-args=-H:InitialCollectionPolicy=com.oracle.svm.core.genscavenge.CollectionPolicy$BySpaceAndTime\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:86
#, fuzzy
msgid "Escaping the `$` character is required to configure the \"space/time\" GC collection policy if passing via command line in Bash.  Other command line environments might have similar requirements."
msgstr "Escapar o carácter `$` é necessário para configurar a política de recolha de GC \"espaço/tempo\" se passar através da linha de comandos no Bash. Outros ambientes de linha de comando podem ter requisitos semelhantes."

#. type: Title ====
#: upstream/_guides/native-reference.adoc:88
#, fuzzy, no-wrap
msgid "Epsilon GC"
msgstr "Epsilon GC"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:92
#, fuzzy
msgid "Epsilon GC is a no-op garbage collector which does not do any memory reclamation.  From a Quarkus perspective, some of the most relevant use cases for this garbage collector are extremely short-lived jobs, e.g. serverless functions.  To build Quarkus native with epsilon GC, pass the following argument at build time:"
msgstr "O Epsilon GC é um coletor de lixo no-op que não faz qualquer recuperação de memória. Do ponto de vista do Quarkus, alguns dos casos de uso mais relevantes para esse coletor de lixo são trabalhos de vida extremamente curta, por exemplo, funções sem servidor. Para construir o Quarkus nativo com o epsilon GC, passe o seguinte argumento no momento da construção:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:96
#, no-wrap
msgid "-Dquarkus.native.additional-build-args=--gc=epsilon\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/native-reference.adoc:98
#, fuzzy, no-wrap
msgid "Memory Management Options"
msgstr "Opções de gestão de memória"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:101
#, fuzzy
msgid "For information about options to control maximum heap size, young space, and other typical use cases found in the JVM, see the link:https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/MemoryManagement[GraalVM Memory Management] guide.  Setting the maximum heap size, either as a percentage or an explicit value, is generally recommended."
msgstr "Para obter informações sobre opções para controlar o tamanho máximo do heap, espaço jovem e outros casos de uso típicos encontrados na JVM, consulte o guia  link:https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/MemoryManagement[Gerenciamento de Memória GraalVM]. Definir o tamanho máximo do heap, seja como uma porcentagem ou um valor explícito, é geralmente recomendado."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:103
#, fuzzy, no-wrap
msgid "GC Logging"
msgstr "Registo de GC"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:106
#, fuzzy
msgid "Multiple options exist to print information about garbage collection cycles, depending on the level of detail required.  The minimum detail is provided `-XX:+PrintGC`, which prints a message for each GC cycle that occurs:"
msgstr "Existem várias opções para imprimir informações sobre os ciclos de recolha de lixo, dependendo do nível de detalhe necessário. O detalhe mínimo é fornecido `-XX:+PrintGC`, que imprime uma mensagem para cada ciclo GC que ocorre:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:113
#, no-wrap
msgid ""
"$ quarkus-project-0.1-SNAPSHOT-runner -XX:+PrintGC -Xmx64m\n"
"...\n"
"[Incremental GC (CollectOnAllocation) 20480K->11264K, 0.0003223 secs]\n"
"[Full GC (CollectOnAllocation) 19456K->5120K, 0.0031067 secs]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:118
#, fuzzy
msgid "When you combine this option with `-XX:+VerboseGC` you still get a message per GC cycle, but it contains extra information.  Also, adding this option shows the sizing decisions made by the GC algorithm at startup:"
msgstr "Quando combina esta opção com `-XX:+VerboseGC` continua a receber uma mensagem por ciclo de GC, mas esta contém informação extra. Além disso, adicionar esta opção mostra as decisões de dimensionamento feitas pelo algoritmo GC na inicialização:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:137
#, no-wrap
msgid ""
"$ quarkus-project-0.1-SNAPSHOT-runner -XX:+PrintGC -XX:+VerboseGC -Xmx64m\n"
"[Heap policy parameters:\n"
"YoungGenerationSize: 25165824\n"
"MaximumHeapSize: 67108864\n"
"MinimumHeapSize: 33554432\n"
"AlignedChunkSize: 1048576\n"
"LargeArrayThreshold: 131072]\n"
"...\n"
"[[5378479783321 GC: before  epoch: 8  cause: CollectOnAllocation]\n"
"[Incremental GC (CollectOnAllocation) 16384K->9216K, 0.0003847 secs]\n"
"[5378480179046 GC: after   epoch: 8  cause: CollectOnAllocation  policy: adaptive  type: incremental\n"
"collection time: 384755 nanoSeconds]]\n"
"[[5379294042918 GC: before  epoch: 9  cause: CollectOnAllocation]\n"
"[Full GC (CollectOnAllocation) 17408K->5120K, 0.0030556 secs]\n"
"[5379297109195 GC: after   epoch: 9  cause: CollectOnAllocation  policy: adaptive  type: complete\n"
"collection time: 3055697 nanoSeconds]]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:140
#, fuzzy
msgid "Beyond these two options, `-XX:+PrintHeapShape` and `-XX:+TraceHeapChunks` provide even lower level details about memory chunks on top of which the different memory regions are constructed."
msgstr "Para além destas duas opções, `-XX:+PrintHeapShape` e `-XX:+TraceHeapChunks` fornecem detalhes de nível ainda mais baixo sobre os blocos de memória sobre os quais são construídas as diferentes regiões de memória."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:142
#, fuzzy
msgid "The most up-to-date information on GC logging flags can be obtained by printing the list of flags that can be passed to native executables:"
msgstr "A informação mais actualizada sobre as flags de registo GC pode ser obtida imprimindo a lista de flags que podem ser passadas aos executáveis nativos:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:155
#, no-wrap
msgid ""
"$ quarkus-project-0.1-SNAPSHOT-runner -XX:PrintFlags=\n"
"...\n"
"  -XX:±PrintGC                                 Print summary GC information after each collection. Default: - (disabled).\n"
"  -XX:±PrintGCSummary                          Print summary GC information after application main method returns. Default: - (disabled).\n"
"  -XX:±PrintGCTimeStamps                       Print a time stamp at each collection, if +PrintGC or +VerboseGC. Default: - (disabled).\n"
"  -XX:±PrintGCTimes                            Print the time for each of the phases of each collection, if +VerboseGC. Default: - (disabled).\n"
"  -XX:±PrintHeapShape                          Print the shape of the heap before and after each collection, if +VerboseGC. Default: - (disabled).\n"
"...\n"
"  -XX:±TraceHeapChunks                         Trace heap chunks during collections, if +VerboseGC and +PrintHeapShape. Default: - (disabled).\n"
"  -XX:±VerboseGC                               Print more information about the heap before and after each collection. Default: - (disabled).\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/native-reference.adoc:158
#, fuzzy, no-wrap
msgid "Resident Set Size (RSS)"
msgstr "Tamanho do conjunto residente (RSS)"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:165
#, fuzzy
msgid "As described in the xref:performance-measure.adoc[Measuring Performance guide], the footprint of Quarkus applications is measured using the resident set size (RSS).  This is also applicable to native applications, but the runtime engine that manages the footprint in this case is built in the native executable itself rather than the JVM."
msgstr "Conforme descrito no  link:performance-measure.html[guia Medindo o Desempenho], a área de cobertura das aplicações Quarkus é medida usando o tamanho do conjunto residente (RSS). Isto também se aplica a aplicações nativas, mas o motor de tempo de execução que gere a pegada neste caso é construído no próprio executável nativo e não na JVM."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:170
#, fuzzy
msgid "The reporting techniques specified in the xref:performance-measure.adoc[Measuring Performance guide] are applicable to native applications too, but what causes the RSS to be higher or lower is specific to how the generated native executables work."
msgstr "As técnicas de relatório especificadas no  link:performance-measure.html[guia Medição de desempenho] também são aplicáveis a aplicações nativas, mas o que faz com que o RSS seja maior ou menor é específico da forma como os executáveis nativos gerados funcionam."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:173
#, fuzzy
msgid "When the RSS is higher in one native version of the application versus another, the following checks should be carried out first:"
msgstr "Quando o RSS é mais elevado numa versão nativa da aplicação do que noutra, devem ser efectuadas primeiro as seguintes verificações:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:177
#, fuzzy
msgid "Check the xref:native-reports[native build time reports] and see if there are big discrepancies in the number of used packages, used classes or used methods.  A bigger universe will result in bigger memory footprint."
msgstr "Verifique os  link:#native-reports[relatórios de tempo de compilação nativos] e veja se há grandes discrepâncias no número de pacotes usados, classes usadas ou métodos usados. Um universo maior resultará num maior consumo de memória."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:182
#, fuzzy
msgid "Check the size of the binary for differences.  Using `readelf` you can observe the size of different sections and compare them.  The `.text` section where code lives, and the `.svm_heap` section where heap produced at build time lives, are particularly interesting."
msgstr "Verificar o tamanho do binário para detetar diferenças. Utilizando `readelf` pode observar o tamanho de diferentes secções e compará-las. A secção `.text`, onde reside o código, e a secção `.svm_heap`, onde reside o heap produzido no momento da compilação, são particularmente interessantes."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:183
#, fuzzy
msgid "Generate xref:heap-dumps[heap dumps] and inspect them with tools such as VisualVM or Eclipse MAT."
msgstr "Gerar  link:#heap-dumps[lixeiras de heap] e inspeccioná-las com ferramentas como o VisualVM ou o Eclipse MAT."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:191
#, fuzzy
msgid "Often profiling, instrumenting or tracing applications is the best way to figure out how things work.  In the case of RSS and native applications, the techniques that Brendan Gregg explains in the https://www.brendangregg.com/FlameGraphs/memoryflamegraphs.html[\"Memory Leak (and Growth) Flame Graphs\"] guide are particularly useful.  This section will apply the information in that article to show how to use `perf` and https://github.com/iovisor/bcc[bcc/eBPF] to understand what causes Quarkus native executables to consume memory on startup."
msgstr "Muitas vezes, a criação de perfis, instrumentação ou rastreamento de aplicações é a melhor maneira de descobrir como as coisas funcionam. No caso de RSS e aplicações nativas, as técnicas que Brendan Gregg explica no guia  link:https://www.brendangregg.com/FlameGraphs/memoryflamegraphs.html[\"Memory Leak (and Growth) Flame Graphs\"] são particularmente úteis. Esta secção aplicará a informação desse artigo para mostrar como usar `perf` e  link:https://github.com/iovisor/bcc[bcc/eBPF] para compreender o que faz com que os executáveis nativos do Quarkus consumam memória no arranque."

#. type: Title ====
#: upstream/_guides/native-reference.adoc:193
#, fuzzy, no-wrap
msgid "Perf"
msgstr "Perf"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:198
#, fuzzy
msgid "`perf` works in older Linux systems, whereas eBPF requires a newer Linux kernel.  The overhead of `perf` is higher than eBPF, but it can understand stack traces generated with DWARF debug symbols, which eBPF can't."
msgstr "`perf` funciona em sistemas Linux mais antigos, enquanto o eBPF requer um kernel Linux mais recente. O overhead de `perf` é maior do que o do eBPF, mas ele pode entender os traços de pilha gerados com símbolos de depuração DWARF, o que o eBPF não pode."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:205
#, fuzzy
msgid "In the context of GraalVM, DWARF stack traces contain more detail and are easier to understand than those generated with frame pointers.  As first step, build a Quarkus native executable with debug info enabled and a couple of extra flags.  One flag to disable optimizations, and another to avoid inlined methods being omitted from the stack traces.  These two flags have been added to obtain stack traces that contain as much information as possible."
msgstr "No contexto do GraalVM, os traços de pilha DWARF contêm mais detalhes e são mais fáceis de entender do que os gerados com ponteiros de quadro. Como primeiro passo, construa um executável nativo do Quarkus com a informação de depuração activada e um par de sinalizadores extra. Um sinalizador para desativar as optimizações e outro para evitar que os métodos inlined sejam omitidos dos traços de pilha. Esses dois sinalizadores foram adicionados para obter traços de pilha que contenham o máximo de informações possível."

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:211
#, no-wrap
msgid ""
"$ mvn package -DskipTests -Dnative \\\n"
"  -Dquarkus.native.debug.enabled \\\n"
"  -Dquarkus.native.additional-build-args=-O0,-H:-OmitInlinedMethodDebugLineInfo\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:224
#, fuzzy
msgid "Disabling optimizations makes it easier to learn how to use `perf` and get as detailed stack traces as possible, because it shows more info about what gets called where.  However, doing so might lead to more allocations happening which would not happen if optimizations would have been applied.  In other words, passing in `-O0` will change the allocation pattens for many applications, because it disables optimizations such as escape analysis or dead code elimination.  To properly assess the allocations made by an application deployed in production, run with default optimizations (`-O2`).  With default optimizations the stack traces obtained with `perf` maybe be harder to decipher."
msgstr "Desativar as optimizações torna mais fácil aprender a utilizar `perf` e obter traços de pilha tão detalhados quanto possível, porque mostra mais informações sobre o que é chamado e onde. No entanto, fazer isso pode levar a mais alocações que não aconteceriam se as otimizações fossem aplicadas. Por outras palavras, passar em `-O0` irá alterar os padrões de alocação para muitas aplicações, porque desactiva optimizações como a análise de fuga ou a eliminação de código morto. Para avaliar corretamente as alocações feitas por uma aplicação implantada em produção, execute com otimizações padrão ( `-O2`). Com as optimizações predefinidas, os traços de pilha obtidos com `perf` podem ser mais difíceis de decifrar."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:227
#, fuzzy
msgid "Let's measure how much RSS a Quarkus native executable takes on startup on this particular environment:"
msgstr "Vamos medir a quantidade de RSS que um executável nativo do Quarkus ocupa na inicialização neste ambiente específico:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:233
#, no-wrap
msgid ""
"$ ps -o pid,rss,command -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner)\n"
"      PID   RSS COMMAND\n"
"     1915 35472 ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner -Xmx128m\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:249
#, fuzzy
msgid "How come this Quarkus native executable consumes ~35MB RSS on startup? To get an understanding of this number, this section will use `perf` to trace calls to `syscalls:sys_enter_mmap`.  Assuming the default link:https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/MemoryManagement/#serial-garbage-collector[GraalVM Serial Garbage Collector] is in use, this system call is particularly interesting for native executables generated by GraalVM's `native-image` because of how it allocates heap.  In native executables generated by GraalVM's `native-image`, the heap is allocated using either aligned or unaligned heap chunks.  All non-array objects get allocated in thread local aligned chunks.  Each of these are 1MB in size by default.  For arrays, if they are bigger than 1/8 of the aligned chunk size, they will be allocated in unaligned heap chunks which have a size dependant on the object itself.  The very first time a thread allocates an object or small array, it will request an aligned heap chunk that it will use exclusively until it has run out of space in that chunk, in which case it will request another aligned heap chunk.  So by tracing these system calls, the code paths that end up requesting new aligned or unaligned heap chunks will be recorded.  Next, run the Quarkus native executable through `perf record` tracing the `mmap` system call:"
msgstr "Como é que este executável nativo do Quarkus consome ~35MB de RSS no arranque? Para compreender este número, esta secção utilizará `perf` para rastrear chamadas para `syscalls:sys_enter_mmap`. Assumindo que o  link:https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/MemoryManagement/#serial-garbage-collector[Coletor de Lixo Serial] padrão  link:https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/MemoryManagement/#serial-garbage-collector[do GraalVM] está em uso, essa chamada de sistema é particularmente interessante para executáveis nativos gerados pelo `native-image` do GraalVM por causa de como ele aloca o heap. Nos executáveis nativos gerados pelo GraalVM's `native-image`, o heap é alocado usando pedaços de heap alinhados ou não alinhados. Todos os objetos que não são de matriz são alocados em pedaços alinhados locais de thread. Cada um deles tem 1MB de tamanho por padrão. Para arrays, se eles forem maiores que 1/8 do tamanho do chunk alinhado, eles serão alocados em chunks de heap não alinhados que têm um tamanho dependente do próprio objeto. Na primeira vez que uma thread aloca um objeto ou um pequeno array, ela solicitará um pedaço de heap alinhado que usará exclusivamente até que o espaço nesse pedaço se esgote, caso em que solicitará outro pedaço de heap alinhado. Assim, ao rastrear estas chamadas de sistema, os caminhos de código que acabam por pedir novos pedaços de heap alinhados ou não alinhados serão registados. Em seguida, execute o executável nativo do Quarkus em `perf record` rastreando a chamada de sistema `mmap`:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:253
#, no-wrap
msgid "$ sudo perf record -e syscalls:sys_enter_mmap --call-graph dwarf -a -- target/code-with-quarkus-1.0.0-SNAPSHOT-runner -Xmx128m\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:260
#, fuzzy
msgid "The size of the aligned heap chunks can be changed during native build time.  A custom value (in number of bytes) can be passed via the `-H:AlignedHeapChunkSize` flag.  One caveat is that this value needs to be multiple of 4096 (4KB)."
msgstr "O tamanho dos pedaços de heap alinhados pode ser alterado durante o tempo de compilação nativa. Um valor personalizado (em número de bytes) pode ser passado através da flag `-H:AlignedHeapChunkSize`. Uma ressalva é que esse valor precisa ser múltiplo de 4096 (4KB)."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:263
#, fuzzy
msgid "Once the startup completes, stop the process and generate the stacks:"
msgstr "Quando o arranque estiver concluído, pare o processo e gere as pilhas:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:267
#, no-wrap
msgid "$ perf script > out.stacks\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:272
#, fuzzy
msgid "As a final step, generate a https://github.com/brendangregg/FlameGraph[flamegraph] with the generated stacks:"
msgstr "Como passo final, gerar um  link:https://github.com/brendangregg/FlameGraph[gráfico de chama] com as pilhas geradas:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:278
#, no-wrap
msgid ""
"$ export FG_HOME=...\n"
"$ ${FG_HOME}/stackcollapse-perf.pl < out.stacks | ${FG_HOME}/flamegraph.pl \\\n"
"    --color=mem --title=\"mmap Flame Graph\" --countname=\"calls\" > out.svg\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:281
#, fuzzy
msgid "The flamegraph should look similar to this:"
msgstr "O gráfico de chama deve ser semelhante a este:"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/native-reference.adoc:282
#, fuzzy, no-wrap
msgid "mmap flamegraph"
msgstr "mmap flamegraph"

#. type: Target for macro image
#: upstream/_guides/native-reference.adoc:282
#, no-wrap
msgid "mmap.svg"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:285
#, fuzzy
msgid "There are several things of interest to notice there:"
msgstr "Há vários aspectos interessantes a ter em conta:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:290
#, fuzzy
msgid "First, the stack traces that contain method calls to `com.oracle.svm.core.genscavenge.ThreadLocalAllocation` are related to aligned or unaligned heap chunk allocations explained above.  As noted earlier, for the majority of allocations these chunks will be 1MB by default, so they're interesting because each allocated chunk has a considerable effect on the RSS consumption."
msgstr "Primeiro, os traços de pilha que contêm chamadas de método para `com.oracle.svm.core.genscavenge.ThreadLocalAllocation` estão relacionados a alocações de pedaços de heap alinhados ou não alinhados explicados acima. Como observado anteriormente, para a maioria das alocações esses pedaços serão de 1MB por padrão, então eles são interessantes porque cada pedaço alocado tem um efeito considerável no consumo de RSS."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:298
#, fuzzy
msgid "Second, of the thread allocation stacks, the ones under `start_thread` are particularly revealing.  In this environment, taking into account the `-Xmx` value passed in, Quarkus creates 12 event loop threads.  Aside from those, there are 6 extra threads.  The names of all those 18 threads exceed 16 characters.  This can be observed via the `ps` command:"
msgstr "Em segundo lugar, das pilhas de alocação de threads, as que estão em `start_thread` são particularmente reveladoras. Neste ambiente, tendo em conta o valor `-Xmx` introduzido, o Quarkus cria 12 threads de ciclo de eventos. Para além destas, existem 6 threads extra. Os nomes de todas essas 18 threads excedem 16 caracteres. Isso pode ser observado através do comando `ps`:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:320
#, no-wrap
msgid ""
"$ ps -e -T | grep $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner)\n"
"   2320    2320 pts/0    00:00:00 code-with-quark\n"
"   2320    2321 pts/0    00:00:00 ference Handler\n"
"   2320    2322 pts/0    00:00:00 gnal Dispatcher\n"
"   2320    2324 pts/0    00:00:00 ecutor-thread-0\n"
"   2320    2325 pts/0    00:00:00 -thread-checker\n"
"   2320    2326 pts/0    00:00:00 ntloop-thread-0\n"
"   2320    2327 pts/0    00:00:00 ntloop-thread-1\n"
"   2320    2328 pts/0    00:00:00 ntloop-thread-2\n"
"   2320    2329 pts/0    00:00:00 ntloop-thread-3\n"
"   2320    2330 pts/0    00:00:00 ntloop-thread-4\n"
"   2320    2331 pts/0    00:00:00 ntloop-thread-5\n"
"   2320    2332 pts/0    00:00:00 ntloop-thread-6\n"
"   2320    2333 pts/0    00:00:00 ntloop-thread-7\n"
"   2320    2334 pts/0    00:00:00 ntloop-thread-8\n"
"   2320    2335 pts/0    00:00:00 ntloop-thread-9\n"
"   2320    2336 pts/0    00:00:00 tloop-thread-10\n"
"   2320    2337 pts/0    00:00:00 tloop-thread-11\n"
"   2320    2338 pts/0    00:00:00 ceptor-thread-0\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:329
#, fuzzy
msgid "The very first allocation that all these threads do is taking the thread name and trimming it so that it can fall within the character limit enforced by kernels.  For each of those allocations, there are 2 `mmap` calls, one to reserve the memory and the other to commit it.  When recording `syscalls:sys_enter_mmap` system call, the `perf` implementation tracks calls to `__GI___mmap64`.  But this glibc `__GI___mmap64` implementation makes another call into `__GI___mmap64`:"
msgstr "A primeira alocação que todas essas threads fazem é pegar o nome da thread e cortá-lo para que fique dentro do limite de caracteres imposto pelos kernels. Para cada uma dessas alocações, há duas chamadas `mmap`, uma para reservar a memória e outra para confirmá-la. Ao gravar a chamada de sistema `syscalls:sys_enter_mmap`, a implementação `perf` rastreia as chamadas para `_GI__mmap64`. Mas esta implementação glibc `_GI__mmap64` faz outra chamada para `_GI__mmap64`:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:359
#, no-wrap
msgid ""
"(gdb) break __GI___mmap64\n"
"(gdb) set scheduler-locking step\n"
"...\n"
"Thread 2 \"code-with-quark\" hit Breakpoint 1, __GI___mmap64 (offset=0, fd=-1, flags=16418, prot=0, len=2097152, addr=0x0) at ../sysdeps/unix/sysv/linux/mmap64.c:58\n"
"58\t  return (void *) MMAP_CALL (mmap, addr, len, prot, flags, fd, offset);\n"
"(gdb) bt\n"
"#0  __GI___mmap64 (offset=0, fd=-1, flags=16418, prot=0, len=2097152, addr=0x0) at ../sysdeps/unix/sysv/linux/mmap64.c:58\n"
"#1  __GI___mmap64 (addr=0x0, len=2097152, prot=0, flags=16418, fd=-1, offset=0) at ../sysdeps/unix/sysv/linux/mmap64.c:46\n"
"#2  0x00000000004f4033 in com.oracle.svm.core.posix.headers.Mman$NoTransitions::mmap (__0=<optimized out>, __1=<optimized out>, __2=<optimized out>, __3=<optimized out>, __4=<optimized out>, __5=<optimized out>)\n"
"#3  0x00000000004f194e in com.oracle.svm.core.posix.PosixVirtualMemoryProvider::reserve (this=0x7ffff7691220, nbytes=0x100000, alignment=0x100000, executable=false) at com/oracle/svm/core/posix/PosixVirtualMemoryProvider.java:126\n"
"#4  0x00000000004ef3b3 in com.oracle.svm.core.os.AbstractCommittedMemoryProvider::allocate (this=0x7ffff7658cb0, size=0x100000, alignment=0x100000, executable=false) at com/oracle/svm/core/os/AbstractCommittedMemoryProvider.java:124\n"
"#5  0x0000000000482f40 in com.oracle.svm.core.os.AbstractCommittedMemoryProvider::allocateAlignedChunk (this=0x7ffff7658cb0, nbytes=0x100000, alignment=0x100000) at com/oracle/svm/core/os/AbstractCommittedMemoryProvider.java:107\n"
"#6  com.oracle.svm.core.genscavenge.HeapChunkProvider::produceAlignedChunk (this=0x7ffff7444398) at com/oracle/svm/core/genscavenge/HeapChunkProvider.java:112\n"
"#7  0x0000000000489485 in com.oracle.svm.core.genscavenge.ThreadLocalAllocation::slowPathNewArrayLikeObject0 (hub=0x7ffff6ff6110, length=15, size=0x20, podReferenceMap=0x7ffff6700000) at com/oracle/svm/core/genscavenge/ThreadLocalAllocation.java:306\n"
"#8  0x0000000000489165 in com.oracle.svm.core.genscavenge.ThreadLocalAllocation::slowPathNewArrayLikeObject (objectHeader=0x8f6110 <io.smallrye.common.expression.ExpressionNode::toString+160>, length=15, podReferenceMap=0x7ffff6700000) at com/oracle/svm/core/genscavenge/ThreadLocalAllocation.java:279\n"
"#9  0x0000000000489066 in com.oracle.svm.core.genscavenge.ThreadLocalAllocation::slowPathNewArray (objectHeader=0x8f6110 <io.smallrye.common.expression.ExpressionNode::toString+160>, length=15) at com/oracle/svm/core/genscavenge/ThreadLocalAllocation.java:242\n"
"#10 0x0000000000d202a1 in java.util.Arrays::copyOfRange (original=0x7ffff6a33410, from=2, to=17) at java/util/Arrays.java:3819\n"
"#11 0x0000000000acf8e6 in java.lang.StringLatin1::newString (val=0x7ffff6a33410, index=2, len=15) at java/lang/StringLatin1.java:769\n"
"#12 0x0000000000acac59 in java.lang.String::substring (this=0x7ffff6dc0d48, beginIndex=2, endIndex=17) at java/lang/String.java:2712\n"
"#13 0x0000000000acaba2 in java.lang.String::substring (this=0x7ffff6dc0d48, beginIndex=2) at java/lang/String.java:2680\n"
"#14 0x00000000004f96cd in com.oracle.svm.core.posix.thread.PosixPlatformThreads::setNativeName (this=0x7ffff7658d10, thread=0x7ffff723fb30, name=0x7ffff6dc0d48) at com/oracle/svm/core/posix/thread/PosixPlatformThreads.java:163\n"
"#15 0x00000000004f9285 in com.oracle.svm.core.posix.thread.PosixPlatformThreads::beforeThreadRun (this=0x7ffff7658d10, thread=0x7ffff723fb30) at com/oracle/svm/core/posix/thread/PosixPlatformThreads.java:212\n"
"#16 0x00000000005237a2 in com.oracle.svm.core.thread.PlatformThreads::threadStartRoutine (threadHandle=0x1) at com/oracle/svm/core/thread/PlatformThreads.java:760\n"
"#17 0x00000000004f9627 in com.oracle.svm.core.posix.thread.PosixPlatformThreads::pthreadStartRoutine (data=0x2a06e20) at com/oracle/svm/core/posix/thread/PosixPlatformThreads.java:203\n"
"#18 0x0000000000462ab0 in com.oracle.svm.core.code.IsolateEnterStub::PosixPlatformThreads_pthreadStartRoutine_38d96cbc1a188a6051c29be1299afe681d67942e (__0=<optimized out>) at com/oracle/svm/core/code/IsolateEnterStub.java:1\n"
"#19 0x00007ffff7e4714d in start_thread (arg=<optimized out>) at pthread_create.c:442\n"
"#20 0x00007ffff7ec8950 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:365
#, fuzzy
msgid "Setting `set scheduler-locking step` when the Quarkus native executable is running through `gdb` makes it easier to debug multi-threaded applications.  It optimizes for single-stepping by stopping other threads from \"seizing the prompt\" by preempting the current thread is being stepped through."
msgstr "Definir `set scheduler-locking step` quando o executável nativo Quarkus está a ser executado através de `gdb` facilita a depuração de aplicações multi-threaded. Optimiza o passo único, impedindo que outras threads \"aproveitem o prompt\", antecipando a thread atual que está a ser executada."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:369
#, fuzzy
msgid "This is how the above flamegraph shows a total of 72 calls to `__GI___mmap64` for the thread name abbreviation stack trace, given that Quarkus native executable runs 18 threads."
msgstr "É assim que o gráfico de chama acima mostra um total de 72 chamadas para `_GI__mmap64` para o stack trace da abreviação do nome da thread, dado que o executável nativo do Quarkus executa 18 threads."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:379
#, fuzzy
msgid "A third, and final observation, is that if you capture the `syscalls:sys_enter_munmmap` event, you might observe that some allocations also result in calls to `munmap`.  When calculating the size to reserve, the requested size to allocate can be rounded up to the page size.  The maintain alignment, 1MB in case of aligned chunks or 1 byte for unaligned chunks, some of the reserved memory might be unreserved.  That is where these `munmap` calls would come from."
msgstr "Uma terceira e última observação é que, se capturar o evento `syscalls:sys_enter_munmmap`, poderá observar que algumas atribuições também resultam em chamadas para `munmap`. Ao calcular o tamanho a reservar, o tamanho solicitado para atribuição pode ser arredondado para o tamanho da página. Para manter o alinhamento, 1MB no caso de pedaços alinhados ou 1 byte para pedaços não alinhados, parte da memória reservada pode não ser reservada. É daí que vêm estas chamadas `munmap`."

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:388
#, fuzzy
msgid "Just by looking at the flamegraph and counting the number of `mmap` calls that originate in thread local allocations, an approximate estimation can be made on the RSS a Quarkus native executable uses on startup.  This estimation can't be fully precise because for unaligned heap chunks, the stack trace doesn't record the size of the chunk.  Also, if the additional build args are removed, inlining optimizations might obscure the type of array allocation chunk requested, so it might not be possible to decipher if the allocation is for an aligned or unaligned chunk."
msgstr "Apenas olhando para o gráfico de chama e contando o número de chamadas `mmap` que se originam em alocações locais de threads, uma estimativa aproximada pode ser feita sobre o RSS que um executável nativo do Quarkus usa na inicialização. Esta estimativa não pode ser totalmente precisa porque, para pedaços de heap não alinhados, o rastreio da pilha não regista o tamanho do pedaço. Além disso, se os args de compilação adicionais forem removidos, as otimizações de inlining podem obscurecer o tipo de pedaço de alocação de array solicitado, então pode não ser possível decifrar se a alocação é para um pedaço alinhado ou não alinhado."

#. type: Title ====
#: upstream/_guides/native-reference.adoc:391
#, fuzzy, no-wrap
msgid "bcc/eBPF"
msgstr "bcc/eBPF"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:401
#, fuzzy
msgid "A version of https://github.com/iovisor/bcc[bcc]/ https://ebpf.io/[eBPF] that can do stack traces is only available from Linux kernel 4.8 onwards.  It can do in-kernel summaries, which makes it more efficient and has lower overhead.  Unfortunately it doesn't understand DWARF debug symbols, so the information obtained might be harder to read and contain less detail."
msgstr "Uma versão do  link:https://github.com/iovisor/bcc[bcc/]  link:https://ebpf.io/[eBPF] que pode fazer traços de pilha só está disponível a partir do kernel Linux 4.8. Ela pode fazer resumos dentro do kernel, o que a torna mais eficiente e tem menor sobrecarga. Infelizmente não compreende os símbolos de depuração DWARF, pelo que a informação obtida pode ser mais difícil de ler e conter menos detalhes."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:410
#, fuzzy
msgid "bcc/eBPF is very extensible so it's easier to tailor make scripts to track specific metrics.  The `bcc` project contains a `stackcount` program that can be used to count stack traces in similar way to what `perf` did in the previous section.  But in some cases, it might be more useful to have other metrics other than number of calls to a system call.  `malloc` is one such example.  The number of `malloc` calls is not so important, but rather the size of the allocations.  So rather than having a flamegraph showing sample counts, a flamegraph can be generated that shows bytes allocated."
msgstr "O bcc/eBPF é muito extensível, por isso é mais fácil fazer scripts à medida para seguir métricas específicas. O projeto `bcc` contém um programa `stackcount` que pode ser usado para contar traços de pilha de forma semelhante ao que `perf` fez na secção anterior. Mas em alguns casos, pode ser mais útil ter outras métricas para além do número de chamadas a uma chamada de sistema. `malloc` é um exemplo disso. O número de chamadas `malloc` não é tão importante, mas sim o tamanho das alocações. Assim, em vez de ter um gráfico de chama que mostre a contagem de amostras, pode ser gerado um gráfico de chama que mostre os bytes atribuídos."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:414
#, fuzzy
msgid "Aside from `mmap`, `malloc` system calls are also present in native executables generated by GraalVM.  Let's put bcc/eBPF in action to generate a flamegraph of bytes allocated using `malloc`."
msgstr "Além de `mmap`, as chamadas de sistema `malloc` também estão presentes nos executáveis nativos gerados pelo GraalVM. Vamos colocar o bcc/eBPF em ação para gerar um flamegraph de bytes alocados usando `malloc`."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:419
#, fuzzy
msgid "To do this, first re-generate a Quarkus native executable removing debug info, which bcc/eBPF does not understand, and instead use frame pointer with local symbols to get the stack traces:"
msgstr "Para fazer isso, primeiro gere novamente um executável nativo do Quarkus removendo as informações de depuração, que o bcc/eBPF não entende, e em vez disso use o ponteiro de quadro com símbolos locais para obter os traços de pilha:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:424
#, no-wrap
msgid ""
"$ mvn package -DskipTests -Dnative \\\n"
"  -Dquarkus.native.additional-build-args=-H:-DeleteLocalSymbols,-H:+PreserveFramePointer\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:434
#, fuzzy
msgid "The link:mallocstacks.py[mallocstacks.py] bcc/eBPF script will be used to capture the `malloc` stacktraces with their allocated size.  This script, and other typical bcc/eBPF scripts (e.g. `stackcount`), need to be given a process ID (PID).  This makes a bit tricky when you want to trace startup, but you can use `gdb` (even if you haven't enabled debug info)  to get around this obstacle because it allows you to stop the application at the first instruction.  Let's start by running the native executable via `gdb`:"
msgstr "O script  link:mallocstacks.py[mallocstacks.py] bcc/eBPF será usado para capturar os stacktraces de `malloc` com seu tamanho alocado. Este script, e outros scripts bcc/eBPF típicos (e.g. `stackcount`), precisam de receber um ID de processo (PID). Isto torna um pouco complicado quando se quer rastrear o arranque, mas pode-se usar `gdb` (mesmo que não se tenha ativado a informação de depuração) para contornar este obstáculo porque permite parar a aplicação na primeira instrução. Vamos começar por executar o executável nativo através de `gdb`:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:440
#, no-wrap
msgid ""
"$ gdb --args ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner -Xmx128m\n"
"...\n"
"(No debugging symbols found in ./target/code-with-quarkus-1.0.0-SNAPSHOT-runner)\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:443
#, fuzzy
msgid "`starti` is a `gdb` command that sets a temporary breakpoint at the very first instruction of the program's execution."
msgstr "`starti` é um comando `gdb` que define um ponto de interrupção temporário na primeira instrução da execução do programa."

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:450
#, no-wrap
msgid ""
"(gdb) starti\n"
"Starting program: <..>/code-with-quarkus/target/code-with-quarkus-1.0.0-SNAPSHOT-runner -Xmx128m\n"
"Program stopped.\n"
"0x00007ffff7fe4790 in _start () from /lib64/ld-linux-x86-64.so.2\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:455
#, fuzzy
msgid "Next invoke the bcc/eBPF script giving it the PID of the Quarkus process, so that it can track the `malloc` calls, capture stack traces and dump them to a file for post-processing:"
msgstr "Em seguida, invoque o script bcc/eBPF dando-lhe o PID do processo Quarkus, para que possa seguir as chamadas `malloc`, capturar os traços da pilha e descarregá-los para um ficheiro para pós-processamento:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:459
#, no-wrap
msgid "$ sudo ./mallocstacks.py -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner) -f > out.stacks\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:462
#, fuzzy
msgid "Then go back to the `gdb` shell and instruct it to continue the startup procedure after hitting the first instruction:"
msgstr "Depois volte à shell `gdb` e dê-lhe instruções para continuar o procedimento de arranque depois de carregar na primeira instrução:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:479
#, no-wrap
msgid ""
"(gdb) continue\n"
"Continuing.\n"
"[Thread debugging using libthread_db enabled]\n"
"Using host libthread_db library \"/lib64/libthread_db.so.1\".\n"
"[New Thread 0x7ffff65ff6c0 (LWP 3342)]\n"
"...\n"
"[New Thread 0x7fffc6ffd6c0 (LWP 3359)]\n"
"__  ____  __  _____   ___  __ ____  ______\n"
" --/ __ \\/ / / / _ | / _ \\/ //_/ / / / __/\n"
" -/ /_/ / /_/ / __ |/ , _/ ,< / /_/ /\\ \\\n"
"--\\___\\_\\____/_/ |_/_/|_/_/|_|\\____/___/\n"
"2023-02-09 18:02:32,794 INFO  [io.quarkus] (main) code-with-quarkus 1.0.0-SNAPSHOT native (powered by Quarkus 2.16.1.Final) started in 0.011s. Listening on: http://0.0.0.0:8080\n"
"2023-02-09 18:02:32,794 INFO  [io.quarkus] (main) Profile prod activated.\n"
"2023-02-09 18:02:32,794 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy-reactive, smallrye-context-propagation, vertx]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:483
#, fuzzy
msgid "Once the startup has complete, press `Ctrl-C` on the `stackcount` shell."
msgstr "Quando o arranque estiver concluído, prima `Ctrl-C` na shell `stackcount`."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:487
#, fuzzy
msgid "Then process the stacks file as a flamegraph.  Note that the stacks generated by this script are already collapsed, so the flamegraph can be generated just like this:"
msgstr "Em seguida, processe o ficheiro de pilhas como um gráfico de chama. Note-se que as pilhas geradas por este guião já estão colapsadas, pelo que o gráfico de chama pode ser gerado da mesma forma:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:491
#, no-wrap
msgid "$ cat out.stacks | ${FG_HOME}/flamegraph.pl --color=mem --title=\"malloc bytes Flame Graph\" --countname=\"bytes\" > out.svg\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:494
#, fuzzy
msgid "The flamegraph produced should look something like this:"
msgstr "O gráfico de chama produzido deve ser mais ou menos assim:"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/native-reference.adoc:495
#, fuzzy, no-wrap
msgid "malloc bytes flamegraph"
msgstr "malloc bytes flamegraph"

#. type: Target for macro image
#: upstream/_guides/native-reference.adoc:495
#, no-wrap
msgid "malloc-bytes.svg"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:502
#, fuzzy
msgid "This shows that most of the memory requested using `malloc` comes from epoll in Java NIO, but the overall amount allocated via `malloc` is barely 268KB.  This amount of 274,269 bytes can be observed by hovering on top of `all` at the bottom of flamegraph (you might need to ask the browser to open the flamegraph in a different tab or window to observe this).  This is very small compared with the amount allocated for the heap with `mmap`."
msgstr "Isso mostra que a maior parte da memória solicitada usando `malloc` vem de epoll em Java NIO, mas a quantidade total alocada via `malloc` é de apenas 268KB. Essa quantidade de 274.269 bytes pode ser observada passando o mouse sobre `all` na parte inferior do gráfico de chama (talvez seja necessário pedir ao navegador para abrir o gráfico de chama em uma guia ou janela diferente para observar isso). Isto é muito pequeno comparado com a quantidade alocada para o heap com `mmap`."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:505
#, fuzzy
msgid "Finally, just a brief mention about other bcc/eBPF commands, and how to transform them into flamegraphs."
msgstr "Finalmente, apenas uma breve menção sobre outros comandos bcc/eBPF, e como transformá-los em flamegraphs."

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:510
#, no-wrap
msgid ""
"$ sudo /usr/share/bcc/tools/stackcount -P -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner) \\\n"
"  -U \"t:syscalls:sys_enter_m*\" # count stacks for mmap and munmap\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:513
#, no-wrap
msgid ""
"$ sudo /usr/share/bcc/tools/stackcount -P -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner) \\\n"
"  -U \"c:*alloc\" # count stacks for malloc, calloc and realloc\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:516
#, no-wrap
msgid ""
"$ sudo /usr/share/bcc/tools/stackcount -P -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner) \\\n"
"  -U \"c:free\" # count stacks for free\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:519
#, no-wrap
msgid ""
"$ sudo /usr/share/bcc/tools/stackcount -P -p $(pidof code-with-quarkus-1.0.0-SNAPSHOT-runner) \\\n"
"  -U \"t:exceptions:page_fault_*\" # count stacks for page faults\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:523
#, fuzzy
msgid "Stacks produced by `stackcount` need to be collapsed before they can be transformed into flamegraphs.  For example:"
msgstr "As pilhas produzidas por `stackcount` precisam de ser colapsadas antes de poderem ser transformadas em flamegraphs. Por exemplo:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:528
#, no-wrap
msgid ""
"${FG_HOME}/stackcollapse.pl < out.stacks | ${FG_HOME}/flamegraph.pl \\\n"
"  --color=mem --title=\"mmap munmap Flame Graph\" --countname=\"calls\" > out.svg\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/native-reference.adoc:531
#, fuzzy, no-wrap
msgid "Inspecting and Debugging Native Executables"
msgstr "Inspeção e depuração de executáveis nativos"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:533
#, fuzzy
msgid "This debugging guide provides further details on debugging issues in Quarkus native executables that might arise during development or production."
msgstr "Este guia de depuração fornece mais pormenores sobre a depuração de problemas nos executáveis nativos Quarkus que podem surgir durante o desenvolvimento ou a produção."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:536
#, fuzzy
msgid "It takes as input the application developed in the xref:getting-started.adoc[Getting Started Guide].  You can find instructions on how to quickly set up this application in this guide."
msgstr "Utiliza como entrada a aplicação desenvolvida no  link:getting-started.html[Guia de Iniciação]. Neste guia, pode encontrar instruções sobre como configurar rapidamente esta aplicação."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:537
#, fuzzy, no-wrap
msgid "Requirements and Assumptions"
msgstr "Requisitos e pressupostos"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:540
#, fuzzy
msgid "This debugging guide has the following requirements:"
msgstr "Este guia de depuração tem os seguintes requisitos:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:542
#, fuzzy
msgid "JDK 11 installed with `JAVA_HOME` configured appropriately"
msgstr "JDK 11 instalado com `JAVA_HOME` configurado corretamente"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:543
#, fuzzy
msgid "Apache Maven {maven-version}"
msgstr "Apache Maven {maven-version}"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:544
#, fuzzy
msgid "A working container runtime (Docker, podman)"
msgstr "Um tempo de execução de contentor funcional (Docker, podman)"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:549
#, fuzzy
msgid "This guide builds and executes Quarkus native executables within a Linux environment.  To offer a homogeneous experience across all environments, the guide relies on a container runtime environment to build and run the native executables.  The instructions below use Docker as example, but very similar commands should work on alternative container runtimes, e.g. podman."
msgstr "Este guia constrói e executa os executáveis nativos do Quarkus num ambiente Linux. Para oferecer uma experiência homogénea em todos os ambientes, o guia baseia-se num ambiente de tempo de execução de contentor para construir e executar os executáveis nativos. As instruções abaixo usam o Docker como exemplo, mas comandos muito semelhantes devem funcionar em ambientes de execução de contentores alternativos, por exemplo, podman."

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:555
#, fuzzy
msgid "Building native executables is an expensive process, so make sure the container runtime has enough CPU and memory to do this.  A minimum of 4 CPUs and 4GB of memory is required."
msgstr "A criação de executáveis nativos é um processo dispendioso, por isso certifique-se de que o tempo de execução do contentor tem CPU e memória suficientes para o fazer. É necessário um mínimo de 4 CPUs e 4 GB de memória."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:559
#, fuzzy
msgid "Finally, this guide assumes the use of the link:https://github.com/graalvm/mandrel[Mandrel distribution] of GraalVM for building native executables, and these are built within a container so there is no need for installing Mandrel on the host."
msgstr "Finalmente, este guia assume o uso da  link:https://github.com/graalvm/mandrel[distribuição Mandrel] do GraalVM para a construção de executáveis nativos, e estes são construídos dentro de um contêiner, portanto não há necessidade de instalar o Mandrel no host."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:560
#, fuzzy, no-wrap
msgid "Bootstrapping the project"
msgstr "Arranque do projeto"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:564
#, fuzzy
msgid "Start by creating a new Quarkus project.  Open a terminal and run the following command:"
msgstr "Comece por criar um novo projeto Quarkus. Abra um terminal e execute o seguinte comando:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:566
#, fuzzy
msgid "For Linux & MacOS users"
msgstr "Para utilizadores de Linux e MacOS"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:573
#, fuzzy
msgid "For Windows users"
msgstr "Para utilizadores do Windows"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:575
#, fuzzy
msgid "If using cmd , (don't use backward slash `\\` and put everything on the same line)"
msgstr "Se utilizar cmd , (não utilize a barra invertida `\\` e coloque tudo na mesma linha)"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:576
#, fuzzy
msgid "If using Powershell , wrap `-D` parameters in double quotes e.g. `\"-DprojectArtifactId=debugging-native\"`"
msgstr "Se utilizar o Powershell , envolva os parâmetros `-D` entre aspas duplas, por exemplo. `\"-DprojectArtifactId=debugging-native\"`"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:577
#, fuzzy, no-wrap
msgid "Configure Quarkus properties"
msgstr "Configurar as propriedades do Quarkus"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:583
#, fuzzy
msgid "Some Quarkus configuration options will be used constantly throughout this debugging guide, so to help declutter command line invocations, it's recommended to add these options to the `application.properties` file.  So, go ahead and add the following options to that file:"
msgstr "Algumas opções de configuração do Quarkus serão utilizadas constantemente ao longo deste guia de depuração, por isso, para ajudar a organizar as invocações da linha de comandos, recomenda-se que adicione estas opções ao ficheiro `application.properties`. Portanto, vá em frente e adicione as seguintes opções a esse ficheiro:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:590
#, no-wrap
msgid ""
"quarkus.native.container-build=true\n"
"quarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel-builder-image:{mandrel-flavor}\n"
"quarkus.container-image.build=true\n"
"quarkus.container-image.group=test\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:597
#, fuzzy
msgid "Starting with 22.3, Mandrel does not provide a `-java11` version anymore.  Note, however, that this doesn't mean that you may no longer produce native executables with Mandrel for Java 11 projects.  You can still compile your Java 11 projects using OpenJDK 11 and produce native executables from the resulting Java 11 bytecode using the `-java17` Mandrel builder images."
msgstr "A partir da versão 22.3, o Mandrel não fornece mais uma versão `-java11`. Observe, no entanto, que isso não significa que você não pode mais produzir executáveis nativos com o Mandrel para projetos Java 11. Você ainda pode compilar seus projetos Java 11 usando o OpenJDK 11 e produzir executáveis nativos a partir do bytecode Java 11 resultante usando as imagens do Mandrel builder `-java17`."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:599
#, fuzzy, no-wrap
msgid "First Debugging Steps"
msgstr "Primeiros passos de depuração"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:602
#, fuzzy
msgid "As a first step, change to the project directory and build the native executable for the application:"
msgstr "Como primeiro passo, mude para o diretório do projeto e construa o executável nativo para a aplicação:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:606
#: upstream/_guides/native-reference.adoc:1071
#, no-wrap
msgid "./mvnw package -DskipTests -Dnative\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:609
#, fuzzy
msgid "Run the application to verify it works as expected. In one terminal:"
msgstr "Execute a aplicação para verificar se funciona como esperado. Num terminal:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:613
#: upstream/_guides/native-reference.adoc:1079
#, no-wrap
msgid "docker run -i --rm -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:616
#, fuzzy
msgid "In another:"
msgstr "Noutro:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:620
#, no-wrap
msgid "curl -w '\\n' http://localhost:8080/hello\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:625
#, fuzzy
msgid "The rest of this section explores ways to build the native executable with extra information, but first, stop the running application.  We can obtain this information while building the native executable by adding additional native-image build options using `-Dquarkus.native.additional-build-args`, e.g."
msgstr "O resto desta secção explora formas de construir o executável nativo com informação extra, mas primeiro, pare a aplicação em execução. Podemos obter esta informação enquanto construímos o executável nativo adicionando opções adicionais de construção de imagem nativa utilizando `-Dquarkus.native.additional-build-args`, e.g."

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:630
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=--native-image-info\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:633
#, fuzzy
msgid "Executing that will produce additional output lines like this:"
msgstr "A sua execução produzirá linhas de saída adicionais como esta:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:640
#, no-wrap
msgid ""
"...\n"
"# Printing compilation-target information to: /project/reports/target_info_20220223_100915.txt\n"
"…\n"
"# Printing native-library information to: /project/reports/native_library_info_20220223_100925.txt\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:648
#, fuzzy
msgid "Note that `/project` is a folder within the container that is building the native executable.  So, this is not a folder that you will find in the host environment.  `/project` folder is mapped to `target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar`, so you will find the files under the `reports` folder in that directory."
msgstr "Note que `/project` é uma pasta dentro do contentor que está a construir o executável nativo. Portanto, esta não é uma pasta que se encontra no ambiente do anfitrião. A pasta `/project` está mapeada para `target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar`, pelo que encontrará os ficheiros na pasta `reports` nesse diretório."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:653
#, fuzzy
msgid "The target info file contains information such as the target platform, the toolchain used to compile the executable, and the C library in use:"
msgstr "O ficheiro de informações de destino contém informações como a plataforma de destino, a cadeia de ferramentas utilizada para compilar o executável e a biblioteca C em utilização:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:665
#, no-wrap
msgid ""
"$ cat target/*/reports/target_info_*.txt\n"
"Building image for target platform: org.graalvm.nativeimage.Platform$LINUX_AMD64\n"
"Using native toolchain:\n"
"   Name: GNU project C and C++ compiler (gcc)\n"
"   Vendor: redhat\n"
"   Version: 8.5.0\n"
"   Target architecture: x86_64\n"
"   Path: /usr/bin/gcc\n"
"Using CLibrary: com.oracle.svm.core.posix.linux.libc.GLib\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:668
#, fuzzy
msgid "The native library info file contains information on the static libraries added to the binary and the other libraries dynamically linked to the executable:"
msgstr "O ficheiro de informações da biblioteca nativa contém informações sobre as bibliotecas estáticas adicionadas ao binário e as outras bibliotecas ligadas dinamicamente ao executável:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:683
#, no-wrap
msgid ""
"$ cat target/*/reports/native_library_info_*.txt\n"
"Static libraries:\n"
"   ../opt/mandrel/lib/svm/clibraries/linux-amd64/liblibchelper.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libnet.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libextnet.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libnio.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libjava.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libfdlibm.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libsunec.a\n"
"   ../opt/mandrel/lib/static/linux-amd64/glibc/libzip.a\n"
"   ../opt/mandrel/lib/svm/clibraries/linux-amd64/libjvm.a\n"
"Other libraries: stdc++,pthread,dl,z,rt\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:688
#, fuzzy
msgid "Even more detail can be obtained by passing in `--verbose` as an additional native-image build argument.  This option can be very useful in detecting whether the options that you pass at a high level via Quarkus are being passed down to the native executable production, or whether some third party jar has some native-image configuration embedded in it that is reaching the native-image invocation:"
msgstr "Ainda mais detalhes podem ser obtidos passando em `--verbose` como um argumento adicional de compilação de imagem nativa. Esta opção pode ser muito útil para detetar se as opções que passa a um nível elevado através do Quarkus estão a ser passadas para a produção do executável nativo, ou se algum jar de terceiros tem alguma configuração de imagem nativa incorporada que está a atingir a invocação da imagem nativa:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:693
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=--verbose\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:696
#, fuzzy
msgid "Running with `--verbose` demonstrates how the native-image building process is two sequential java processes:"
msgstr "Executar com `--verbose` demonstra como o processo de criação de imagens nativas é constituído por dois processos java sequenciais:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:699
#, fuzzy
msgid "The first is a very short Java process that does some basic validation and builds the arguments for the second process (in a stock GraalVM distribution, this is executed as native code)."
msgstr "O primeiro é um processo Java muito curto que faz alguma validação básica e constrói os argumentos para o segundo processo (em uma distribuição GraalVM de estoque, isso é executado como código nativo)."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:702
#, fuzzy
msgid "The second Java process is where the main part of the native executable production happens.  The `--verbose` option shows the actual Java process executed.  You could take the output and run it yourself."
msgstr "O segundo processo Java é onde ocorre a parte principal da produção do executável nativo. A opção `--verbose` mostra o processo Java real executado. Você pode pegar a saída e executá-la você mesmo."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:704
#, fuzzy
msgid "One may also combine multiple native build options by separating with a comma, e.g.:"
msgstr "Também é possível combinar várias opções de compilação nativas separando-as com uma vírgula, por exemplo:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:709
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=--native-image-info,--verbose\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:715
#, fuzzy
msgid "Remember that if an argument for `-Dquarkus.native.additional-build-args` includes the `,` symbol, it needs to be escaped to be processed correctly, e.g. `\\\\,`."
msgstr "Lembre-se de que, se um argumento para `-Dquarkus.native.additional-build-args` incluir o símbolo `,`, este tem de ser escapado para ser processado corretamente, por exemplo, `\\\\,`."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:717
#, fuzzy, no-wrap
msgid "Inspecting Native Executables"
msgstr "Inspeção de executáveis nativos"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:723
#, fuzzy
msgid "Given a native executable, various Linux tools can be used to inspect it.  To allow supporting a variety of environments, inspections will be done from within a Linux container.  Let's create a Linux container image with all the tools required for this guide:"
msgstr "Dado um executável nativo, podem ser utilizadas várias ferramentas Linux para o inspecionar. Para permitir o suporte de uma variedade de ambientes, as inspecções serão feitas a partir de um contentor Linux. Vamos criar uma imagem de contentor Linux com todas as ferramentas necessárias para este guia:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:727
#, no-wrap
msgid "FROM fedora:35\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:734
#, no-wrap
msgid ""
"RUN dnf install -y \\\n"
"binutils \\\n"
"gdb \\\n"
"git \\\n"
"perf \\\n"
"perl-open\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:736
#, no-wrap
msgid "ENV FG_HOME /opt/FlameGraph\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:738
#, no-wrap
msgid "RUN git clone https://github.com/brendangregg/FlameGraph $FG_HOME\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:740
#, no-wrap
msgid "WORKDIR /data\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:742
#, no-wrap
msgid "ENTRYPOINT /bin/bash\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:745
#, fuzzy
msgid "Using docker in the non-Linux environment, you can create an image using this Dockerfile via:"
msgstr "Utilizando o docker num ambiente não Linux, pode criar uma imagem utilizando este Dockerfile via:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:749
#, no-wrap
msgid "docker build -t fedora-tools:v1 .\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:752
#, fuzzy
msgid "Then, go to the root of the project and run the Docker container we have just created as:"
msgstr "Em seguida, vá para a raiz do projeto e execute o contentor Docker que acabámos de criar como:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:756
#, no-wrap
msgid "docker run -t -i --rm -v ${PWD}:/data -p 8080:8080 fedora-tools:v1\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:759
#, fuzzy
msgid "`ldd` shows the shared library dependencies of an executable:"
msgstr "`ldd` mostra as dependências da biblioteca partilhada de um executável:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:763
#, no-wrap
msgid "ldd ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:766
#, fuzzy
msgid "`strings` can be used to look for text messages inside the binary:"
msgstr "`strings` pode ser utilizado para procurar mensagens de texto no interior do binário:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:770
#, no-wrap
msgid "strings ./target/debugging-native-1.0.0-SNAPSHOT-runner | grep Hello\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:773
#, fuzzy
msgid "Using `strings` you can also get Mandrel information given the binary:"
msgstr "Utilizando `strings`, também é possível obter informações sobre o mandril com base no binário:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:777
#, no-wrap
msgid "strings ./target/debugging-native-1.0.0-SNAPSHOT-runner | grep core.VM\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:781
#, fuzzy
msgid "Finally, using `readelf` we can inspect different sections of the binary.  For example, we can see how the heap and text sections take most of the binary:"
msgstr "Finalmente, usando `readelf` podemos inspecionar diferentes secções do binário. Por exemplo, podemos ver como as secções heap e text ocupam a maior parte do binário:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:785
#, no-wrap
msgid "readelf -SW ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:792
#, fuzzy
msgid "Runtime containers produced by Quarkus to run native executables will not include the tools mentioned above.  To explore a native executable within a runtime container, it's best to run the container itself and then `docker cp` the executable locally, e.g.:"
msgstr "Os contentores de tempo de execução produzidos pelo Quarkus para executar executáveis nativos não incluem as ferramentas mencionadas acima. Para explorar um executável nativo dentro de um contentor de tempo de execução, é melhor executar o próprio contentor e depois `docker cp` o executável localmente, por exemplo:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:797
#, no-wrap
msgid ""
"docker run -i --rm --name=mytest -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
"docker cp mytest:/work/application path/on/host/\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:800
#, fuzzy
msgid "From there, you can either inspect the executable directly or use a tools container like above."
msgstr "A partir daí, pode inspecionar o executável diretamente ou utilizar um contentor de ferramentas como acima."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:803
#, fuzzy, no-wrap
msgid "Native Reports"
msgstr "Relatórios nativos"

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:806
#, fuzzy
msgid "Optionally, the native build process can generate reports that show what goes into the binary:"
msgstr "Opcionalmente, o processo de compilação nativo pode gerar relatórios que mostram o que vai para o binário:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:811
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.enable-reports\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:815
#, fuzzy
msgid "The reports will be created under `target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/reports/`.  These reports are some of the most useful resources when encountering issues with missing methods/classes, or encountering forbidden methods by Mandrel."
msgstr "Os relatórios serão criados em `target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/reports/`. Estes relatórios são alguns dos recursos mais úteis quando se depara com problemas de falta de métodos/classes ou com métodos proibidos pelo Mandrel."

#. type: Title ====
#: upstream/_guides/native-reference.adoc:816
#, fuzzy, no-wrap
msgid "Call Tree Reports"
msgstr "Relatórios da árvore de chamadas"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:822
#, fuzzy
msgid "`call_tree` csv file reports are some of the default reports generated when the `-Dquarkus.native.enable-reports` option is passed in.  These csv files can be imported into a graph database, such as Neo4j, to inspect them more easily and run queries against the call tree.  This is useful for getting an approximation on why a method/class is included in the binary."
msgstr "`call_tree` Os relatórios de arquivo csv são alguns dos relatórios padrão gerados quando a opção `-Dquarkus.native.enable-reports` é passada. Esses arquivos csv podem ser importados para um banco de dados gráfico, como o Neo4j, para inspecioná-los mais facilmente e executar consultas contra a árvore de chamadas. Isso é útil para obter uma aproximação do motivo pelo qual um método/classe está incluído no binário."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:824
#, fuzzy
msgid "Let’s see this in action."
msgstr "Vamos ver isto em ação."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:826
#, fuzzy
msgid "First, start a Neo4j instance:"
msgstr "Primeiro, inicie uma instância do Neo4j:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:837
#, no-wrap
msgid ""
"export NEO_PASS=...\n"
"docker run \\\n"
"    --detach \\\n"
"    --rm \\\n"
"    --name testneo4j \\\n"
"    -p7474:7474 -p7687:7687 \\\n"
"    --env NEO4J_AUTH=neo4j/${NEO_PASS} \\\n"
"    neo4j:latest\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:842
#, fuzzy
msgid "Once the container is running, you can access the link:http://localhost:7474[Neo4j browser].  Use `neo4j` as the username and the value of `NEO_PASS` as the password to log in."
msgstr "Quando o contentor estiver em execução, pode aceder ao  link:http://localhost:7474[navegador Neo4j]. Utilize `neo4j` como nome de utilizador e o valor de `NEO_PASS` como palavra-passe para iniciar sessão."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:845
#, fuzzy
msgid "To import the CSV files, we need the following cypher script which will import the data within the CSV files and create graph database nodes and edges:"
msgstr "Para importar os ficheiros CSV, precisamos do seguinte script cypher que importará os dados dos ficheiros CSV e criará nós e arestas da base de dados gráfica:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:850
#, no-wrap
msgid ""
"CREATE CONSTRAINT unique_vm_id ON (v:VM) ASSERT v.vmId IS UNIQUE;\n"
"CREATE CONSTRAINT unique_method_id ON (m:Method) ASSERT m.methodId IS UNIQUE;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:854
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_vm.csv' AS row\n"
"MERGE (v:VM {vmId: row.Id, name: row.Name})\n"
"RETURN count(v);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:858
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_methods.csv' AS row\n"
"MERGE (m:Method {methodId: row.Id, name: row.Name, type: row.Type, parameters: row.Parameters, return: row.Return, display: row.Display})\n"
"RETURN count(m);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:862
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_virtual_methods.csv' AS row\n"
"MERGE (m:Method {methodId: row.Id, name: row.Name, type: row.Type, parameters: row.Parameters, return: row.Return, display: row.Display})\n"
"RETURN count(m);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:868
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_entry_points.csv' AS row\n"
"MATCH (m:Method {methodId: row.Id})\n"
"MATCH (v:VM {vmId: '0'})\n"
"MERGE (v)-[:ENTRY]->(m)\n"
"RETURN count(*);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:874
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_direct_edges.csv' AS row\n"
"MATCH (m1:Method {methodId: row.StartId})\n"
"MATCH (m2:Method {methodId: row.EndId})\n"
"MERGE (m1)-[:DIRECT {bci: row.BytecodeIndexes}]->(m2)\n"
"RETURN count(*);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:880
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_override_by_edges.csv' AS row\n"
"MATCH (m1:Method {methodId: row.StartId})\n"
"MATCH (m2:Method {methodId: row.EndId})\n"
"MERGE (m1)-[:OVERRIDEN_BY]->(m2)\n"
"RETURN count(*);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:886
#, no-wrap
msgid ""
"LOAD CSV WITH HEADERS FROM 'file:///reports/call_tree_virtual_edges.csv' AS row\n"
"MATCH (m1:Method {methodId: row.StartId})\n"
"MATCH (m2:Method {methodId: row.EndId})\n"
"MERGE (m1)-[:VIRTUAL {bci: row.BytecodeIndexes}]->(m2)\n"
"RETURN count(*);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:889
#, fuzzy
msgid "Copy and paste the contents of the script into a file called `import.cypher`."
msgstr "Copie e cole o conteúdo do script num ficheiro chamado `import.cypher`."

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:895
#, fuzzy
msgid "Mandrel 22.0.0 contains a bug where the symbolic links used by the import cypher file are not correctly set when generating reports within a container (for more details see link:https://github.com/oracle/graal/issues/4355[here]).  This can be worked around by copying the following script into a file and executing it:"
msgstr "O Mandrel 22.0.0 contém um erro em que os links simbólicos usados pelo arquivo de importação cypher não são definidos corretamente ao gerar relatórios dentro de um contêiner (para obter mais detalhes, consulte  link:https://github.com/oracle/graal/issues/4355[aqui]). Isso pode ser contornado copiando o script a seguir em um arquivo e executando-o:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:899
#, no-wrap
msgid "set -e\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:901
#, no-wrap
msgid "project=\"debugging-native\"\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:903
#, no-wrap
msgid "pushd target/*-native-image-source-jar/reports\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:906
#, no-wrap
msgid ""
"rm -f call_tree_vm.csv\n"
"ln -s call_tree_vm_${project}-* call_tree_vm.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:909
#, no-wrap
msgid ""
"rm -f call_tree_direct_edges.csv\n"
"ln -s call_tree_direct_edges_${project}-* call_tree_direct_edges.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:912
#, no-wrap
msgid ""
"rm -f call_tree_entry_points.csv\n"
"ln -s call_tree_entry_points_${project}-* call_tree_entry_points.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:915
#, no-wrap
msgid ""
"rm -f call_tree_methods.csv\n"
"ln -s call_tree_methods_${project}-* call_tree_methods.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:918
#, no-wrap
msgid ""
"rm -f call_tree_virtual_edges.csv\n"
"ln -s call_tree_virtual_edges_${project}-* call_tree_virtual_edges.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:921
#, no-wrap
msgid ""
"rm -f call_tree_virtual_methods.csv\n"
"ln -s call_tree_virtual_methods_${project}-* call_tree_virtual_methods.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:924
#, no-wrap
msgid ""
"rm -f call_tree_override_by_edges.csv\n"
"ln -s call_tree_override_by_edges_${project}-* call_tree_override_by_edges.csv\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:926
#, no-wrap
msgid "popd\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:930
#, fuzzy
msgid "Next, copy the import cypher script and CSV files into Neo4j's import folder:"
msgstr "Em seguida, copie o script de importação de cifras e os ficheiros CSV para a pasta de importação do Neo4j:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:936
#, no-wrap
msgid ""
"docker cp \\\n"
"    target/*-native-image-source-jar/reports \\\n"
"    testneo4j:/var/lib/neo4j/import\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:938
#, no-wrap
msgid "docker cp import.cypher testneo4j:/var/lib/neo4j\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:941
#, fuzzy
msgid "After copying all the files, invoke the import script:"
msgstr "Depois de copiar todos os ficheiros, invoque o script de importação:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:945
#, no-wrap
msgid "docker exec testneo4j bin/cypher-shell -u neo4j -p ${NEO_PASS} -f import.cypher\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:949
#, fuzzy
msgid "Once the import completes (shouldn't take more than a couple of minutes), go to the link:http://localhost:7474[Neo4j browser], and you'll be able to observe a small summary of the data in the graph:"
msgstr "Quando a importação estiver concluída (não deve demorar mais do que alguns minutos), aceda ao  link:http://localhost:7474[navegador Neo4j] e poderá observar um pequeno resumo dos dados no gráfico:"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/native-reference.adoc:950
#, fuzzy, no-wrap
msgid "Neo4j database information after import"
msgstr "Informações da base de dados Neo4j após a importação"

#. type: Target for macro image
#: upstream/_guides/native-reference.adoc:950
#, no-wrap
msgid "native-reference-neo4j-db-info.png"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:955
#, fuzzy
msgid "The data above shows that there are ~60000 methods, and just over ~200000 edges between them.  The Quarkus application demonstrated here is very basic, so there’s not a lot we can explore, but here are some example queries you can run to explore the graph in more detail.  Typically, you’d start by looking for a given method:"
msgstr "Os dados acima mostram que existem ~60000 métodos, e pouco mais de ~200000 arestas entre eles. A aplicação Quarkus demonstrada aqui é muito básica, por isso não há muito que possamos explorar, mas aqui estão alguns exemplos de consultas que pode executar para explorar o gráfico com mais pormenor. Normalmente, começa-se por procurar um determinado método:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:959
#, no-wrap
msgid "match (m:Method) where m.name = \"hello\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:962
#, fuzzy
msgid "From there, you can narrow down to a given method on a specific type:"
msgstr "A partir daí, pode restringir-se a um determinado método num tipo específico:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:966
#, no-wrap
msgid "match (m:Method) where m.name = \"hello\" and m.type =~ \".*GreetingResource\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:973
#, fuzzy
msgid "Once you’ve located the node for the specific method you’re after, a typical question you’d want to get an answer for is: why does this method get included in the call tree? To do that, start from the method and look for incoming connections at a given depth, starting from the end method.  For example, methods that directly call a method can be located via:"
msgstr "Depois de localizar o nó para o método específico que procura, uma pergunta típica para a qual quer obter uma resposta é: porque é que este método é incluído na árvore de chamadas? Para fazer isso, comece pelo método e procure por conexões de entrada em uma determinada profundidade, começando pelo método final. Por exemplo, os métodos que chamam diretamente um método podem ser localizados através de:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:977
#, no-wrap
msgid "match (m:Method) <- [*1..1] - (o) where m.name = \"hello\" and m.type =~ \".*GreetingResource\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:981
#, fuzzy
msgid "Then you can look for direct calls at depth of 2, so you’d search for methods that call methods that call into the target method:"
msgstr "Depois, pode procurar chamadas directas a uma profundidade de 2, ou seja, procuraria métodos que chamam métodos que chamam o método de destino:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:985
#, no-wrap
msgid "match (m:Method) <- [*1..2] - (o) where m.name = \"hello\" and m.type =~ \".*GreetingResource\" return *\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:991
#, fuzzy
msgid "You can continue going up layers, but unfortunately if you reach a depth with too many nodes, the Neo4j browser will be unable to visualize them all.  When that happens, you can alternatively run the queries directly against the cypher shell:"
msgstr "Pode continuar a subir camadas, mas infelizmente se atingir uma profundidade com demasiados nós, o navegador Neo4j não conseguirá visualizá-los a todos. Quando isso acontecer, pode, em alternativa, executar as consultas diretamente na shell do cypher:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:996
#, no-wrap
msgid ""
"docker exec testneo4j bin/cypher-shell -u neo4j -p ${NEO_PASS} \\\n"
"  \"match (m:Method) <- [*1..10] - (o) where m.name = 'hello' and m.type =~ '.*GreetingResource' return *\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1001
#, fuzzy
msgid "For further information, check out this link:https://quarkus.io/blog/quarkus-native-neo4j-call-tree[blog post] that explores the Quarkus Hibernate ORM quickstart using the techniques explained above."
msgstr "Para mais informações, consulte esta  link:https://quarkus.io/blog/quarkus-native-neo4j-call-tree[publicação do blog] ue que explora o início rápido do Quarkus Hibernate ORM utilizando as técnicas explicadas acima."

#. type: Title ====
#: upstream/_guides/native-reference.adoc:1002
#, fuzzy, no-wrap
msgid "Used Packages/Classes/Methods Reports"
msgstr "Relatórios de pacotes/classes/métodos utilizados"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1006
#, fuzzy
msgid "`used_packages`, `used_classes` and `used_methods` text file reports come in handy when comparing different versions of the application, e.g. why does the image take longer to build? Or why is the image bigger now?"
msgstr "`used_packages`Os relatórios dos ficheiros de texto `used_classes` e `used_methods` são úteis para comparar diferentes versões da aplicação, por exemplo, porque é que a imagem demora mais tempo a ser criada? Ou porque é que a imagem é agora maior?"

#. type: Title ====
#: upstream/_guides/native-reference.adoc:1007
#, fuzzy, no-wrap
msgid "Further Reports"
msgstr "Outros relatórios"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1011
#, fuzzy
msgid "Mandrel can produce further reports beyond the ones that are enabled with the `-Dquarkus.native.enable-reports` option.  These are called expert options and you can learn more about them by running:"
msgstr "O Mandril pode produzir outros relatórios para além dos que são activados com a opção `-Dquarkus.native.enable-reports`. Essas opções são chamadas de opções especializadas e você pode saber mais sobre elas executando:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1015
#, no-wrap
msgid "docker run quay.io/quarkus/ubi-quarkus-mandrel-builder-image:{mandrel-flavor} --expert-options-all\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:1021
#, fuzzy
msgid "These expert options are not considered part of the GraalVM native image API, so they might change anytime."
msgstr "Essas opções de especialistas não são consideradas parte da API de imagem nativa do GraalVM, então elas podem mudar a qualquer momento."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1024
#, fuzzy
msgid "To use these expert options, add them comma separated to the `-Dquarkus.native.additional-build-args` parameter."
msgstr "Para utilizar estas opções de especialista, adicione-as separadas por vírgulas ao parâmetro `-Dquarkus.native.additional-build-args`."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1025
#, fuzzy, no-wrap
msgid "Build-time vs Run-time Initialization"
msgstr "Inicialização em tempo de construção vs. inicialização em tempo de execução"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1032
#, fuzzy
msgid "Quarkus instructs Mandrel to initialize as much as possible at build time, so that runtime startup can be as fast as possible.  This is important in containerized environments where the startup speed has a big impact on how quickly an application is ready to do work.  Build time initialization also minimizes the risk of runtime failures due to unsupported features becoming reachable through runtime initialization, thus making Quarkus more reliable."
msgstr "O Quarkus instrui o Mandrel a inicializar o máximo possível no momento da compilação, para que a inicialização em tempo de execução possa ser a mais rápida possível. Isso é importante em ambientes em contêineres, onde a velocidade de inicialização tem um grande impacto na rapidez com que um aplicativo está pronto para trabalhar. A inicialização em tempo de compilação também minimiza o risco de falhas em tempo de execução devido a recursos não suportados que se tornam acessíveis por meio da inicialização em tempo de execução, tornando o Quarkus mais confiável."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1036
#, fuzzy
msgid "The most common examples of build-time initialized code are static variables and blocks.  Although Mandrel executes those at run-time by default, Quarkus instructs Mandrel to run them at build-time for the reasons given."
msgstr "Os exemplos mais comuns de código inicializado em tempo de construção são as variáveis estáticas e os blocos. Embora o Mandrel os execute em tempo de execução por defeito, o Quarkus dá instruções ao Mandrel para os executar em tempo de construção pelas razões apresentadas."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1040
#, fuzzy
msgid "This means that any static variables initialized inline, or initialized in a static block, will keep the same value even if the application is restarted.  This is a different behaviour compared to what would happen if executed as Java."
msgstr "Isso significa que quaisquer variáveis estáticas inicializadas inline, ou inicializadas em um bloco estático, manterão o mesmo valor mesmo que o aplicativo seja reiniciado. Este é um comportamento diferente em comparação com o que aconteceria se fosse executado como Java."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1043
#, fuzzy
msgid "To see this in action with a very basic example, add a new `TimestampResource` to the application that looks like this:"
msgstr "Para ver isto em ação com um exemplo muito básico, adicione um novo `TimestampResource` à aplicação com o seguinte aspeto:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1047
#: upstream/_guides/native-reference.adoc:1099
#: upstream/_guides/native-reference.adoc:1245
#: upstream/_guides/native-reference.adoc:1437
#: upstream/_guides/native-reference.adoc:1574
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1052
#: upstream/_guides/native-reference.adoc:1250
#, no-wrap
msgid ""
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1055
#, no-wrap
msgid ""
"@Path(\"/timestamp\")\n"
"public class TimestampResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1057
#, no-wrap
msgid "    static long firstAccess = System.currentTimeMillis();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1064
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String timestamp() {\n"
"        return \"First access \" + firstAccess;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1067
#, fuzzy
msgid "Rebuild the binary using:"
msgstr "Reconstruir o binário utilizando:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1075
#, fuzzy
msgid "Run the application in one terminal (make sure you stop any other native executable container runs before executing this):"
msgstr "Execute a aplicação num terminal (certifique-se de que pára qualquer outro executável nativo do contentor antes de executar isto):"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1082
#, fuzzy
msgid "Send a `GET` request multiple times from another terminal:"
msgstr "Enviar um pedido `GET` várias vezes a partir de outro terminal:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1086
#, no-wrap
msgid "curl -w '\\n' http://localhost:8080/timestamp # run this multiple times\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1091
#, fuzzy
msgid "to see how the current time has been baked into the binary.  This time was calculated when the binary was being built, hence application restarts have no effect."
msgstr "para ver como a hora atual foi incorporada no binário. Esta hora foi calculada quando o binário estava a ser construído, pelo que o reinício da aplicação não tem qualquer efeito."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1095
#, fuzzy
msgid "In some situations, built time initializations can lead to errors when building native executables.  One example is when a value gets computed at build time which is forbidden to reside in the heap of the JVM that gets baked into the binary.  To see this in action, add this REST resource:"
msgstr "Em algumas situações, as inicializações em tempo de construção podem levar a erros durante a construção de executáveis nativos. Um exemplo é quando um valor é computado em tempo de construção que é proibido de residir no heap da JVM que é incorporado ao binário. Para ver isso em ação, adicione este recurso REST:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1108
#, no-wrap
msgid ""
"import javax.crypto.Cipher;\n"
"import javax.crypto.NoSuchPaddingException;\n"
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import java.nio.charset.StandardCharsets;\n"
"import java.security.KeyPair;\n"
"import java.security.KeyPairGenerator;\n"
"import java.security.NoSuchAlgorithmException;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1111
#, no-wrap
msgid ""
"@Path(\"/encrypt-decrypt\")\n"
"public class EncryptDecryptResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1114
#, no-wrap
msgid ""
"    static final KeyPairGenerator KEY_PAIR_GEN;\n"
"    static final Cipher CIPHER;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1119
#, no-wrap
msgid ""
"    static {\n"
"        try {\n"
"            KEY_PAIR_GEN = KeyPairGenerator.getInstance(\"RSA\");\n"
"            KEY_PAIR_GEN.initialize(1024);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1125
#, no-wrap
msgid ""
"            CIPHER = Cipher.getInstance(\"RSA\");\n"
"        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {\n"
"            throw new RuntimeException(e);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1130
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/{message}\")\n"
"    public String encryptDecrypt(String message) throws Exception {\n"
"        KeyPair keyPair = KEY_PAIR_GEN.generateKeyPair();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1132
#, no-wrap
msgid "        byte[] text = message.getBytes(StandardCharsets.UTF_8);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1136
#, no-wrap
msgid ""
"        // Encrypt with private key\n"
"        CIPHER.init(Cipher.ENCRYPT_MODE, keyPair.getPrivate());\n"
"        byte[] encrypted = CIPHER.doFinal(text);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1140
#, no-wrap
msgid ""
"        // Decrypt with public key\n"
"        CIPHER.init(Cipher.DECRYPT_MODE, keyPair.getPublic());\n"
"        byte[] unencrypted = CIPHER.doFinal(encrypted);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1144
#, no-wrap
msgid ""
"        return new String(unencrypted, StandardCharsets.UTF_8);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1147
#, fuzzy
msgid "When trying to rebuild the application, you’ll encounter an error:"
msgstr "Ao tentar reconstruir a aplicação, deparar-se-á com um erro:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1166
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative\n"
"...\n"
"Error: Unsupported features in 2 methods\n"
"Detailed message:\n"
"Error: Detected an instance of Random/SplittableRandom class in the image heap. Instances created during image generation have cached seed values and don't behave as expected.  To see how this object got instantiated use --trace-object-instantiation=java.security.SecureRandom. The object was probably created by a class initializer and is reachable from a static field. You can request class initialization at image runtime by using the option --initialize-at-run-time=<class-name>. Or you can write your own initialization methods and call them explicitly from your main entry point.\n"
"Trace: Object was reached by\n"
"\treading field java.security.KeyPairGenerator$Delegate.initRandom of\n"
"\t\tconstant java.security.KeyPairGenerator$Delegate@58b0fe1b reached by\n"
"\treading field org.acme.EncryptDecryptResource.KEY_PAIR_GEN\n"
"Error: Detected an instance of Random/SplittableRandom class in the image heap. Instances created during image generation have cached seed values and don't behave as expected.  To see how this object got instantiated use --trace-object-instantiation=java.security.SecureRandom. The object was probably created by a class initializer and is reachable from a static field. You can request class initialization at image runtime by using the option --initialize-at-run-time=<class-name>. Or you can write your own initialization methods and call them explicitly from your main entry point.\n"
"Trace: Object was reached by\n"
"\treading field sun.security.rsa.RSAKeyPairGenerator.random of\n"
"\t\tconstant sun.security.rsa.RSAKeyPairGenerator$Legacy@3248a092 reached by\n"
"\treading field java.security.KeyPairGenerator$Delegate.spi of\n"
"\t\tconstant java.security.KeyPairGenerator$Delegate@58b0fe1b reached by\n"
"\treading field org.acme.EncryptDecryptResource.KEY_PAIR_GEN\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1174
#, fuzzy
msgid "So, what the message above is telling us is that our application caches a value that is supposed to be random as a constant.  This is not desirable because something that's supposed to be random is no longer so, because the seed is baked in the image.  The message above makes it quite clear what is causing this, but in other situations the cause might be more obfuscated.  As a next step, we'll add some extra flags to the native executable generation to get more information."
msgstr "Portanto, o que a mensagem acima nos está a dizer é que a nossa aplicação guarda um valor que é suposto ser aleatório como uma constante. Isto não é desejável porque algo que é suposto ser aleatório já não o é, porque a semente está incorporada na imagem. A mensagem acima deixa bem claro o que está causando isso, mas em outras situações a causa pode ser mais ofuscada. Como próximo passo, adicionaremos alguns sinalizadores extras à geração do executável nativo para obter mais informações."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1176
#, fuzzy
msgid "As suggested by the message, let's start by adding an option to track object instantiation:"
msgstr "Como sugerido pela mensagem, vamos começar por adicionar uma opção para controlar a instanciação de objectos:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1206
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=\"--trace-object-instantiation=java.security.SecureRandom\"\n"
"...\n"
"Error: Unsupported features in 2 methods\n"
"Detailed message:\n"
"Error: Detected an instance of Random/SplittableRandom class in the image heap. Instances created during image generation have cached seed values and don't behave as expected.  Object has been initialized by the com.sun.jndi.dns.DnsClient class initializer with a trace:\n"
" \tat java.security.SecureRandom.<init>(SecureRandom.java:218)\n"
"\tat sun.security.jca.JCAUtil$CachedSecureRandomHolder.<clinit>(JCAUtil.java:59)\n"
"\tat sun.security.jca.JCAUtil.getSecureRandom(JCAUtil.java:69)\n"
"\tat com.sun.jndi.dns.DnsClient.<clinit>(DnsClient.java:82)\n"
". Try avoiding to initialize the class that caused initialization of the object. The object was probably created by a class initializer and is reachable from a static field. You can request class initialization at image runtime by using the option --initialize-at-run-time=<class-name>. Or you can write your own initialization methods and call them explicitly from your main entry point.\n"
"Trace: Object was reached by\n"
"\treading field java.security.KeyPairGenerator$Delegate.initRandom of\n"
"\t\tconstant java.security.KeyPairGenerator$Delegate@4a5058f9 reached by\n"
"\treading field org.acme.EncryptDecryptResource.KEY_PAIR_GEN\n"
"Error: Detected an instance of Random/SplittableRandom class in the image heap. Instances created during image generation have cached seed values and don't behave as expected.  Object has been initialized by the com.sun.jndi.dns.DnsClient class initializer with a trace:\n"
" \tat java.security.SecureRandom.<init>(SecureRandom.java:218)\n"
"\tat sun.security.jca.JCAUtil$CachedSecureRandomHolder.<clinit>(JCAUtil.java:59)\n"
"\tat sun.security.jca.JCAUtil.getSecureRandom(JCAUtil.java:69)\n"
"\tat com.sun.jndi.dns.DnsClient.<clinit>(DnsClient.java:82)\n"
". Try avoiding to initialize the class that caused initialization of the object. The object was probably created by a class initializer and is reachable from a static field. You can request class initialization at image runtime by using the option --initialize-at-run-time=<class-name>. Or you can write your own initialization methods and call them explicitly from your main entry point.\n"
"Trace: Object was reached by\n"
"\treading field sun.security.rsa.RSAKeyPairGenerator.random of\n"
"\t\tconstant sun.security.rsa.RSAKeyPairGenerator$Legacy@71880cf1 reached by\n"
"\treading field java.security.KeyPairGenerator$Delegate.spi of\n"
"\t\tconstant java.security.KeyPairGenerator$Delegate@4a5058f9 reached by\n"
"\treading field org.acme.EncryptDecryptResource.KEY_PAIR_GEN\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1215
#, fuzzy
msgid "The error messages point to the code in the example, but it can be surprising that a reference to `DnsClient` appears.  Why is that? The key is in what happens inside `KeyPairGenerator.initialize()` method call.  It uses `JCAUtil.getSecureRandom()` which is why this is problematic, but sometimes the tracing options can show some stack traces that do not represent what happens in reality.  The best option is to dig through the source code and use tracing output for guidance but not as full truth."
msgstr "As mensagens de erro apontam para o código do exemplo, mas pode ser surpreendente que apareça uma referência a `DnsClient`. Porquê? A chave está no que acontece dentro da chamada do método `KeyPairGenerator.initialize()`. Ele usa `JCAUtil.getSecureRandom()` e é por isso que isso é problemático, mas às vezes as opções de rastreamento podem mostrar alguns rastreamentos de pilha que não representam o que acontece na realidade. A melhor opção é pesquisar no código-fonte e usar o resultado do rastreamento como orientação, mas não como verdade total."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1218
#, fuzzy
msgid "Moving the `KEY_PAIR_GEN.initialize(1024);` call to the run-time executed method `encryptDecrypt` is enough to solve this particular issue.  Rebuild the application and verify that encrypt/decrypt endpoint works as expected by sending any message and check if the reply is the same as the incoming message:"
msgstr "Mover a chamada `KEY_PAIR_GEN.initialize(1024);` para o método executado em tempo de execução `encryptDecrypt` é suficiente para resolver este problema específico. Reconstrua a aplicação e verifique se o ponto de extremidade de encriptação/desencriptação funciona como esperado, enviando qualquer mensagem e verificando se a resposta é a mesma que a mensagem recebida:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1227
#, no-wrap
msgid ""
"$ ./mvnw package -DskipTests -Dnative\n"
"...\n"
"$ docker run -i --rm -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
"...\n"
"$ curl -w '\\n' http://localhost:8080/encrypt-decrypt/hellomandrel\n"
"hellomandrel\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1230
#, fuzzy
msgid "Additional information on which classes are initialized and why can be obtained by passing in the `-H:+PrintClassInitialization` flag via `-Dquarkus.native.additional-build-args`."
msgstr "Informações adicionais sobre quais classes são inicializadas e por que podem ser obtidas passando o sinalizador `-H:+PrintClassInitialization` via `-Dquarkus.native.additional-build-args`."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1232
#, fuzzy, no-wrap
msgid "Profile Runtime Behaviour"
msgstr "Perfil Comportamento em tempo de execução"

#. type: Title ====
#: upstream/_guides/native-reference.adoc:1234
#, fuzzy, no-wrap
msgid "Single Thread"
msgstr "Linha única"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1238
#, fuzzy
msgid "In this exercise, we profile the runtime behaviour of some Quarkus application that was compiled to a native executable to determine where the bottleneck is.  Assume that you’re in a scenario where profiling the pure Java version is not possible, maybe because the issue only occurs with the native version of the application."
msgstr "Neste exercício, traçamos o perfil do comportamento em tempo de execução de uma aplicação Quarkus que foi compilada para um executável nativo para determinar onde está o gargalo. Suponha que se encontra num cenário em que não é possível traçar o perfil da versão Java pura, talvez porque o problema só ocorre com a versão nativa da aplicação."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1241
#, fuzzy
msgid "Add a REST resource with the following code (example courtesy of link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo1/StringBuilderTest.java[Andrei Pangin's Java Profiling presentation]):"
msgstr "Adicione um recurso REST com o seguinte código (exemplo cortesia da  link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo1/StringBuilderTest.java[apresentação Java Profiling de Andrei Pangin]):"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1253
#, no-wrap
msgid ""
"@Path(\"/string-builder\")\n"
"public class StringBuilderResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1259
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String appendDelete() {\n"
"        StringBuilder sb = new StringBuilder();\n"
"        sb.append(new char[1_000_000]);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1265
#, no-wrap
msgid ""
"        do\n"
"        {\n"
"            sb.append(12345);\n"
"            sb.delete(0, 5);\n"
"        } while (Thread.currentThread().isAlive());\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1269
#, no-wrap
msgid ""
"        return \"Never happens\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1272
#, fuzzy
msgid "Recompile the application, rebuild the binary and run it. Attempting a simple curl will never complete, as expected:"
msgstr "Recompilar a aplicação, reconstruir o binário e executá-la. A tentativa de um simples curl nunca será concluída, como esperado:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1280
#, no-wrap
msgid ""
"$ ./mvnw package -DskipTests -Dnative\n"
"...\n"
"$ docker run -i --rm -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
"...\n"
"$ curl http://localhost:8080/string-builder # this will never complete\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1285
#, fuzzy
msgid "However, the question we’re trying to answer here is: what would be the bottleneck of such code? Is it appending the characters? Is it deleting it? Is it checking whether the thread is alive?"
msgstr "No entanto, a questão a que estamos a tentar responder aqui é: qual seria o gargalo de tal código? Será que está a acrescentar os caracteres? Estará a apagá-los? Será que está a verificar se a thread está viva?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1290
#, fuzzy
msgid "Since we're dealing with a linux native executable, we can use tools like `perf` directly.  To use `perf`, go to the root of the project and start the tools container created earlier as a privileged user:"
msgstr "Como estamos lidando com um executável nativo do Linux, podemos usar ferramentas como `perf` diretamente. Para usar `perf`, vá para a raiz do projeto e inicie o container de ferramentas criado anteriormente como um usuário privilegiado:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1294
#, no-wrap
msgid "docker run --privileged -t -i --rm -v ${PWD}:/data -p 8080:8080 fedora-tools:v1\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:1301
#, fuzzy
msgid "Note that in order to use `perf` to profile the native executables in the guide, the container needs to run as privileged, or with `--cap-add sys_admin`.  Please note that privileged containers are **NOT** recommended in production, so use this flag with caution!"
msgstr "Observe que, para usar `perf` para criar o perfil dos executáveis nativos no guia, o contêiner precisa ser executado como privilegiado ou com `--cap-add sys_admin`. Observe que os contêineres privilegiados *NÃO* são recomendados na produção, portanto, use esse sinalizador com cautela!"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1304
#, fuzzy
msgid "Once the container is running, you need to ensure that the kernel is ready for the profiling exercises:"
msgstr "Quando o contentor estiver a funcionar, é necessário garantir que o kernel está pronto para os exercícios de criação de perfil:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1309
#, no-wrap
msgid ""
"echo -1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n"
"echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:1316
#, fuzzy
msgid "The kernel modifications above also apply to Linux virtual machines.  If running on a bare metal Linux machine, tweaking only `perf_event_paranoid` is enough."
msgstr "As modificações do kernel acima também se aplicam a máquinas virtuais Linux. Se estiver a correr numa máquina Linux bare metal, basta ajustar apenas `perf_event_paranoid`."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1319
#, fuzzy
msgid "Then, from inside the tools container we execute:"
msgstr "Em seguida, a partir do contentor de ferramentas, executamos:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1323
#: upstream/_guides/native-reference.adoc:2069
#, no-wrap
msgid "perf record -F 1009 -g -a ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: delimited block =
#: upstream/_guides/native-reference.adoc:1334
#, fuzzy
msgid "The `perf record` command above takes `1009` samples per second.  Increasing this value means more samples are gathered, which can end up affecting the runtime performance.  This also increases the amount of data generated.  The more data generated, the longer it takes to process it, but the more precision you get on what the application is doing.  So, finding the right value is a balancing act."
msgstr "O comando `perf record` acima coleta `1009` amostras por segundo. Aumentar este valor significa que são recolhidas mais amostras, o que pode acabar por afetar o desempenho do tempo de execução. Isto também aumenta a quantidade de dados gerados. Quanto mais dados forem gerados, mais tempo demora a processá-los, mas mais precisão se obtém sobre o que a aplicação está a fazer. Por isso, encontrar o valor certo é um ato de equilíbrio."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1337
#, fuzzy
msgid "While `perf record` is running, open another window and access the endpoint:"
msgstr "Enquanto o `perf record` estiver em execução, abra outra janela e aceda ao ponto final:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1341
#, no-wrap
msgid "curl http://localhost:8080/string-builder # this will never complete\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1350
#, fuzzy
msgid "After a few seconds, halt the `perf record` process.  This will generate a `perf.data` file.  We could use `perf report` to inspect the perf data, but you can often get a better picture showing that data as a flame graph.  To generate flame graphs, we will use https://github.com/brendangregg/FlameGraph[FlameGraph GitHub repository], which has already been installed inside the tools container."
msgstr "Após alguns segundos, interrompa o processo `perf record`. Isto irá gerar um ficheiro `perf.data`. Poderíamos usar `perf report` para inspecionar os dados de desempenho, mas muitas vezes é possível obter uma imagem melhor mostrando esses dados como um gráfico de chamas. Para gerar gráficos de chama, usaremos o  link:https://github.com/brendangregg/FlameGraph[repositório FlameGraph do GitHub], que já foi instalado dentro do contêiner de ferramentas."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1352
#, fuzzy
msgid "Next, generate a flame graph using the data captured via `perf record`:"
msgstr "Em seguida, gerar um gráfico de chama utilizando os dados capturados através de `perf record`:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1356
#: upstream/_guides/native-reference.adoc:1420
#: upstream/_guides/native-reference.adoc:1527
#, no-wrap
msgid "perf script -i perf.data | ${FG_HOME}/stackcollapse-perf.pl | ${FG_HOME}/flamegraph.pl > flamegraph.svg\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1360
#, fuzzy
msgid "The flame graph is a svg file that a web browser, such as Firefox, can easily display.  After the above two commands complete one can open `flamegraph.svg` in their browser:"
msgstr "O gráfico da chama é um ficheiro svg que um navegador Web, como o Firefox, pode visualizar facilmente. Após a conclusão dos dois comandos acima, é possível abrir `flamegraph.svg` no seu browser:"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/native-reference.adoc:1361
#, fuzzy, no-wrap
msgid "Perf flamegraph without symbols"
msgstr "Gráfico de chama perfeito sem símbolos"

#. type: Target for macro image
#: upstream/_guides/native-reference.adoc:1361
#, no-wrap
msgid "native-reference-perf-flamegraph-no-symbols.svg"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1370
#, fuzzy
msgid "We see a big majority of time spent in what is supposed to be our main, but we see no trace of the `StringBuilderResource` class, nor the `StringBuilder` class we're calling.  We should look at the symbol table of the binary: can we find symbols for our class and `StringBuilder`? We need those in order to get meaningful data.  From within the tools container, query the symbol table:"
msgstr "Vemos uma grande maioria do tempo gasto no que é suposto ser o nosso main, mas não vemos qualquer vestígio da classe `StringBuilderResource`, nem da classe `StringBuilder` que estamos a chamar. Devemos olhar para a tabela de símbolos do binário: podemos encontrar símbolos para a nossa classe e `StringBuilder`? Precisamos deles para obter dados significativos. A partir do contentor de ferramentas, consulte a tabela de símbolos:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1375
#, no-wrap
msgid ""
"objdump -t ./target/debugging-native-1.0.0-SNAPSHOT-runner | grep StringBuilder\n"
"[no output]\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1381
#, fuzzy
msgid "No output appears when querying the symbol table.  This is why we don't see any call graphs in the flame graphs.  This is a deliberate decision that native-image makes.  By default, it removes symbols from the binary."
msgstr "Não aparece nenhum resultado quando se consulta a tabela de símbolos. É por isso que não vemos nenhum gráfico de chamada nos gráficos de chama. Esta é uma decisão deliberada que o native-image faz. Por padrão, ele remove os símbolos do binário."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1385
#, fuzzy
msgid "To regain the symbols, we need to rebuild the binary instructing GraalVM not to delete the symbols.  On top of that, enable DWARF debug info so that the stack traces can be populated with that information.  From outside the tools container, execute:"
msgstr "Para recuperar os símbolos, precisamos reconstruir o binário instruindo o GraalVM a não excluir os símbolos. Além disso, habilite as informações de depuração do DWARF para que os traços de pilha possam ser preenchidos com essas informações. De fora do contêiner de ferramentas, execute:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1391
#: upstream/_guides/native-reference.adoc:1506
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.debug.enabled \\\n"
"    -Dquarkus.native.additional-build-args=-H:-DeleteLocalSymbols\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1396
#, fuzzy
msgid "Next, re-enter the tools container if you exited, and inspect the native executable with `objdump`, and see how the symbols are now present:"
msgstr "Em seguida, volte a entrar no contentor de ferramentas, se tiver saído, e inspeccione o executável nativo com `objdump`, e veja como os símbolos estão agora presentes:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1403
#, no-wrap
msgid ""
"$ objdump -t ./target/debugging-native-1.0.0-SNAPSHOT-runner | grep StringBuilder\n"
"000000000050a940 l     F .text\t0000000000000091              .hidden ReflectionAccessorHolder_StringBuilderResource_appendDelete_9e06d4817d0208a0cce97ebcc0952534cac45a19_e22addf7d3eaa3ad14013ce01941dc25beba7621\n"
"000000000050a9e0 l     F .text\t00000000000000bb              .hidden ReflectionAccessorHolder_StringBuilderResource_constructor_0f8140ea801718b80c05b979a515d8a67b8f3208_12baae06bcd6a1ef9432189004ae4e4e176dd5a4\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1406
#, fuzzy
msgid "You should see a long list of symbols that match that pattern."
msgstr "Deverá ver uma longa lista de símbolos que correspondem a esse padrão."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1409
#, fuzzy
msgid "Then, run the executable through perf, *indicating that the call graph is dwarf*:"
msgstr "Em seguida, execute o executável através do perf, *indicando que o gráfico de chamadas é anão*:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1413
#: upstream/_guides/native-reference.adoc:1513
#, no-wrap
msgid "perf record -F 1009 --call-graph dwarf -a ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1416
#, fuzzy
msgid "Run the curl command once again, stop the binary, generate the flamegraphs and open it:"
msgstr "Execute o comando curl mais uma vez, pare o binário, gere os flamegraphs e abra-o:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1425
#, fuzzy
msgid "The flamegraph now shows where the bottleneck is.  It's when `StringBuilder.delete()` is called which calls `System.arraycopy()`.  The issue is that 1 million characters need to be shifted in very small increments:"
msgstr "O gráfico de chama mostra agora onde está o estrangulamento. É quando `StringBuilder.delete()` é chamado, que chama `System.arraycopy()`. O problema é que 1 milhão de caracteres precisam de ser deslocados em incrementos muito pequenos:"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/native-reference.adoc:1426
#, fuzzy, no-wrap
msgid "Perf flamegraph with symbols"
msgstr "Gráfico de chama de perfuração com símbolos"

#. type: Target for macro image
#: upstream/_guides/native-reference.adoc:1426
#, no-wrap
msgid "native-reference-perf-flamegraph-symbols.svg"
msgstr ""

#. type: Title ====
#: upstream/_guides/native-reference.adoc:1428
#, fuzzy, no-wrap
msgid "Multi-Thread"
msgstr "Multi-Thread"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1433
#, fuzzy
msgid "Multithreaded programs might require special attention when trying to understand their runtime behaviour.  To demonstrate this, add this `MulticastResource` code to your project (example courtesy of link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo6/DatagramTest.java[Andrei Pangin's Java Profiling presentation]):"
msgstr "Os programas multithread podem exigir atenção especial ao tentar entender seu comportamento em tempo de execução. Para demonstrar isso, adicione este código `MulticastResource` ao seu projeto (exemplo cortesia da  link:https://github.com/apangin/java-profiling-presentation/blob/master/src/demo6/DatagramTest.java[apresentação Java Profiling de Andrei Pangin]):"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1449
#, no-wrap
msgid ""
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
"import java.net.InetSocketAddress;\n"
"import java.nio.ByteBuffer;\n"
"import java.nio.channels.DatagramChannel;\n"
"import java.util.concurrent.ExecutorService;\n"
"import java.util.concurrent.Executors;\n"
"import java.util.concurrent.ThreadFactory;\n"
"import java.util.concurrent.atomic.AtomicInteger;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1459
#, no-wrap
msgid ""
"@Path(\"/multicast\")\n"
"public class MulticastResource\n"
"{\n"
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String send() throws Exception {\n"
"        sendMulticasts();\n"
"        return \"Multicast packets sent\";\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1464
#, no-wrap
msgid ""
"    static void sendMulticasts() throws Exception {\n"
"        DatagramChannel ch = DatagramChannel.open();\n"
"        ch.bind(new InetSocketAddress(5555));\n"
"        ch.configureBlocking(false);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1472
#, no-wrap
msgid ""
"        ExecutorService pool =\n"
"            Executors.newCachedThreadPool(new ShortNameThreadFactory());\n"
"        for (int i = 0; i < 10; i++) {\n"
"            pool.submit(() -> {\n"
"                final ByteBuffer buf = ByteBuffer.allocateDirect(1000);\n"
"                final InetSocketAddress remoteAddr =\n"
"                    new InetSocketAddress(\"127.0.0.1\", 5556);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1479
#, no-wrap
msgid ""
"                while (true) {\n"
"                    buf.clear();\n"
"                    ch.send(buf, remoteAddr);\n"
"                }\n"
"            });\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1482
#, no-wrap
msgid ""
"        System.out.println(\"Warming up...\");\n"
"        Thread.sleep(3000);\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1486
#, no-wrap
msgid ""
"        System.out.println(\"Benchmarking...\");\n"
"        Thread.sleep(5000);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1488
#, no-wrap
msgid "    private static final class ShortNameThreadFactory implements ThreadFactory {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1491
#, no-wrap
msgid ""
"        private final AtomicInteger threadNumber = new AtomicInteger(1);\n"
"        private final String namePrefix = \"thread-\";\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1497
#, no-wrap
msgid ""
"        public Thread newThread(Runnable r) {\n"
"            return new Thread(r, namePrefix + threadNumber.getAndIncrement());\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1500
#, fuzzy
msgid "Build the native executable with debug info:"
msgstr "Constrói o executável nativo com informações de depuração:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1509
#, fuzzy
msgid "From inside the tools container (as privileged user) run the native executable through `perf`:"
msgstr "A partir do interior do contentor de ferramentas (como utilizador privilegiado), execute o executável nativo através de `perf`:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1516
#, fuzzy
msgid "Invoke the endpoint to send the multicast packets:"
msgstr "Invoca o ponto final para enviar os pacotes multicast:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1520
#, no-wrap
msgid "curl -w '\\n' http://localhost:8080/multicast\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1523
#, fuzzy
msgid "Make and open a flamegraph:"
msgstr "Criar e abrir um gráfico de chama:"

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/native-reference.adoc:1529
#, fuzzy, no-wrap
msgid "Muti-thread perf flamegraph with separate threads"
msgstr "Flamegraph de desempenho multi-thread com threads separadas"

#. type: Target for macro image
#: upstream/_guides/native-reference.adoc:1529
#, no-wrap
msgid "native-reference-multi-flamegraph-separate-threads.svg"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1533
#, fuzzy
msgid "The flamegraph produced looks odd. Each thread is treated independently even though they all do the same work.  This makes it difficult to have a clear picture of the bottlenecks in the program."
msgstr "O gráfico de chama produzido parece estranho. Cada thread é tratada de forma independente, embora todas façam o mesmo trabalho. Isto torna difícil ter uma imagem clara dos estrangulamentos no programa."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1536
#, fuzzy
msgid "This is happening because from a `perf` perspective, each thread is a different command.  We can see that if we inspect `perf report`:"
msgstr "Isto acontece porque, de uma perspetiva `perf`, cada thread é um comando diferente. Podemos ver isso se inspeccionarmos `perf report`:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1547
#, no-wrap
msgid ""
"perf report --stdio\n"
"# Children      Self  Command          Shared Object       Symbol\n"
"# ........  ........  ...............  ......................................  ......................................................................................\n"
"...\n"
"     6.95%     0.03%  thread-2         debugging-native-1.0.0-SNAPSHOT-runner  [.] MulticastResource_lambda$sendMulticasts$0_cb1f7b5dcaed7dd4e3f90d18bad517d67eae4d88\n"
"...\n"
"     4.60%     0.02%  thread-10        debugging-native-1.0.0-SNAPSHOT-runner  [.] MulticastResource_lambda$sendMulticasts$0_cb1f7b5dcaed7dd4e3f90d18bad517d67eae4d88\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1551
#, fuzzy
msgid "This can be worked around by applying some modifications to the perf output, in order to make all threads have the same name. E.g."
msgstr "Isso pode ser contornado aplicando algumas modificações na saída do perf, para que todos os threads tenham o mesmo nome. Por exemplo."

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1555
#, no-wrap
msgid "perf script | sed -E \"s/thread-[0-9]*/thread/\" | ${FG_HOME}/stackcollapse-perf.pl | ${FG_HOME}/flamegraph.pl > flamegraph.svg\n"
msgstr ""

#. type: Positional ($1) AttributeList argument for macro 'image'
#: upstream/_guides/native-reference.adoc:1557
#, fuzzy, no-wrap
msgid "Muti-thread perf flamegraph with joined threads"
msgstr "Flamegrama de desempenho multi-fios com fios unidos"

#. type: Target for macro image
#: upstream/_guides/native-reference.adoc:1557
#, no-wrap
msgid "native-reference-multi-flamegraph-joined-threads.svg"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1561
#, fuzzy
msgid "When you open the flamegraph, you will see all threads' work collapsed into a single area.  Then, you can clearly see that there's some locking that could affect performance."
msgstr "Ao abrir o gráfico de chama, verá o trabalho de todas as threads agrupado numa única área. Assim, pode ver claramente que existe algum bloqueio que pode afetar o desempenho."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1563
#, fuzzy, no-wrap
msgid "Debugging Native Crashes"
msgstr "Depuração de falhas nativas"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1570
#, fuzzy
msgid "One of the drawbacks of using native executables is that they cannot be debugged using the standard Java debuggers, instead we need to debug them using `gdb`, the GNU Project debugger.  To demonstrate how to do this, we are going to generate a native Quarkus application that crashes due to a Segmentation Fault when accessing http://localhost:8080/crash.  To achieve this, add the following REST resource to the project:"
msgstr "Uma das desvantagens de usar executáveis nativos é que eles não podem ser depurados usando os depuradores Java padrão, em vez disso, precisamos depurá-los usando `gdb`, o depurador do Projeto GNU. Para demonstrar como fazer isso, vamos gerar uma aplicação Quarkus nativa que falha devido a uma falha de segmentação ao aceder a  http://localhost:8080/crash  Para isso, adicione o seguinte recurso REST ao projeto:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1576
#, no-wrap
msgid "import sun.misc.Unsafe;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1582
#, no-wrap
msgid ""
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
"import jakarta.ws.rs.core.MediaType;\n"
"import java.lang.reflect.Field;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1585
#, no-wrap
msgid ""
"@Path(\"/crash\")\n"
"public class CrashResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1601
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(MediaType.TEXT_PLAIN)\n"
"    public String hello() {\n"
"        Field theUnsafe = null;\n"
"        try {\n"
"            theUnsafe = Unsafe.class.getDeclaredField(\"theUnsafe\");\n"
"            theUnsafe.setAccessible(true);\n"
"            Unsafe unsafe = (Unsafe) theUnsafe.get(null);\n"
"            unsafe.copyMemory(0, 128, 256);\n"
"        } catch (NoSuchFieldException | IllegalAccessException e) {\n"
"            e.printStackTrace();\n"
"        }\n"
"        return \"Never happens\";\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1605
#, fuzzy
msgid "This code will try to copy 256 bytes from address `0x0` to `0x80` resulting in a Segmentation Fault.  To verify this, compile and run the example application:"
msgstr "Esse código tentará copiar 256 bytes do endereço `0x0` para `0x80`, resultando em uma falha de segmentação. Para verificar isso, compile e execute o aplicativo de exemplo:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1613
#, no-wrap
msgid ""
"$ ./mvnw package -DskipTests -Dnative\n"
"...\n"
"$ docker run -i --rm -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
"...\n"
"$ curl http://localhost:8080/crash\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1616
#, fuzzy
msgid "This will result in the following output:"
msgstr "Isto resultará na seguinte saída:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1623
#, no-wrap
msgid ""
"$ docker run -i --rm -p 8080:8080 test/debugging-native:1.0.0-SNAPSHOT\n"
"...\n"
"Segfault detected, aborting process. Use runtime option -R:-InstallSegfaultHandler if you don't want to use SubstrateSegfaultHandler.\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1629
#, fuzzy
msgid "The omitted output above contains clues to what caused the issue, but in this exercise we are going to assume that no information was provided.  Let’s try to debug the segmentation fault using `gdb`.  To do that, go to the root of the project and enter the tools container:"
msgstr "A saída omitida acima contém pistas sobre o que causou o problema, mas neste exercício vamos assumir que nenhuma informação foi fornecida. Vamos tentar depurar a falha de segmentação usando `gdb`. Para fazer isso, vá para a raiz do projeto e entre no contêiner de ferramentas:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1633
#, no-wrap
msgid "docker run -t -i --rm -v ${PWD}:/data -p 8080:8080 fedora-tools:v1 /bin/bash\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1636
#, fuzzy
msgid "Then start the application in `gdb` and execute `run`."
msgstr "Em seguida, iniciar a aplicação em `gdb` e executar `run`."

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1645
#, no-wrap
msgid ""
"gdb ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
"...\n"
"Reading symbols from ./target/debugging-native-1.0.0-SNAPSHOT-runner...\n"
"(No debugging symbols found in ./target/debugging-ntaive-1.0.0-SNAPSHOT-runner)\n"
"(gdb) run\n"
"Starting program: /data/target/debugging-native-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1648
#, fuzzy
msgid "Next, try to access http://localhost:8080/crash:"
msgstr "Em seguida, tente aceder a  http://localhost:8080/crash"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1651
#, no-wrap
msgid "curl http://localhost:8080/crash\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1654
#: upstream/_guides/native-reference.adoc:1698
#, fuzzy
msgid "This will result in the following message in `gdb`:"
msgstr "O resultado será a seguinte mensagem em `gdb`:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1660
#, no-wrap
msgid ""
"Thread 4 \"ecutor-thread-0\" received signal SIGSEGV, Segmentation fault.\n"
"[Switching to Thread 0x7fe103dff640 (LWP 190)]\n"
"0x0000000000461f6e in ?? ()\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1663
#, fuzzy
msgid "If we try to get more info about the backtrace that led to this crash we will see that there is not enough information available."
msgstr "Se tentarmos obter mais informações sobre o backtrace que levou a esta falha, veremos que não há informações suficientes disponíveis."

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1674
#, no-wrap
msgid ""
"(gdb) bt\n"
"#0  0x0000000000418b5e in ?? ()\n"
"#1  0x00007ffff6f2d328 in ?? ()\n"
"#2  0x0000000000418a04 in ?? ()\n"
"#3  0x00007ffff44062a0 in ?? ()\n"
"#4  0x00000000010c3dd3 in ?? ()\n"
"#5  0x0000000000000100 in ?? ()\n"
"#6  0x0000000000000000 in ?? ()\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1679
#, fuzzy
msgid "This is because we didn’t compile the Quarkus application with `-Dquarkus.native.debug.enabled`, so `gdb` cannot find debugging symbols for our native executable, as indicated by the \"_No debugging symbols found in ./target/debugging-native-1.0.0-SNAPSHOT-runner_\" message in the beginning of `gdb`."
msgstr "Isto deve-se ao facto de não termos compilado a aplicação Quarkus com `-Dquarkus.native.debug.enabled`, pelo que `gdb` não consegue encontrar símbolos de depuração para o nosso executável nativo, como indicado pela mensagem _\"No debugging symbols found in ./target/debugging-native-1.0.0-SNAPSHOT-runner_\" no início de `gdb`."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1682
#, fuzzy
msgid "Recompiling the Quarkus application with `-Dquarkus.native.debug.enabled` and rerunning it through `gdb` we are now able to get a backtrace making clear what caused the crash.  On top of that, add `-H:-OmitInlinedMethodDebugLineInfo` option to avoid inlined methods being omitted from the backtrace:"
msgstr "Recompilando a aplicação Quarkus com `-Dquarkus.native.debug.enabled` e voltando a executá-la através de `gdb`, conseguimos agora obter um backtrace que torna claro o que causou a falha. Para além disso, adicione a opção `-H:-OmitInlinedMethodDebugLineInfo` para evitar que os métodos inlined sejam omitidos do backtrace:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1695
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.debug.enabled \\\n"
"    -Dquarkus.native.additional-build-args=-H:-OmitInlinedMethodDebugLineInfo\n"
"...\n"
"$ gdb ./target/debugging-native-1.0.0-SNAPSHOT-runner\n"
"Reading symbols from ./target/debugging-native-1.0.0-SNAPSHOT-runner...\n"
"(gdb) run\n"
"Starting program: /data/target/debugging-native-1.0.0-SNAPSHOT-runner\n"
"...\n"
"$ curl http://localhost:8080/crash\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1706
#, no-wrap
msgid ""
"Thread 4 \"ecutor-thread-0\" received signal SIGSEGV, Segmentation fault.\n"
"[Switching to Thread 0x7fffeffff640 (LWP 362984)]\n"
"com.oracle.svm.core.UnmanagedMemoryUtil::copyLongsBackward(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) ()\n"
"\tat com/oracle/svm/core/UnmanagedMemoryUtil.java:169\n"
"169    com/oracle/svm/core/UnmanagedMemoryUtil.java: No such file or directory.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1710
#, fuzzy
msgid "We already see that `gdb` is able to tell us which method caused the crash and where it’s located in the source code.  We can also get a backtrace of the call graph that led us to this state:"
msgstr "Já vimos que `gdb` é capaz de nos dizer qual método causou a falha e onde ele está localizado no código-fonte. Também podemos obter um backtrace do gráfico de chamadas que nos levou a este estado:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1723
#, no-wrap
msgid ""
"(gdb) bt\n"
"#0  com.oracle.svm.core.UnmanagedMemoryUtil::copyLongsBackward(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) () at com/oracle/svm/core/UnmanagedMemoryUtil.java:169\n"
"#1  0x0000000000461e14 in com.oracle.svm.core.UnmanagedMemoryUtil::copyBackward(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) () at com/oracle/svm/core/UnmanagedMemoryUtil.java:110\n"
"#2  0x0000000000461dc8 in com.oracle.svm.core.UnmanagedMemoryUtil::copy(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) () at com/oracle/svm/core/UnmanagedMemoryUtil.java:67\n"
"#3  0x000000000045d3c0 in com.oracle.svm.core.JavaMemoryUtil::unsafeCopyMemory(java.lang.Object *, long, java.lang.Object *, long, long) () at com/oracle/svm/core/JavaMemoryUtil.java:276\n"
"#4  0x00000000013277de in jdk.internal.misc.Unsafe::copyMemory0 () at com/oracle/svm/core/jdk/SunMiscSubstitutions.java:125\n"
"#5  jdk.internal.misc.Unsafe::copyMemory(java.lang.Object *, long, java.lang.Object *, long, long) () at jdk/internal/misc/Unsafe.java:788\n"
"#6  0x00000000013b1a3f in jdk.internal.misc.Unsafe::copyMemory () at jdk/internal/misc/Unsafe.java:799\n"
"#7  sun.misc.Unsafe::copyMemory () at sun/misc/Unsafe.java:585\n"
"#8  org.acme.CrashResource::hello(void) () at org/acme/CrashResource.java:22\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1726
#, fuzzy
msgid "Similarly, we can get a backtrace of the call graph of other threads."
msgstr "Da mesma forma, podemos obter um backtrace do gráfico de chamadas de outras threads."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1728
#, fuzzy
msgid "First, we can list the available threads with:"
msgstr "Primeiro, podemos listar as threads disponíveis com:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1739
#, no-wrap
msgid ""
"(gdb) info threads\n"
"  Id   Target Id                                             Frame\n"
"  1    Thread 0x7fcc62a07d00 (LWP 322) \"debugging-nativ\" 0x00007fcc62b8b77a in __futex_abstimed_wait_common () from /lib64/libc.so.6\n"
"  2    Thread 0x7fcc60eff640 (LWP 326) \"gnal Dispatcher\" 0x00007fcc62b8b77a in __futex_abstimed_wait_common () from /lib64/libc.so.6\n"
"* 4    Thread 0x7fcc5b7fe640 (LWP 328) \"ecutor-thread-0\" com.oracle.svm.core.UnmanagedMemoryUtil::copyLongsBackward(org.graalvm.word.Pointer *, org.graalvm.word.Pointer *, org.graalvm.word.UnsignedWord *) () at com/oracle/svm/core/UnmanagedMemoryUtil.java:169\n"
"  5    Thread 0x7fcc5abff640 (LWP 329) \"-thread-checker\" 0x00007fcc62b8b77a in __futex_abstimed_wait_common () from /lib64/libc.so.6\n"
"  6    Thread 0x7fcc59dff640 (LWP 330) \"ntloop-thread-0\" 0x00007fcc62c12c9e in epoll_wait () from /lib64/libc.so.6\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1742
#, fuzzy
msgid "select the thread we want to inspect, e.g. thread 1:"
msgstr "selecionar o segmento que queremos inspecionar, por exemplo, o segmento 1:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1749
#, no-wrap
msgid ""
"(gdb) thread 1\n"
"[Switching to thread 1 (Thread 0x7ffff7a58d00 (LWP 1028851))]\n"
"#0  __futex_abstimed_wait_common64 (private=0, cancel=true, abstime=0x0, op=393, expected=0, futex_word=0x2cd7adc) at futex-internal.c:57\n"
"57\t    return INTERNAL_SYSCALL_CANCEL (futex_time64, futex_word, op, expected,\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1752
#, fuzzy
msgid "and, finally, print the stack trace:"
msgstr "e, finalmente, imprime o traço da pilha:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1780
#, no-wrap
msgid ""
"(gdb) bt\n"
"#0  __futex_abstimed_wait_common64 (private=0, cancel=true, abstime=0x0, op=393, expected=0, futex_word=0x2cd7adc) at futex-internal.c:57\n"
"#1  __futex_abstimed_wait_common (futex_word=futex_word@entry=0x2cd7adc, expected=expected@entry=0, clockid=clockid@entry=0, abstime=abstime@entry=0x0, private=private@entry=0,\n"
"    cancel=cancel@entry=true) at futex-internal.c:87\n"
"#2  0x00007ffff7bdd79f in __GI___futex_abstimed_wait_cancelable64 (futex_word=futex_word@entry=0x2cd7adc, expected=expected@entry=0, clockid=clockid@entry=0, abstime=abstime@entry=0x0,\n"
"    private=private@entry=0) at futex-internal.c:139\n"
"#3  0x00007ffff7bdfeb0 in __pthread_cond_wait_common (abstime=0x0, clockid=0, mutex=0x2ca07b0, cond=0x2cd7ab0) at pthread_cond_wait.c:504\n"
"#4  ___pthread_cond_wait (cond=0x2cd7ab0, mutex=0x2ca07b0) at pthread_cond_wait.c:619\n"
"#5  0x00000000004e2014 in com.oracle.svm.core.posix.headers.Pthread::pthread_cond_wait () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:252\n"
"#6  com.oracle.svm.core.posix.thread.PosixParkEvent::condWait(void) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:252\n"
"#7  0x0000000000547070 in com.oracle.svm.core.thread.JavaThreads::park(void) () at com/oracle/svm/core/thread/JavaThreads.java:764\n"
"#8  0x0000000000fc5f44 in jdk.internal.misc.Unsafe::park(boolean, long) () at com/oracle/svm/core/thread/Target_jdk_internal_misc_Unsafe_JavaThreads.java:49\n"
"#9  0x0000000000eac1ad in java.util.concurrent.locks.LockSupport::park(java.lang.Object *) () at java/util/concurrent/locks/LockSupport.java:194\n"
"#10 0x0000000000ea5d68 in java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject::awaitUninterruptibly(void) ()\n"
"    at java/util/concurrent/locks/AbstractQueuedSynchronizer.java:2018\n"
"#11 0x00000000008b6b30 in io.quarkus.runtime.ApplicationLifecycleManager::run(io.quarkus.runtime.Application *, java.lang.Class *, java.util.function.BiConsumer *, java.lang.String[] *) ()\n"
"    at io/quarkus/runtime/ApplicationLifecycleManager.java:144\n"
"#12 0x00000000008bc055 in io.quarkus.runtime.Quarkus::run(java.lang.Class *, java.util.function.BiConsumer *, java.lang.String[] *) () at io/quarkus/runtime/Quarkus.java:67\n"
"#13 0x000000000045c88b in io.quarkus.runtime.Quarkus::run () at io/quarkus/runtime/Quarkus.java:41\n"
"#14 io.quarkus.runtime.Quarkus::run () at io/quarkus/runtime/Quarkus.java:120\n"
"#15 0x000000000045c88b in io.quarkus.runner.GeneratedMain::main ()\n"
"#16 com.oracle.svm.core.JavaMainWrapper::runCore () at com/oracle/svm/core/JavaMainWrapper.java:150\n"
"#17 com.oracle.svm.core.JavaMainWrapper::run(int, org.graalvm.nativeimage.c.type.CCharPointerPointer *) () at com/oracle/svm/core/JavaMainWrapper.java:186\n"
"#18 0x000000000048084d in com.oracle.svm.core.code.IsolateEnterStub::JavaMainWrapper_run_5087f5482cc9a6abc971913ece43acb471d2631b(int, org.graalvm.nativeimage.c.type.CCharPointerPointer *)\n"
"    () at com/oracle/svm/core/JavaMainWrapper.java:280\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1783
#, fuzzy
msgid "Alternatively, we can list the backtraces of all threads with a single command:"
msgstr "Alternativamente, podemos listar os backtraces de todas as threads com um único comando:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1787
#, no-wrap
msgid "(gdb) thread apply all backtrace\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1807
#, no-wrap
msgid ""
"Thread 22 (Thread 0x7fffc8dff640 (LWP 1028872) \"tloop-thread-15\"):\n"
"#0  0x00007ffff7c64c2e in epoll_wait (epfd=8, events=0x2ca3880, maxevents=1024, timeout=-1) at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"#1  0x000000000166e01c in Java_sun_nio_ch_EPoll_wait ()\n"
"#2  0x00000000011bfece in sun.nio.ch.EPoll::wait(int, long, int, int) () at com/oracle/svm/core/stack/JavaFrameAnchors.java:42\n"
"#3  0x00000000011c08d2 in sun.nio.ch.EPollSelectorImpl::doSelect(java.util.function.Consumer *, long) () at sun/nio/ch/EPollSelectorImpl.java:120\n"
"#4  0x00000000011d8977 in sun.nio.ch.SelectorImpl::lockAndDoSelect(java.util.function.Consumer *, long) () at sun/nio/ch/SelectorImpl.java:124\n"
"#5  0x0000000000705720 in sun.nio.ch.SelectorImpl::select () at sun/nio/ch/SelectorImpl.java:141\n"
"#6  io.netty.channel.nio.SelectedSelectionKeySetSelector::select(void) () at io/netty/channel/nio/SelectedSelectionKeySetSelector.java:68\n"
"#7  0x0000000000703c2e in io.netty.channel.nio.NioEventLoop::select(long) () at io/netty/channel/nio/NioEventLoop.java:813\n"
"#8  0x0000000000701a5f in io.netty.channel.nio.NioEventLoop::run(void) () at io/netty/channel/nio/NioEventLoop.java:460\n"
"#9  0x00000000008496df in io.netty.util.concurrent.SingleThreadEventExecutor$4::run(void) () at io/netty/util/concurrent/SingleThreadEventExecutor.java:986\n"
"#10 0x0000000000860762 in io.netty.util.internal.ThreadExecutorMap$2::run(void) () at io/netty/util/internal/ThreadExecutorMap.java:74\n"
"#11 0x0000000000840da4 in io.netty.util.concurrent.FastThreadLocalRunnable::run(void) () at io/netty/util/concurrent/FastThreadLocalRunnable.java:30\n"
"#12 0x0000000000b7dd04 in java.lang.Thread::run(void) () at java/lang/Thread.java:829\n"
"#13 0x0000000000547dcc in com.oracle.svm.core.thread.JavaThreads::threadStartRoutine(org.graalvm.nativeimage.ObjectHandle *) () at com/oracle/svm/core/thread/JavaThreads.java:597\n"
"#14 0x00000000004e15b1 in com.oracle.svm.core.posix.thread.PosixJavaThreads::pthreadStartRoutine(com.oracle.svm.core.thread.JavaThreads$ThreadStartData *) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:194\n"
"#15 0x0000000000480984 in com.oracle.svm.core.code.IsolateEnterStub::PosixJavaThreads_pthreadStartRoutine_e1f4a8c0039f8337338252cd8734f63a79b5e3df(com.oracle.svm.core.thread.JavaThreads$ThreadStartData *) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:182\n"
"#16 0x00007ffff7be0b1a in start_thread (arg=<optimized out>) at pthread_create.c:443\n"
"#17 0x00007ffff7c65650 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1827
#, no-wrap
msgid ""
"Thread 21 (Thread 0x7fffc97fa640 (LWP 1028871) \"tloop-thread-14\"):\n"
"#0  0x00007ffff7c64c2e in epoll_wait (epfd=53, events=0x2cd0970, maxevents=1024, timeout=-1) at ../sysdeps/unix/sysv/linux/epoll_wait.c:30\n"
"#1  0x000000000166e01c in Java_sun_nio_ch_EPoll_wait ()\n"
"#2  0x00000000011bfece in sun.nio.ch.EPoll::wait(int, long, int, int) () at com/oracle/svm/core/stack/JavaFrameAnchors.java:42\n"
"#3  0x00000000011c08d2 in sun.nio.ch.EPollSelectorImpl::doSelect(java.util.function.Consumer *, long) () at sun/nio/ch/EPollSelectorImpl.java:120\n"
"#4  0x00000000011d8977 in sun.nio.ch.SelectorImpl::lockAndDoSelect(java.util.function.Consumer *, long) () at sun/nio/ch/SelectorImpl.java:124\n"
"#5  0x0000000000705720 in sun.nio.ch.SelectorImpl::select () at sun/nio/ch/SelectorImpl.java:141\n"
"#6  io.netty.channel.nio.SelectedSelectionKeySetSelector::select(void) () at io/netty/channel/nio/SelectedSelectionKeySetSelector.java:68\n"
"#7  0x0000000000703c2e in io.netty.channel.nio.NioEventLoop::select(long) () at io/netty/channel/nio/NioEventLoop.java:813\n"
"#8  0x0000000000701a5f in io.netty.channel.nio.NioEventLoop::run(void) () at io/netty/channel/nio/NioEventLoop.java:460\n"
"#9  0x00000000008496df in io.netty.util.concurrent.SingleThreadEventExecutor$4::run(void) () at io/netty/util/concurrent/SingleThreadEventExecutor.java:986\n"
"#10 0x0000000000860762 in io.netty.util.internal.ThreadExecutorMap$2::run(void) () at io/netty/util/internal/ThreadExecutorMap.java:74\n"
"#11 0x0000000000840da4 in io.netty.util.concurrent.FastThreadLocalRunnable::run(void) () at io/netty/util/concurrent/FastThreadLocalRunnable.java:30\n"
"#12 0x0000000000b7dd04 in java.lang.Thread::run(void) () at java/lang/Thread.java:829\n"
"#13 0x0000000000547dcc in com.oracle.svm.core.thread.JavaThreads::threadStartRoutine(org.graalvm.nativeimage.ObjectHandle *) () at com/oracle/svm/core/thread/JavaThreads.java:597\n"
"#14 0x00000000004e15b1 in com.oracle.svm.core.posix.thread.PosixJavaThreads::pthreadStartRoutine(com.oracle.svm.core.thread.JavaThreads$ThreadStartData *) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:194\n"
"#15 0x0000000000480984 in com.oracle.svm.core.code.IsolateEnterStub::PosixJavaThreads_pthreadStartRoutine_e1f4a8c0039f8337338252cd8734f63a79b5e3df(com.oracle.svm.core.thread.JavaThreads$ThreadStartData *) () at com/oracle/svm/core/posix/thread/PosixJavaThreads.java:182\n"
"#16 0x00007ffff7be0b1a in start_thread (arg=<optimized out>) at pthread_create.c:443\n"
"#17 0x00007ffff7c65650 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1830
#, no-wrap
msgid ""
"Thread 20 (Thread 0x7fffc9ffb640 (LWP 1028870) \"tloop-thread-13\"):\n"
"...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1833
#, fuzzy
msgid "Note, however, that despite being able to get a backtrace we can still not list the source code at point with the `list` command."
msgstr "Note-se, no entanto, que apesar de sermos capazes de obter um backtrace, ainda não podemos listar o código fonte no ponto com o comando `list`."

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1838
#, no-wrap
msgid ""
"(gdb) list\n"
"164    in com/oracle/svm/core/UnmanagedMemoryUtil.java\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1844
#, fuzzy
msgid "This is because `gdb` is not aware of the location of the source files.  We are running the executable outside the target directory.  To fix this we can either rerun `gdb` from the target directory or, run `directory target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/sources` e.g.:"
msgstr "Isto acontece porque o `gdb` não tem conhecimento da localização dos ficheiros de origem. Estamos a executar o executável fora do diretório de destino. Para resolver isto, podemos voltar a executar `gdb` a partir do diretório de destino ou executar `directory target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/sources`, por exemplo:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1860
#, no-wrap
msgid ""
"(gdb) directory target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/sources\n"
"Source directories searched: /data/target/debugging-native-1.0.0-SNAPSHOT-native-image-source-jar/sources:$cdir:$cwd\n"
"(gdb) list\n"
"164        \tUnsignedWord offset = size;\n"
"165        \twhile (offset.aboveOrEqual(32)) {\n"
"166            \toffset = offset.subtract(32);\n"
"167            \tPointer src = from.add(offset);\n"
"168            \tPointer dst = to.add(offset);\n"
"169            \tlong l24 = src.readLong(24);\n"
"170            \tlong l16 = src.readLong(16);\n"
"171            \tlong l8 = src.readLong(8);\n"
"172            \tlong l0 = src.readLong(0);\n"
"173            \tdst.writeLong(24, l24);\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1867
#, fuzzy
msgid "We can now examine line `169` and get a first hint of what might be wrong (in this case we see that it fails at the first read from src which contains the address `0x0000`), or walk up the stack using `gdb`’s `up` command to see what part of our code led to this situation.  For more information about using `gdb` to debug native executables, see the link:https://www.graalvm.org/latest/reference-manual/native-image/debugging-and-diagnostics/DebugInfo/[GraalVM Debug Info Feature] guide."
msgstr "Podemos agora examinar a linha `169` e obter uma primeira dica do que pode estar errado (neste caso, vemos que ele falha na primeira leitura de src que contém o endereço `0x0000`), ou subir na pilha usando o comando `up` do `gdb`para ver que parte do nosso código levou a essa situação. Para obter mais informações sobre o uso do `gdb` para depurar executáveis nativos, consulte o Guia de  link:https://www.graalvm.org/latest/reference-manual/native-image/debugging-and-diagnostics/DebugInfo/[recursos de informações de depuração do GraalVM]."

#. type: Title ==
#: upstream/_guides/native-reference.adoc:1869
#, fuzzy, no-wrap
msgid "Frequently Asked Questions"
msgstr "Perguntas frequentes"

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1871
#, fuzzy, no-wrap
msgid "Why is the process of generating a native executable slow?"
msgstr "Porque é que o processo de geração de um executável nativo é lento?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1875
#, fuzzy
msgid "Native executable generation is a multi-step process.  The analysis and compile steps are the most expensive of all and hence the ones that dominate the time spent generating the native executable."
msgstr "A geração de um executável nativo é um processo com várias etapas. As etapas de análise e compilação são as mais dispendiosas de todas e, por conseguinte, as que dominam o tempo gasto na geração do executável nativo."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1881
#, fuzzy
msgid "In the analysis phase, a static points-to analysis starts from the main method of the program to find out what is reachable.  As new classes are discovered, some of them will be initialized during this process depending on the configuration.  In the next step, the heap is snapshotted and checks are made to see which types need to be available at runtime.  The initialization and heap snapshotting can cause new types to be discovered, in which case the process is repeated.  The process stops when a fixed point is reached, that is when the reachable program grows no more."
msgstr "Na fase de análise, uma análise estática ponto-a-ponto começa no método principal do programa para descobrir o que é acessível. À medida que novas classes são descobertas, algumas delas serão inicializadas durante esse processo, dependendo da configuração. Na próxima etapa, o heap é capturado e são feitas verificações para ver quais tipos precisam estar disponíveis em tempo de execução. A inicialização e o snapshotting da heap podem fazer com que novos tipos sejam descobertos, caso em que o processo é repetido. O processo pára quando é atingido um ponto fixo, ou seja, quando o programa alcançável não cresce mais."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1883
#, fuzzy
msgid "The compilation step is pretty straightforward, it simply compiles all the reachable code."
msgstr "O passo de compilação é bastante simples, basta compilar todo o código acessível."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1890
#, fuzzy
msgid "The time spent in analysis and compilation phases depends on how big the application is.  The bigger the application, the longer it takes to compile it.  However, there are certain features that can have an exponential effect.  For example, when registering types and methods for reflection access, the analysis can’t easily see what’s behind those types or methods, so it has to do more work to complete the analysis step."
msgstr "O tempo gasto nas fases de análise e compilação depende da dimensão da aplicação. Quanto maior for a aplicação, mais tempo é necessário para a compilar. No entanto, há certas características que podem ter um efeito exponencial. Por exemplo, ao registar tipos e métodos para acesso por reflexão, a análise não consegue ver facilmente o que está por trás desses tipos ou métodos, pelo que tem de trabalhar mais para concluir a etapa de análise."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1891
#, fuzzy, no-wrap
msgid "I get a `AnalysisError\\$ParsingError` when building a native executable due to an `UnresolvedElementException`, what can I do?"
msgstr "Recebo um `AnalysisError\\$ParsingError` ao construir um executável nativo devido a um `UnresolvedElementException`, o que posso fazer?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1896
#, fuzzy
msgid "When building a native executable Quarkus requires all classes being referenced by the code, no matter if they are build-time or run-time initialized, to be present in the classpath.  This way it ensures that there will be no crashes at runtime due to potential `NoClassDefFoundError` exceptions.  To achieve this it makes use of GraalVM's `--link-at-build-time` parameter:"
msgstr "Ao construir um executável nativo, o Quarkus exige que todas as classes referenciadas pelo código, independentemente de serem inicializadas em tempo de construção ou em tempo de execução, estejam presentes no classpath. Desta forma, garante que não haverá falhas em tempo de execução devido a potenciais excepções `NoClassDefFoundError`. Para conseguir isso, ele faz uso do parâmetro `--link-at-build-time` do GraalVM:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:1902
#, no-wrap
msgid ""
"--link-at-build-time  require types to be fully defined at image build-time. If used\n"
"                      without args, all classes in scope of the option are required to\n"
"                      be fully defined.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1906
#, fuzzy
msgid "This, however, may result in an `AnalysisError\\$ParsingError` due to an `UnresolvedElementException` at build time.  This is often caused because the application references a class from an https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html#optional-dependencies[optional dependency]."
msgstr "No entanto, isto pode resultar num `AnalysisError\\$ParsingError` devido a um `UnresolvedElementException` em tempo de construção. Isto deve-se frequentemente ao facto de a aplicação fazer referência a uma classe de uma  link:https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html#optional-dependencies[dependência opcional]."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1908
#, fuzzy
msgid "If you have access to the source code responsible for the reference to the missing dependency and can alter it, you should consider one of the following:"
msgstr "Se o utilizador tiver acesso ao código-fonte responsável pela referência à dependência em falta e puder alterá-lo, deve considerar uma das seguintes opções:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1910
#, fuzzy
msgid "Remove the reference if it's not actually necessary."
msgstr "Remover a referência se não for efetivamente necessária."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1911
#, fuzzy
msgid "Move the affected code in a sub-module and make the dependency non-optional (as is the best practice)."
msgstr "Mova o código afetado para um submódulo e torne a dependência não opcional (como é a melhor prática)."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1912
#, fuzzy
msgid "Make the dependency non-optional."
msgstr "Tornar a dependência não opcional."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1914
#, fuzzy
msgid "In the unfortunate case where the reference causing the issue is made by a 3rd party library, that you cannot modify, you should consider one of the following:"
msgstr "No caso infeliz de a referência que causa o problema ser feita por uma biblioteca de terceiros, que não pode ser modificada, deve considerar uma das seguintes opções:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1916
#, fuzzy
msgid "Use a class/method substitution to remove the said reference."
msgstr "Utilizar uma substituição de classe/método para remover a referida referência."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1917
#, fuzzy
msgid "Add the optional dependency as a non-optional dependency of your project."
msgstr "Adicione a dependência opcional como uma dependência não opcional do seu projeto."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1921
#, fuzzy
msgid "Note that although option (1) is the best choice performance wise, as it minimizes the applications footprint,it might not be trivial to implement.  To make matters worse, it's also not easy to maintain as it is tightly coupled to the 3rd party library implementation.  Option (2) is a straight forward alternative to work around the issue, but comes at the cost of including possibly never invoked code in the resulting native executable."
msgstr "Note-se que, embora a opção (1) seja a melhor escolha em termos de desempenho, uma vez que minimiza a pegada das aplicações, pode não ser trivial de implementar. Para piorar a situação, também não é fácil de manter, pois está fortemente acoplada à implementação da biblioteca de terceiros. A opção (2) é uma alternativa direta para contornar o problema, mas tem o custo de incluir código possivelmente nunca invocado no executável nativo resultante."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1922
#, fuzzy, no-wrap
msgid "I get an `OutOfMemoryError` (OOME) building native executables, what can I do?"
msgstr "Recebo um `OutOfMemoryError` (OOME) a construir executáveis nativos, o que posso fazer?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1934
#, fuzzy
msgid "Building native executables is not only time consuming, but it also takes a fair amount of memory.  For example, building a sample native Quarkus Jakarta Persistence application such as the Hibernate ORM quickstart, may use 6GB to 8GB resident set size in memory.  A big chunk of this memory is Java heap, but extra memory is required for other aspects of the JVM that runs the native building process.  It is still possible to build such applications in environments that have total memory close to the limits, but to do that it is necessary to shrink the maximum heap size of the GraalVM native image process.  To do that, set a maximum heap size using the `quarkus.native.native-image-xmx` property.  For example, we can instruct GraalVM to use 5GB of maximum heap size by passing in `-Dquarkus.native.native-image-xmx=5g` in the command line."
msgstr "A criação de executáveis nativos não só consome tempo, como também consome uma boa quantidade de memória. Por exemplo, a criação de um exemplo de aplicação nativa Quarkus Jakarta Persistence, como o início rápido do Hibernate ORM, pode utilizar 6 GB a 8 GB de tamanho de conjunto residente na memória. Uma grande parte desta memória é o Java heap, mas é necessária memória extra para outros aspectos da JVM que executa o processo de construção nativo. Ainda é possível construir tais aplicativos em ambientes que têm memória total próxima aos limites, mas para isso é necessário reduzir o tamanho máximo do heap do processo de imagem nativa do GraalVM. Para fazer isso, defina um tamanho máximo de heap usando a propriedade `quarkus.native.native-image-xmx`. Por exemplo, podemos instruir o GraalVM a usar 5GB de tamanho máximo de heap, passando `-Dquarkus.native.native-image-xmx=5g` na linha de comando."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1937
#, fuzzy
msgid "Building native executables this way might have the side effect of requiring more time to complete.  This is due to garbage collection having to work harder for native image generation to have free space to do its job."
msgstr "Construir executáveis nativos desta forma pode ter o efeito colateral de exigir mais tempo para ser concluído. Isto deve-se ao facto de a recolha de lixo ter de trabalhar mais para que a geração de imagens nativas tenha espaço livre para fazer o seu trabalho."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1940
#, fuzzy
msgid "Note that typical applications are likely bigger than quickstarts, so the memory requirements will also likely be higher."
msgstr "Note-se que as aplicações típicas são provavelmente maiores do que os arranques rápidos, pelo que os requisitos de memória também serão provavelmente mais elevados."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1941
#, fuzzy, no-wrap
msgid "Why is runtime performance of a native executable inferior compared to JVM mode?"
msgstr "Porque é que o desempenho em tempo de execução de um executável nativo é inferior ao do modo JVM?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1946
#, fuzzy
msgid "As with most things in life there are some trade-offs involved when choosing native compilation over JVM mode.  So depending on the application the runtime performance of a native application might be slower compared to JVM mode, though that’s not always the case."
msgstr "Como acontece com a maioria das coisas na vida, há algumas compensações envolvidas ao escolher a compilação nativa em vez do modo JVM. Assim, dependendo da aplicação, o desempenho em tempo de execução de uma aplicação nativa pode ser mais lento em comparação com o modo JVM, embora nem sempre seja esse o caso."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1952
#, fuzzy
msgid "JVM execution of an application includes runtime optimization of the code that profits from profile information built up during execution.  That includes the opportunities to inline a lot more of the code, locate hot code on direct paths (i.e. ensure better instruction cache locality)  and cut out a lot of the code on cold paths (on the JVM a lot of code does not get compiled until something tries to execute it -- it is replaced with a trap that causes deoptimization and recompilation).  Removal of cold paths provides many more optimization opportunities than are available for ahead of time compilation because it significantly reduces the branch complexity and combinatorial logic of the smaller amount of hot code that is compiled."
msgstr "A execução de uma aplicação na JVM inclui a otimização do código em tempo de execução, que beneficia das informações de perfil obtidas durante a execução. Isso inclui as oportunidades de inlinear muito mais código, localizar código quente em caminhos directos (ou seja, garantir uma melhor localização da cache de instruções) e eliminar muito código em caminhos frios (na JVM, muito código não é compilado até que algo o tente executar - é substituído por uma armadilha que causa a desoptimização e a recompilação). A remoção dos caminhos frios oferece muito mais oportunidades de otimização do que as disponíveis para a compilação antecipada, porque reduz significativamente a complexidade dos ramos e a lógica combinatória da pequena quantidade de código quente que é compilado."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1955
#, fuzzy
msgid "By contrast, native executable compilation has to cater for all possible execution paths when it compiles code offline since it does not know which are the hot or cold paths and cannot use the trick of planting a trap and recompiling if it is hit. For the same reason it cannot load the dice to ensure that code cache conflicts are minimized by co-locating hot paths adjacent.  Native executable generation is able to remove some code because of the closed world hypothesis but that is often not enough to make up for all the benefits that profiling and runtime deopt & recompile provides to the JVM JIT compiler."
msgstr "Em contrapartida, a compilação executável nativa tem de ter em conta todos os caminhos de execução possíveis quando compila código offline, uma vez que não sabe quais são os caminhos quentes ou frios e não pode utilizar o truque de colocar uma armadilha e recompilar se for atingida. Pela mesma razão, não pode carregar os dados para garantir que os conflitos de cache de código são minimizados através da co-localização de caminhos quentes adjacentes. A geração de executáveis nativos é capaz de remover algum código devido à hipótese do mundo fechado, mas isso muitas vezes não é suficiente para compensar todos os benefícios que a criação de perfis e a desopção e recompilação em tempo de execução fornecem ao compilador JVM JIT."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1957
#, fuzzy
msgid "Note, however, that there is a price you pay for that potentially higher JVM speed, and that price is in increased resource usage (both CPU and memory) and startup time because:"
msgstr "Note, no entanto, que há um preço a pagar por essa velocidade potencialmente maior da JVM, e esse preço é o aumento da utilização de recursos (CPU e memória) e do tempo de arranque:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1959
#, fuzzy
msgid "it takes some time before the JIT kicks in and fully optimizes the code."
msgstr "demora algum tempo até que o JIT entre em ação e optimize totalmente o código."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1960
#, fuzzy
msgid "the JIT compiler consumes resources that could be utilized by the application."
msgstr "o compilador JIT consome recursos que poderiam ser utilizados pela aplicação."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1961
#, fuzzy
msgid "the JVM has to retain a lot more metadata and compiler/profiler data to support the better optimizations that it can offer."
msgstr "a JVM tem de reter muito mais metadados e dados do compilador/perfilador para suportar as melhores optimizações que pode oferecer."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1963
#, fuzzy
msgid "The reason for 1) is that code needs to be run interpreted for some time and, possibly, to be compiled several times before all potential optimizations are realized to ensure that:"
msgstr "A razão para 1) é que o código precisa de ser executado interpretado durante algum tempo e, possivelmente, de ser compilado várias vezes antes de todas as potenciais optimizações serem realizadas para garantir isso:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1965
#, fuzzy
msgid "it’s worth compiling that code path, i.e. it’s being executed enough times, and that"
msgstr "vale a pena compilar ganhe esse caminho de código, ou seja, está a ser executado vezes suficientes, e que"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1966
#, fuzzy
msgid "we have enough profiling data to perform meaningful optimizations."
msgstr "temos dados de perfil suficientes para efetuar optimizações significativas."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1969
#, fuzzy
msgid "An implication of 1) is that for small, short-lived applications a native executable may well be a better bet.  Although the compiled code is not as well optimized it is available straight away."
msgstr "Uma implicação de 1) é que, para aplicações pequenas e de curta duração, um executável nativo pode ser uma aposta melhor. Embora o código compilado não seja tão bem optimizado, está disponível de imediato."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1972
#, fuzzy
msgid "The reason for 2) is that the JVM is essentially running the compiler at runtime in parallel with the application itself.  In the case of native executables the compiler is run ahead of time removing the need to run the compiler in parallel with the application."
msgstr "A razão para 2) é que a JVM está essencialmente a executar o compilador em tempo de execução em paralelo com a própria aplicação. No caso de executáveis nativos, o compilador é executado antes do tempo, eliminando a necessidade de executar o compilador em paralelo com a aplicação."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1981
#, fuzzy
msgid "There are several reasons for 3). The JVM does not have a closed world assumption.  So, it has to be able to recompile code if loading of new classes implies that it needs to revise optimistic assumptions made at compile time.  For example, if an interface has only one implementation it can make a call jump directly to that code.  However, in the case where a second implementation class is loaded the call site needs to be patched to test the type of the receiver instance and jump to the code that belongs to its class.  Supporting optimizations like this one requires keeping track of a lot more details of the class base than a native executable, including recording the full class and interface hierarchy, details of which methods override other methods, all method bytecode etc.  In a native executable most of the details of class structure and bytecode can be ignored at run time."
msgstr "Existem várias razões para 3). A JVM não tem um pressuposto de mundo fechado. Assim, tem de ser capaz de recompilar o código se o carregamento de novas classes implicar a necessidade de rever os pressupostos optimistas feitos em tempo de compilação. Por exemplo, se uma interface tiver apenas uma implementação, pode fazer uma chamada diretamente para esse código. No entanto, no caso em que uma segunda classe de implementação é carregada, o local de chamada precisa de ser corrigido para testar o tipo da instância recetora e saltar para o código que pertence à sua classe. O suporte de optimizações como esta requer o registo de muito mais detalhes da base da classe do que um executável nativo, incluindo a gravação de toda a hierarquia de classes e interfaces, detalhes de quais os métodos que substituem outros métodos, todo o bytecode do método, etc. Num executável nativo, a maioria dos detalhes da estrutura da classe e do bytecode pode ser ignorada em tempo de execução."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1986
#, fuzzy
msgid "The JVM also has to cope with changes to the class base or execution profiles that result in a thread going down a previously cold path.  At that point the JVM has to jump out of the compiled code into the interpreter and recompile the code to cater for a new execution profile that includes the previously cold path.  That requires keeping runtime info that allow a compiled stack frame to be replaced with one or more interpreter frames.  It also requires runtime extensible profile counters to be allocated and updated to track what has or has not been executed."
msgstr "A JVM também tem de lidar com as alterações à base de classes ou aos perfis de execução que resultam num thread a percorrer um caminho anteriormente frio. Nesse momento, a JVM tem de saltar do código compilado para o interpretador e recompilar o código para atender a um novo perfil de execução que inclui o caminho anteriormente frio. Isso requer a manutenção de informações de tempo de execução que permitam que um stack frame compilado seja substituído por um ou mais frames de interpretador. Também requer que contadores de perfil extensíveis em tempo de execução sejam alocados e atualizados para rastrear o que foi ou não foi executado."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:1987
#, fuzzy, no-wrap
msgid "Why are native executables “big”?"
msgstr "Porque é que os executáveis nativos são \"grandes\"?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1990
#, fuzzy
msgid "This can be attributed to a number of different reasons:"
msgstr "Este facto pode ser atribuído a uma série de razões diferentes:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:1996
#, fuzzy
msgid "Native executables include not only the application code but also, library code, and JDK code.  As a result a more fair comparison would be to compare the native executable’s size with the size of the application, plus the size of the libraries it uses, plus the size of the JDK.  Especially the JDK part is not negligible even in simple applications like HelloWorld.  To get a glance on what is being pulled in the image one can use `-H:+PrintUniverse` when building the native executable."
msgstr "Os executáveis nativos incluem não só o código da aplicação, mas também o código da biblioteca e o código do JDK. Como resultado, uma comparação mais justa seria comparar o tamanho do executável nativo com o tamanho da aplicação, mais o tamanho das bibliotecas que utiliza, mais o tamanho do JDK. Especialmente a parte do JDK não é desprezível, mesmo em aplicações simples como o HelloWorld. Para ter uma ideia do que está a ser puxado na imagem, pode usar-se `-H:+PrintUniverse` ao construir o executável nativo."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2002
#, fuzzy
msgid "Some features are always included in a native executable even though they might never be actually used at run time.  An example of such a feature is garbage collection.  At compile time we can’t be sure whether an application will need to run garbage collection at run time, so garbage collection is always included in native executables increasing their size even if not necessary.  Native executable generation relies on static code analysis to identify which code paths are reachable, and static code analysis can be imprecise leading to more code getting into the image than what’s actually needed."
msgstr "Algumas funcionalidades são sempre incluídas num executável nativo, embora possam nunca ser efetivamente utilizadas em tempo de execução. Um exemplo de tal caraterística é a recolha de lixo. No momento da compilação, não podemos ter a certeza de que uma aplicação necessitará de executar a recolha de lixo em tempo de execução, pelo que a recolha de lixo é sempre incluída nos executáveis nativos, aumentando o seu tamanho mesmo que não seja necessária. A geração de executáveis nativos depende da análise de código estático para identificar quais os caminhos de código que são acessíveis, e a análise de código estático pode ser imprecisa, levando a que mais código entre na imagem do que o que é realmente necessário."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2005
#, fuzzy
msgid "There is a https://github.com/oracle/graal/issues/287[GraalVM upstream issue] with some interesting discussions about that topic."
msgstr "Há uma  link:https://github.com/oracle/graal/issues/287[edição do GraalVM upstream] com algumas discussões interessantes sobre esse tópico."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2006
#, fuzzy, no-wrap
msgid "What version of Mandrel was used to generate a binary?"
msgstr "Que versão do Mandrel foi utilizada para gerar um binário?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2009
#, fuzzy
msgid "One can see which Mandrel version was used to generate a binary by inspecting the binary as follows:"
msgstr "É possível ver que versão do Mandrel foi utilizada para gerar um binário, inspeccionando o binário da seguinte forma:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2014
#, no-wrap
msgid ""
"$ strings target/debugging-native-1.0.0-SNAPSHOT-runner | grep GraalVM\n"
"com.oracle.svm.core.VM=GraalVM 22.0.0.2-Final Java 11 Mandrel Distribution\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2016
#, fuzzy, no-wrap
msgid "How do I enable GC logging in native executables?"
msgstr "Como posso ativar o registo de GC em executáveis nativos?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2019
#, fuzzy
msgid "See xref:gc-logging[Native Memory Management GC Logging section] for details."
msgstr "Consulte a  link:#gc-logging[secção Registo de GC de gestão de memória nativa] para obter mais informações."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2021
#, fuzzy, no-wrap
msgid "Can I get a heap dump of a native executable? e.g. if it runs out of memory"
msgstr "Posso obter um heap dump de um executável nativo? por exemplo, se ele ficar sem memória"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2026
#, fuzzy
msgid "Starting with GraalVM 22.2.0 it is possible to create heap dumps upon request, e.g. `kill -SIGUSR1 <pid>`.  Support for dumping the heap dump upon an out of memory error will follow up."
msgstr "A partir do GraalVM 22.2.0 é possível criar despejos de heap mediante solicitação, por exemplo, `kill -SIGUSR1 &amp;lt;pid&amp;gt;`. O suporte para despejar o despejo de heap após um erro de falta de memória será seguido."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2027
#, fuzzy, no-wrap
msgid "Can I build and run this examples outside a container in Linux?"
msgstr "Posso construir e executar estes exemplos fora de um contentor no Linux?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2033
#, fuzzy
msgid "Yes you can.  In fact, debugging native executables on a Linux bare metal box offers the best possible experience.  In this kind of environments, root access is not needed except to install packages required to run some debug steps, or to enable `perf` to gather events at the kernel."
msgstr "Sim, é possível. De facto, a depuração de executáveis nativos numa caixa Linux bare metal oferece a melhor experiência possível. Neste tipo de ambientes, o acesso root não é necessário, exceto para instalar pacotes necessários para executar alguns passos de depuração, ou para ativar `perf` para recolher eventos no kernel."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2035
#, fuzzy
msgid "These are the packages you'll need on your Linux environment to run through the different debugging sections:"
msgstr "Estes são os pacotes de que necessitará no seu ambiente Linux para executar as diferentes secções de depuração:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2042
#, no-wrap
msgid ""
"# dnf (rpm-based)\n"
"sudo dnf install binutils gdb perf perl-open\n"
"# Debian-based distributions:\n"
"sudo apt install binutils gdb perf\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2044
#, fuzzy, no-wrap
msgid "Generating flame graphs is slow, or produces errors, what can I do?"
msgstr "A geração de gráficos de chama é lenta ou produz erros, o que posso fazer?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2048
#, fuzzy
msgid "There are multiple ways in which a native executable produced by Mandrel can be profiled.  All the methods require you to pass in the `-H:-DeleteLocalSymbols` option."
msgstr "Há várias maneiras de traçar o perfil de um executável nativo produzido pelo Mandrel. Todos os métodos exigem que você passe a opção `-H:-DeleteLocalSymbols`."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2052
#, fuzzy
msgid "The method shown in this reference guide generates a binary with DWARF debug information, runs it via `perf record` and then uses `perf script` and flame graph tooling to generate the flamegraphs.  However, the `perf script` post-processing step done on this binary can appear to be slow or can show some DWARF errors."
msgstr "O método apresentado neste guia de referência gera um binário com informações de depuração DWARF, executa-o através de `perf record` e, em seguida, utiliza `perf script` e as ferramentas de gráficos de chama para gerar os gráficos de chama. No entanto, a etapa de pós-processamento `perf script` feita neste binário pode parecer lenta ou pode mostrar alguns erros DWARF."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2057
#, fuzzy
msgid "An alternative method to generate flame graphs is to pass in `-H:+PreserveFramePointer` when generating the native executable instead of generating the DWARF debug information.  It instructs the binary to use an extra register for the frame pointer.  This enables `perf` to do stack walking to profile the runtime behaviour.  To generate the native executable using these flags, do the following:"
msgstr "Um método alternativo para gerar gráficos de chamas é passar em `-H:+PreserveFramePointer` ao gerar o executável nativo em vez de gerar as informações de depuração DWARF. Este instrui o binário a utilizar um registo extra para o ponteiro da moldura. Isto permite a `perf` fazer stack walking para traçar o perfil do comportamento em tempo de execução. Para gerar o executável nativo usando esses sinalizadores, faça o seguinte:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2062
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative\n"
"    -Dquarkus.native.additional-build-args=-H:+PreserveFramePointer,-H:-DeleteLocalSymbols\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2065
#, fuzzy
msgid "To get runtime profiling information out of the native executable, simply do:"
msgstr "Para obter informações de criação de perfil em tempo de execução a partir do executável nativo, basta fazer:"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2073
#, fuzzy
msgid "The recommended method for generating runtime profiling information is using the debug information rather than generating a binary that preserves the frame pointer.  This is because adding debug information to the native executable build process has no negative runtime performance whereas preserving the frame pointer does."
msgstr "O método recomendado para gerar informações de criação de perfil em tempo de execução é usar as informações de depuração em vez de gerar um binário que preserva o ponteiro de quadro. Isto deve-se ao facto de a adição de informações de depuração ao processo de construção do executável nativo não ter um desempenho negativo em tempo de execução, ao passo que a preservação do ponteiro de fotogramas tem."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2079
#, fuzzy
msgid "DWARF debug info is generated in a separate file and can even be omitted in the default deployment and only be transferred and used on demand, for profiling or debugging purposes.  Furthermore, the presence of debug info enables `perf` to show us the relevant source code lines as well, hence it does not bloat the native executable itself.  To do that, simply call `perf report` with an extra parameter to show source code lines:"
msgstr "As informações de depuração DWARF são geradas num ficheiro separado e podem até ser omitidas na implementação predefinida, sendo apenas transferidas e utilizadas a pedido, para efeitos de criação de perfis ou depuração. Além disso, a presença de informações de depuração permite que o `perf` nos mostre também as linhas de código-fonte relevantes, pelo que não incha o próprio executável nativo. Para o fazer, basta chamar `perf report` com um parâmetro extra para mostrar as linhas de código-fonte:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2089
#, no-wrap
msgid ""
"perf report --stdio -F+srcline\n"
"...\n"
"83.69%     0.00%  GreetingResource.java:20 ...\n"
"...\n"
"83.69%     0.00%  AbstractStringBuilder.java:1025 ...\n"
"...\n"
"83.69%     0.00%  ArraycopySnippets.java:95 ...\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2095
#, fuzzy
msgid "The performance penalty of preserving the frame pointer is due to using the extra register for stack walking, particularly in `x86_64` compared to `aarch64` where there are fewer registers available.  Using this extra register reduces the number of registers that are available for other work, which can lead to performance penalties."
msgstr "A desvantagem de desempenho de preservar o ponteiro da moldura deve-se à utilização do registo extra para percorrer a pilha, particularmente em `x86_64` em comparação com `aarch64`, onde há menos registos disponíveis. A utilização deste registo extra reduz o número de registos disponíveis para outros trabalhos, o que pode levar a penalizações no desempenho."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2096
#, fuzzy, no-wrap
msgid "I think I’ve found a bug in native-image, how can I debug it with the IDE?"
msgstr "Acho que encontrei um erro na native-image, como é que o posso depurar com o IDE?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2100
#, fuzzy
msgid "Although it is possible to remote debug processes within containers, it might be easier to step-by-step debug native-image by installing Mandrel locally and adding it to the path of the shell process."
msgstr "Embora seja possível depurar remotamente processos dentro de containers, pode ser mais fácil depurar passo a passo a imagem nativa instalando o Mandrel localmente e adicionando-o ao caminho do processo do shell."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2105
#, fuzzy
msgid "Native executable generation is the result of two Java processes that are executed sequentially.  The first process is very short and its main job is to set things up for the second process.  The second process is the one that takes care of most of the work.  The steps to debug one process or the other vary slightly."
msgstr "A geração de executáveis nativos é o resultado de dois processos Java que são executados sequencialmente. O primeiro processo é muito curto e sua principal função é preparar as coisas para o segundo processo. O segundo processo é o que cuida da maior parte do trabalho. Os passos para depurar um processo ou o outro variam ligeiramente."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2110
#, fuzzy
msgid "Let’s discuss first how to debug the second process, which is the one you most likely to want to debug.  The starting point for the second process is the `com.oracle.svm.hosted.NativeImageGeneratorRunner` class.  To debug this process, simply add `--debug-attach=*:8000` as an additional build time argument:"
msgstr "Vamos discutir primeiro como depurar o segundo processo, que é o mais provável de querer depurar. O ponto de partida para o segundo processo é a classe `com.oracle.svm.hosted.NativeImageGeneratorRunner`. Para depurar esse processo, basta adicionar `--debug-attach=*:8000` como um argumento adicional de tempo de compilação:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2115
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=--debug-attach=*:8000\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2121
#, fuzzy
msgid "The starting point for the first process is the `com.oracle.svm.driver.NativeImages` class.  In GraalVM CE distributions, this first process is a binary, so debugging it in the traditional way with a Java IDE is not possible.  However, Mandrel distributions (or locally built GraalVM CE instances) keep this as a normal Java process, so you can remote debug this process by adding the `--vm.agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:8000` as an additional build argument, e.g."
msgstr "O ponto de partida para o primeiro processo é a classe `com.oracle.svm.driver.NativeImages`. Nas distribuições do GraalVM CE, este primeiro processo é um binário, então depurá-lo da maneira tradicional com um IDE Java não é possível. No entanto, as distribuições Mandrel (ou instâncias do GraalVM CE construídas localmente) mantêm esse processo como um processo Java normal, então é possível depurar esse processo remotamente adicionando o `--vm.agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:8000` como um argumento de construção adicional, por exemplo"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2126
#, no-wrap
msgid ""
"$ ./mvnw package -DskipTests -Dnative \\\n"
"    -Dquarkus.native.additional-build-args=--vm.agentlib:jdwp=transport=dt_socket\\\\,server=y\\\\,suspend=y\\\\,address=*:8000\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2128
#, fuzzy, no-wrap
msgid "Can I use JFR/JMC to debug or profile native binaries?"
msgstr "Posso usar o JFR/JMC para depurar ou traçar o perfil de binários nativos?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2137
#, fuzzy
msgid "https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH170[Java Flight Recorder (JFR)] and https://www.oracle.com/java/technologies/jdk-mission-control.html[JDK Mission Control (JMC)] can be used to profile native binaries since GraalVM CE 21.2.0.  However, JFR in GraalVM is currently limited in capabilities compared to HotSpot.  The custom event API is fully supported, but some VM level features are unavailable.  More events and JFR features will continue to be added in later releases.  The following table outlines Native Image JFR support and limitations by version."
msgstr "O  link:https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH170[Java Flight Recorder (JFR)] e o  link:https://www.oracle.com/java/technologies/jdk-mission-control.html[JDK Mission Control (JMC)] podem ser usados para traçar o perfil de binários nativos desde o GraalVM CE 21.2.0. No entanto, o JFR no GraalVM é atualmente limitado em recursos comparado ao HotSpot. A API de eventos personalizados é totalmente suportada, mas alguns recursos de nível de VM não estão disponíveis. Mais eventos e recursos JFR continuarão a ser adicionados em versões posteriores. A tabela a seguir descreve o suporte e as limitações do JFR da imagem nativa por versão."

#. type: Table
#: upstream/_guides/native-reference.adoc:2140
#, fuzzy, no-wrap
msgid "GraalVM Version"
msgstr "Versão do GraalVM"

#. type: Table
#: upstream/_guides/native-reference.adoc:2140
#, fuzzy, no-wrap
msgid "Supports"
msgstr "Apoios"

#. type: Table
#: upstream/_guides/native-reference.adoc:2142
#, fuzzy, no-wrap
msgid "Limitations"
msgstr "Limitações"

#. type: Table
#: upstream/_guides/native-reference.adoc:2143
#, fuzzy, no-wrap
msgid "GraalVM CE 21.3 and Mandrel 21.3"
msgstr "GraalVM CE 21.3 e Mandrel 21.3"

#. type: Bullet: '* '
#: upstream/_guides/native-reference.adoc:2146
#, fuzzy
msgid "Minimal VM Level events"
msgstr "Eventos mínimos de nível VM"

#. type: Bullet: '* '
#: upstream/_guides/native-reference.adoc:2146
#, fuzzy
msgid "Custom events API"
msgstr "API de eventos personalizados"

#. type: Table
#: upstream/_guides/native-reference.adoc:2146
#, fuzzy, no-wrap
msgid "* Start recordings upon executabe run or JFR Recording API"
msgstr "<li> <p>Iniciar gravações após a execução do executável ou da API de gravação JFR</p> </li>"

#. type: Bullet: '* '
#: upstream/_guides/native-reference.adoc:2151
#: upstream/_guides/native-reference.adoc:2158
#, fuzzy
msgid "No old object sampling"
msgstr "Sem amostragem de objectos antigos"

#. type: Bullet: '* '
#: upstream/_guides/native-reference.adoc:2151
#: upstream/_guides/native-reference.adoc:2158
#, fuzzy
msgid "No stacktrace tracing"
msgstr "Sem rastreio de stacktrace"

#. type: Table
#: upstream/_guides/native-reference.adoc:2151
#: upstream/_guides/native-reference.adoc:2158
#, fuzzy, no-wrap
msgid "* No event streaming"
msgstr "<li> <p>Não há transmissão de eventos</p> </li>"

#. type: Table
#: upstream/_guides/native-reference.adoc:2152
#, fuzzy, no-wrap
msgid "GraalVM CE 22.3 and Mandrel 22.3"
msgstr "GraalVM CE 22.3 e Mandrel 22.3"

#. type: Bullet: '* '
#: upstream/_guides/native-reference.adoc:2154
#, fuzzy
msgid "Everything from GraalVM CE 21.3"
msgstr "Tudo a partir do GraalVM CE 21.3"

#. type: Table
#: upstream/_guides/native-reference.adoc:2154
#, fuzzy, no-wrap
msgid "* Additional monitor and thread events"
msgstr "<li> <p>Eventos adicionais do monitor e da linha</p> </li>"

#. type: Table
#: upstream/_guides/native-reference.adoc:2159
#, fuzzy, no-wrap
msgid "GraalVM CE for JDK 17/20 and Mandrel 23.0"
msgstr "GraalVM CE para JDK 17/20 e Mandrel 23.0"

#. type: Bullet: '* '
#: upstream/_guides/native-reference.adoc:2164
#, fuzzy
msgid "Everything from GraalVM CE 22.3"
msgstr "Tudo a partir do GraalVM CE 22.3"

#. type: Bullet: '* '
#: upstream/_guides/native-reference.adoc:2164
#, fuzzy
msgid "Additional monitor, thread, container, and allocation events"
msgstr "Eventos adicionais de monitor, thread, contentor e atribuição"

#. type: Bullet: '* '
#: upstream/_guides/native-reference.adoc:2164
#, fuzzy
msgid "Stacktraces"
msgstr "Rastreios de pilha"

#. type: Bullet: '* '
#: upstream/_guides/native-reference.adoc:2164
#, fuzzy
msgid "Sampling based method profiling"
msgstr "Perfilagem por método de amostragem"

#. type: Table
#: upstream/_guides/native-reference.adoc:2164
#, fuzzy, no-wrap
msgid "* Event streaming"
msgstr "<li> <p>Transmissão de eventos</p> </li>"

#. type: Table
#: upstream/_guides/native-reference.adoc:2166
#, fuzzy, no-wrap
msgid "* No old object sampling"
msgstr "<li> <p>Sem amostragem de objectos antigos</p> </li>"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2171
#, fuzzy
msgid "To add JFR support to your Quarkus executable, add the application property: `-Dquarkus.native.monitoring=jfr`.  E.g."
msgstr "Para adicionar o suporte JFR ao seu executável Quarkus, adicione a propriedade da aplicação: `-Dquarkus.native.monitoring=jfr`. Por exemplo."

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2177
#, no-wrap
msgid ""
"./mvnw package -DskipTests -Dnative -Dquarkus.native.container-build=true \\\n"
"    -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel-builder-image:{mandrel-flavor} \\\n"
"    -Dquarkus.native.monitoring=jfr\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2180
#, fuzzy
msgid "Once the image is compiled, enable and start JFR via runtime flags: `-XX:+FlightRecorder` and `-XX:StartFlightRecording`. For example:"
msgstr "Uma vez compilada a imagem, ativar e iniciar o JFR através das flags de tempo de execução: `-XX:+FlightRecorder` e `-XX:StartFlightRecording`. Por exemplo:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2186
#, no-wrap
msgid ""
"./target/debugging-native-1.0.0-SNAPSHOT-runner \\\n"
"    -XX:+FlightRecorder \\\n"
"    -XX:StartFlightRecording=\"filename=recording.jfr\"\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2189
#, fuzzy
msgid "For more information about using JFR, see the link:https://www.graalvm.org/latest/reference-manual/native-image/debugging-and-diagnostics/JFR/[GraalVM JDK Flight Recorder (JFR) with Native Image] guide."
msgstr "Para obter mais informações sobre a utilização do JFR, consulte o guia  link:https://www.graalvm.org/latest/reference-manual/native-image/debugging-and-diagnostics/JFR/[GraalVM JDK Flight Recorder (JFR) with Native Image]."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2190
#, fuzzy, no-wrap
msgid "How can we troubleshoot performance problems only reproducible in production?"
msgstr "Como podemos resolver problemas de desempenho que só podem ser reproduzidos na produção?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2200
#, fuzzy
msgid "In this situation, switching to JVM mode would be the best thing to try first.  If the performance issues continue after switching to JVM mode, you can use more established and mature tooling to figure out the root cause.  If the performance issue is limited to native mode only, you might not be able to use `perf`, so JFR is the only way to gather any information in this situation.  As JFR support for native expands, the ability to detect root causes of performance issues directly in production will improve."
msgstr "Nesta situação, mudar para o modo JVM seria a melhor coisa a tentar primeiro. Se os problemas de desempenho continuarem após a mudança para o modo JVM, você pode usar ferramentas mais estabelecidas e maduras para descobrir a causa raiz. Se o problema de desempenho estiver limitado apenas ao modo nativo, talvez não seja possível usar `perf`, portanto, o JFR é a única maneira de coletar qualquer informação nessa situação. À medida que o suporte do JFR para o modo nativo se expande, a capacidade de detetar as causas principais dos problemas de desempenho diretamente na produção irá melhorar."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2201
#, fuzzy, no-wrap
msgid "What information helps most debug issues that happen either at build-time or run-time?"
msgstr "Que informações ajudam mais a depurar problemas que ocorrem em tempo de compilação ou em tempo de execução?"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2205
#, fuzzy
msgid "To fix classpath, class initialization or forbidden API errors at build time it's best to use xref:native-reports[build time reports] to understand the closed world universe.  A complete picture of the universe, along with the relationships between the different classes and methods will help uncover and fix most of the issues."
msgstr "Para corrigir erros de classpath, inicialização de classe ou API proibida em tempo de compilação, é melhor usar  link:#native-reports[relatórios de tempo de compilação] para entender o universo do mundo fechado. Uma imagem completa do universo, juntamente com as relações entre as diferentes classes e métodos, ajudará a descobrir e corrigir a maioria dos problemas."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2211
#, fuzzy
msgid "To fix runtime native specific errors, it's best to have xref:debug-info[debug info builds] of the native executables around, so that `gdb` can be hooked up quickly to debug the issue.  If you also add local symbols to the debug info builds, you will obtain precise xref:profiling[profiling information] as well."
msgstr "Para corrigir erros específicos nativos de tempo de execução, é melhor ter  link:#debug-info[compilações de informações] de depuração dos executáveis nativos, de modo que `gdb` possa ser conectado rapidamente para depurar o problema. Se também adicionar símbolos locais às compilações de informações de depuração, também obterá  link:#profiling[informações] precisas  link:#profiling[de criação de perfil]."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2212
#, fuzzy, no-wrap
msgid "Build stalled for minutes, barely using any CPU"
msgstr "A compilação ficou parada por minutos, quase não usando nenhuma CPU"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2215
#, fuzzy
msgid "It might so happen that the build gets stalled and even ends up with:"
msgstr "Pode acontecer que a compilação fique bloqueada e acabe mesmo por ser interrompida:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2219
#, no-wrap
msgid "Image generator watchdog detected no activity.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2222
#, fuzzy
msgid "One of the possible explanations could be a lack of entropy, e.g. on an entropy constrained VM, if such a source is needed as it is the case with Bouncycastle at build time."
msgstr "Uma das explicações possíveis pode ser a falta de entropia, por exemplo, numa VM com restrições de entropia, se tal fonte for necessária, como é o caso do Bouncycastle na altura da construção."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2224
#, fuzzy
msgid "One can check the available entropy on a Linux system with:"
msgstr "É possível verificar a entropia disponível num sistema Linux com:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2228
#, no-wrap
msgid "$ cat /proc/sys/kernel/random/entropy_avail\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2230
#, fuzzy
msgid "If the amount is not in hundreds, it could be a problem. A possible workaround is to compromise, acceptable for testing, and set:"
msgstr "Se o valor não estiver em centenas, isso pode ser um problema. Uma possível solução alternativa é comprometer-se, aceitável para testes, e definir:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2233
#, no-wrap
msgid "export JAVA_OPTS=-Djava.security.egd=/dev/urandom\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2235
#, fuzzy
msgid "The proper solution is to increase the entropy available for the system. That is specific for each OS vendor and virtualization solution though."
msgstr "A solução adequada é aumentar a entropia disponível para o sistema. No entanto, isso é específico para cada fornecedor de SO e solução de virtualização."

#. type: Title ===
#: upstream/_guides/native-reference.adoc:2236
#, fuzzy, no-wrap
msgid "Work around missing CPU features"
msgstr "Contornar funcionalidades da CPU em falta"

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2239
#, fuzzy
msgid "When building on recent machines and running your native executable on older machines, you may see the following failure when starting the application:"
msgstr "Ao construir em máquinas recentes e executar o seu executável nativo em máquinas mais antigas, poderá ver a seguinte falha ao iniciar a aplicação:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2244
#, no-wrap
msgid ""
"The current machine does not support all of the following CPU features that are required by the image: [CX8, CMOV, FXSR, MMX, SSE, SSE2, SSE3, SSSE3, SSE4_1, SSE4_2, POPCNT, LZCNT, AVX, AVX2, BMI1, BMI2, FMA].\n"
"Please rebuild the executable with an appropriate setting of the -march option.\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2248
#, fuzzy
msgid "This error message means that the native compilation used more advanced instruction sets, not supported by the CPU running the application.  To work around that issue, add the following line to the `application.properties`:"
msgstr "Esta mensagem de erro significa que a compilação nativa utilizou conjuntos de instruções mais avançados, não suportados pela CPU que está a executar a aplicação. Para contornar esse problema, adicione a seguinte linha ao `application.properties`:"

#. type: delimited block -
#: upstream/_guides/native-reference.adoc:2252
#, no-wrap
msgid "quarkus.native.additional-build-args=-march=compatibility\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2256
#, fuzzy
msgid "Then, rebuild your native executable.  This setting forces the native compilation to use an older instruction set, increasing the chance of compatibility."
msgstr "Em seguida, reconstrua o executável nativo. Esta definição força a compilação nativa a utilizar um conjunto de instruções mais antigo, aumentando a probabilidade de compatibilidade."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2259
#, fuzzy
msgid "To explicitly define the target architecture run `native-image -march=list` to get the supported configurations and then set `-march` to one of them, e.g., `quarkus.native.additional-build-args=-march=x86-64-v4`.  If you are targeting an AMD64 host, `-march=x86-64-v2` would work in most cases."
msgstr "Para definir explicitamente a arquitetura alvo, execute `native-image -march=list` para obter as configurações suportadas e depois defina `-march` para uma delas, por exemplo, `quarkus.native.additional-build-args=-march=x86-64-v4`. Se estiver a visar um anfitrião AMD64, `-march=x86-64-v2` funcionará na maioria dos casos."

#. type: Plain text
#: upstream/_guides/native-reference.adoc:2260
#, fuzzy
msgid "The `march` parameter is only available on GraalVM 23+."
msgstr "O parâmetro `march` só está disponível no GraalVM 23+."
