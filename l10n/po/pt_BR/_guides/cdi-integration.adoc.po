# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-09-21 08:24+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/cdi-integration.adoc:6
#, fuzzy, no-wrap
msgid "CDI Integration Guide"
msgstr "Guia de integração CDI"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:17
#, fuzzy
msgid "ArC, the CDI container in Quarkus, is bootstrapped at build time.  To integrate with the container, https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#spi_lite[CDI Build Compatible Extensions, window=\"_blank\"] can be used, as well as a Quarkus-specific extension API.  CDI Portable Extensions are not and cannot be supported.  This guide focuses on the Quarkus-specific extensions API."
msgstr "O ArC, o contentor CDI no Quarkus, é iniciado no momento da construção. Para integrar com o contentor, podem ser utilizadas  link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#spi_lite[extensões compatíveis com a compilação CDI, window=_blank], bem como uma API de extensão específica do Quarkus. As Extensões Portáteis CDI não são e não podem ser suportadas. Este guia concentra-se na API de extensões específica do Quarkus."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:20
#, fuzzy
msgid "The container is bootstrapped in multiple phases.  From a high level perspective these phases go as follows:"
msgstr "O contentor é inicializado em várias fases. Numa perspetiva de alto nível, estas fases são as seguintes:"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:22
#, fuzzy
msgid "Initialization"
msgstr "Inicialização"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:23
#, fuzzy
msgid "Bean discovery"
msgstr "Descoberta do feijão"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:24
#, fuzzy
msgid "Registration of synthetic components"
msgstr "Registo de componentes sintéticos"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:25
#, fuzzy
msgid "Validation"
msgstr "Validação"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:32
#, fuzzy
msgid "In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.  _Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.  Subsequently, the extensions can register _synthetic components_.  Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.  Finally, the _deployment is validated_.  For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers."
msgstr "Na fase _de inicialização_, é efectuado o trabalho preparatório e são registados os contextos personalizados. _A descoberta de beans_ é então o processo em que o contentor analisa todas as classes da aplicação, identifica beans e liga-os com base nos metadados fornecidos. Posteriormente, as extensões podem registar _componentes sintéticos_. Os atributos destes componentes são totalmente controlados pelas extensões, ou seja, não são derivados de uma classe existente. Por fim, a _implantação é validada_. Por exemplo, o contentor valida todos os pontos de injeção na aplicação e falha a construção se não houver um bean que satisfaça o tipo e os qualificadores exigidos."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:34
#, fuzzy
msgid "You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X` or `--debug` and grep the lines that contain `io.quarkus.arc`. In the xref:cdi-reference.adoc#dev-mode[development mode], you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format."
msgstr "Pode ver mais informações sobre o bootstrap activando o registo adicional. Basta executar a compilação do Maven com `-X` ou `--debug` e procurar as linhas que contêm `io.quarkus.arc`. No  link:cdi-reference.html#dev-mode[modo de desenvolvimento], você pode usar `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` e dois pontos de extremidade especiais também são registrados automaticamente para fornecer algumas informações básicas de depuração no formato JSON."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:37
#, fuzzy
msgid "Quarkus build steps can produce and consume various build items and hook into each phase.  In the following sections we will describe all the relevant build items and common scenarios."
msgstr "Os passos de construção do Quarkus podem produzir e consumir vários itens de construção e ligar-se a cada fase. Nas secções seguintes, descreveremos todos os itens de construção relevantes e cenários comuns."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:38
#, fuzzy, no-wrap
msgid "Metadata Sources"
msgstr "Fontes de metadados"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:45
#, fuzzy
msgid "Classes and annotations are the primary source of bean-level metadata.  The initial metadata are read from the _bean archive index_, an immutable https://github.com/wildfly/jandex[Jandex index, window=\"_blank\"] which is built from various sources during xref:cdi-reference.adoc#bean_discovery[bean discovery].  However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.  Moreover, extensions can also register xref:synthetic_beans[synthetic components].  This is an important aspect to realize when integrating CDI components in Quarkus."
msgstr "As classes e anotações são a principal fonte de metadados ao nível do bean. Os metadados iniciais são lidos a partir do _índice do arquivo do bean_, um  link:https://github.com/wildfly/jandex[índice Jandex, window=_blank] imutável que é construído a partir de várias fontes durante a  link:cdi-reference.html#bean_discovery[descoberta do bean]. No entanto, as extensões podem adicionar, remover ou transformar os metadados em determinadas fases do bootstrap. Além disso, as extensões também podem registar  link:#synthetic_beans[componentes sintéticos]. Trata-se de um aspeto importante a ter em conta aquando da integração de componentes CDI no Quarkus."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:48
#, fuzzy
msgid "This way, extensions can turn classes, that would be otherwise ignored, into beans and vice versa.  For example, a class that declares a `@Scheduled` method is always registered as a bean even if it is not annotated with a bean defining annotation and would be normally ignored."
msgstr "Desta forma, as extensões podem transformar classes, que de outra forma seriam ignoradas, em beans e vice-versa. Por exemplo, uma classe que declare um método `@Scheduled` é sempre registada como um bean, mesmo que não esteja anotada com uma anotação de definição de bean e seja normalmente ignorada."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:52
#, fuzzy, no-wrap
msgid "Use Case - My Class Is Not Recognized as a Bean"
msgstr "Caso de uso - Minha classe não é reconhecida como um Bean"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:58
#, fuzzy
msgid "An `UnsatisfiedResolutionException` indicates a problem during xref:cdi.adoc#typesafe_resolution[typesafe resolution].  Sometimes an injection point cannot be satisfied even if there is a class on the classpath that appears to be eligible for injection.  There are several reasons why a class is not recognized and also several ways to fix it.  In the first step we should identify the _reason_."
msgstr "Um `UnsatisfiedResolutionException` indica um problema durante a  link:cdi.html#typesafe_resolution[resolução typesafe]. Por vezes, um ponto de injeção não pode ser satisfeito mesmo que exista uma classe no classpath que pareça ser elegível para injeção. Há várias razões pelas quais uma classe não é reconhecida e também várias maneiras de corrigi-la. No primeiro passo, devemos identificar o _motivo_."

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:60
#, fuzzy, no-wrap
msgid "_Reason 1_: Class Is Not discovered "
msgstr "_Razão 1_: A turma não está descoberta"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:65
#, fuzzy
msgid "Quarkus has a xref:cdi-reference.adoc#bean_discovery[simplified discovery].  It might happen that the class is not part of the application index.  For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically."
msgstr "O Quarkus tem uma  link:cdi-reference.html#bean_discovery[descoberta simplificada]. Pode acontecer que a classe não faça parte do índice da aplicação. Por exemplo, as classes do _módulo de tempo de execução_ de uma extensão Quarkus não são indexadas automaticamente."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:69
#, fuzzy
msgid "_Solution_: Use the `AdditionalBeanBuildItem`.  This build item can be used to specify one or more additional classes to be analyzed during the discovery.  Additional bean classes are transparently added to the application index processed by the container."
msgstr "_Solução_: Use o `AdditionalBeanBuildItem`. Esse item de compilação pode ser usado para especificar uma ou mais classes adicionais a serem analisadas durante a descoberta. As classes de bean adicionais são adicionadas de forma transparente ao índice da aplicação processado pelo contentor."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:71
#, fuzzy
msgid "It is not possible to conditionally enable/disable additional beans via the `@IfBuildProfile`, `@UnlessBuildProfile`, `@IfBuildProperty` and `@UnlessBuildProperty` annotations as described in xref:cdi-reference.adoc#enable_build_profile[Enabling Beans for Quarkus Build Profile] and xref:cdi-reference.adoc#enable_build_properties[Enabling Beans for Quarkus Build Properties]. Extensions should inspect the configuration or the current profile and only produce an `AdditionalBeanBuildItem` if really needed."
msgstr "Não é possível ativar/desativar condicionalmente beans adicionais através das anotações `@IfBuildProfile`, `@UnlessBuildProfile`, `@IfBuildProperty` e `@UnlessBuildProperty`, conforme descrito em  link:cdi-reference.html#enable_build_profile[Ativar beans para o perfil de construção Quarkus] e  link:cdi-reference.html#enable_build_properties[Ativar beans para as propriedades de construção Quarkus]. As extensões devem inspecionar a configuração ou o perfil atual e apenas produzir um `AdditionalBeanBuildItem` se for realmente necessário."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:72
#, fuzzy, no-wrap
msgid "`AdditionalBeanBuildItem` Example"
msgstr "`AdditionalBeanBuildItem` Exemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:79
#, no-wrap
msgid ""
"@BuildStep\n"
"AdditionalBeanBuildItem additionalBeans() {\n"
"     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:81
#, fuzzy
msgid "`AdditionalBeanBuildItem.Builder` can be used for more complex use cases."
msgstr "`AdditionalBeanBuildItem.Builder` pode ser utilizado para casos de utilização mais complexos."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:86
#, fuzzy
msgid "Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.  If the container considers them xref:cdi-reference.adoc#remove_unused_beans[unused], they are just ignored.  However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.  See also xref:cdi-reference.adoc#remove_unused_beans[Removing Unused Beans] and xref:unremovable_builditem[_Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed] for more details."
msgstr "As classes Bean adicionadas através de `AdditionalBeanBuildItem` são _amovíveis_ por predefinição. Se o contentor as considerar  link:cdi-reference.html#remove_unused_beans[não utilizadas], são simplesmente ignoradas. No entanto, é possível utilizar o método `AdditionalBeanBuildItem.Builder.setUnremovable()` para instruir o contentor a nunca remover as classes de bean registadas através deste item de compilação. Consulte também  link:cdi-reference.html#remove_unused_beans[Removendo beans não utilizados] e  link:#unremovable_builditem[_Motivo 3_: a classe foi descoberta e tem uma anotação de definição de bean, mas foi removida] para obter mais detalhes."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:89
#, fuzzy
msgid "It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.  The default scope is only used if there is no scope declared on the bean class."
msgstr "Também é possível definir o âmbito predefinido através de `AdditionalBeanBuildItem.Builder#setDefaultScope()`. O âmbito predefinido só é utilizado se não existir um âmbito declarado na classe do bean."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:91
#: upstream/_guides/cdi-integration.adoc:133
#, fuzzy
msgid "If no default scope is specified the `@Dependent` pseudo-scope is used."
msgstr "Se não for especificado um âmbito predefinido, é utilizado o pseudoâmbito `@Dependent`."

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:92
#, fuzzy, no-wrap
msgid "_Reason 2_: Class Is Discovered but Has No Bean Defining Annotation"
msgstr "_Motivo 2_: A classe é descoberta mas não tem uma anotação de definição de feijão"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:97
#, fuzzy
msgid "In Quarkus, the application is represented by a single bean archive with the https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].  Therefore, bean classes that don't have a https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.  Bean defining annotations are declared on the class-level and include scopes, stereotypes and `@Interceptor`."
msgstr "No Quarkus, a aplicação é representada por um único arquivo de bean com o  link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#default_bean_discovery[modo de descoberta de bean `annotated`, window=_blank]. Por conseguinte, as classes de feijões que não têm uma  link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#bean_defining_annotations[anotação de definição de fei, window=_blank] jões são ignoradas. As anotações que definem o bean são declaradas ao nível da classe e incluem âmbitos, estereótipos e `@Interceptor`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:99
#, fuzzy
msgid "_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions."
msgstr "_Solução 1_: Utilizar o `AutoAddScopeBuildItem`. Este item de compilação pode ser utilizado para adicionar um âmbito a uma classe que satisfaça determinadas condições."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:100
#, fuzzy, no-wrap
msgid "`AutoAddScopeBuildItem` Example"
msgstr "`AutoAddScopeBuildItem` Exemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:109
#, no-wrap
msgid ""
"@BuildStep\n"
"AutoAddScopeBuildItem autoAddScope() {\n"
"   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n"
"      .defaultScope(BuiltinScope.SINGLETON) <2>\n"
"      .build();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:111
#, fuzzy
msgid "Find all classes annotated with `@Scheduled`."
msgstr "Encontrar todas as classes anotadas com `@Scheduled`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:112
#, fuzzy
msgid "Add `@Singleton` as default scope. Classes already annotated with a scope are skipped automatically."
msgstr "Adicione `@Singleton` como escopo padrão. As classes já anotadas com um âmbito são ignoradas automaticamente."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:114
#, fuzzy
msgid "_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`."
msgstr "_Solução 2_: Se precisar de processar classes anotadas com uma anotação específica, é possível alargar o conjunto de anotações que definem os feijões através do endereço `BeanDefiningAnnotationBuildItem`."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:115
#, fuzzy, no-wrap
msgid "`BeanDefiningAnnotationBuildItem` Example"
msgstr "`BeanDefiningAnnotationBuildItem` Exemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:122
#, no-wrap
msgid ""
"@BuildStep\n"
"BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n"
"   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:124
#, fuzzy
msgid "Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations."
msgstr "Adicionar `org.eclipse.microprofile.graphql.GraphQLApi` ao conjunto de anotações de definição de feijão."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:128
#, fuzzy
msgid "Bean classes added via `BeanDefiningAnnotationBuildItem` are _not removable_ by default, i.e. the resulting beans must not be removed even if they are considered unused.  However, you can change the default behavior.  See also xref:cdi-reference.adoc#remove_unused_beans[Removing Unused Beans] and xref:unremovable_builditem[_Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed] for more details."
msgstr "As classes de beans adicionadas via `BeanDefiningAnnotationBuildItem` _não_ são _removíveis_ por padrão, ou seja, os beans resultantes não devem ser removidos mesmo que sejam considerados não utilizados. No entanto, é possível alterar o comportamento padrão. Consulte também  link:cdi-reference.html#remove_unused_beans[Removendo beans não utilizados] e  link:#unremovable_builditem[_Razão 3_: A classe foi descoberta e tem uma anotação de definição de bean, mas foi removida] para obter mais detalhes."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:131
#, fuzzy
msgid "It is also possible to specify the default scope.  The default scope is only used if there is no scope declared on the bean class."
msgstr "Também é possível especificar o âmbito predefinido. O âmbito predefinido só é utilizado se não existir um âmbito declarado na classe do bean."

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:135
#, fuzzy, no-wrap
msgid "_Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed"
msgstr "_Motivo 3_: A classe foi descoberta e tem uma anotação que define o feijão, mas foi removida"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:142
#, fuzzy
msgid "The container attempts to xref:cdi-reference.adoc#remove_unused_beans[remove all unused beans] during the build by default.  This optimization allows for _framework-level dead code elimination_.  In few special cases, it's not possible to correctly identify an unused bean.  In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.  Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`."
msgstr "Por defeito, o contentor tenta  link:cdi-reference.html#remove_unused_beans[remover todos os beans não utilizados] durante a construção. Esta otimização permite a _eliminação de código morto ao nível da estrutura_. Em alguns casos especiais, não é possível identificar corretamente um bean não utilizado. Em particular, o Quarkus ainda não é capaz de detetar a utilização do método estático `CDI.current()`. As extensões podem eliminar possíveis falsos positivos produzindo um `UnremovableBeanBuildItem`."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:143
#, fuzzy, no-wrap
msgid "`UnremovableBeanBuildItem` Example"
msgstr "`UnremovableBeanBuildItem` Exemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:150
#, no-wrap
msgid ""
"@BuildStep\n"
"UnremovableBeanBuildItem unremovableBeans() {\n"
"   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:152
#, fuzzy
msgid "Make all classes annotated with `@Startup` unremovable."
msgstr "Tornar todas as classes anotadas com `@Startup` não removíveis."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:153
#, fuzzy, no-wrap
msgid "Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding"
msgstr "Caso de uso - Minha anotação não é reconhecida como um qualificador ou uma ligação de intercetor"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:157
#, fuzzy
msgid "It is likely that the annotation class is not part of the application index.  For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically."
msgstr "É provável que a classe de anotação não faça parte do índice da aplicação. Por exemplo, as classes do _módulo de tempo de execução_ de uma extensão Quarkus não são indexadas automaticamente."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:159
#, fuzzy
msgid "_Solution_: Use the `AdditionalBeanBuildItem` as described in xref:additional_bean_build_item[_Reason 1_: Class Is Not discovered]."
msgstr "_Solução_: Utilize o endereço `AdditionalBeanBuildItem` conforme descrito em  link:#additional_bean_build_item[_Razão 1_: A classe não foi descoberta]."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:161
#, fuzzy, no-wrap
msgid "Use Case - I Need To Transform Annotation Metadata"
msgstr "Caso de utilização - Preciso de transformar metadados de anotações"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:166
#, fuzzy
msgid "In some cases, it's useful to be able to modify the annotation metadata.  Quarkus provides a powerful alternative to https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#process_annotated_type[`jakarta.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"] and https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#bce_enhancement[`jakarta.enterprise.inject.build.compatible.spi.Enhancement`, window=\"_blank\"].  With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes."
msgstr "Em alguns casos, é útil poder modificar os metadados das anotações. O Quarkus fornece uma alternativa poderosa para  link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#process_annotated_type[`jakarta.enterprise.inject.spi.ProcessAnnotatedType`, window=_blank] e  link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#bce_enhancement[`jakarta.enterprise.inject.build.compatible.spi.Enhancement`, window=_blank]. Com um `AnnotationsTransformerBuildItem` é possível substituir as anotações que existem nas classes de feijão."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:168
#, fuzzy
msgid "Keep in mind that annotation transformers must be produced _before_ the bean discovery starts."
msgstr "Tenha em mente que os transformadores de anotação devem ser produzidos _antes do_ início da descoberta do bean."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:171
#, fuzzy
msgid "For example, you might want to add an interceptor binding to a specific bean class.  You can use a convenient builder-like API to create a transformer instance:"
msgstr "Por exemplo, pode querer adicionar uma ligação de intercetor a uma classe de feijão específica. Pode utilizar uma conveniente API do tipo construtor para criar uma instância de transformador:"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:173
#, fuzzy
msgid "Builder Example"
msgstr "Exemplo de construtor"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:181
#, no-wrap
msgid ""
"@BuildStep\n"
"AnnotationsTransformerBuildItem transform() {\n"
"   return new AnnotationsTransformerBuildItem(AnnotationsTransformer.appliedToClass() <1>\n"
"        .whenClass(c -> c.name().toString().equals(\"org.acme.Bar\")) <2>\n"
"        .thenTransform(t -> t.add(MyInterceptorBinding.class))); <3>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:183
#: upstream/_guides/cdi-integration.adoc:208
#, fuzzy
msgid "The transformer is only applied to classes."
msgstr "O transformador só é aplicado às classes."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:184
#, fuzzy
msgid "Only apply the transformation if the class name equals to `org.acme.Bar`."
msgstr "Aplicar a transformação apenas se o nome da classe for igual a `org.acme.Bar`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:185
#, fuzzy
msgid "Add the `@MyInterceptorBinding` annotation."
msgstr "Adicionar a anotação `@MyInterceptorBinding`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:187
#, fuzzy
msgid "The example above can be rewritten with an anonymous class:"
msgstr "O exemplo acima pode ser reescrito com uma classe anónima:"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:188
#, fuzzy, no-wrap
msgid "`AnnotationsTransformerBuildItem` Example"
msgstr "`AnnotationsTransformerBuildItem` Exemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:194
#, no-wrap
msgid ""
"@BuildStep\n"
"AnnotationsTransformerBuildItem transform() {\n"
"   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:198
#, no-wrap
msgid ""
"      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n"
"         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n"
"      }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:206
#, no-wrap
msgid ""
"      public void transform(TransformationContext context) {\n"
"         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n"
"            context.transform().add(MyInterceptorBinding.class).done(); <2>\n"
"         }\n"
"      }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:209
#, fuzzy
msgid "If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`."
msgstr "Se o nome da classe for igual a `org.acme.Bar`, adicione `@MyInterceptorBinding`. Não se esqueça de invocar `Transformation#done()`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:211
#, fuzzy
msgid "Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`."
msgstr "As etapas de construção podem consultar as anotações transformadas para um determinado alvo de anotação através do endereço `TransformedAnnotationsBuildItem`."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:212
#, fuzzy, no-wrap
msgid "`TransformedAnnotationsBuildItem` Example"
msgstr "`TransformedAnnotationsBuildItem` Exemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:222
#, no-wrap
msgid ""
"@BuildStep\n"
"void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n"
"   ClassInfo myClazz = ...;\n"
"   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n"
"     myBuildItem.produce(new MyBuildItem());\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:224
#, fuzzy
msgid "`TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations."
msgstr "`TransformedAnnotationsBuildItem.getAnnotations()` devolverá um conjunto de anotações possivelmente transformadas."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:226
#, fuzzy
msgid "There are other build items specialized in transformation: xref:additional_interceptor_bindings[Use Case - Additional Interceptor Bindings] and xref:injection_point_transformation[Use Case - Injection Point Transformation]."
msgstr "Existem outros itens de compilação especializados em transformação:  link:#additional_interceptor_bindings[Caso de utilização - Ligações de interceptores adicionais] e  link:#injection_point_transformation[Caso de utilização - Transformação de pontos de injeção]."

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:227
#, fuzzy, no-wrap
msgid "How to Enable Trace Logging for Annotation Transformers"
msgstr "Como ativar o registo de rastreio para transformadores de anotações"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:230
#, fuzzy
msgid "You can set the `TRACE` level for the category `io.quarkus.arc.processor` and try to analyze the log output afterwards."
msgstr "Pode definir o nível `TRACE` para a categoria `io.quarkus.arc.processor` e tentar analisar a saída do registo posteriormente."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:231
#, fuzzy, no-wrap
msgid "`application.properties` Example"
msgstr "`application.properties` Exemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:236
#, no-wrap
msgid ""
"quarkus.log.category.\"io.quarkus.arc.processor\".min-level=TRACE <1>\n"
"quarkus.log.category.\"io.quarkus.arc.processor\".level=TRACE\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:238
#, fuzzy
msgid "You also need to adjust the minimum log level for the relevant category."
msgstr "Também é necessário ajustar o nível mínimo de registo para a categoria relevante."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:240
#, fuzzy, no-wrap
msgid "Use Case - Inspect Beans, Observers and Injection Points"
msgstr "Caso de utilização - Inspecionar feijões, observadores e pontos de injeção"

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:242
#, fuzzy, no-wrap
msgid "_Solution 1_: `BeanDiscoveryFinishedBuildItem`"
msgstr "_Solução 1_: `BeanDiscoveryFinishedBuildItem`"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:246
#, fuzzy
msgid "Consumers of `BeanDiscoveryFinishedBuildItem` can easily inspect all class-based beans, observers and injection points registered in the application.  However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered."
msgstr "Os consumidores de `BeanDiscoveryFinishedBuildItem` podem inspecionar facilmente todos os beans baseados em classes, observadores e pontos de injeção registados na aplicação. No entanto, os beans e observadores sintéticos _não_ estão _incluídos_ porque este item de compilação é produzido _antes de_ os componentes sintéticos serem registados."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:248
#, fuzzy
msgid "Additionally, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers."
msgstr "Além disso, o resolvedor de feijões devolvido por `BeanDiscoveryFinishedBuildItem#getBeanResolver()` pode ser utilizado para aplicar as regras de resolução à prova de tipo, por exemplo, para descobrir se existe um feijão que satisfaça uma determinada combinação de tipo e qualificadores necessários."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:249
#, fuzzy, no-wrap
msgid "`BeanDiscoveryFinishedBuildItem` Example"
msgstr "`BeanDiscoveryFinishedBuildItem` Exemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:257
#, no-wrap
msgid ""
"@BuildStep\n"
"void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n"
"   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n"
"   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:259
#, fuzzy
msgid "The resulting list will not contain `@Named` synthetic beans."
msgstr "A lista resultante não conterá `@Named` feijões sintéticos."

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:260
#, fuzzy, no-wrap
msgid "_Solution 2_: `SynthesisFinishedBuildItem`"
msgstr "_Solução 2_: `SynthesisFinishedBuildItem`"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:263
#, fuzzy
msgid "Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered."
msgstr "Os consumidores de `SynthesisFinishedBuildItem` podem inspecionar facilmente todos os beans, observadores e pontos de injeção registados na aplicação. Os beans e observadores sintéticos estão incluídos porque este item de compilação é produzido _depois de_ os componentes sintéticos serem registados."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:265
#, fuzzy
msgid "Additionally, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers."
msgstr "Além disso, o resolvedor de feijões devolvido por `SynthesisFinishedBuildItem#getBeanResolver()` pode ser utilizado para aplicar as regras de resolução à prova de tipo, por exemplo, para descobrir se existe um feijão que satisfaça uma determinada combinação de tipo e qualificadores necessários."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:266
#, fuzzy, no-wrap
msgid "`SynthesisFinishedBuildItem` Example"
msgstr "`SynthesisFinishedBuildItem` Exemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:274
#, no-wrap
msgid ""
"@BuildStep\n"
"void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n"
"   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n"
"   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:276
#, fuzzy
msgid "The resulting list will contain `@Named` synthetic beans."
msgstr "A lista resultante conterá `@Named` feijões sintéticos."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:278
#, fuzzy, no-wrap
msgid "Use Case - The Need for Synthetic Beans"
msgstr "Caso de utilização - A necessidade de feijões sintéticos"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:284
#, fuzzy
msgid "Sometimes it is practical to be able to register a _synthetic bean_.  Bean attributes of a synthetic bean are not derived from a Java class, method or field.  Instead, all the attributes are defined by an extension.  In regular CDI, this could be achieved using the https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] and https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#bce_synthesis[`SyntheticComponents.addBean()`] methods."
msgstr "Por vezes, é prático poder registar um _bean sintético_. Os atributos de um bean sintético não são derivados de uma classe, método ou campo Java. Em vez disso, todos os atributos são definidos por uma extensão. Em CDI normal, isto pode ser conseguido utilizando os atributos  link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=_blank] e  link:https://jakarta.ee/specifications/cdi/4.0/jakarta-cdi-spec-4.0.html#bce_synthesis[`SyntheticComponents.addBean()`] métodos."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:286
#, fuzzy
msgid "_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`."
msgstr "_Solução_: Se for necessário registar um feijão sintético, utilize o endereço `SyntheticBeanBuildItem`."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:287
#, fuzzy, no-wrap
msgid "`SyntheticBeanBuildItem` Example 1"
msgstr "`SyntheticBeanBuildItem` Exemplo 1"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:297
#, no-wrap
msgid ""
"@BuildStep\n"
"SyntheticBeanBuildItem syntheticBean() {\n"
"   return SyntheticBeanBuildItem.configure(String.class)\n"
"             .qualifiers(AnnotationInstance.builder(MyQualifier.class).build())\n"
"             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n"
"             .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:299
#, fuzzy
msgid "Generate the bytecode of the `jakarta.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation."
msgstr "Gerar o bytecode da implementação `jakarta.enterprise.context.spi.Contextual#create(CreationalContext&amp;lt;T&amp;gt;)`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:303
#, fuzzy
msgid "The output of a bean configurator is recorded as bytecode.  Therefore, there are some limitations in how a synthetic bean instance is created at runtime.  You can:"
msgstr "A saída de um configurador de bean é registada como bytecode. Por conseguinte, existem algumas limitações na forma como uma instância de bean sintético é criada em tempo de execução. É possível:"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:305
#, fuzzy
msgid "Generate the bytecode of the `Contextual#create(CreationalContext<T>)` method directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`."
msgstr "Gerar o bytecode do método `Contextual#create(CreationalContext&amp;lt;T&amp;gt;)` diretamente através de `ExtendedBeanConfigurator.creator(Consumer&amp;lt;MethodCreator&amp;gt;)`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:306
#, fuzzy
msgid "Pass a subclass of `io.quarkus.arc.BeanCreator` via `ExtendedBeanConfigurator#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some build-time parameters via `ExtendedBeanConfigurator#param()` and synthetic injection points via `ExtendedBeanConfigurator#addInjectionPoint()`."
msgstr "Passar uma subclasse de `io.quarkus.arc.BeanCreator` através de `ExtendedBeanConfigurator#creator(Class&amp;lt;? extends BeanCreator&amp;lt;U&amp;gt;&amp;gt;)`, e possivelmente especificar alguns parâmetros de tempo de construção através de `ExtendedBeanConfigurator#param()` e pontos de injeção sintéticos através de `ExtendedBeanConfigurator#addInjectionPoint()`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:307
#, fuzzy
msgid "Produce the runtime instance through a proxy returned from a xref:writing-extensions.adoc#bytecode-recording[`@Recorder` method] and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)`, `ExtendedBeanConfigurator#runtimeProxy(Object)`, `ExtendedBeanConfigurator#supplier(Supplier<?>)` or `ExtendedBeanConfigurator#createWith(Function<SyntheticCreationalContext<?>, <?>)`."
msgstr "Produzir a instância de tempo de execução através de um proxy devolvido por um  link:writing-extensions.html#bytecode-recording[método `@Recorder`] e defini-la através de `ExtendedBeanConfigurator#runtimeValue(RuntimeValue&amp;lt;?&amp;gt;)`, `ExtendedBeanConfigurator#runtimeProxy(Object)`, `ExtendedBeanConfigurator#supplier(Supplier&amp;lt;?&amp;gt;)` ou `ExtendedBeanConfigurator#createWith(Function&amp;lt;SyntheticCreationalContext&amp;lt;?&amp;gt;, &amp;lt;?&amp;gt;)`."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:308
#, fuzzy, no-wrap
msgid "`SyntheticBeanBuildItem` Example 2"
msgstr "`SyntheticBeanBuildItem` Exemplo 2"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:318
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(STATIC_INIT) <1>\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n"
"                .runtimeValue(recorder.createFoo()) <2>\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:320
#, fuzzy
msgid "By default, a synthetic bean is initialized during `STATIC_INIT`."
msgstr "Por defeito, um bean sintético é inicializado durante `STATIC_INIT`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:321
#, fuzzy
msgid "The bean instance is supplied by a value returned from a recorder method."
msgstr "A instância do bean é fornecida por um valor devolvido por um método de registo."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:324
#, fuzzy
msgid "It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`.  See the xref:writing-extensions.adoc#bootstrap-three-phases[Three Phases of Bootstrap and Quarkus Philosophy] for more information about the difference between `STATIC_INIT` and `RUNTIME_INIT`."
msgstr "É possível marcar um bean sintético para ser inicializado durante `RUNTIME_INIT`. Consulte as  link:writing-extensions.html#bootstrap-three-phases[Três Fases do Bootstrap e a Filosofia Quarkus] para obter mais informações sobre a diferença entre `STATIC_INIT` e `RUNTIME_INIT`."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:325
#, fuzzy, no-wrap
msgid "`RUNTIME_INIT` `SyntheticBeanBuildItem` Example"
msgstr "`RUNTIME_INIT` `SyntheticBeanBuildItem` Exemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:336
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(RUNTIME_INIT) <1>\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n"
"                .setRuntimeInit() <2>\n"
"                .runtimeValue(recorder.createFoo())\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:338
#, fuzzy
msgid "The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase."
msgstr "O registador deve ser executado na fase `ExecutionTime.RUNTIME_INIT`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:339
#: upstream/_guides/cdi-integration.adoc:382
#, fuzzy
msgid "The bean instance is initialized during `RUNTIME_INIT`."
msgstr "A instância do bean é inicializada durante `RUNTIME_INIT`."

#. type: delimited block =
#: upstream/_guides/cdi-integration.adoc:343
#, fuzzy
msgid "Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:"
msgstr "Os beans sintéticos inicializados durante `RUNTIME_INIT` não devem ser acedidos durante `STATIC_INIT`. As etapas de construção de `RUNTIME_INIT` que acedem a um bean sintético inicializado em tempo de execução devem consumir o `SyntheticBeansRuntimeInitBuildItem`:"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:352
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(RUNTIME_INIT) \n"
"@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n"
"void accessFoo(TestRecorder recorder) {\n"
"   recorder.foo(); <2>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:354
#, fuzzy
msgid "This build step must be executed after `syntheticBean()` completes."
msgstr "Este passo de construção deve ser executado após a conclusão de `syntheticBean()`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:355
#, fuzzy
msgid "This recorder method results in an invocation upon the `Foo` bean instance and thus we need to make sure that the build step is executed after all synthetic beans are initialized."
msgstr "Este método de registo resulta numa invocação da instância do bean `Foo` e, por isso, temos de nos certificar de que a etapa de construção é executada depois de todos os beans sintéticos serem inicializados."

#. type: delimited block =
#: upstream/_guides/cdi-integration.adoc:358
#, fuzzy
msgid "It is also possible to use the `BeanRegistrationPhaseBuildItem` to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus."
msgstr "Também é possível utilizar o endereço `BeanRegistrationPhaseBuildItem` para registar um bean sintético. No entanto, recomendamos aos autores de extensões que utilizem `SyntheticBeanBuildItem`, que é mais idiomático para o Quarkus."

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:359
#, fuzzy, no-wrap
msgid "Synthetic Injection Points"
msgstr "Pontos de injeção sintéticos"

#. type: delimited block =
#: upstream/_guides/cdi-integration.adoc:364
#, fuzzy
msgid "A synthetic bean may register a synthetic injection point via the `ExtendedBeanConfigurator#addInjectionPoint()` method.  This injection point is validated at build time and considered when xref:cdi-reference.adoc#remove_unused_beans[detecting unused beans].  The injected reference is accessible through the `SyntheticCreationalContext#getInjectedReference()` methods at runtime."
msgstr "Um bean sintético pode registar um ponto de injeção sintético através do método `ExtendedBeanConfigurator#addInjectionPoint()`. Este ponto de injeção é validado em tempo de construção e considerado na  link:cdi-reference.html#remove_unused_beans[deteção de beans não utilizados]. A referência injectada é acessível através dos métodos `SyntheticCreationalContext#getInjectedReference()` em tempo de execução."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:365
#, fuzzy, no-wrap
msgid "Synthetic Injection Point - Build Step Example"
msgstr "Ponto de injeção sintético - Exemplo de etapa de construção"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:370
#, no-wrap
msgid ""
"import org.jboss.jandex.ClassType;\n"
"import org.jboss.jandex.DotName;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:380
#, no-wrap
msgid ""
"@BuildStep\n"
"@Record(RUNTIME_INIT) <1>\n"
"SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n"
"   return SyntheticBeanBuildItem.configure(Foo.class)\n"
"                .scope(Singleton.class)\n"
"                .addInjectionPoint(ClassType.create(DotName.createSimple(Bar.class))) <2>\n"
"                .createWith(recorder.createFoo()) <3>\n"
"                .done();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:383
#, fuzzy
msgid "A synthetic injection point with required type `Bar` was added; this is an equivalent of `@Inject Bar`."
msgstr "Foi acrescentado um ponto de injeção sintético com o tipo necessário `Bar`; este é equivalente a `@Inject Bar`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:384
#, fuzzy
msgid "The bean instance is created with a function returned from a recorder method."
msgstr "A instância do bean é criada com uma função devolvida de um método de registo."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:385
#, fuzzy, no-wrap
msgid "Synthetic Injection Point - Recorder Example"
msgstr "Ponto de injeção sintético - Exemplo de registador"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:390
#, no-wrap
msgid ""
"@Recorder\n"
"public class TestRecorder {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:397
#, no-wrap
msgid ""
"   public Function<SyntheticCreationalContext<Foo>, Foo> createFoo() {\n"
"     return (context) -> {\n"
"        return new Foo(context.getInjectedReference(Bar.class)); <1>\n"
"     };\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:399
#, fuzzy
msgid "Pass a contextual reference of `Bar` to the constructor of `Foo`."
msgstr "Passar uma referência contextual de `Bar` ao construtor de `Foo`."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:401
#, fuzzy, no-wrap
msgid "Use Case - Synthetic Observers"
msgstr "Caso de utilização - Observadores sintéticos"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:404
#, fuzzy
msgid "Similar to xref:synthetic_beans[synthetic beans], the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension."
msgstr "À semelhança dos  link:#synthetic_beans[synthetic beans], os atributos de um método de observador sintético não são derivados de um método Java. Em vez disso, todos os atributos são definidos por uma extensão."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:406
#, fuzzy
msgid "_Solution_: If you need to register a synthetic observer, use the `ObserverRegistrationPhaseBuildItem`."
msgstr "_Solução_: Se for necessário registar um observador sintético, utilize o endereço `ObserverRegistrationPhaseBuildItem`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:408
#, fuzzy
msgid "A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase)."
msgstr "Um passo de construção que consome o `ObserverRegistrationPhaseBuildItem` deve sempre produzir um `ObserverConfiguratorBuildItem` ou, pelo menos, injetar um `BuildProducer` para este item de construção, caso contrário, pode ser ignorado ou processado no momento errado (por exemplo, após a fase de arranque correcta do CDI)."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:409
#, fuzzy, no-wrap
msgid "`ObserverRegistrationPhaseBuildItem` Example"
msgstr "`ObserverRegistrationPhaseBuildItem` Exemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:425
#, no-wrap
msgid ""
"@BuildStep\n"
"void syntheticObserver(ObserverRegistrationPhaseBuildItem observerRegistrationPhase,\n"
"            BuildProducer<MyBuildItem> myBuildItem, \n"
"            BuildProducer<ObserverConfiguratorBuildItem> observerConfigurationRegistry) {\n"
"   observerConfigurationRegistry.produce(new ObserverConfiguratorBuildItem(observerRegistrationPhase.getContext()\n"
"       .configure()\n"
"       .beanClass(DotName.createSimple(MyBuildStep.class.getName()))\n"
"       .observedType(String.class)\n"
"       .notify(mc -> {\n"
"           // do some gizmo bytecode generation...\n"
"       })));\n"
"   myBuildItem.produce(new MyBuildItem());\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:430
#, fuzzy
msgid "The output of a `ObserverConfigurator` is recorded as bytecode.  Therefore, there are some limitations in how a synthetic observer is invoked at runtime.  Currently, you must generate the bytecode of the method body directly."
msgstr "A saída de um `ObserverConfigurator` é registada como bytecode. Portanto, existem algumas limitações na forma como um observador sintético é invocado em tempo de execução. Atualmente, é necessário gerar o bytecode do corpo do método diretamente."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:432
#, fuzzy, no-wrap
msgid "Use Case - I Have a Generated Bean Class"
msgstr "Caso de utilização - Tenho uma classe de feijão gerada"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:436
#, fuzzy
msgid "No problem.  You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`."
msgstr "Não há problema. Pode gerar o bytecode de uma classe bean manualmente e depois só precisa de produzir um `GeneratedBeanBuildItem` em vez de `GeneratedClassBuildItem`."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:437
#, fuzzy, no-wrap
msgid "`GeneratedBeanBuildItem` Example"
msgstr "`GeneratedBeanBuildItem` Exemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:449
#, no-wrap
msgid ""
"@BuildStep\n"
"void generatedBean(BuildProducer<GeneratedBeanBuildItem> generatedBeans) {\n"
"    ClassOutput beansClassOutput = new GeneratedBeanGizmoAdaptor(generatedBeans); <1>\n"
"    ClassCreator beanClassCreator = ClassCreator.builder().classOutput(beansClassOutput)\n"
"                .className(\"org.acme.MyBean\")\n"
"                .build();\n"
"    beanClassCreator.addAnnotation(Singleton.class);\n"
"    beanClassCreator.close(); <2>\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:451
#, fuzzy
msgid "`io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` makes it easy to produce ``GeneratedBeanBuildItem``s from Gizmo constructs."
msgstr "`io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` facilita a produção de `GeneratedBeanBuildItem`s a partir de construções Gizmo."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:452
#, fuzzy
msgid "The resulting bean class is something like `public class @Singleton MyBean { }`."
msgstr "A classe de feijão resultante é algo como `public class @Singleton MyBean { }`."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:453
#, fuzzy, no-wrap
msgid "Use Case - I Need to Validate the Deployment"
msgstr "Caso de utilização - Preciso de validar a implementação"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:456
#, fuzzy
msgid "Sometimes extensions need to inspect the beans, observers and injection points, then perform additional validations and fail the build if something is wrong."
msgstr "Por vezes, as extensões precisam de inspecionar os beans, os observadores e os pontos de injeção e, em seguida, efetuar validações adicionais e falhar a construção se algo estiver errado."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:458
#, fuzzy
msgid "_Solution_: If an extension needs to validate the deployment it should use the `ValidationPhaseBuildItem`."
msgstr "_Solução_: Se uma extensão precisar de validar a implementação, deve utilizar o endereço `ValidationPhaseBuildItem`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:460
#, fuzzy
msgid "A build step that consumes the `ValidationPhaseBuildItem` should always produce a `ValidationErrorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase)."
msgstr "Um passo de construção que consome o `ValidationPhaseBuildItem` deve sempre produzir um `ValidationErrorBuildItem` ou, pelo menos, injetar um `BuildProducer` para este item de construção, caso contrário, pode ser ignorado ou processado no momento errado (por exemplo, após a fase de arranque correcta do CDI)."

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:472
#, no-wrap
msgid ""
"@BuildStep\n"
"void validate(ValidationPhaseBuildItem validationPhase,\n"
"            BuildProducer<MyBuildItem> myBuildItem, \n"
"            BuildProducer<ValidationErrorBuildItem> errors) {\n"
"   if (someCondition) {\n"
"     errors.produce(new ValidationErrorBuildItem(new IllegalStateException()));\n"
"     myBuildItem.produce(new MyBuildItem());\n"
"   }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:475
#, fuzzy
msgid "You can easily filter all registered beans via the convenient `BeanStream` returned from the `ValidationPhaseBuildItem.getContext().beans()` method."
msgstr "Pode filtrar facilmente todos os feijões registados através do prático `BeanStream` devolvido pelo método `ValidationPhaseBuildItem.getContext().beans()`."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:477
#, fuzzy, no-wrap
msgid "Use Case - Register a Custom CDI Context"
msgstr "Caso de utilização - Registar um contexto CDI personalizado"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:480
#, fuzzy
msgid "Sometimes extensions need to extend the set of built-in CDI contexts."
msgstr "Por vezes, as extensões precisam de alargar o conjunto de contextos CDI incorporados."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:482
#, fuzzy
msgid "_Solution_: If you need to register a custom context, use the `ContextRegistrationPhaseBuildItem`."
msgstr "_Solução_: Se for necessário registar um contexto personalizado, utilize o endereço `ContextRegistrationPhaseBuildItem`."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:484
#, fuzzy
msgid "A build step that consumes the `ContextRegistrationPhaseBuildItem` should always produce a `ContextConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase)."
msgstr "Um passo de construção que consome o `ContextRegistrationPhaseBuildItem` deve sempre produzir um `ContextConfiguratorBuildItem` ou, pelo menos, injetar um `BuildProducer` para este item de construção, caso contrário, pode ser ignorado ou processado no momento errado (por exemplo, após a fase de arranque correcta do CDI)."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:486
#, fuzzy
msgid "`ContextRegistrationPhaseBuildItem` Example"
msgstr "`ContextRegistrationPhaseBuildItem` Exemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:492
#, no-wrap
msgid ""
"@BuildStep\n"
"ContextConfiguratorBuildItem registerContext(ContextRegistrationPhaseBuildItem phase) {\n"
"      return new ContextConfiguratorBuildItem(phase.getContext().configure(TransactionScoped.class).normal().contextClass(TransactionContext.class));\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:495
#, fuzzy
msgid "Additionally, each extension that registers a custom CDI context via `ContextRegistrationPhaseBuildItem` should also produce the `CustomScopeBuildItem` in order to contribute the custom scope annotation name to the set of bean defining annotations."
msgstr "Além disso, cada extensão que regista um contexto CDI personalizado através de `ContextRegistrationPhaseBuildItem` deve também produzir o `CustomScopeBuildItem` de modo a contribuir com o nome da anotação de âmbito personalizado para o conjunto de anotações que definem o bean."

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:497
#, fuzzy
msgid "`CustomScopeBuildItem` Example"
msgstr "`CustomScopeBuildItem` Exemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:503
#, no-wrap
msgid ""
"@BuildStep\n"
"CustomScopeBuildItem customScope() {\n"
"   return new CustomScopeBuildItem(DotName.createSimple(TransactionScoped.class.getName()));\n"
"}\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/cdi-integration.adoc:505
#, fuzzy, no-wrap
msgid "What if I Need to Know All the Scopes Used in the Application?"
msgstr "E se eu precisar de conhecer todos os âmbitos de aplicação utilizados na aplicação?"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:508
#, fuzzy
msgid "_Solution_: You can inject the `CustomScopeAnnotationsBuildItem` in a build step and use the convenient methods such as `CustomScopeAnnotationsBuildItem.isScopeDeclaredOn()`."
msgstr "_Solução_: Pode injetar o `CustomScopeAnnotationsBuildItem` num passo de construção e utilizar os métodos convenientes, como `CustomScopeAnnotationsBuildItem.isScopeDeclaredOn()`."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:510
#, fuzzy, no-wrap
msgid "Use Case - Additional Interceptor Bindings"
msgstr "Caso de utilização - Ligações de interceptores adicionais"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:515
#, fuzzy
msgid "In rare cases it might be handy to programmatically register an existing annotation that is not annotated with `@jakarta.interceptor.InterceptorBinding` as an interceptor binding.  This is similar to what CDI achieves through `BeforeBeanDiscovery#addInterceptorBinding()`.  We are going to use `InterceptorBindingRegistrarBuildItem` to get it done."
msgstr "Em casos raros, pode ser útil registar programaticamente uma anotação existente que não esteja anotada com `@jakarta.interceptor.InterceptorBinding` como uma ligação de intercetor. Isto é semelhante ao que o CDI consegue através de `BeforeBeanDiscovery#addInterceptorBinding()`. Vamos utilizar `InterceptorBindingRegistrarBuildItem` para o fazer."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:516
#, fuzzy, no-wrap
msgid "`InterceptorBindingRegistrarBuildItem` Example"
msgstr "`InterceptorBindingRegistrarBuildItem` Exemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:528
#, no-wrap
msgid ""
"@BuildStep\n"
"InterceptorBindingRegistrarBuildItem addInterceptorBindings() {\n"
"    return new InterceptorBindingRegistrarBuildItem(new InterceptorBindingRegistrar() {\n"
"        @Override\n"
"        public List<InterceptorBinding> getAdditionalBindings() {\n"
"            return List.of(InterceptorBinding.of(NotAnInterceptorBinding.class));\n"
"        }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:530
#, fuzzy, no-wrap
msgid "Use Case - Additional Qualifiers"
msgstr "Caso de utilização - Qualificadores adicionais"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:535
#, fuzzy
msgid "Sometimes it might be useful to register an existing annotation that is not annotated with `@jakarta.inject.Qualifier` as a CDI qualifier.  This is similar to what CDI achieves through `BeforeBeanDiscovery#addQualifier()`.  We are going to use `QualifierRegistrarBuildItem` to get it done."
msgstr "Por vezes, pode ser útil registar uma anotação existente que não esteja anotada em `@jakarta.inject.Qualifier` como um qualificador CDI. Isto é semelhante ao que a CDI consegue através de `BeforeBeanDiscovery#addQualifier()`. Vamos utilizar `QualifierRegistrarBuildItem` para o fazer."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:536
#, fuzzy, no-wrap
msgid "`QualifierRegistrarBuildItem` Example"
msgstr "`QualifierRegistrarBuildItem` Exemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:549
#, no-wrap
msgid ""
"@BuildStep\n"
"QualifierRegistrarBuildItem addQualifiers() {\n"
"    return new QualifierRegistrarBuildItem(new QualifierRegistrar() {\n"
"        @Override\n"
"        public Map<DotName, Set<String>> getAdditionalQualifiers() {\n"
"            return Collections.singletonMap(DotName.createSimple(NotAQualifier.class.getName()),\n"
"                                        Collections.emptySet());\n"
"        }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:551
#, fuzzy, no-wrap
msgid "Use Case - Additional Stereotypes"
msgstr "Caso de utilização - Estereótipos adicionais"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:556
#, fuzzy
msgid "It is sometimes useful to register an existing annotation that is not annotated with `@jakarta.enterprise.inject.Stereotype` as a CDI stereotype.  This is similar to what CDI achieves through `BeforeBeanDiscovery#addStereotype()`.  We are going to use `StereotypeRegistrarBuildItem` to get it done."
msgstr "Por vezes, é útil registar uma anotação existente que não esteja anotada em `@jakarta.enterprise.inject.Stereotype` como um estereótipo CDI. Isto é semelhante ao que a CDI consegue através de `BeforeBeanDiscovery#addStereotype()`. Vamos utilizar `StereotypeRegistrarBuildItem` para o fazer."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:557
#, fuzzy, no-wrap
msgid "`StereotypeRegistrarBuildItem` Example"
msgstr "`StereotypeRegistrarBuildItem` Exemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:569
#, no-wrap
msgid ""
"@BuildStep\n"
"StereotypeRegistrarBuildItem addStereotypes() {\n"
"    return new StereotypeRegistrarBuildItem(new StereotypeRegistrar() {\n"
"        @Override\n"
"        public Set<DotName> getAdditionalStereotypes() {\n"
"            return Collections.singleton(DotName.createSimple(NotAStereotype.class.getName()));\n"
"        }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:572
#, fuzzy
msgid "If the newly registered stereotype annotation doesn't have the appropriate meta-annotations, such as scope or interceptor bindings, use an xref:annotations_transformer_build_item[annotation transformation] to add them."
msgstr "Se a anotação de estereótipo recém-registada não tiver as meta-anotações apropriadas, como as ligações de âmbito ou de intercetor, utilize uma  link:#annotations_transformer_build_item[transformação de anotação] para as adicionar."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:574
#, fuzzy, no-wrap
msgid "Use Case - Injection Point Transformation"
msgstr "Caso de utilização - Transformação de pontos de injeção"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:579
#, fuzzy
msgid "Every now and then it is handy to be able to change the qualifiers of an injection point programmatically.  You can do just that with `InjectionPointTransformerBuildItem`.  The following sample shows how to apply transformation to injection points with type `Foo` that contain qualifier `MyQualifier`:"
msgstr "De vez em quando, é útil poder alterar os qualificadores de um ponto de injeção de forma programática. Pode fazer isso mesmo com `InjectionPointTransformerBuildItem`. O exemplo seguinte mostra como aplicar a transformação a pontos de injeção com o tipo `Foo` que contêm o qualificador `MyQualifier`:"

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:580
#, fuzzy, no-wrap
msgid "`InjectionPointTransformerBuildItem` Example"
msgstr "`InjectionPointTransformerBuildItem` Exemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:586
#, no-wrap
msgid ""
"@BuildStep\n"
"InjectionPointTransformerBuildItem transformer() {\n"
"    return new InjectionPointTransformerBuildItem(new InjectionPointsTransformer() {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:590
#, no-wrap
msgid ""
"        public boolean appliesTo(Type requiredType) {\n"
"            return requiredType.name().equals(DotName.createSimple(Foo.class.getName()));\n"
"        }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:602
#, no-wrap
msgid ""
"        public void transform(TransformationContext context) {\n"
"            if (context.getQualifiers().stream()\n"
"                    .anyMatch(a -> a.name().equals(DotName.createSimple(MyQualifier.class.getName())))) {\n"
"                context.transform()\n"
"                        .removeAll()\n"
"                        .add(DotName.createSimple(MyOtherQualifier.class.getName()))\n"
"                        .done();\n"
"            }\n"
"        }\n"
"    });\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:605
#, fuzzy
msgid "In theory, you can use xref:annotations_transformer_build_item[an `AnnotationsTransformer`] to achieve the same goal. However, there are few differences that make `InjectionPointsTransformer` more suitable for this particular task: (1) annotation transformers are applied to all classes during bean discovery, whereas `InjectionPointsTransformer` is only applied to discovered injection points after bean discovery; (2) with `InjectionPointsTransformer` you don't need to handle various types of injection points (field, parameters of initializer methods, etc.)."
msgstr "Em teoria, é possível utilizar  link:#annotations_transformer_build_item[um `AnnotationsTransformer`] para atingir o mesmo objetivo. No entanto, existem algumas diferenças que tornam o `InjectionPointsTransformer` mais adequado para esta tarefa específica: (1) os transformadores de anotação são aplicados a todas as classes durante a descoberta do bean, enquanto o `InjectionPointsTransformer` só é aplicado aos pontos de injeção descobertos após a descoberta do bean; (2) com o `InjectionPointsTransformer` não precisa de tratar vários tipos de pontos de injeção (campo, parâmetros de métodos inicializadores, etc.)."

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:606
#, fuzzy, no-wrap
msgid "Use Case - Resource Annotations and Injection"
msgstr "Caso de utilização - Anotações e injeção de recursos"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:610
#, fuzzy
msgid "The `ResourceAnnotationBuildItem` can be used to specify resource annotations that make it possible to resolve non-CDI injection points, such as Jakarta EE resources.  An integrator must also provide a corresponding `io.quarkus.arc.ResourceReferenceProvider` service provider implementation."
msgstr "O `ResourceAnnotationBuildItem` pode ser utilizado para especificar anotações de recursos que possibilitam a resolução de pontos de injeção não-CDI, tais como recursos Jakarta EE. Um integrador também deve fornecer uma implementação correspondente do provedor de serviços `io.quarkus.arc.ResourceReferenceProvider`."

#. type: Block title
#: upstream/_guides/cdi-integration.adoc:611
#, fuzzy, no-wrap
msgid "`ResourceAnnotationBuildItem` Example"
msgstr "`ResourceAnnotationBuildItem` Exemplo"

#. type: delimited block -
#: upstream/_guides/cdi-integration.adoc:620
#, no-wrap
msgid ""
"@BuildStep\n"
"void setupResourceInjection(BuildProducer<ResourceAnnotationBuildItem> resourceAnnotations, BuildProducer<GeneratedResourceBuildItem> resources) {\n"
"    resources.produce(new GeneratedResourceBuildItem(\"META-INF/services/io.quarkus.arc.ResourceReferenceProvider\",\n"
"        MyResourceReferenceProvider.class.getName().getBytes()));\n"
"    resourceAnnotations.produce(new ResourceAnnotationBuildItem(DotName.createSimple(MyAnnotation.class.getName())));\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/cdi-integration.adoc:623
#, fuzzy, no-wrap
msgid "Available Build Time Metadata"
msgstr "Metadados de tempo de construção disponíveis"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:627
#, fuzzy
msgid "Any of the above extensions that operates with `BuildExtension.BuildContext` can leverage certain build time metadata that are generated during build.  The built-in keys located in `io.quarkus.arc.processor.BuildExtension.Key` are:"
msgstr "Qualquer uma das extensões acima que opere com `BuildExtension.BuildContext` pode aproveitar certos metadados de tempo de construção que são gerados durante a construção. As chaves incorporadas localizadas em `io.quarkus.arc.processor.BuildExtension.Key` são:"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:628
#, fuzzy, no-wrap
msgid "ANNOTATION_STORE"
msgstr "LOJA_DE_ANOTAÇÕES"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:629
#, fuzzy
msgid "Contains an `AnnotationStore` that keeps information about all `AnnotationTarget` annotations after application of annotation transformers"
msgstr "Contém um `AnnotationStore` que mantém informações sobre todas as anotações `AnnotationTarget` após a aplicação de transformadores de anotações"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:629
#, fuzzy, no-wrap
msgid "INJECTION_POINTS"
msgstr "PONTOS_DE_INJECÇÃO"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:630
#, fuzzy
msgid "`Collection<InjectionPointInfo>` containing all injection points"
msgstr "`Collection&amp;lt;InjectionPointInfo&amp;gt;` que contém todos os pontos de injeção"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:630
#, fuzzy, no-wrap
msgid "BEANS"
msgstr "FEIJÕES"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:631
#, fuzzy
msgid "`Collection<BeanInfo>` containing all beans"
msgstr "`Collection&amp;lt;BeanInfo&amp;gt;` contendo todos os feijões"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:631
#, fuzzy, no-wrap
msgid "REMOVED_BEANS"
msgstr "FEIJÕES REMOVIDOS"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:632
#, fuzzy
msgid "`Collection<BeanInfo>` containing all the removed beans; see xref:cdi-reference.adoc#remove_unused_beans[Removing unused beans] for more information"
msgstr "`Collection&amp;lt;BeanInfo&amp;gt;` contendo todos os beans removidos; para mais informações, ver  link:cdi-reference.html#remove_unused_beans[Remoção de beans não utilizados]"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:632
#, fuzzy, no-wrap
msgid "OBSERVERS"
msgstr "OBSERVADORES"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:633
#, fuzzy
msgid "`Collection<ObserverInfo>` containing all observers"
msgstr "`Collection&amp;lt;ObserverInfo&amp;gt;` contendo todos os observadores"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:633
#, fuzzy, no-wrap
msgid "SCOPES"
msgstr "ESCOPAS"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:634
#, fuzzy
msgid "`Collection<ScopeInfo>` containing all scopes, including custom ones"
msgstr "`Collection&amp;lt;ScopeInfo&amp;gt;` contendo todos os âmbitos de aplicação, incluindo os personalizados"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:634
#, fuzzy, no-wrap
msgid "QUALIFIERS"
msgstr "QUALIFICADORES"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:635
#, fuzzy
msgid "`Map<DotName, ClassInfo>` containing all qualifiers"
msgstr "`Map&amp;lt;DotName, ClassInfo&amp;gt;` contendo todos os qualificadores"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:635
#, fuzzy, no-wrap
msgid "INTERCEPTOR_BINDINGS"
msgstr "LIGAÇÕES DE INTERCEPTORES"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:636
#, fuzzy
msgid "`Map<DotName, ClassInfo>` containing all interceptor bindings"
msgstr "`Map&amp;lt;DotName, ClassInfo&amp;gt;` contendo todas as ligações de interceptores"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:636
#, fuzzy, no-wrap
msgid "STEREOTYPES"
msgstr "ESTEREÓTIPOS"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:637
#, fuzzy
msgid "`Map<DotName, StereotypeInfo>` containing all stereotypes"
msgstr "`Map&amp;lt;DotName, StereotypeInfo&amp;gt;` contendo todos os estereótipos"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:642
#, fuzzy
msgid "To get hold of these, simply query the extension context object for given key.  Note that these metadata are made available as build proceeds which means that extensions can only leverage metadata that were built before the extensions are invoked.  If your extension attempts to retrieve metadata that wasn't yet produced, `null` will be returned.  Here is a summary of which extensions can access which metadata:"
msgstr "Para os obter, basta consultar o objeto de contexto da extensão para uma determinada chave. Note-se que estes metadados são disponibilizados à medida que a compilação avança, o que significa que as extensões só podem aproveitar os metadados que foram compilados antes de as extensões serem invocadas. Se a sua extensão tentar obter metadados que ainda não foram produzidos, será devolvido `null`. Aqui está um resumo de quais extensões podem acessar quais metadados:"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:643
#, fuzzy, no-wrap
msgid "AnnotationsTransformer"
msgstr "AnotaçõesTransformador"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:644
#, fuzzy
msgid "Shouldn't rely on any metadata as it could be used at any time in any phase of the bootstrap"
msgstr "Não deve depender de quaisquer metadados, uma vez que pode ser utilizado em qualquer altura e em qualquer fase do arranque"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:644
#, fuzzy, no-wrap
msgid "ContextRegistrar"
msgstr "Registrador de contexto"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:645
#: upstream/_guides/cdi-integration.adoc:646
#: upstream/_guides/cdi-integration.adoc:647
#, fuzzy
msgid "Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`"
msgstr "Tem acesso a `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:645
#, fuzzy, no-wrap
msgid "InjectionPointsTransformer"
msgstr "InjectionPointsTransformer (Transformador de pontos de injeção)"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:646
#, fuzzy, no-wrap
msgid "ObserverTransformer"
msgstr "ObservadorTransformador"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:647
#, fuzzy, no-wrap
msgid "BeanRegistrar"
msgstr "Registrador de feijão"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:648
#, fuzzy
msgid "Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`, `BEANS` (class-based beans only), `OBSERVERS` (class-based observers only), `INJECTION_POINTS`"
msgstr "Tem acesso a `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`, `BEANS` (apenas feijões baseados em classes), `OBSERVERS` (apenas observadores baseados em classes), `INJECTION_POINTS`"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:648
#, fuzzy, no-wrap
msgid "ObserverRegistrar"
msgstr "ObservadorRegistador"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:649
#, fuzzy
msgid "Has access to `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`, `BEANS`, `OBSERVERS` (class-based observers only), `INJECTION_POINTS`"
msgstr "Tem acesso a `ANNOTATION_STORE`, `QUALIFIERS`, `INTERCEPTOR_BINDINGS`, `STEREOTYPES`, `BEANS`, `OBSERVERS` (apenas observadores por turma), `INJECTION_POINTS`"

#. type: Labeled list
#: upstream/_guides/cdi-integration.adoc:649
#, fuzzy, no-wrap
msgid "BeanDeploymentValidator"
msgstr "Validador de implantação de feijões (BeanDeploymentValidator)"

#. type: Plain text
#: upstream/_guides/cdi-integration.adoc:649
#, fuzzy
msgid "Has access to all build metadata"
msgstr "Tem acesso a todos os metadados de construção"
