# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-06-17 02:55+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:6
#, no-wrap
msgid "Amazon Lambda with RESTEasy Reactive, Undertow, or Reactive Routes"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:15
msgid "With Quarkus you can deploy your favorite Java HTTP frameworks as Amazon Lambda's using either the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[AWS Gateway HTTP API] or https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[AWS Gateway REST API].  This means that you can deploy your microservices written with RESTEasy Reactive (JAX-RS), Undertow (servlet), Reactive Routes, xref:funqy-http.adoc[Funqy HTTP] or any other Quarkus HTTP framework as an AWS Lambda."
msgstr "Con Quarkus puede implementar sus marcos Java HTTP favoritos como Amazon Lambda utilizando la https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[API HTTP de AWS Gateway] o https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[la API REST de AWS Gateway]. Esto significa que puede implementar sus microservicios escritos con RESTEasy Reactive (JAX-RS), Undertow (servlet), Reactive Routes, xref:funqy-http.adoc[Funqy HTTP] o cualquier otro marco HTTP de Quarkus como un AWS Lambda."

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:18
msgid "You can deploy your Lambda as a pure Java jar, or you can compile your project to a native image and deploy that for a smaller memory footprint and startup time.  Our integration also generates SAM deployment files that can be consumed by https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html[Amazon's SAM framework]."
msgstr "Puede desplegar su Lambda como una jar de Java, o puede compilar su proyecto en una imagen nativa y desplegarla para obtener una menor huella de memoria y tiempo de inicio. Nuestra integración también genera archivos de despliegue SAM que pueden ser consumidos por https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html[el framework SAM de Amazon]."

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:22
msgid "Quarkus has a different extension for each Gateway API.  The HTTP Gateway API is implemented within the `quarkus-amazon-lambda-http` extension.  The REST Gateway API is implemented within the `quarkus-amazon-lambda-rest` extension.  If you are confused on which Gateway product to use, Amazon has a https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[great guide] to help you navigate this decision."
msgstr "Quarkus tiene una extensión diferente para cada API de Gateway. La API HTTP Gateway se implementa dentro de la extensión `quarkus-amazon-lambda-http`. La API REST Gateway se implementa dentro de la extensión `quarkus-amazon-lambda-rest`. Si estás confundido sobre qué producto Gateway utilizar, Amazon tiene una https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[excelente guía] para ayudarte a tomar esta decisión."

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:24
msgid "Like most Quarkus extensions, the Quarkus AWS Lambda HTTP/REST extensions support Live Coding."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:27
#, no-wrap
msgid "Prerequisites"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:32
msgid "https://aws.amazon.com[An Amazon AWS account]"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:33
msgid "https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]"
msgstr "https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]"

#. type: Title ==
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:34
#, no-wrap
msgid "Getting Started"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:38
#, fuzzy
#| msgid "This guide walks you through generating an example Java project via a Maven archetype.  Later on it walks through the structure of the project so you can adapt any existing projects you have to use Amazon Lambda."
msgid "This guide walks you through generating an example Java project via a Maven archetype.  Later on, it walks through the structure of the project so you can adapt any existing projects you have to use Amazon Lambda."
msgstr "Esta guía le acompaña a través de la generación de un proyecto Java de ejemplo a través de un arquetipo de Maven. Más adelante, le guiará por la estructura del proyecto para que pueda adaptar cualquier proyecto existente que tenga para utilizar Amazon Lambda."

#. type: Title ==
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:39
#, no-wrap
msgid "Installing AWS bits"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:43
msgid "Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps for installing AWS SAM CLI."
msgstr "Instalar todos los bits de AWS es probablemente lo más difícil de esta guía. Asegúrate de seguir todos los pasos para instalar AWS SAM CLI."

#. type: Title ==
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:44
#, no-wrap
msgid "Creating the Maven Deployment Project"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:47
msgid "Create the Quarkus AWS Lambda Maven project using our Maven Archetype."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:49
msgid "If you want to use the AWS Gateway HTTP API, generate your project with this script:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:55
#, no-wrap
msgid ""
"mvn archetype:generate \\\n"
"       -DarchetypeGroupId=io.quarkus \\\n"
"       -DarchetypeArtifactId=quarkus-amazon-lambda-http-archetype \\\n"
"       -DarchetypeVersion={quarkus-version}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:58
msgid "If you want to use the AWS Gateway REST API, generate your project with this script:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:64
#, no-wrap
msgid ""
"mvn archetype:generate \\\n"
"       -DarchetypeGroupId=io.quarkus \\\n"
"       -DarchetypeArtifactId=quarkus-amazon-lambda-rest-archetype \\\n"
"       -DarchetypeVersion={quarkus-version}\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:67
#, no-wrap
msgid "Build and Deploy"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:70
msgid "Build the project:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:76
msgid "This will compile the code and run the unit tests included within the generated project.  Unit testing is the same as any other Java project and does not require running on Amazon.  Quarkus dev mode is also available with this extension."
msgstr "Esto compilará el código y ejecutará las pruebas unitarias incluidas en el proyecto generado. Las pruebas unitarias son las mismas que en cualquier otro proyecto Java y no requieren ser ejecutadas en Amazon. El modo Quarkus dev también está disponible con esta extensión."

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:79
msgid "If you want to build a native executable, make sure you have GraalVM installed correctly and just add a `native` property to the build"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:85
msgid "If you are building on a non-Linux system, you will need to also pass in a property instructing quarkus to use a Docker build as Amazon Lambda requires Linux binaries.  You can do this by passing `-Dquarkus.native.container-build=true` to your build command.  This requires you to have Docker installed locally, however."
msgstr "Si estás construyendo en un sistema que no es Linux, tendrás que pasar también una propiedad que indique a quarkus que utilice una construcción Docker, ya que Amazon Lambda requiere binarios Linux. Puedes hacer esto pasando `-Dquarkus.native.container-build=true` a tu comando de construcción. Sin embargo, esto requiere que tengas Docker instalado localmente."

#. type: Title ==
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:88
#, no-wrap
msgid "Extra Build Generated Files"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:92
#, fuzzy
#| msgid "After you run the build, there are a few extra files generated by the Quarkus lambda extension you are using.  These files are in the the build directory: `target/` for Maven, `build/` for Gradle."
msgid "After you run the build, there are a few extra files generated by the Quarkus lambda extension you are using.  These files are in the build directory: `target/` for Maven, `build/` for Gradle."
msgstr "Después de ejecutar la construcción, hay algunos archivos adicionales generados por la extensión lambda de Quarkus que estás utilizando. Estos archivos están en el directorio de construcción: `target/` para Maven, `build/` para Gradle."

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:94
msgid "`function.zip` - lambda deployment file"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:95
msgid "`sam.jvm.yaml` - sam cli deployment script"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:96
msgid "`sam.native.yaml` - sam cli deployment script for native"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:97
#, no-wrap
msgid "Live Coding and Simulating AWS Lambda Environment Locally"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:103
msgid "In dev and test mode, Quarkus will start a mock AWS Lambda event server that will convert HTTP requests to the corresponding API Gateway event types and post them to the underlying Quarkus HTTP lambda environment for processing.  This simulates the AWS Lambda environment as much as possible locally without requiring tools like Docker and SAM CLI."
msgstr "En el modo de desarrollo y prueba, Quarkus iniciará un servidor de eventos AWS Lambda falso que convertirá las solicitudes HTTP en los tipos de eventos de API Gateway correspondientes y los enviará al entorno HTTP Lambda subyacente de Quarkus para su procesamiento. Esto simula el entorno de AWS Lambda tanto como sea posible localmente sin requerir herramientas como Docker y SAM CLI."

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:107
msgid "When using Quarkus Dev Mode just invoke HTTP requests on `http://localhost:8080` as you normally would when testing your REST endpoints.  This request will hit the Mock Event Server and will be converted to the API Gateway json message that is consumed by the Quarkus Lambda Poll loop."
msgstr "Cuando se utiliza el Modo Dev de Quarkus sólo hay que invocar peticiones HTTP en `http://localhost:8080` como lo harías normalmente al probar tus endpoints REST. Esta solicitud llegará al Servidor de Eventos Mock y se convertirá en el mensaje json de API Gateway que es consumido por el bucle Quarkus Lambda."

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:110
msgid "For testing, Quarkus starts up a separate Mock Event server under port 8081.  The default port for Rest Assured is automatically set to 8081 by Quarkus, so you don't have to worry about setting this up."
msgstr "Para las pruebas, Quarkus inicia un servidor de Eventos Mock separado bajo el puerto 8081. El puerto por defecto para Rest Assured se establece automáticamente en 8081 por Quarkus, por lo que no tiene que preocuparse de configurar esto."

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:115
msgid "If you want to simulate more complex API Gateway events in your tests, then manually do an HTTP POST to `http://localhost:8080/\\_lambda_` (port 8081 in test mode) with the raw API Gateway json events.  These events will be placed directly on the Quarkus Lambda poll loop for processing.  Here's an example of that:"
msgstr "Si quieres simular eventos más complejos de la API Gateway en tus pruebas, entonces haz manualmente un HTTP POST a `http://localhost:8080/_lambda_` (puerto 8081 en modo de prueba) con los eventos json de API Gateway sin procesar. Estos eventos se colocarán directamente en el bucle de Quarkus Lambda para su procesamiento. Aquí hay un ejemplo de eso:"

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:120
#, no-wrap
msgid ""
"import static io.restassured.RestAssured.given;\n"
"import static org.hamcrest.CoreMatchers.equalTo;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:122
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:445
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:486
#, no-wrap
msgid "import com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:124
#, no-wrap
msgid "import io.quarkus.test.junit.QuarkusTest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:134
#, no-wrap
msgid ""
"@QuarkusTest\n"
"public class AmazonLambdaSimpleTestCase {\n"
"    @Test\n"
"    public void testJaxrsCognitoJWTSecurityContext() throws Exception {\n"
"        APIGatewayV2HTTPEvent request = request(\"/security/username\");\n"
"        request.getRequestContext().setAuthorizer(new APIGatewayV2HTTPEvent.RequestContext.Authorizer());\n"
"        request.getRequestContext().getAuthorizer().setJwt(new APIGatewayV2HTTPEvent.RequestContext.Authorizer.JWT());\n"
"        request.getRequestContext().getAuthorizer().getJwt().setClaims(new HashMap<>());\n"
"        request.getRequestContext().getAuthorizer().getJwt().getClaims().put(\"cognito:username\", \"Bill\");\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:145
#, no-wrap
msgid ""
"        given()\n"
"                .contentType(\"application/json\")\n"
"                .accept(\"application/json\")\n"
"                .body(request)\n"
"                .when()\n"
"                .post(\"/_lambda_\")\n"
"                .then()\n"
"                .statusCode(200)\n"
"                .body(\"body\", equalTo(\"Bill\"));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:148
msgid "The above example simulates sending a Cognito principal with an HTTP request to your HTTP Lambda."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:153
msgid "If you want to hand code raw events for the AWS HTTP API, the AWS Lambda library has the request event type which is `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` and the response event type of `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse`.  This corresponds to the `quarkus-amazon-lambda-http` extension and the AWS HTTP API."
msgstr "Si desea codificar a mano eventos sin procesar para la API de AWS HTTP, la biblioteca de AWS Lambda tiene el tipo de evento de solicitud que es `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` y el tipo de evento de respuesta de `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse`. Esto corresponde a la extensión `quarkus-amazon-lambda-http` y a la API de AWS HTTP."

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:157
msgid "If you want to hand code raw events for the AWS REST API, Quarkus has its own implementation: `io.quarkus.amazon.lambda.http.model.AwsProxyRequest` and `io.quarkus.amazon.lambda.http.model.AwsProxyResponse`.  This corresponds to `quarkus-amazon-lambda-rest` extension and the AWS REST API."
msgstr "Si quieres codificar a mano los eventos en bruto para la API de AWS REST, Quarkus tiene su propia implementación: `io.quarkus.amazon.lambda.http.model.AwsProxyRequest` y `io.quarkus.amazon.lambda.http.model.AwsProxyResponse`. Esto corresponde a la extensión `quarkus-amazon-lambda-rest` y a la API REST de AWS."

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:160
msgid "The mock event server is also started for `@NativeImageTest` and `@QuarkusIntegrationTest` tests so will work with native binaries too.  All this provides similar functionality to the SAM CLI local testing, without the overhead of Docker."
msgstr "El servidor de eventos simulados también se inicia para las pruebas de `@NativeImageTest` y `@QuarkusIntegrationTest`, por lo que también funcionará con binarios nativos. Todo esto proporciona una funcionalidad similar a las pruebas locales de SAM CLI, sin la sobrecarga de Docker."

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:163
msgid "Finally, if port 8080 or port 8081 is not available on your computer, you can modify the dev and test mode ports with application.properties"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:168
#, no-wrap
msgid ""
"quarkus.lambda.mock-event-server.dev-port=8082\n"
"quarkus.lambda.mock-event-server.test-port=8083\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:171
msgid "A port value of zero will result in a randomly assigned port."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:172
#, no-wrap
msgid "Simulate Amazon Lambda Deployment with SAM CLI"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:176
msgid "The AWS SAM CLI allows you to run your lambda's locally on your laptop in a simulated Lambda environment.  This requires Docker to be installed.  After you have built your Maven project, execute this command:"
msgstr "La CLI de AWS SAM le permite ejecutar sus lambdas localmente en su portátil en un entorno de lambda simulado. Esto requiere que Docker esté instalado. Después de haber construido su proyecto Maven, ejecute este comando:"

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:180
#, no-wrap
msgid "sam local start-api --template target/sam.jvm.yaml\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:184
msgid "This will start a Docker container that mimics Amazon's Lambda's deployment environment. Once the environment is started you can invoke the example lambda in your browser by going to:"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:186
msgid "http://127.0.0.1:3000/hello"
msgstr "http://127.0.0.1:3000/hello"

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:189
msgid "In the console you'll see startup messages from the lambda.  This particular deployment starts a JVM and loads your lambda as pure Java."
msgstr "En la consola verás los mensajes de inicio de la lambda. Este despliegue particular inicia una JVM y carga tu lambda como Java puro."

#. type: Title ==
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:191
#, no-wrap
msgid "Deploy to AWS"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:196
#, no-wrap
msgid "sam deploy -t target/sam.jvm.yaml -g\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:200
msgid "Answer all the questions and your lambda will be deployed and the necessary hooks to the API Gateway will be set up. If everything deploys successfully, the root URL of your microservice will be output to the console.  Something like this:"
msgstr "Responde a todas las preguntas y tu lambda se desplegará y se configurarán los hooks necesarios para el API Gateway. Si todo se despliega con éxito, la URL raíz de tu microservicio se mostrará en la consola. Algo así:"

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:205
#, no-wrap
msgid ""
"Key                 LambdaHttpApi\n"
"Description         URL for application\n"
"Value               https://234asdf234as.execute-api.us-east-1.amazonaws.com/\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:208
msgid "The `Value` attribute is the root URL for your lambda. Copy it to your browser and add `hello` at the end."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:214
#, fuzzy
#| msgid "Responses for binary types will be automatically encoded with base64.  This is different than the behavior using `quarkus:dev` which will return the raw bytes.  Amazon's API has additional restrictions requiring the base64 encoding.  In general, client code will automatically handle this encoding but in certain custom situations, you should be aware you may need to manually manage that encoding."
msgid "Responses for binary types will be automatically encoded with base64.  This is different from the behavior using `quarkus:dev` which will return the raw bytes.  Amazon's API has additional restrictions requiring the base64 encoding.  In general, client code will automatically handle this encoding but in certain custom situations, you should be aware you may need to manually manage that encoding."
msgstr "Las respuestas para los tipos binarios se codificarán automáticamente con base64. Esto es diferente al comportamiento usando `quarkus:dev` que devolverá los bytes sin procesar. La API de Amazon tiene restricciones adicionales que requieren la codificación base64. En general, el código del cliente manejará automáticamente esta codificación, pero en ciertas situaciones personalizadas, debes tener en cuenta que puedes necesitar manejar manualmente esa codificación."

#. type: Title ==
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:215
#, no-wrap
msgid "Deploying a native executable"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:218
msgid "To deploy a native executable, you must build it with GraalVM."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:222
msgid "You can then test the executable locally with sam local"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:226
#, no-wrap
msgid "sam local start-api --template target/sam.native.yaml\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:229
msgid "To deploy to AWS Lambda:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:232
#, no-wrap
msgid "sam deploy -t target/sam.native.yaml -g\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:234
#, no-wrap
msgid "Examine the POM"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:239
#, fuzzy
#| msgid "There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda-http` extension (if you are deploying an AWS Gateway HTTP API) or the `quarkus-amazon-lambda-rest` extension (if you are deploy an AWS Gateway REST API).  These extensions automatically generate everything you might need for your lambda deployment."
msgid "There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda-http` extension (if you are deploying an AWS Gateway HTTP API) or the `quarkus-amazon-lambda-rest` extension (if you are deploying an AWS Gateway REST API).  These extensions automatically generate everything you might need for your lambda deployment."
msgstr "No hay nada especial en el POM aparte de la inclusión de la extensión `quarkus-amazon-lambda-http` (si está implementando una API HTTP de AWS Gateway) o la extensión `quarkus-amazon-lambda-rest` (si está implementando una API REST de AWS Gateway). Estas extensiones generan automáticamente todo lo que pueda necesitar para su implementación de Lambda."

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:243
msgid "Also, at least in the generated Maven archetype `pom.xml`, the `quarkus-resteasy-reactive`, `quarkus-reactive-routes`, and `quarkus-undertow` dependencies are all optional.  Pick which HTTP framework(s) you want to use (JAX-RS, Reactive Routes, and/or Servlet) and remove the other dependencies to shrink your deployment."
msgstr "Además, al menos en el arquetipo de Maven generado `pom.xml`, las dependencias `quarkus-resteasy-reactive`, `quarkus-reactive-routes`, y `quarkus-undertow` son todas opcionales. Escoge qué marco(s) HTTP quieres usar (JAX-RS, Reactive Routes, y/o Servlet) y elimina las otras dependencias para reducir tu despliegue."

#. type: Title ===
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:244
#, no-wrap
msgid "Examine sam.yaml"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:248
msgid "The `sam.yaml` syntax is beyond the scope of this document.  There's a couple of things that must be highlighted just in case you are going to craft your own custom `sam.yaml` deployment files."
msgstr "La sintaxis de `sam.yaml` está fuera del alcance de este documento. Hay un par de cosas que hay que resaltar en caso de que vayas a elaborar tus propios archivos de despliegue personalizados de `sam.yaml`."

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:251
msgid "The first thing to note is that for pure Java lambda deployments require a specific handler class.  Do not change the Lambda handler name."
msgstr "Lo primero que hay que tener en cuenta es que para las implantaciones de lambda en Java puro se requiere una clase manejadora específica. No cambie el nombre del manejador Lambda."

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:257
#, no-wrap
msgid ""
"     Properties:\n"
"        Handler: io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest\n"
"        Runtime: java11\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:260
msgid "This handler is a bridge between the lambda runtime and the Quarkus HTTP framework you are using (JAX-RS, Servlet, etc.)"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:263
msgid "If you want to go native, there's an environment variable that must be set for native GraalVM deployments.  If you look at `sam.native.yaml` you'll see this:"
msgstr "Si quieres ir de forma nativa, hay una variable de entorno que se debe establecer para los despliegues nativos de GraalVM. Si miras en `sam.native.yaml` verás esto:"

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:269
#, no-wrap
msgid ""
"        Environment:\n"
"          Variables:\n"
"            DISABLE_SIGNAL_HANDLERS: true\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:272
msgid "This environment variable resolves some incompatibilities between Quarkus and the Amazon Lambda Custom Runtime environment."
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:277
msgid "Finally, there is one specific thing for AWS Gateway REST API deployments.  That API assumes that HTTP response bodies are text unless you explicitly tell it which media types are binary through configuration.  To make things easier, the Quarkus extension forces a binary (base 64) encoding of all HTTP response messages and the `sam.yaml` file must configure the API Gateway to assume all media types are binary:"
msgstr "Por último, hay una cosa específica para las implementaciones de la API REST de AWS Gateway. Esa API asume que los cuerpos de las respuestas HTTP son texto, a menos que se le indique explícitamente qué tipos de medios son binarios mediante la configuración. Para facilitar las cosas, la extensión de Quarkus fuerza una codificación binaria (base 64) de todos los mensajes de respuesta HTTP y el archivo `sam.yaml` debe configurar la API Gateway para asumir que todos los tipos de medios son binarios:"

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:285
#, no-wrap
msgid ""
"  Globals:\n"
"    Api:\n"
"      EndpointConfiguration: REGIONAL\n"
"      BinaryMediaTypes:\n"
"        - \"*/*\"\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:287
#, no-wrap
msgid "Injectable AWS Context Variables"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:291
msgid "If you are using RESTEasy Reactive and JAX-RS, you can inject various AWS Context variables into your JAX-RS resource classes using the JAX-RS `@Context` annotation or anywhere else with the CDI `@Inject` annotation."
msgstr "Si utiliza RESTEasy Reactive y JAX-RS, puede inyectar varias variables de contexto de AWS en sus clases de recursos JAX-RS utilizando la anotación JAX-RS `@Context` o en cualquier otro lugar con la anotación CDI `@Inject`."

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:294
msgid "For the AWS HTTP API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent`.  Here is an example:"
msgstr "Para la API HTTP de AWS puedes inyectar las variables de AWS `com.amazonaws.services.lambda.runtime.Context` y `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent`. Aquí tienes un ejemplo:"

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:299
#, no-wrap
msgid ""
"import javax.ws.rs.core.Context;\n"
"import com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:305
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:330
#, no-wrap
msgid ""
"@Path(\"/myresource\")\n"
"public class MyResource {\n"
"    @GET\n"
"    public String ctx(@Context com.amazonaws.services.lambda.runtime.Context ctx) { }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:308
#, no-wrap
msgid ""
"    @GET\n"
"    public String event(@Context APIGatewayV2HTTPEvent event) { }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:311
#, no-wrap
msgid ""
"    @GET\n"
"    public String requestContext(@Context APIGatewayV2HTTPEvent.RequestContext req) { }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:314
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:338
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:318
msgid "For the AWS REST API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext`.  Here is an example:"
msgstr "Para la API de AWS REST puedes inyectar las variables de AWS `com.amazonaws.services.lambda.runtime.Context` y `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext`. Aquí tienes un ejemplo:"

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:324
#, no-wrap
msgid ""
"import javax.ws.rs.core.Context;\n"
"import io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext;\n"
"import io.quarkus.amazon.lambda.http.model.AwsProxyRequest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:333
#, no-wrap
msgid ""
"    @GET\n"
"    public String reqContext(@Context AwsProxyRequestContext req) { }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:336
#, no-wrap
msgid ""
"    @GET\n"
"    public String req(@Context AwsProxyRequest req) { }\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:340
#, no-wrap
msgid "Tracing with AWS XRay and GraalVM"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:345
#, fuzzy
#| msgid "If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray library is not fully compatible with GraalVM so we had to do some integration work to make this work."
msgid "If you are building native images, and want to use https://aws.amazon.com/xray[AWS X-Ray Tracing] with your lambda you will need to include `quarkus-amazon-lambda-xray` as a dependency in your pom.  The AWS X-Ray library is not fully compatible with GraalVM, so we had to do some integration work to make this work."
msgstr "Si estás construyendo imágenes nativas, y quieres usar https://aws.amazon.com/xray[AWS X-Ray Tracing] con tu lambda necesitarás incluir `quarkus-amazon-lambda-xray` como una dependencia en tu pom. La biblioteca de AWS X-Ray no es totalmente compatible con GraalVM, por lo que hemos tenido que hacer un trabajo de integración para que funcione."

#. type: Title ==
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:346
#, no-wrap
msgid "Security Integration"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:351
msgid "When you invoke an HTTP request on the API Gateway, the Gateway turns that HTTP request into a JSON event document that is forwarded to a Quarkus Lambda.  The Quarkus Lambda parses this json and converts in into an internal representation of an HTTP request that can be consumed by any HTTP framework Quarkus supports (JAX-RS, servlet, Reactive Routes)."
msgstr "Cuando se invoca una solicitud HTTP en la pasarela de la API, la pasarela convierte esa solicitud HTTP en un documento de evento JSON que se reenvía a un Quarkus Lambda. La Lambda de Quarkus analiza este json y lo convierte en una representación interna de una solicitud HTTP que puede ser consumida por cualquier marco HTTP que Quarkus admita (JAX-RS, servlet, Rutas Reactivas)."

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:358
#, fuzzy
#| msgid "API Gateway supports many different ways to securely invoke on your HTTP endpoints that are backed by Lambda and Quarkus.  If you enable it, Quarkus will automatically parse relevant parts of the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html[event json document] and look for security based metadata and register a `java.security.Principal` internally that can be looked up in JAX-RS by injecting a `javax.ws.rs.core.SecurityContext`, via `HttpServletRequest.getUserPrincipal()` in servlet, and `RouteContext.user()` in Reactive Routes.  If you want more security information, the `Principal` object can be typecast to a class that will give you more information."
msgid "API Gateway supports many ways to securely invoke on your HTTP endpoints that are backed by Lambda and Quarkus.  If you enable it, Quarkus will automatically parse relevant parts of the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html[event json document] and look for security based metadata and register a `java.security.Principal` internally that can be looked up in JAX-RS by injecting a `javax.ws.rs.core.SecurityContext`, via `HttpServletRequest.getUserPrincipal()` in servlet, and `RouteContext.user()` in Reactive Routes.  If you want more security information, the `Principal` object can be typecast to a class that will give you more information."
msgstr "API Gateway admite muchas formas diferentes de invocar de forma segura en sus puntos finales HTTP que están respaldados por Lambda y Quarkus. Si lo habilitas, Quarkus analizará automáticamente las partes relevantes del https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html[documento json] del evento y buscará metadatos basados en la seguridad y registrará un `java.security.Principal` internamente que puede ser buscado en JAX-RS inyectando un `javax.ws.rs.core.SecurityContext`, a través de `HttpServletRequest.getUserPrincipal()` en servlet, y `RouteContext.user()` en Reactive Routes. Si quieres más información de seguridad, el objeto `Principal` puede ser typecast a una clase que te dará más información."

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:360
msgid "To enable this security feature, add this to your `application.properties` file:"
msgstr "Para activar esta función de seguridad, añada esto a su archivo `application.properties`:"

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:362
#, no-wrap
msgid "quarkus.lambda-http.enable-security=true\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:366
msgid "Here's how its mapped:"
msgstr ""

#. type: Block title
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:367
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:396
#, no-wrap
msgid "HTTP `quarkus-amazon-lambda-http`"
msgstr "HTTP `quarkus-amazon-lambda-http`"

#. type: Table
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:370
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:380
#, no-wrap
msgid "Auth Type"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:370
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:380
#, no-wrap
msgid "Principal Class"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:371
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:381
#, no-wrap
msgid "Json path of Principal Name"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:371
#, no-wrap
msgid "Cognito JWT"
msgstr "Cognito JWT"

#. type: Table
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:371
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:381
#, no-wrap
msgid "`io.quarkus.amazon.lambda.http.CognitoPrincipal`"
msgstr "`io.quarkus.amazon.lambda.http.CognitoPrincipal`"

#. type: Table
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:372
#, no-wrap
msgid "`requestContext.authorizer.jwt.claims.cognito:username`"
msgstr "`requestContext.authorizer.jwt.claims.cognito:username`"

#. type: Table
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:372
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:382
#, no-wrap
msgid "IAM"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:372
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:382
#, no-wrap
msgid "`io.quarkus.amazon.lambda.http.IAMPrincipal`"
msgstr "`io.quarkus.amazon.lambda.http.IAMPrincipal`"

#. type: Table
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:373
#, no-wrap
msgid "`requestContext.authorizer.iam.userId`"
msgstr "`requestContext.authorizer.iam.userId`"

#. type: Table
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:373
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:383
#, no-wrap
msgid "Custom Lambda"
msgstr ""

#. type: Table
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:373
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:383
#, no-wrap
msgid "`io.quarkus.amazon.lambda.http.CustomPrincipal`"
msgstr "`io.quarkus.amazon.lambda.http.CustomPrincipal`"

#. type: Table
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:375
#, no-wrap
msgid "`requestContext.authorizer.lambda.principalId`"
msgstr "`requestContext.authorizer.lambda.principalId`"

#. type: Block title
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:377
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:437
#, no-wrap
msgid "REST `quarkus-amazon-lambda-rest`"
msgstr "REST `quarkus-amazon-lambda-rest`"

#. type: Table
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:381
#, no-wrap
msgid "Cognito"
msgstr "Cognito"

#. type: Table
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:382
#, no-wrap
msgid "`requestContext.authorizer.claims.cognito:username`"
msgstr "`requestContext.authorizer.claims.cognito:username`"

#. type: Table
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:383
#, no-wrap
msgid "`requestContext.identity.user`"
msgstr "`requestContext.identity.user`"

#. type: Table
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:385
#, no-wrap
msgid "`requestContext.authorizer.principalId`"
msgstr "`requestContext.authorizer.principalId`"

#. type: Title ==
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:387
#, no-wrap
msgid "Custom Security Integration"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:395
#, fuzzy
#| msgid "The default support for AWS security only maps the principal name to Quarkus security APIs and does nothing to map claims or roles or permissions.  You have can full control how security metadata in the lambda HTTP event is mapped to Quarkus security APIs using implementations of the `io.quarkus.amazon.lambda.http.LambdaIdentityProvider` interface.  By implementing this interface, you can do things like define role mappings for your principal or publish additional attributes provided by IAM or Cognito or your Custom Lambda security integration."
msgid "The default support for AWS security only maps the principal name to Quarkus security APIs and does nothing to map claims or roles or permissions.  You have full control on how security metadata in the lambda HTTP event is mapped to Quarkus security APIs using implementations of the `io.quarkus.amazon.lambda.http.LambdaIdentityProvider` interface.  By implementing this interface, you can do things like define role mappings for your principal or publish additional attributes provided by IAM or Cognito or your Custom Lambda security integration."
msgstr "El soporte por defecto para la seguridad de AWS sólo asigna el nombre principal a las API de seguridad de Quarkus y no hace nada para asignar reclamaciones, funciones o permisos. Usted puede controlar completamente cómo se asignan los metadatos de seguridad en el evento HTTP lambda a las API de seguridad de Quarkus utilizando implementaciones de la interfaz `io.quarkus.amazon.lambda.http.LambdaIdentityProvider`. Al implementar esta interfaz, puede hacer cosas como definir asignaciones de roles para su director o publicar atributos adicionales proporcionados por IAM o Cognito o su integración de seguridad Lambda personalizada."

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:400
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:441
#, no-wrap
msgid "package io.quarkus.amazon.lambda.http;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:410
#, no-wrap
msgid ""
"/**\n"
" * Helper interface that removes some boilerplate for creating\n"
" * an IdentityProvider that processes APIGatewayV2HTTPEvent\n"
" */\n"
"public interface LambdaIdentityProvider extends IdentityProvider<LambdaAuthenticationRequest> {\n"
"    @Override\n"
"    default public Class<LambdaAuthenticationRequest> getRequestType() {\n"
"        return LambdaAuthenticationRequest.class;\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:420
#, no-wrap
msgid ""
"    @Override\n"
"    default Uni<SecurityIdentity> authenticate(LambdaAuthenticationRequest request, AuthenticationRequestContext context) {\n"
"        APIGatewayV2HTTPEvent event = request.getEvent();\n"
"        SecurityIdentity identity = authenticate(event);\n"
"        if (identity == null) {\n"
"            return Uni.createFrom().optional(Optional.empty());\n"
"        }\n"
"        return Uni.createFrom().item(identity);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:432
#, no-wrap
msgid ""
"    /**\n"
"     * You must override this method unless you directly override\n"
"     * IdentityProvider.authenticate\n"
"     *\n"
"     * @param event\n"
"     * @return\n"
"     */\n"
"    default SecurityIdentity authenticate(APIGatewayV2HTTPEvent event) {\n"
"        throw new IllegalStateException(\"You must override this method or IdentityProvider.authenticate\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:436
msgid "For HTTP, the important method to override is `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)`.  From this you will allocate a SecurityIdentity based on how you want to map security data from `APIGatewayV2HTTPEvent`"
msgstr "En el caso de HTTP, el método importante a anular es `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)`. A partir de él, asignarás una SecurityIdentity basada en cómo quieres asignar los datos de seguridad de `APIGatewayV2HTTPEvent`"

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:443
#, no-wrap
msgid "import java.util.Optional;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:451
#, no-wrap
msgid ""
"import io.quarkus.amazon.lambda.http.model.AwsProxyRequest;\n"
"import io.quarkus.security.identity.AuthenticationRequestContext;\n"
"import io.quarkus.security.identity.IdentityProvider;\n"
"import io.quarkus.security.identity.SecurityIdentity;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:458
#, no-wrap
msgid ""
"/**\n"
" * Helper interface that removes some boilerplate for creating\n"
" * an IdentityProvider that processes APIGatewayV2HTTPEvent\n"
" */\n"
"public interface LambdaIdentityProvider extends IdentityProvider<LambdaAuthenticationRequest> {\n"
"...\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:470
#, no-wrap
msgid ""
"    /**\n"
"     * You must override this method unless you directly override\n"
"     * IdentityProvider.authenticate\n"
"     *\n"
"     * @param event\n"
"     * @return\n"
"     */\n"
"    default SecurityIdentity authenticate(AwsProxyRequest event) {\n"
"        throw new IllegalStateException(\"You must override this method or IdentityProvider.authenticate\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:474
msgid "For REST, the important method to override is `LambdaIdentityProvider.authenticate(AwsProxyRequest event)`.  From this you will allocate a SecurityIdentity based on how you want to map security data from `AwsProxyRequest`."
msgstr "Para REST, el método importante que hay que anular es `LambdaIdentityProvider.authenticate(AwsProxyRequest event)`. A partir de esto, asignarás una SecurityIdentity basada en cómo quieres asignar los datos de seguridad de `AwsProxyRequest`."

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:476
msgid "Your implemented provider must be a CDI bean.  Here's an example:"
msgstr "Su proveedor implementado debe ser un bean CDI. He aquí un ejemplo:"

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:480
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:511
#, no-wrap
msgid "package org.acme;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:482
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:513
#, no-wrap
msgid "import java.security.Principal;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:484
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:515
#, no-wrap
msgid "import javax.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:491
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:522
#, no-wrap
msgid ""
"import io.quarkus.amazon.lambda.http.LambdaIdentityProvider;\n"
"import io.quarkus.security.identity.SecurityIdentity;\n"
"import io.quarkus.security.runtime.QuarkusPrincipal;\n"
"import io.quarkus.security.runtime.QuarkusSecurityIdentity;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:504
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class CustomSecurityProvider implements LambdaIdentityProvider {\n"
"    @Override\n"
"    public SecurityIdentity authenticate(APIGatewayV2HTTPEvent event) {\n"
"        if (event.getHeaders() == null || !event.getHeaders().containsKey(\"x-user\"))\n"
"            return null;\n"
"        Principal principal = new QuarkusPrincipal(event.getHeaders().get(\"x-user\"));\n"
"        QuarkusSecurityIdentity.Builder builder = QuarkusSecurityIdentity.builder();\n"
"        builder.setPrincipal(principal);\n"
"        return builder.build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:507
msgid "Here's the same example, but with the AWS Gateway REST API:"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:517
#, no-wrap
msgid "import io.quarkus.amazon.lambda.http.model.AwsProxyRequest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:535
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class CustomSecurityProvider implements LambdaIdentityProvider {\n"
"    @Override\n"
"    public SecurityIdentity authenticate(AwsProxyRequest event) {\n"
"        if (event.getMultiValueHeaders() == null || !event.getMultiValueHeaders().containsKey(\"x-user\"))\n"
"            return null;\n"
"        Principal principal = new QuarkusPrincipal(event.getMultiValueHeaders().getFirst(\"x-user\"));\n"
"        QuarkusSecurityIdentity.Builder builder = QuarkusSecurityIdentity.builder();\n"
"        builder.setPrincipal(principal);\n"
"        return builder.build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:539
msgid "Quarkus should automatically discover this implementation and use it instead of the default implementation discussed earlier."
msgstr ""

#. type: Title ==
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:540
#, no-wrap
msgid "Simple SAM Local Principal"
msgstr "Simple SAM Local Principal"

#. type: Plain text
#: upstream/_versions/main/guides/amazon-lambda-http.adoc:544
msgid "If you are testing your application with `sam local` you can hardcode a principal name to use when your application runs by setting the `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME` environment variable"
msgstr "Si está probando su aplicación con `sam local`, puede codificar un nombre principal para utilizarlo cuando se ejecute su aplicación, estableciendo la variable de entorno `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME`"
