# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-04-22 09:22+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/software-transactional-memory.adoc:6
#, fuzzy, no-wrap
msgid "Using Software Transactional Memory in Quarkus"
msgstr "Uso de la memoria transaccional de software en Quarkus"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:20
#, fuzzy
msgid "Software Transactional Memory (STM) has been around in research environments since the late 1990's and has relatively recently started to appear in products and various programming languages. We won't go into all of the details behind STM but the interested reader could look at https://groups.csail.mit.edu/tds/papers/Shavit/ShavitTouitou-podc95.pdf[this paper].  However, suffice it to say that STM offers an approach to developing transactional applications in a highly concurrent environment with some of the same characteristics of ACID transactions, which you've probably already used through JTA. Importantly though, the Durability property is relaxed (removed) within STM implementations, or at least made optional. This is not the situation with JTA, where state changes are made durable to a relational database which supports https://pubs.opengroup.org/onlinepubs/009680699/toc.pdf[the X/Open XA standard]."
msgstr "La Memoria Transaccional de Software (STM) ha estado presente en los entornos de investigación desde finales de los años 90 y ha empezado a aparecer en productos y en varios lenguajes de programación hace relativamente poco tiempo. No vamos a entrar en todos los detalles de la STM, pero el lector interesado puede consultar  link:https://groups.csail.mit.edu/tds/papers/Shavit/ShavitTouitou-podc95.pdf[este documento]. Sin embargo, basta con decir que STM ofrece un enfoque para desarrollar aplicaciones transaccionales en un entorno altamente concurrente con algunas de las mismas características de las transacciones ACID, que probablemente ya has utilizado a través de JTA. Sin embargo, es importante destacar que la propiedad de durabilidad se ha relajado (eliminado) en las implementaciones de STM, o al menos se ha hecho opcional. Esta no es la situación con JTA, donde los cambios de estado se hacen duraderos en una base de datos relacional que soporta  link:https://pubs.opengroup.org/onlinepubs/009680699/toc.pdf[el estándar X/Open XA]."

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:24
#, fuzzy
msgid "Note, the STM implementation provided by Quarkus is based on the https://narayana.io/docs/project/index.html#d0e16066[Narayana STM] implementation. This document isn't meant to be a replacement for that project's documentation so you may want to look at that for more detail. However, we will try to focus more on how you can combine some of the key capabilities into Quarkus when developing Kubernetes native applications and microservices."
msgstr "Ten en cuenta que la implementación del STM proporcionada por Quarkus se basa en la implementación  link:https://narayana.io/docs/project/index.html#d0e16066[del STM de Narayana]. Este documento no pretende ser un reemplazo de la documentación de ese proyecto, por lo que es posible que desee ver eso para obtener más detalles. Sin embargo, intentaremos centrarnos más en cómo puedes combinar algunas de las capacidades clave en Quarkus cuando desarrolles aplicaciones nativas de Kubernetes y microservicios."

#. type: Title ==
#: upstream/_guides/software-transactional-memory.adoc:25
#, fuzzy, no-wrap
msgid "Why use STM with Quarkus?"
msgstr "¿Por qué utilizar STM con Quarkus?"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:31
#, fuzzy
msgid "Now you may still be asking yourself \"Why STM instead of JTA?\" or \"What are the benefits to STM that I don't get from JTA?\" Let's try to answer those or similar questions, with a particular focus on why we think they're great for Quarkus, microservices and Kubernetes native applications. So in no specific order ..."
msgstr "Ahora puede que todavía te estés preguntando \"¿Por qué STM en lugar de JTA?\" o \"¿Qué beneficios tiene STM que no obtengo de JTA?\". Vamos a tratar de responder a esas o similares preguntas, con un enfoque particular en por qué creemos que son grandes para Quarkus, microservicios y aplicaciones nativas de Kubernetes. Así que, sin un orden específico..."

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:40
#, fuzzy
msgid "The goal of STM is to simplify object reads and writes from multiple threads/protect state from concurrent updates. The Quarkus STM implementation will safely manage any conflicts between these threads using whatever isolation model has been chosen to protect that specific state instance (object in the case of Quarkus). In Quarkus STM, there are two isolation implementations, pessimistic (the default), which would cause conflicting threads to be blocked until the original has completed its updates (committed or aborted the transaction); then there's the optimistic approach which allows all of the threads to proceed and checks for conflicts at commit time, where one or more of the threads may be forced to abort if there have been conflicting updates."
msgstr "El objetivo de STM es simplificar las lecturas y escrituras de objetos desde múltiples hilos/proteger el estado de actualizaciones concurrentes. La implementación de Quarkus STM gestionará de forma segura cualquier conflicto entre estos hilos utilizando cualquier modelo de aislamiento que se haya elegido para proteger esa instancia de estado específica (objeto en el caso de Quarkus). En Quarkus STM, hay dos implementaciones de aislamiento, la pesimista (la predeterminada), que haría que los hilos en conflicto se bloquearan hasta que el original haya completado sus actualizaciones (confirmado o abortado la transacción); luego está el enfoque optimista que permite que todos los hilos continúen y comprueba los conflictos en el momento de la confirmación, donde uno o más de los hilos pueden verse obligados a abortar si ha habido actualizaciones conflictivas."

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:54
#, fuzzy
msgid "STM objects have state but it doesn't need to be persistent (durable). In fact the default behaviour is for objects managed within transactional memory to be volatile, such that if the service or microservice within which they are being used crashes or is spawned elsewhere, e.g., by a scheduler, all state in memory is lost and the objects start from scratch. But surely you get this and more with JTA (and a suitable transactional datastore) and don't need to worry about restarting your application? Not quite. There's a trade-off here: we're doing away with persistent state and the overhead of reading from and then writing (and sync-ing) to the datastore during each transaction. This makes updates to (volatile) state very fast but you still get the benefits of atomic updates across multiple STM objects (e.g., objects your team wrote then calling objects you inherited from another team and requiring them to make all-or-nothing updates), as well as consistency and isolation in the presence of concurrent threads/users (common in distributed microservices architectures).  Furthermore, not all stateful applications need to be durable - even when JTA transactions are used, it tends to be the exception and not the rule. And as you'll see later, because applications can optionally start and control transactions, it's possible to build microservices which can undo state changes and try alternative paths."
msgstr "Los objetos STM tienen estado, pero no es necesario que sea persistente (duradero). De hecho, el comportamiento por defecto es que los objetos gestionados dentro de la memoria transaccional sean volátiles, de manera que si el servicio o microservicio en el que se están utilizando se bloquea o se genera en otro lugar, por ejemplo, por un planificador, todo el estado en la memoria se pierde y los objetos comienzan desde cero. Pero seguro que con JTA (y un almacén de datos transaccional adecuado) se consigue esto y más y no hay que preocuparse por reiniciar la aplicación. No es así. Hay una compensación: estamos eliminando el estado persistente y la sobrecarga de leer y escribir (y sincronizar) en el almacén de datos durante cada transacción. Esto hace que las actualizaciones del estado (volátil) sean muy rápidas, pero aún así se obtienen los beneficios de las actualizaciones atómicas a través de múltiples objetos STM (por ejemplo, objetos que tu equipo escribió y que luego llaman a objetos que heredaste de otro equipo y que requieren que hagan actualizaciones de todo o nada), así como la consistencia y el aislamiento en presencia de hilos/usuarios concurrentes (común en arquitecturas de microservicios distribuidos). Además, no todas las aplicaciones con estado necesitan ser duraderas - incluso cuando se utilizan transacciones JTA, tiende a ser la excepción y no la regla. Y como verás más adelante, dado que las aplicaciones pueden iniciar y controlar opcionalmente las transacciones, es posible construir microservicios que puedan deshacer los cambios de estado y probar caminos alternativos."

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:61
#, fuzzy
msgid "Another benefit of STM is composability and modularity. You can write concurrent Quarkus objects/services that can be easily composed with any other services built using STM, without exposing the details of how the objects/services are implemented. As we discussed earlier, this ability to compose objects you wrote with those other teams may have written weeks, months or years earlier, and have A, C and I properties can be hugely beneficial. Furthermore, some STM implementations, including the one Quarkus uses, support nested transactions and these allow changes made within the context of a nested (sub) transaction to later be rolled back by the parent transaction."
msgstr "Otro beneficio de STM es la componibilidad y la modularidad. Puedes escribir objetos/servicios concurrentes de Quarkus que pueden ser fácilmente compuestos con cualquier otro servicio construido usando STM, sin exponer los detalles de cómo se implementan los objetos/servicios. Como hemos comentado antes, esta capacidad de componer objetos que escribiste con los que otros equipos pueden haber escrito semanas, meses o años antes, y que tienen propiedades A, C e I puede ser enormemente beneficiosa. Además, algunas implementaciones de STM, incluida la que utiliza Quarkus, admiten transacciones anidadas y éstas permiten que los cambios realizados en el contexto de una transacción anidada (sub) sean revertidos posteriormente por la transacción principal."

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:66
#, fuzzy
msgid "Although the default for STM object state is volatile, it is possible to configure the STM implementation such that an object's state is durable. Although it's possible to configure Narayana such that different backend datastores can be used, including relational databases, the default is the local operating system file system, which means you don't need to configure anything else with Quarkus such as a database."
msgstr "Aunque el estado de los objetos STM es volátil por defecto, es posible configurar la implementación de STM para que el estado de un objeto sea duradero. Aunque es posible configurar Narayana de manera que se puedan utilizar diferentes almacenes de datos backend, incluidas las bases de datos relacionales, el valor predeterminado es el sistema de archivos del sistema operativo local, lo que significa que no es necesario configurar nada más con Quarkus, como una base de datos."

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:70
#, fuzzy
msgid "Many STM implementations allow \"plain old language objects\" to be made STM-aware with little or no changes to the application code. You can build, test and deploy applications without wanting them to be STM-aware and then later add those capabilities if they become necessary and without much development overhead at all."
msgstr "Muchas implementaciones de STM permiten hacer que los \"objetos de lenguaje corriente\" sean compatibles con STM con pocos o ningún cambio en el código de la aplicación. Se pueden crear, probar y desplegar aplicaciones sin querer que sean compatibles con STM y, más adelante, añadir esas capacidades si son necesarias y sin mucha sobrecarga de desarrollo."

#. type: Title ==
#: upstream/_guides/software-transactional-memory.adoc:71
#, fuzzy, no-wrap
msgid "Building STM applications"
msgstr "Creación de aplicaciones STM"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:78
#, fuzzy
msgid "There is also a fully worked example in the quickstarts which you may access by cloning the Git repository: `git clone {quickstarts-clone-url}`, or by downloading an {quickstarts-archive-url}[archive].  Look for the `software-transactional-memory-quickstart` example. This will help to understand how you can build STM-aware applications with Quarkus. However, before we do so there are a few basic concepts which we need to cover."
msgstr "También hay un ejemplo completamente trabajado en los quickstarts al que puedes acceder clonando el repositorio Git: `git clone {quickstarts-clone-url}`, o descargando un {quickstarts-archive-url}[archivo]. Busque el ejemplo `software-transactional-memory-quickstart`. Esto ayudará a entender cómo se pueden construir aplicaciones compatibles con STM con Quarkus. Sin embargo, antes de hacerlo hay algunos conceptos básicos que debemos cubrir."

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:84
#, fuzzy
msgid "Note, as you will see, STM in Quarkus relies on a number of annotations to define behaviours. The lack of these annotations causes sensible defaults to be assumed but it is important for the developer to understand what these may be. Please refer to the https://narayana.io/docs/project/index.html#d0e16066[Narayana STM manual] and the https://narayana.io//docs/project/index.html#d0e16133[STM annotations guide] for more details on all of the annotations Narayana STM provides."
msgstr "Tenga en cuenta que, como verá, STM en Quarkus se basa en una serie de anotaciones para definir comportamientos. La falta de estas anotaciones hace que se asuman valores por defecto sensibles, pero es importante que el desarrollador entienda cuáles pueden ser. Por favor, consulte el  link:https://narayana.io/docs/project/index.html#d0e16066[manual de Narayana STM] y la  link:https://narayana.io//docs/project/index.html#d0e16133[guía de anotaciones STM] para obtener más detalles sobre todas las anotaciones que Narayana STM proporciona."

#. type: Title ==
#: upstream/_guides/software-transactional-memory.adoc:87
#, fuzzy, no-wrap
msgid "Setting it up"
msgstr "Cómo se prepara"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:90
#, fuzzy
msgid "To use the extension include it as a dependency in your build file:"
msgstr "Para utilizar la extensión, inclúyala como dependencia en su archivo de compilación:"

#. type: Block title
#: upstream/_guides/software-transactional-memory.adoc:92
#, fuzzy, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:98
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-narayana-stm</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/software-transactional-memory.adoc:101
#, fuzzy, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:104
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-narayana-stm\")\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/software-transactional-memory.adoc:106
#, fuzzy, no-wrap
msgid "Defining STM-aware classes"
msgstr "Definición de clases compatibles con STM"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:114
#, fuzzy
msgid "In order for the STM subsystem to have knowledge about which classes are to be managed within the context of transactional memory it is necessary to provide a minimal level of instrumentation. This occurs by categorising STM-aware and STM-unaware classes through an interface boundary; specifically all STM-aware objects must be instances of classes which inherit from interfaces that themselves have been annotated to identify them as STM-aware. Any other objects (and their classes) which do not follow this rule will not be managed by the STM subsystem and hence any of their state changes will not be rolled back, for example."
msgstr "Para que el subsistema STM sepa qué clases deben gestionarse en el contexto de la memoria transaccional, es necesario proporcionar un nivel mínimo de instrumentación. Esto se consigue clasificando las clases con y sin STM a través de un límite de interfaz; en concreto, todos los objetos con STM deben ser instancias de clases que heredan de interfaces que han sido anotadas para identificarlas como con STM. Todos los demás objetos (y sus clases) que no sigan esta regla no serán gestionados por el subsistema STM y, por lo tanto, ninguno de sus cambios de estado se revertirá, por ejemplo."

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:117
#, fuzzy
msgid "The specific annotation that STM-aware application interfaces must use is `org.jboss.stm.annotations.Transactional`.  For example:"
msgstr "La anotación específica que deben utilizar las interfaces de aplicación compatibles con STM es `org.jboss.stm.annotations.Transactional`. Por ejemplo:"

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:125
#, no-wrap
msgid ""
"@Transactional\n"
"public interface FlightService {\n"
"    int getNumberOfBookings();\n"
"    void makeBooking(String details);\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:132
#, fuzzy
msgid "Classes which implement this interface are able to use additional annotations from Narayana to tell the STM subsystem about things such as whether a method will modify the state of the object, or what state variables within the class should be managed transactionally, e.g., some instance variables may not need to be rolled back if a transaction aborts. As mentioned earlier, if those annotations are not present then defaults are chosen to guarantee safety, such as assuming all methods will modify state."
msgstr "Las clases que implementan esta interfaz pueden utilizar anotaciones adicionales de Narayana para indicar al subsistema STM cosas como si un método modificará el estado del objeto, o qué variables de estado dentro de la clase deben ser gestionadas transaccionalmente, por ejemplo, algunas variables de instancia pueden no necesitar ser revertidas si una transacción aborta. Como se mencionó anteriormente, si esas anotaciones no están presentes, se eligen valores por defecto para garantizar la seguridad, como asumir que todos los métodos modificarán el estado."

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:139
#, no-wrap
msgid ""
"public class FlightServiceImpl implements FlightService {\n"
"    @ReadLock\n"
"    public int getNumberOfBookings() { ... }\n"
"    public void makeBooking(String details) {...}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:143
#, no-wrap
msgid ""
"    @NotState\n"
"    private int timesCalled;\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:149
#, fuzzy
msgid "For example, by using the `@ReadLock` annotation on the `getNumberOfBookings` method, we are able to tell the STM subsystem that no state modifications will occur in this object when it is used in the transactional memory. Also, the `@NotState` annotation tells the system to ignore `timesCalled` when transactions commit or abort, so this value only changes due to application code."
msgstr "Por ejemplo, utilizando la anotación `@ReadLock` en el método `getNumberOfBookings`, podemos decirle al subsistema STM que no se producirán modificaciones de estado en este objeto cuando se utilice en la memoria transaccional. Además, la anotación `@NotState` le dice al sistema que ignore `timesCalled` cuando las transacciones se comprometen o abortan, por lo que este valor sólo cambia debido al código de la aplicación."

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:152
#, fuzzy
msgid "Please refer to the Narayana guide for details of how to exert finer grained control over the transactional behaviour of objects that implement interfaces marked with the `@Transactional` annotation."
msgstr "Consulte la guía Narayana para obtener detalles sobre cómo ejercer un control más preciso sobre el comportamiento transaccional de los objetos que implementan interfaces marcadas con la anotación `@Transactional`."

#. type: Title ==
#: upstream/_guides/software-transactional-memory.adoc:153
#, fuzzy, no-wrap
msgid "Creating STM objects"
msgstr "Creación de objetos STM"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:159
#, fuzzy
msgid "The STM subsystem needs to be told about which objects it should be managing. The Quarkus (aka Narayana) STM implementation does this by providing containers of transactional memory within which these object instances reside. Until an object is placed within one of these STM containers it cannot be managed within transactions and any state changes will not possess the A, C, I (or even D) properties."
msgstr "El subsistema STM necesita saber qué objetos debe gestionar. La implementación del STM de Quarkus (también conocido como Narayana) hace esto proporcionando contenedores de memoria transaccional dentro de los cuales residen estas instancias de objetos. Hasta que un objeto es colocado dentro de uno de estos contenedores STM no puede ser gestionado dentro de las transacciones y cualquier cambio de estado no poseerá las propiedades A, C, I (o incluso D)."

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:163
#, fuzzy
msgid "Note, the term \"container\" was defined within the STM implementation years before Linux containers came along. It may be confusing to use especially in a Kubernetes native environment such as Quarkus, but hopefully the reader can do the mental mapping."
msgstr "Tenga en cuenta que el término \"contenedor\" se definió dentro de la implementación de STM años antes de que aparecieran los contenedores de Linux. Puede ser confuso de usar especialmente en un entorno nativo de Kubernetes como Quarkus, pero esperamos que el lector pueda hacer el mapeo mental."

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:169
#, fuzzy
msgid "The default STM container (`org.jboss.stm.Container`) provides support for volatile objects that can only be shared between threads in the same microservice/JVM instance. When a STM-aware object is placed into the container it returns a handle through which that object should then be used in the future. It is important to use this handle as continuing to access the object through the original reference will not allow the STM subsystem to track access and manage state and concurrency control."
msgstr "El contenedor STM por defecto ( `org.jboss.stm.Container`) proporciona soporte para objetos volátiles que sólo pueden ser compartidos entre hilos en la misma instancia de microservicio/JVM. Cuando un objeto compatible con STM se coloca en el contenedor, éste devuelve un manejador a través del cual ese objeto debe ser utilizado en el futuro. Es importante utilizar este manejador, ya que si se sigue accediendo al objeto a través de la referencia original no se permitirá que el subsistema STM rastree el acceso y gestione el estado y el control de la concurrencia."

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:173
#, no-wrap
msgid "    import org.jboss.stm.Container;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:175
#, no-wrap
msgid "    ...\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:179
#, no-wrap
msgid ""
"    Container<FlightService> container = new Container<>(); <1>\n"
"    FlightServiceImpl instance = new FlightServiceImpl(); <2>\n"
"    FlightService flightServiceProxy = container.create(instance); <3>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:183
#, fuzzy
msgid "You need to tell each Container about the type of objects for which it will be responsible. In this example it will be instances that implement the FlightService interface."
msgstr "Es necesario indicar a cada Contenedor el tipo de objetos de los que será responsable. En este ejemplo serán instancias que implementen la interfaz FlightService."

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:185
#, fuzzy
msgid "Then you create an instance that implements `FlightService`. You should not use it directly at this stage because access to it is not being managed by the STM subsystem."
msgstr "A continuación, se crea una instancia que implementa `FlightService`. En esta fase no debes utilizarla directamente porque el acceso a ella no está siendo gestionado por el subsistema STM."

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:187
#, fuzzy
msgid "To obtain a managed instance, pass the original object to the STM `container` which then returns a reference through which you will be able to perform transactional operations. This reference can be used safely from multiple threads."
msgstr "Para obtener una instancia gestionada, hay que pasar el objeto original al STM `container` que devuelve una referencia a través de la cual se podrán realizar operaciones transaccionales. Esta referencia puede ser utilizada de forma segura desde múltiples hilos."

#. type: Title ==
#: upstream/_guides/software-transactional-memory.adoc:188
#, fuzzy, no-wrap
msgid "Defining transaction boundaries"
msgstr "Definir los límites de las transacciones"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:193
#, fuzzy
msgid "Once an object is placed within an STM container the application developer can manage the scope of transactions within which it is used. There are some annotations which can be applied to the STM-aware class to have the container automatically create a transaction whenever a specific method is invoked."
msgstr "Una vez que un objeto se coloca dentro de un contenedor STM, el desarrollador de la aplicación puede gestionar el alcance de las transacciones dentro de las cuales se utiliza. Hay algunas anotaciones que se pueden aplicar a la clase con STM para que el contenedor cree automáticamente una transacción siempre que se invoque un método específico."

#. type: Title ===
#: upstream/_guides/software-transactional-memory.adoc:194
#, fuzzy, no-wrap
msgid "Declarative approach"
msgstr "Enfoque declarativo"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:203
#, fuzzy
msgid "If the `@NestedTopLevel` or `@Nested` annotation is placed on a method signature then the STM container will start a new transaction when that method is invoked and attempt to commit it when the method returns. If there is a transaction already associated with the calling thread then each of these annotations behaves slightly differently: the former annotation will always create a new top-level transaction within which the method will execute, so the enclosing transaction does not behave as a parent, i.e., the nested top-level transaction will commit or abort independently; the latter annotation will create a transaction with is properly nested within the calling transaction, i.e., that transaction acts as the parent of this newly created transaction."
msgstr "Si se coloca la anotación `@NestedTopLevel` o `@Nested` en la firma de un método, el contenedor STM iniciará una nueva transacción cuando se invoque ese método e intentará consignarla cuando el método regrese. Si hay una transacción ya asociada con el hilo que llama, entonces cada una de estas anotaciones se comporta de manera ligeramente diferente: la primera anotación siempre creará una nueva transacción de nivel superior dentro de la cual se ejecutará el método, por lo que la transacción adjunta no se comporta como un padre, es decir, la transacción de nivel superior anidada se comprometerá o abortará de manera independiente; la última anotación creará una transacción con está adecuadamente anidada dentro de la transacción que llama, es decir, esa transacción actúa como el padre de esta transacción recién creada."

#. type: Title ===
#: upstream/_guides/software-transactional-memory.adoc:204
#, fuzzy, no-wrap
msgid "Programmatic approach"
msgstr "Enfoque programático"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:207
#, fuzzy
msgid "The application can programmatically start a transaction before accessing the methods of STM objects:"
msgstr "La aplicación puede iniciar programáticamente una transacción antes de acceder a los métodos de los objetos STM:"

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:211
#, no-wrap
msgid "AtomicAction aa = new AtomicAction(); <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/software-transactional-memory.adoc:224
#, no-wrap
msgid ""
"aa.begin(); <2>\n"
"{\n"
"    try {\n"
"        flightService.makeBooking(\"BA123 ...\");\n"
"        taxiService.makeBooking(\"East Coast Taxis ...\"); <3>\n"
"        <4>\n"
"        aa.commit();\n"
"        <5>\n"
"    } catch (Exception e) {\n"
"        aa.abort(); <6>\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:229
#, fuzzy
msgid "An object for manually controlling transaction boundaries (AtomicAction and many other useful classes are included in the extension).  Refer https://narayana.io//docs/api/com/arjuna/ats/arjuna/AtomicAction.html[to the javadoc] for more detail."
msgstr "Un objeto para controlar manualmente los límites de las transacciones (AtomicAction y muchas otras clases útiles están incluidas en la extensión).  link:https://narayana.io//docs/api/com/arjuna/ats/arjuna/AtomicAction.html[Consulte el javadoc] para más detalles."

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:230
#, fuzzy
msgid "Programmatically begin a transaction."
msgstr "Inicie una transacción de forma programada."

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:233
#, fuzzy
msgid "Notice that object updates can be composed which means that updates to multiple objects can be committed together as a single action.  [Note that it is also possible to begin nested transactions so that you can perform speculative work which may then be abandoned without abandoning other work performed by the outer transaction]."
msgstr "Observe que las actualizaciones de los objetos pueden ser compuestas, lo que significa que las actualizaciones de varios objetos pueden ser confirmadas juntas como una sola acción. [Obsérvese que también es posible iniciar transacciones anidadas para poder realizar un trabajo especulativo que luego puede abandonarse sin abandonar otro trabajo realizado por la transacción externa]."

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:234
#, fuzzy
msgid "Since the transaction has not yet been committed the changes made by the flight and taxi services are not visible outside of the transaction."
msgstr "Como la transacción aún no se ha comprometido, los cambios realizados por los servicios de vuelo y taxi no son visibles fuera de la transacción."

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:237
#, fuzzy
msgid "Since the commit was successful the changes made by the flight and taxi services are now visible to other threads.  Note that other transactions that relied on the old state may or may not now incur conflicts when they commit (the STM library provides a number of features for managing conflicting behaviour and these are covered in the Narayana STM manual)."
msgstr "Como la confirmación fue exitosa, los cambios hechos por los servicios de vuelo y taxi son ahora visibles para otros hilos. Tenga en cuenta que otras transacciones que se basaron en el estado anterior pueden o no incurrir en conflictos cuando se comprometen (la biblioteca STM proporciona una serie de características para la gestión de los comportamientos conflictivos y estos están cubiertos en el manual Narayana STM)."

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:238
#, fuzzy
msgid "Programmatically decide to abort the transaction which means that the changes made by the flight and taxi services are discarded."
msgstr "Decidir programáticamente abortar la transacción, lo que significa que se descartan los cambios realizados por los servicios de vuelo y taxi."

#. type: Title ==
#: upstream/_guides/software-transactional-memory.adoc:239
#, fuzzy, no-wrap
msgid "Distributed transactions"
msgstr "Transacciones distribuidas"

#. type: Plain text
#: upstream/_guides/software-transactional-memory.adoc:244
#, fuzzy
msgid "Sharing a transaction between multiple services is possible but is currently an advanced use case only and the Narayana documentation should be consulted if this behaviour is required. In particular, STM does not yet support the features described in the xref:context-propagation.adoc[Context Propagation guide]."
msgstr "Compartir una transacción entre múltiples servicios es posible, pero actualmente es un caso de uso avanzado solamente y la documentación de Narayana debe ser consultada si se requiere este comportamiento. En particular, STM aún no soporta las características descritas en la  link:context-propagation.html[guía de Propagación de Contexto]."
