# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-08-27 08:17+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/virtual-threads.adoc:7
#, no-wrap
msgid "Virtual Thread support reference"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:19
#, fuzzy
msgid "This guide explains how to benefit from Java 19+ virtual threads in Quarkus application."
msgstr "Esta guía explica cómo beneficiarse de los hilos virtuales de Java 19 al escribir servicios REST en Quarkus."

#. type: Title ==
#: upstream/_guides/virtual-threads.adoc:20
#, fuzzy, no-wrap
msgid "What are virtual threads?"
msgstr "¿Qué son los hilos virtuales?"

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:22
#, fuzzy, no-wrap
msgid "Terminology"
msgstr "Terminología"

#. type: Labeled list
#: upstream/_guides/virtual-threads.adoc:23
#, fuzzy, no-wrap
msgid "OS thread"
msgstr "Hilo conductor del sistema operativo"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:25
#, fuzzy
msgid "A \"thread-like\" data structure managed by the Operating System."
msgstr "Una estructura de datos \"tipo hilo\" gestionada por el sistema operativo."

#. type: Labeled list
#: upstream/_guides/virtual-threads.adoc:26
#, fuzzy, no-wrap
msgid "Platform thread"
msgstr "Hilo conductor de la plataforma"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:29
#, fuzzy
msgid "Until Java 19, every instance of the link:{thread}[Thread] class was a platform thread, a wrapper around an OS thread.  Creating a platform thread creates an OS thread, and blocking a platform thread blocks an OS thread."
msgstr "Hasta Java 19, cada instancia de la clase  link:{thread}[Thread] era un hilo de plataforma, es decir, una envoltura alrededor de un hilo del SO. La creación de un hilo de plataforma crea un hilo del SO, el bloqueo de un hilo de plataforma bloquea un hilo del SO."

#. type: Labeled list
#: upstream/_guides/virtual-threads.adoc:30
#, fuzzy, no-wrap
msgid "Virtual thread"
msgstr "Hilo virtual"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:33
#, fuzzy
msgid "Lightweight, JVM-managed threads. They extend the link:{thread}[Thread] class but are not tied to one specific OS thread.  Thus, scheduling virtual threads is the responsibility of the JVM."
msgstr "Hilos ligeros gestionados por la JVM. Extienden la clase  link:{thread}[Thread] pero no están ligados a un hilo específico del sistema operativo. Por lo tanto, la programación de los hilos virtuales es responsabilidad de la JVM."

#. type: Labeled list
#: upstream/_guides/virtual-threads.adoc:34
#, fuzzy, no-wrap
msgid "Carrier thread"
msgstr "Hilo conductor"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:37
#, fuzzy
msgid "A platform thread used to execute a virtual thread is called a **carrier** thread.  It isn't a class distinct from link:{Thread}[Thread] or `VirtualThread` but rather a functional denomination."
msgstr "Un hilo de plataforma utilizado para ejecutar un hilo virtual se denomina portador. No se trata de una clase distinta de  link:{Thread}[Thread] o VirtualThread, sino de una denominación funcional."

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:38
#, fuzzy, no-wrap
msgid "Differences between virtual threads and platform threads"
msgstr "Diferencias entre hilos virtuales e hilos de plataforma"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:40
#, fuzzy
msgid "We will give a brief overview of the topic here; please refer to the link:{vthreadjep}[JEP 425] for more information."
msgstr "Aquí daremos una breve visión general del tema, pero para más información consulte el  link:{vthreadjep}[PEC 425]."

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:42
#, fuzzy
msgid "Virtual threads are a feature available since Java 19, aiming at providing a cheap alternative to platform threads for I/O-bound workloads."
msgstr "Los hilos virtuales son una característica disponible desde Java 19 que tiene como objetivo proporcionar una alternativa barata a los hilos de plataforma para las cargas de trabajo de E/S."

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:46
#, fuzzy
msgid "Until now, platform threads were the concurrency unit of the JVM.  They are a wrapper over OS structures.  Creating a Java platform thread creates a \"thread-like\" structure in your operating system."
msgstr "Hasta ahora, los hilos de la plataforma eran la unidad de concurrencia de la JVM. Son una envoltura sobre las estructuras del sistema operativo. Esto significa que la creación de un hilo de plataforma Java en realidad resulta en la creación de una estructura \"similar a un hilo\" en su sistema operativo."

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:49
#, fuzzy
msgid "Virtual threads, on the other hand, are managed by the JVM. To be executed, they need to be mounted on a platform thread (which acts as a carrier to that virtual thread).  As such, they have been designed to offer the following characteristics:"
msgstr "Los hilos virtuales, en cambio, son gestionados por la JVM. Para ser ejecutados, necesitan ser montados en un hilo de la plataforma (que actúa como portador de ese hilo virtual). Como tal, han sido diseñados para ofrecer las siguientes características:"

#. type: Labeled list
#: upstream/_guides/virtual-threads.adoc:50
#, fuzzy, no-wrap
msgid "Lightweight "
msgstr "Ligero"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:54
#, fuzzy
msgid "Virtual threads occupy less space than platform threads in memory.  Hence, it becomes possible to use more virtual threads than platform threads simultaneously without blowing up the memory.  By default, platform threads are created with a stack of about 1 MB, whereas virtual threads stack is \"pay-as-you-go.\" You can find these numbers and other motivations for virtual threads in this https://youtu.be/lIq-x_iI-kc?t=543[presentation] given by the lead developer of project Loom (the project that added the virtual thread support to the JVM)."
msgstr "Los hilos virtuales ocupan menos espacio que los hilos de plataforma en la memoria. Por lo tanto, es posible utilizar más hilos virtuales que hilos de plataforma simultáneamente sin reventar la pila. Por defecto, los hilos de plataforma se crean con una pila de aproximadamente 1 MB, mientras que la pila de los hilos virtuales es \"de pago\". Puedes encontrar estos números junto con otras motivaciones para los hilos virtuales en esta presentación dada por el desarrollador principal del proyecto Loom:  https://youtu.be/lIq-x_iI-kc?t=543"

#. type: Labeled list
#: upstream/_guides/virtual-threads.adoc:55
#, fuzzy, no-wrap
msgid "Cheap to create"
msgstr "Barato de crear"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:59
#, fuzzy
msgid "Creating a platform thread in Java takes time.  Currently, techniques such as pooling, where threads are created once and then reused, are strongly encouraged to minimize the time lost in starting them (as well as limiting the maximum number of threads to keep memory consumption low).  Virtual threads are supposed to be disposable entities that we create when we need them, it is discouraged to pool them or reuse them for different tasks."
msgstr "La creación de un hilo de plataforma en Java lleva tiempo. Actualmente, se fomentan técnicas como el pooling, en el que los hilos se crean una vez y luego se reutilizan, para minimizar el tiempo que se pierde al iniciarlos (además de limitar el número máximo de hilos para mantener un bajo consumo de memoria). Se supone que los hilos virtuales son entidades desechables que creamos cuando los necesitamos, se desaconseja ponerlos en común o reutilizarlos para diferentes tareas."

#. type: Labeled list
#: upstream/_guides/virtual-threads.adoc:60
#, fuzzy, no-wrap
msgid "Cheap to block"
msgstr "Barato de bloquear"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:63
#, fuzzy
msgid "When performing blocking I/O, the underlying OS thread wrapped by the Java platform thread is put in a wait queue, and a context switch occurs to load a new thread context onto the CPU core. This operation takes time.  Since the JVM manages virtual threads, no underlying OS thread is blocked when they perform a blocking operation.  Their state is stored in the heap, and another virtual thread is executed on the same Java platform (carrier) thread."
msgstr "Cuando se realiza un bloqueo de E/S, el hilo del SO subyacente envuelto por el hilo de la plataforma Java se pone en una cola de espera y se produce un cambio de contexto para cargar un nuevo contexto de hilo en el núcleo de la CPU. Esta operación lleva tiempo. Dado que los hilos virtuales son gestionados por la JVM, ningún hilo del SO subyacente se bloquea cuando realiza una operación de bloqueo. Su estado simplemente se almacena en el montón y otro hilo virtual se ejecuta en el mismo hilo de la plataforma Java."

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:64
#, no-wrap
msgid "The Continuation Dance"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:66
msgid "As mentioned above, the JVM schedules the virtual threads. These virtual threads are mounted on carrier threads. The scheduling comes with a pinch of magic. When the virtual thread attempts to use blocking I/O, the JVM _transforms_ this call into a non-blocking one, unmounts the virtual thread, and mounts another virtual thread on the carrier thread. When the I/O completes, the _waiting_ virtual thread becomes eligible again and will be re-mounted on a carrier thread to continue its execution. For the user, all this dance is invisible. Your synchronous code is executed asynchronously."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:68
msgid "Note that the virtual thread may not be re-mounted on the same carrier thread."
msgstr ""

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:70
#, fuzzy, no-wrap
msgid "Virtual threads are useful for I/O-bound workloads only"
msgstr "Los hilos virtuales son útiles sólo para cargas de trabajo de E/S"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:78
#, fuzzy
msgid "We now know we can create more virtual threads than platform threads. One could be tempted to use virtual threads to perform long computations (CPU-bound workload).  It is useless and counterproductive.  CPU-bound doesn't consist of quickly swapping threads while they need to wait for the completion of an I/O, but in leaving them attached to a CPU core to compute something.  In this scenario, it is worse than useless to have thousands of threads if we have tens of CPU cores, virtual threads won't enhance the performance of CPU-bound workloads.  Even worse, when running a CPU-bound workload on a virtual thread, the virtual thread monopolizes the carrier thread on which it is mounted.  It will either reduce the chance for the other virtual thread to run or will start creating new carrier threads, leading to high memory usage."
msgstr "Ahora sabemos que podemos crear muchos más hilos virtuales que hilos de plataforma. Uno podría tener la tentación de utilizar hilos virtuales para realizar cálculos largos (carga de trabajo ligada a la CPU). Esto es inútil, si no contraproducente. CPU-bound no consiste en intercambiar rápidamente los hilos mientras tienen que esperar a que se complete una E/S, sino en dejarlos unidos a un núcleo de la CPU para que realmente computen algo. En este escenario, es inútil tener miles de hilos si tenemos decenas de núcleos de CPU, los hilos virtuales no mejorarán el rendimiento de las cargas de trabajo ligadas a la CPU."

#. type: Title ==
#: upstream/_guides/virtual-threads.adoc:79
#, no-wrap
msgid "Run code on virtual threads using @RunOnVirtualThread"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:84
msgid "In Quarkus, the support of virtual thread is implemented using the link:{runonvthread}[@RunOnVirtualThread] annotation.  This section briefly overviews the rationale and how to use it.  There are dedicated guides for extensions supporting that annotation, such as // TODO."
msgstr ""

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:86
#, fuzzy, no-wrap
msgid "Why not run everything on virtual threads?"
msgstr "¿Qué son los hilos virtuales?"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:93
msgid "As mentioned above, not everything can run safely on virtual threads.  The risk of **monopolization** can lead to high-memory usage.  Also, there are situations where the virtual thread cannot be unmounted from the carrier thread.  This is called **pinning**.  Finally, some libraries use `ThreadLocal` to store and reuse objects.  Using virtual threads with these libraries will lead to massive allocation, as the intentionally pooled objects will be instantiated for every (disposable and generally short-lived) virtual thread."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:99
msgid "As of today, it is not possible to use virtual threads in a carefree manner.  Following such a laissez-faire approach could quickly lead to memory and resource starvation issues.  Thus, Quarkus uses an explicit model until the aforementioned issues disappear (as the Java ecosystem matures).  It is also the reason why _reactive_ extensions have the virtual thread support, and rarely the _classic_ ones.  We need to know when to dispatch on a virtual thread."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:101
msgid "It is essential to understand that these issues are not Quarkus limitations or bugs but are due to the current state of the Java ecosystem which needs to evolve to become virtual thread friendly."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:103
msgid "To learn more about the internal design and choices, check the https://dl.acm.org/doi/10.1145/3583678.3596895[Considerations for integrating virtual threads in a Java framework: a Quarkus example in a resource-constrained environment] paper."
msgstr ""

#. type: Title ====
#: upstream/_guides/virtual-threads.adoc:105
#, no-wrap
msgid "Monopolization cases"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:109
msgid "The monopolization has been explained in the xref:cpu-bound[Virtual threads are useful for I/O-bound workloads only] section.  When running long computations, we do not allow the JVM to unmount and switch to another virtual thread until the virtual thread terminates.  Indeed, the current scheduler does not support preempting tasks."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:113
msgid "This monopolization can lead to the creation of new carrier threads to execute other virtual threads.  Creating carrier threads results in creating platform threads.  So, there is a memory cost associated with this creation."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:116
msgid "Suppose you run in a constrained environment, such as containers. In that case, monopolization can quickly become a concern, as the high memory usage can lead to out-of-memory issues and container termination.  The memory usage may be higher than with regular worker threads because of the inherent cost of the scheduling and virtual threads."
msgstr ""

#. type: Title ====
#: upstream/_guides/virtual-threads.adoc:118
#, fuzzy, no-wrap
msgid "Pinning cases"
msgstr "Casos de fijación"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:121
#, fuzzy
msgid "The promise of \"cheap blocking\" might not always hold: a virtual thread might _pin_ its carrier on certain occasions.  The platform thread is blocked in this situation, precisely as it would have been in a typical blocking scenario."
msgstr "La noción de \"bloqueo barato\" puede no ser siempre cierta: en ciertas ocasiones un hilo virtual puede \"clavar\" a su portador (el hilo de plataforma sobre el que está montado). En esta situación, el hilo de la plataforma se bloquea exactamente como lo haría en un escenario típico de bloqueo."

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:123
#, fuzzy
msgid "According to link:{vthreadjep}[JEP 425] this can happen in two situations:"
msgstr "Según  link:{vthreadjep}[el PEC 425], esto puede ocurrir en dos situaciones:"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:125
#, fuzzy
msgid "when a virtual thread performs a blocking operation inside a `synchronized` block or method"
msgstr "cuando un hilo virtual ejecuta realiza una operación de bloqueo dentro de un bloque o método de `synchronized`"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:126
#, fuzzy
msgid "when it executes a blocking operation inside a native method or a foreign function"
msgstr "cuando ejecuta una operación de bloqueo dentro de un método nativo o una función ajena"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:132
#, fuzzy
msgid "It can be reasonably easy to avoid these situations in your code, but verifying every dependency you use is hard.  Typically, while experimenting with virtual threads, we realized that old versions of the link:{pgsql-driver}[postgresql-JDBC driver] results in frequent pinning.  Most JDBC drivers still pin the carrier thread.  Even worse, lots of widespread libraries are pinning and would require code changes."
msgstr "Puede ser bastante fácil evitar estas situaciones en nuestro propio código, pero es difícil verificar cada dependencia que utilizamos. Por lo general, mientras experimentábamos con hilos virtuales, nos dimos cuenta de que el uso del  link:{pgsql-driver}[controlador postgresql-JDBC] da lugar a frecuentes pellizcos."

#. type: Title ====
#: upstream/_guides/virtual-threads.adoc:134
#, no-wrap
msgid "The pooling case"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:137
msgid "Some libraries are using `ThreadLocal` as an object pooling mechanism.  Extremely popular libraries like https://github.com/FasterXML/jackson-core/issues/919[Jackson] and Netty assume that the application uses a limited number of threads, which are recycled (using a thread pool) to run multiple (unrelated but sequential) tasks."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:139
msgid "This pattern has multiple advantages, such as:"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:141
msgid "Allocation benefit: heavy objects are only allocated once per thread, but because the number of these threads was intended to be limited, it would not use too much memory."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:142
msgid "Thread safety: only one thread can access the object stored in the thread local - preventing concurrent accesses."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:149
msgid "However, this pattern is counter-productive when using virtual threads.  Virtual threads are not pooled and generally short-lived.  So, instead of a few of them, we now have many of them.  For each of them, the object stored in the `ThreadLocal` is created (often large and expensive) and won't be reused, as the virtual thread is not pooled (and won't be used to run another task once the execution completes).  This problem leads to high memory usage.  Unfortunately, it requires sophisticated code changes in the libraries themselves."
msgstr ""

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:150
#, no-wrap
msgid "Use @RunVirtualThread with RESTEasy Reactive"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:154
msgid "This section shows a brief example of using the link:{runonvthread}[@RunOnVirtualThread] annotation.  It also explains the various development and execution models offered by Quarkus."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:157
msgid "The `@RunOnVirtualThread` annotation instructs Quarkus to invoke the annotated method on a **new** virtual thread instead of the current one.  Quarkus handles the creation of the virtual thread and the offloading."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:159
#, fuzzy
msgid "Since virtual threads are disposable entities, the fundamental idea of `@RunOnVirtualThread` is to offload the execution of an endpoint handler on a new virtual thread instead of running it on an event-loop or worker thread (in the case of RESTEasy Reactive)."
msgstr "Dado que los hilos virtuales son entidades desechables, la idea fundamental de quarkus-loom es descargar la ejecución de un manejador de punto final en un nuevo hilo virtual en lugar de ejecutarlo en un bucle de eventos (en el caso de RESTeasy-reactive) o en un hilo trabajador de la plataforma."

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:163
#, fuzzy
msgid "To do so, it suffices to add the link:{runonvthread}[@RunOnVirtualThread] annotation to the endpoint.  If the Java Virtual Machine used to **run** the application provides virtual thread support (so, Java 19 or later versions), then the endpoint execution is offloaded to a virtual thread.  It will then be possible to perform blocking operations without blocking the platform thread upon which the virtual thread is mounted."
msgstr "Para ello, basta con añadir la anotación  link:{runonvthread}[@RunOnVirtualThread] al endpoint. Si el JDK es compatible (Java 19 o versiones posteriores), el endpoint se descargará en un hilo virtual. Entonces será posible realizar operaciones de bloqueo sin bloquear el hilo de la plataforma sobre el que está montado el hilo virtual."

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:168
#, fuzzy
msgid "In the case of RESTEasy Reactive, this annotation can only be used on endpoints annotated with link:{blockingannotation}[@Blocking] or considered blocking because of their signature.  You can visit xref:resteasy-reactive.adoc#execution-model-blocking-non-blocking[Execution model, blocking, non-blocking] for more information."
msgstr "Esta anotación sólo puede utilizarse junto con endpoints anotados con  link:{blockingannotation}[@Blocking] o considerados bloqueantes por su firma. Puede visitar  link:resteasy-reactive.html#execution-model-blocking-non-blocking[Modelo de ejecución, bloqueante, no bloqueante] para más información."

#. type: Title ====
#: upstream/_guides/virtual-threads.adoc:169
#, no-wrap
msgid "Get started with virtual threads with RESTEasy Reactive"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:172
#, fuzzy
msgid "Add the following dependency to your build file:"
msgstr "Añade la siguiente importación a tu archivo de construcción:"

#. type: Block title
#: upstream/_guides/virtual-threads.adoc:174
#: upstream/_guides/virtual-threads.adoc:191
#, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:180
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-resteasy-reactive</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/virtual-threads.adoc:183
#, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:186
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-resteasy-reactive\")\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:189
#, fuzzy
msgid "Then, you also need to make sure that you are using the version 19+ of Java, this can be enforced in your pom.xml file with the following:"
msgstr "También debe asegurarse de que está utilizando la versión 19 de Java, esto puede ser aplicado en su archivo pom.xml con lo siguiente:"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:197
#, no-wrap
msgid ""
"<properties>\n"
"    <maven.compiler.source>19</maven.compiler.source>\n"
"    <maven.compiler.target>19</maven.compiler.target>\n"
"</properties>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:201
msgid "Finally, until Java 21, you need to configure your compiler plugin with the `--enable-preview` flag.  If you use Maven, make sure that the configuration of the Maven compiler plugin is the following:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:214
#, no-wrap
msgid ""
"<plugin>\n"
"  <artifactId>maven-compiler-plugin</artifactId>\n"
"  <version>${compiler-plugin.version}</version>\n"
"  <configuration>\n"
"    <compilerArgs>\n"
"      <arg>--enable-preview</arg>\n"
"      <arg>-parameters</arg>\n"
"    </compilerArgs>\n"
"  </configuration>\n"
"</plugin>\n"
msgstr ""

#. type: Title ====
#: upstream/_guides/virtual-threads.adoc:216
#, no-wrap
msgid "Three development and execution models"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:220
#, fuzzy
msgid "The example below shows the differences between three endpoints, all of them querying a _fortune_ in the database then returning it to the client."
msgstr "El ejemplo siguiente muestra las diferencias entre tres puntos finales, todos ellos consultando una fortuna en la base de datos y devolviéndola al cliente."

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:222
#, fuzzy
msgid "the first one uses the traditional blocking style, it is considered blocking due to its signature."
msgstr "el primero utiliza el estilo de bloqueo tradicional, se considera de bloqueo debido a su firma."

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:223
#, fuzzy
msgid "the second one uses Mutiny, it is considered non-blocking due to its signature."
msgstr "el segundo utiliza flujos reactivos Mutiny en un estilo declarativo, se considera no-bloqueo debido a su firma."

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:225
#, fuzzy
msgid "the third one uses Mutiny but in a synchronous way, since it doesn't return a \"reactive type\" it is considered blocking and the link:{runonvthread}[@RunOnVirtualThread] annotation can be used."
msgstr "la tercera utiliza los flujos reactivos de Mutiny de forma sincrónica, ya que al no devolver un \"tipo reactivo\" se considera de bloqueo y se puede utilizar la anotación  link:{runonvthread}[@RunOnVirtualThread]."

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:229
#, no-wrap
msgid "package org.acme.rest;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:234
#, no-wrap
msgid ""
"import org.acme.fortune.model.Fortune;\n"
"import org.acme.fortune.repository.FortuneRepository;\n"
"import io.smallrye.common.annotation.RunOnVirtualThread;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:239
#, no-wrap
msgid ""
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import java.util.List;\n"
"import java.util.Random;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:243
#, no-wrap
msgid ""
"@Path(\"\")\n"
"public class FortuneResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:245
#, no-wrap
msgid "    @Inject FortuneRepository repository;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:253
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/blocking\")\n"
"    public Fortune blocking() {\n"
"        // Runs on a worker (platform) thread\n"
"        var list = repository.findAllBlocking();\n"
"        return pickOne(list);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:261
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/reactive\")\n"
"    public Uni<Fortune> reactive() {\n"
"        // Runs on the event loop\n"
"        return repository.findAllAsync()\n"
"                .map(this::pickOne);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:270
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"/virtual\")\n"
"    @RunOnVirtualThread\n"
"    public Fortune virtualThread() {\n"
"        // Runs on a virtual thread\n"
"        var list = repository.findAllAsyncAndAwait();\n"
"        return pickOne(list);\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:272
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:275
msgid "The following table summarizes the options:"
msgstr ""

#. type: Table
#: upstream/_guides/virtual-threads.adoc:277
#, no-wrap
msgid "Model"
msgstr ""

#. type: Table
#: upstream/_guides/virtual-threads.adoc:277
#, no-wrap
msgid "Example of signature"
msgstr ""

#. type: Table
#: upstream/_guides/virtual-threads.adoc:277
#, no-wrap
msgid "Pros"
msgstr ""

#. type: Table
#: upstream/_guides/virtual-threads.adoc:279
#, no-wrap
msgid "Cons"
msgstr ""

#. type: Table
#: upstream/_guides/virtual-threads.adoc:280
#, no-wrap
msgid "Synchronous code on worker thread"
msgstr ""

#. type: Table
#: upstream/_guides/virtual-threads.adoc:281
#, no-wrap
msgid "`Fortune blocking()`"
msgstr ""

#. type: Table
#: upstream/_guides/virtual-threads.adoc:282
#: upstream/_guides/virtual-threads.adoc:292
#, no-wrap
msgid "Simple code"
msgstr ""

#. type: Table
#: upstream/_guides/virtual-threads.adoc:284
#, no-wrap
msgid "Use worker thread (limit concurrency)"
msgstr ""

#. type: Table
#: upstream/_guides/virtual-threads.adoc:285
#, no-wrap
msgid "Reactive code on event loop"
msgstr ""

#. type: Table
#: upstream/_guides/virtual-threads.adoc:286
#, no-wrap
msgid "`Uni<Fortune> reactive()`"
msgstr ""

#. type: Table
#: upstream/_guides/virtual-threads.adoc:287
#, no-wrap
msgid "High concurrency and low resource usage"
msgstr ""

#. type: Table
#: upstream/_guides/virtual-threads.adoc:289
#, no-wrap
msgid "More complex code"
msgstr ""

#. type: Table
#: upstream/_guides/virtual-threads.adoc:290
#, fuzzy, no-wrap
msgid "Synchronous code on virtual thread"
msgstr "¿Qué son los hilos virtuales?"

#. type: Table
#: upstream/_guides/virtual-threads.adoc:291
#, no-wrap
msgid "`@RunOnVirtualThread Fortune vt()`"
msgstr ""

#. type: Table
#: upstream/_guides/virtual-threads.adoc:293
#, no-wrap
msgid "Risk of pinning, monopolization and under-efficient object pooling"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:296
msgid "Note that all three models can be used in a single application."
msgstr ""

#. type: Title ==
#: upstream/_guides/virtual-threads.adoc:297
#, no-wrap
msgid "Use virtual thread friendly clients"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:301
msgid "As mentioned in the href:why-not[Why not run everything on virtual threads?] section, the Java ecosystem is not entirely ready for virtual threads.  So, you need to be careful, especially when using a libraries doing I/O."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:304
msgid "Fortunately, Quarkus provides a massive ecosystem that is ready to be used in virtual threads.  Mutiny, the reactive programming library used in Quarkus, and the Vert.x Mutiny bindings provides the ability to write blocking code (so, no fear, no learning curve) which do not pin the carrier thread."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:306
msgid "As a result:"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:309
msgid "Quarkus extensions providing blocking APIs on top of reactive APIs can be used in virtual threads.  This includes the reactive rest client, the redis client, the mailer..."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:310
msgid "API returning `Uni` can be used directly using `uni.await().atMost(...)`. It blocks the virtual thread, without blocking the carrier thread, and also improves the resilience of your application with an easy (non-blocking) timeout support."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:311
msgid "If you use a https://smallrye.io/smallrye-mutiny-vertx-bindings/latest/[Vert.x client using the Mutiny bindings], use the `andAwait()` methods which block until you get the result without pinning the carrier thread. It includes all the reactive SQL drivers."
msgstr ""

#. type: Title ==
#: upstream/_guides/virtual-threads.adoc:312
#, no-wrap
msgid "Detect pinned thread in tests"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:316
msgid "We recommend to use the following configuration when running tests in application using virtual threads.  If would not fail the tests, but at least dump start traces if the code pins the carrier thread:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:330
#, no-wrap
msgid ""
"<plugin>\n"
"  <artifactId>maven-surefire-plugin</artifactId>\n"
"  <version>${surefire-plugin.version}</version>\n"
"  <configuration>\n"
"      <systemPropertyVariables>\n"
"        <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n"
"        <maven.home>${maven.home}</maven.home>\n"
"      </systemPropertyVariables>\n"
"      <argLine>--enable-preview -Djdk.tracePinnedThreads</argLine>\n"
"  </configuration>\n"
"</plugin>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:333
msgid "The `--enable-preview` flag is not necessary with Java 21."
msgstr ""

#. type: Title ==
#: upstream/_guides/virtual-threads.adoc:334
#, fuzzy, no-wrap
msgid "Run application using virtual threads"
msgstr "¿Qué son los hilos virtuales?"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:337
#, fuzzy
msgid "Prior to Java 21, virtual threads are still an experimental feature, you need to start your application with the `--enable-preview` flag:"
msgstr "Los hilos virtuales son todavía una característica experimental, necesitas iniciar tu aplicación con la bandera `--enable-preview`:"

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:341
#, no-wrap
msgid "java --enable-preview -jar target/quarkus-app/quarkus-run.jar\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/virtual-threads.adoc:343
#, no-wrap
msgid "Build containers for application using virtual threads"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:346
msgid "When running your application in JVM mode (so not compiled into native, for native check xref:native[the dedicated section]), you can follow the xref:./container-image.adoc[containerization guide] to build a container."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:349
msgid "In this section, we use JIB to build the container.  Refer to the xref:./container-image.adoc[containerization guide] to learn more about the alternatives."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:351
msgid "To containerize your Quarkus application that use `@RunOnVirtualThread`, add the following properties in your `application.properties`:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:360
#, no-wrap
msgid ""
"quarkus.container-image.build=true\n"
"quarkus.container-image.group=<your-group-name>\n"
"quarkus.container-image.name=<you-container-name>\n"
"quarkus.jib.base-jvm-image=eclipse-temurin:20.0.1_9-jre-ubi9-minimal <1>\n"
"quarkus.jib.platforms=linux/amd64,linux/arm64 <2>\n"
"quarkus.jib.jvm-arguments=--enable-preview <3>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:362
msgid "Make sure you use a base image supporting virtual threads. Here we use an image providing Java 20."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:363
msgid "Select the target architecture. You can select more than one to build multi-archs images."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:364
msgid "Don't forget to use the `--enable-preview` flag if you are not using Java 21+."
msgstr ""

#. type: delimited block =
#: upstream/_guides/virtual-threads.adoc:367
#: upstream/_guides/virtual-threads.adoc:438
msgid "Then, build your container as you would do usually.  For example, if you are using Maven, run:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:371
#, no-wrap
msgid "mvn package\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/virtual-threads.adoc:374
#, no-wrap
msgid "Compiling Quarkus application using virtual threads into native executable"
msgstr ""

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:376
#, no-wrap
msgid "Using a local GraalVM installation"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:379
msgid "To compile a Quarkus applications leveraging `@RunOnVirtualThreads` into native executable, you must be sure to use a GraalVM / Mandrel `native-image` supporting virtual threads, so providing at least Java 19+."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:381
msgid "Then, until Java 21, you need to add the following property to your `application.properties` file:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:385
#, no-wrap
msgid "quarkus.native.additional-build-args=--enable-preview\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:389
msgid "Build the native executable as indicated on xref:./building-native-image.adoc[the native compilation guide].  For example, with Maven, run:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:393
#: upstream/_guides/virtual-threads.adoc:442
#, no-wrap
msgid "mvn package -Dnative\n"
msgstr ""

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:395
#, no-wrap
msgid "Using an in-container build"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:400
msgid "In-container build allows building Linux 64 executables by using a `native-image` compiler running in a container.  It avoids having to install `native-image` on your machine, and also allows configuring the GraalVM version you need.  Note that, to use in-container build, you must have Docker or Podman installed on your machine."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:402
msgid "Then, add to your `application.properties` file:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:406
#, no-wrap
msgid "quarkus.native.additional-build-args=--enable-preview <1>\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:410
#, no-wrap
msgid ""
"# In-container build to get a linux 64 executable\n"
"quarkus.native.container-build=true <2>\n"
"quarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel-builder-image:jdk-20 <3>\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:412
msgid "The `enable-preview` flag in only necessary until Java 21."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:413
msgid "Enables the in-container build"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:414
msgid "The builder container to use. Make sure it supports virtual threads"
msgstr ""

#. type: Block title
#: upstream/_guides/virtual-threads.adoc:416
#, no-wrap
msgid "From ARM/64 to AMD/64"
msgstr ""

#. type: delimited block =
#: upstream/_guides/virtual-threads.adoc:420
msgid "If you are using a Mac M1 or M2 (using an ARM64 CPU), you need to be aware that the native executable you will get using an in-container build will be a Linux executable, but using your host (ARM 64) architecture.  You can use emulation to force the architecture when using Docker with the following property:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:424
#, no-wrap
msgid "quarkus.native.container-runtime-options=--platform=linux/amd64\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:427
msgid "Be aware that it increases the compilation time... a lot (>10 minutes)."
msgstr ""

#. type: Title ===
#: upstream/_guides/virtual-threads.adoc:429
#, no-wrap
msgid "Containerize native applications using virtual threads"
msgstr ""

#. type: delimited block =
#: upstream/_guides/virtual-threads.adoc:433
msgid "To build a container running a Quarkus application using virtual threads compiled into a native executable, you must make sure you have a Linux/AMD64 executable (or ARM64 if you are targeting ARM machines)."
msgstr ""

#. type: delimited block =
#: upstream/_guides/virtual-threads.adoc:435
msgid "Make sure your `application.properties` contains the configuration explained in xref:native[the native compilation section]."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:445
msgid "If you ever want to build a native container image and already have an existing native image you can set `-Dquarkus.native.reuse-existing=true` and the native image build will not be re-run."
msgstr ""

#. type: Title ==
#: upstream/_guides/virtual-threads.adoc:446
#, no-wrap
msgid "Use the duplicated context in virtual threads"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:450
msgid "Methods annotated with `@RunOnVirtualThread` inherit from the original duplicated context (See the xref:duplicated-context.adoc[duplicated context reference guide] for details).  So, the data written in the duplicated context (and the request scope, as the request scoped is stored in the duplicated context) by filters and interceptors are available during the method execution (even if the filters and interceptors are not run on the virtual thread)."
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:452
msgid "However, thread locals are not propagated."
msgstr ""

#. type: Title ==
#: upstream/_guides/virtual-threads.adoc:453
#, fuzzy, no-wrap
msgid "Virtual thread names"
msgstr "Hilo virtual"

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:458
msgid "Virtual threads are created without a thread name by default, which is not practical to identify the execution for debugging and logging purposes.  Quarkus managed virtual threads are named and prefixed with `quarkus-virtual-thread-`.  You can customize this prefix, or disable the naming altogether configuring an empty value:"
msgstr ""

#. type: delimited block -
#: upstream/_guides/virtual-threads.adoc:462
#, no-wrap
msgid "quarkus.virtual-threads.name-prefix=\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/virtual-threads.adoc:466
#, no-wrap
msgid "Additional references"
msgstr ""

#. type: Plain text
#: upstream/_guides/virtual-threads.adoc:468
msgid "https://dl.acm.org/doi/10.1145/3583678.3596895[Considerations for integrating virtual threads in a Java framework: a Quarkus example in a resource-constrained environment]"
msgstr ""

#, fuzzy
#~ msgid "Writing simpler reactive REST services with Quarkus Virtual Thread support"
#~ msgstr "Escribir servicios REST reactivos más sencillos con el soporte de Quarkus Virtual Thread"

#, fuzzy
#~ msgid "This is the reference guide for using virtual threads to write reactive REST services.  Please refer to the xref:rest-json.adoc[Writing JSON REST services guides] for a lightweight introduction to reactive REST services and to the xref:resteasy-reactive.adoc[Writing REST Services with RESTEasy Reactive] guide for a detailed presentation."
#~ msgstr "Esta es la guía de referencia para utilizar hilos virtuales para escribir servicios REST reactivos. Consulte  link:rest-json.html[las guías Writing JSON REST services] para una introducción ligera a los servicios REST reactivos y la guía  link:resteasy-reactive.html[Writing REST Services with RESTEasy Reactive] para una presentación detallada."

#, fuzzy
#~ msgid "Bringing virtual threads to reactive REST services"
#~ msgstr "Llevar los hilos virtuales a los servicios REST reactivos"

#, fuzzy
#~ msgid "Getting started"
#~ msgstr "Cómo empezar"

#, fuzzy
#~ msgid "When using Mutiny, alternative \"xAndAwait\" methods are provided to be used with virtual threads.  They ensure that waiting for the completion of the I/O will not \"pin\" the carrier thread and deteriorate performance.  Pinning is a phenomenon that we describe in xref:Pinning cases[this section]."
#~ msgstr "Cuando se utiliza Mutiny, se proporcionan métodos alternativos \"xAndAwait\" para ser utilizados con hilos virtuales. Garantizan que la espera de la finalización de la E/S no \"pinche\" el hilo portador y deteriore el rendimiento. El pinning es un fenómeno que describimos en  link:#Pinning cases[esta sección]."

#, fuzzy
#~ msgid "In other words, the mutiny environment is a safe environment for virtual threads.  The guarantees offered by Mutiny are detailed later."
#~ msgstr "En otras palabras, el entorno de Mutiny es un entorno seguro para los hilos virtuales. Las garantías que ofrece Mutiny se detallan más adelante."

#, fuzzy
#~ msgid "Simplifying complex logic"
#~ msgstr "Simplificar la lógica compleja"

#, fuzzy
#~ msgid "The previous example is trivial and doesn't capture how imperative style can simplify complex reactive operations.  Below is a more complex example.  The endpoints must now fetch all the fortunes in the database, then append a quote to each fortune before finally returning the result to the client."
#~ msgstr "El ejemplo anterior es trivial y no capta cómo el estilo imperativo puede simplificar las operaciones reactivas complejas. A continuación se muestra un ejemplo más complejo. Los puntos finales deben ahora obtener todas las fortunas en la base de datos, luego añadir una cita a cada fortuna antes de devolver finalmente el resultado al cliente."

#, fuzzy
#~ msgid "The JDBC problem"
#~ msgstr "El problema de JDBC"

#, fuzzy
#~ msgid "Our experiments so far show that when a virtual thread queries a database using the JDBC driver, it will pin its carrier thread during the entire operation."
#~ msgstr "Nuestros experimentos hasta el momento muestran que cuando un hilo virtual consulta una base de datos utilizando el controlador JDBC, se fija su hilo portador durante toda la operación."

#, fuzzy
#~ msgid "Let's show the code of the `findAllBlocking()` method we used in the first example"
#~ msgstr "Vamos a mostrar el código del método `findAllBlocking()` que hemos utilizado en el primer ejemplo"

#, fuzzy
#~ msgid "The actual query happens at `ResultSet rs = preparedStatement.executeQuery();`, here is how it is implemented in the postgresql-jdbc driver 42.5.0:"
#~ msgstr "La consulta real ocurre en `ResultSet rs = preparedStatement.executeQuery();`, aquí es cómo se implementa en el controlador postgresql-jdbc 42.5.0:"

#, fuzzy
#~ msgid "This `synchronized` block is the culprit.  Replacing it with a lock is a good solution, but it won't be enough: `synchronized` blocks are also used in `executeWithFlags(int flag)`.  A systematic review of the postgresql-jdbc driver is necessary to make sure that it is compliant with virtual threads."
#~ msgstr "Este bloque `synchronized` es el culpable. Sustituirlo por un bloqueo es una buena solución, pero no será suficiente: los bloques `synchronized` también se utilizan en `executeWithFlags(int flag)`. Es necesaria una revisión sistemática del controlador postgresql-jdbc para asegurarse de que es compatible con los hilos virtuales."

#, fuzzy
#~ msgid "Reactive drivers at the rescue"
#~ msgstr "Conductores reactivos al rescate"

#, fuzzy
#~ msgid "The vertx-sql-client is a reactive client, hence it is not supposed to block while waiting for the completion of a transaction with the database.  However, when using the link:{mutiny-vertx-sql}[smallrye-mutiny-vertx-sqlclient] it is possible to use a variant method that will await for the completion of the transaction, mimicking a blocking behaviour."
#~ msgstr "El cliente vertx-sql es un cliente reactivo, por lo que se supone que no se bloquea mientras espera la finalización de una transacción con la base de datos. Sin embargo, cuando se utiliza el  link:{mutiny-vertx-sql}[smallrye-mutiny-vertx-sqlclient] es posible utilizar un método variante que esperará la finalización de la transacción, imitando un comportamiento de bloqueo."

#, fuzzy
#~ msgid "Below is the `FortuneRepository` except the blocking we've seen earlier has been replaced by reactive methods."
#~ msgstr "A continuación se muestra el `FortuneRepository` excepto que el bloqueo que hemos visto antes ha sido sustituido por métodos reactivos."

#, fuzzy
#~ msgid "Contrary to the link:{pgsql-driver}[postgresql-jdbc driver], no `synchronized` block is used where it shouldn't be, and the `await` behaviour is implemented using locks and latches that won't cause pinning."
#~ msgstr "Al contrario que en el  link:{pgsql-driver}[controlador postgresql-jdbc], no se utiliza ningún bloque `synchronized` donde no debería, y el comportamiento de `await` se implementa utilizando bloqueos y latches que no causan pines."

#, fuzzy
#~ msgid "Using the synchronous methods of the link:{mutiny-vertx-sql}[smallrye-mutiny-vertx-sqlclient] along with virtual threads will allow you to use the synchronous blocking style, avoid pinning the carrier thread, and get performance close to a pure reactive implementation."
#~ msgstr "El uso de los métodos síncronos del  link:{mutiny-vertx-sql}[smallrye-mutiny-vertx-sqlclient] junto con los hilos virtuales le permitirá utilizar el estilo de bloqueo síncrono, evitar la fijación del hilo portador y obtener un rendimiento cercano a una implementación reactiva pura."

#, fuzzy
#~ msgid "A point about performance"
#~ msgstr "Un punto sobre el rendimiento"

#, fuzzy
#~ msgid "Our experiments seem to indicate that Quarkus with virtual threads will scale better than Quarkus blocking (offloading the computation on a pool of platform worker threads) but not as well as Quarkus reactive.  The memory consumption especially might be an issue: if your system needs to keep its memory footprint low we would advise you stick to using reactive constructs."
#~ msgstr "Nuestros experimentos parecen indicar que Quarkus con hilos virtuales escalará mejor que Quarkus de bloqueo (descargando el cálculo en un grupo de hilos de trabajo de la plataforma) pero no tan bien Quarkus reactivo. El consumo de memoria, especialmente, puede ser un problema: si tu sistema necesita mantener su huella de memoria baja, te aconsejamos que sigas utilizando construcciones reactivas."

#, fuzzy
#~ msgid "This degradation of performance doesn't seem to come from virtual threads themselves but from the interactions between Vert.x/Netty (Quarkus underlying reactive engine) and the virtual threads.  This was illustrated in the issue that we will now describe."
#~ msgstr "Esta degradación del rendimiento no parece provenir de los hilos virtuales en sí, sino de las interacciones entre Vert.x/Netty (el motor reactivo subyacente de Quarkus) y los hilos virtuales. Esto se ilustra en el problema que vamos a describir a continuación."

#, fuzzy
#~ msgid "The Netty problem"
#~ msgstr "El problema de Netty"

#, fuzzy
#~ msgid "For JSON serialization, Netty uses their custom implementation of thread locals, `FastThreadLocal` to store buffers.  When using virtual threads in quarkus, the number of virtual threads simultaneously living in the service is directly related to the incoming traffic.  It is possible to get hundreds of thousands, if not millions, of them."
#~ msgstr "Para la serialización de JSON, Netty utiliza su implementación personalizada de hilos locales, `FastThreadLocal` para almacenar búferes. Cuando se utilizan hilos virtuales en quarkus, el número de hilos virtuales que viven simultáneamente en el servicio está directamente relacionado con el tráfico entrante. Es posible tener cientos de miles, si no millones, de ellos."

#, fuzzy
#~ msgid "If they need to serialize some data to JSON they will end up creating as many instances of `FastThreadLocal`, resulting on a massive memory consumption as well as exacerbated pressure on the garbage collector.  This will eventually affect the performance of the application and inhibit its scalability."
#~ msgstr "Si necesitan serializar algunos datos a JSON acabarán creando otras tantas instancias de `FastThreadLocal`, lo que supondrá un consumo masivo de memoria así como una presión exacerbada sobre el recolector de basura. Esto acabará afectando al rendimiento de la aplicación e inhibirá su escalabilidad."

#, fuzzy
#~ msgid "This is a perfect example of the mismatch between the reactive stack and the virtual threads.  The fundamental hypothesis are completely different and result in different optimizations.  Netty expects a system using few event-loops (as many event-loops as CPU cores by default in Quarkus), but it gets hundreds of thousands of threads.  You can refer to link:https://mail.openjdk.org/pipermail/loom-dev/2022-July/004844.html[this mail] to get more information on how we envision our future with virtual threads."
#~ msgstr "Este es un ejemplo perfecto del desajuste entre la pila reactiva y los hilos virtuales. Las hipótesis fundamentales son completamente diferentes y dan lugar a optimizaciones distintas. Netty espera un sistema que utilice pocos bucles de eventos (tantos bucles de eventos como núcleos de CPU por defecto en Quarkus), pero obtiene cientos de miles de hilos. Puedes consultar  link:https://mail.openjdk.org/pipermail/loom-dev/2022-July/004844.html[este correo] para obtener más información sobre cómo imaginamos nuestro futuro con los hilos virtuales."

#, fuzzy
#~ msgid "Our solution to the Netty problem"
#~ msgstr "Nuestra solución al problema de Netty"

#, fuzzy
#~ msgid "In order to avoid this wasting of resource without modifying Netty upstream, we wrote an extension that modifies the bytecode of the class responsible for creating the thread locals at build time.  Using this extension, performance of virtual threads in Quarkus for the Json Serialization test of the Techempower suite increased by nearly 80%, making it almost as good as reactive endpoints."
#~ msgstr "Para evitar este despilfarro de recursos sin modificar Netty en sentido ascendente, escribimos una extensión que modifica el bytecode de la clase responsable de crear los threads locals en tiempo de compilación. Usando esta extensión, el rendimiento de los hilos virtuales en Quarkus para la prueba de serialización Json de la suite Techempower se incrementó en casi un 80%, haciéndolo casi tan bueno como los endpoints reactivos."

#, fuzzy
#~ msgid "To use it, it needs to be added as a dependency:"
#~ msgstr "Para utilizarlo, es necesario añadirlo como dependencia:"

#, fuzzy
#~ msgid "Furthermore, some operations undertaken by this extension need special access, it is necessary to"
#~ msgstr "Además, algunas operaciones realizadas por esta extensión necesitan un acceso especial, es necesario"

#, fuzzy
#~ msgid "compile the application with the flag `-Dnet.bytebuddy.experimental`"
#~ msgstr "compilar la aplicación con la bandera `-Dnet.bytebuddy.experimental`"

#, fuzzy
#~ msgid "open the `java.base.lang` module at runtime with the flag `--add-opens java.base/java.lang=ALL-UNNAMED`"
#~ msgstr "abrir el módulo `java.base.lang` en tiempo de ejecución con la bandera `--add-opens java.base/java.lang=ALL-UNNAMED`"

#, fuzzy
#~ msgid "This extension is only intended to improve performance, it is perfectly fine not to use it."
#~ msgstr "Esta extensión sólo está pensada para mejorar el rendimiento, está perfectamente bien no usarla."

#, fuzzy
#~ msgid "Concerning dev mode"
#~ msgstr "Con respecto al modo de desarrollo"

#, fuzzy
#~ msgid "If you want to use quarkus with the dev mode, it won't be possible to manually specify the flags we mentioned along this guide.  Instead, you want to specify them all in the configuration of the `quarkus-maven-plugin` as presented below."
#~ msgstr "Si quieres usar quarkus con el modo dev, no será posible especificar manualmente las banderas que mencionamos a lo largo de esta guía. En su lugar, debes especificarlas todas en la configuración del `quarkus-maven-plugin` como se presenta a continuación."

#, fuzzy
#~ msgid "If you don't want to specify the opening of the `java.lang` module in your pom.xml file, you can also specify it as an argument when you start the dev mode."
#~ msgstr "Si no quieres poner la apertura del módulo `java.lang` en tu archivo pom.xml, también puedes especificarlo como argumento cuando inicies el modo dev."

#, fuzzy
#~ msgid "The configuration of the quarkus-maven-plugin will be simpler:"
#~ msgstr "La configuración del quarkus-maven-plugin será más sencilla:"

#, fuzzy
#~ msgid "And the command will become:"
#~ msgstr "Y el comando se convertirá:"
