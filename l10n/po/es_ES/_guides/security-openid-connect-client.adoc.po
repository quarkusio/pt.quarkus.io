# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-04-26 15:18+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_guides/security-openid-connect-client.adoc:6
#, fuzzy, no-wrap
msgid "OpenID Connect Client and Token Propagation Quickstart"
msgstr "Inicio rápido del cliente de OpenID Connect y de la propagación de tokens"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:12
#, fuzzy
msgid "This quickstart demonstrates how to use `OpenID Connect Client Reactive Filter` to acquire and propagate access tokens as `HTTP Authorization Bearer` access tokens, alongside `OpenID Token Propagation Reactive Filter` which propagates the incoming `HTTP Authorization Bearer` access tokens."
msgstr "Este inicio rápido demuestra cómo utilizar `OpenID Connect Client Reactive Filter` para adquirir y propagar tokens de acceso como `HTTP Authorization Bearer`, junto con `OpenID Token Propagation Reactive Filter` que propaga los tokens de acceso entrantes `HTTP Authorization Bearer`."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:14
#, fuzzy
msgid "Please check xref:security-openid-connect-client-reference.adoc[OpenID Connect Client and Token Propagation Reference Guide] for all the information related to `Oidc Client` and `Token Propagation` support in Quarkus."
msgstr "Por favor, revisa  link:security-openid-connect-client.html[la Guía de Referencia del Cliente de OpenID Connect y Propagación de Tokens] para toda la información relacionada con `Oidc Client` y el soporte de `Token Propagation` en Quarkus."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:16
#, fuzzy
msgid "Please also read xref:security-oidc-bearer-authentication-concept.adoc[OIDC Bearer authentication] guide if you need to protect your applications using Bearer Token Authorization."
msgstr "link:security-openid-connect.html[Quarkus - Uso de OpenID Connect para proteger las aplicaciones de servicios mediante la autorización de tokens de portador]"

#. type: Title ==
#: upstream/_guides/security-openid-connect-client.adoc:17
#, fuzzy, no-wrap
msgid "Prerequisites"
msgstr "Requisitos previos"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:22
#, fuzzy
msgid "https://stedolan.github.io/jq/[jq tool]"
msgstr "link:https://stedolan.github.io/jq/[herramienta jq]"

#. type: Title ==
#: upstream/_guides/security-openid-connect-client.adoc:23
#, fuzzy, no-wrap
msgid "Architecture"
msgstr "Arquitectura"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:26
#, fuzzy
msgid "In this example, we will build an application which consists of two Jakarta REST resources, `FrontendResource` and `ProtectedResource`. `FrontendResource` propagates access tokens to `ProtectedResource` and uses either `OpenID Connect Client Reactive Filter` to acquire a token first before propagating it or `OpenID Token Propagation Reactive Filter` to propagate the incoming, already existing access token."
msgstr "En este ejemplo, construiremos una aplicación que consta de dos recursos JAX-RS, `FrontendResource` y `ProtectedResource`. `FrontendResource` propaga los tokens de acceso a `ProtectedResource` y utiliza `OpenID Connect Client Reactive Filter` para adquirir un token primero antes de propagarlo o `OpenID Token Propagation Reactive Filter` para propagar el token de acceso entrante ya existente."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:28
#, fuzzy
msgid "`FrontendResource` has 4 endpoints:"
msgstr "`FrontendResource` tiene 4 puntos finales:"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:30
#, fuzzy
msgid "`/frontend/user-name-with-oidc-client-token`"
msgstr "`/frontend/user-name-with-oidc-client`"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:31
#, fuzzy
msgid "`/frontend/admin-name-with-oidc-client-token`"
msgstr "`/frontend/admin-name-with-oidc-client`"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:32
#, fuzzy
msgid "`/frontend/user-name-with-propagated-token`"
msgstr "`/frontend/user-name-with-propagated-token`"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:33
#, fuzzy
msgid "`/frontend/admin-name-with-propagated-token`"
msgstr "`/frontend/admin-name-with-propagated-token`"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:35
#: upstream/_guides/security-openid-connect-client.adoc:268
#, fuzzy
msgid "`FrontendResource` will use REST Client with `OpenID Connect Client Reactive Filter` to acquire and propagate an access token to `ProtectedResource` when either `/frontend/user-name-with-oidc-client-token` or `/frontend/admin-name-with-oidc-client-token` is called. And it will use REST Client with `OpenID Connect Token Propagation Reactive Filter` to propagate the current incoming access token to `ProtectedResource` when either `/frontend/user-name-with-propagated-token` or `/frontend/admin-name-with-propagated-token` is called."
msgstr "`FrontendResource` utilizará el Cliente REST con `OpenID Connect Client Reactive Filter` para adquirir y propagar un token de acceso a `ProtectedResource` cuando se llame a `/frontend/user-name-with-oidc-client` o a `/frontend/admin-name-with-oidc-client`. Y utilizará el cliente REST con `OpenID Connect Token Propagation Reactive Filter` para propagar el token de acceso entrante actual a `ProtectedResource` cuando se llame a `/frontend/user-name-with-propagated-token` o a `/frontend/admin-name-with-propagated-token`."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:37
#, fuzzy
msgid "`ProtecedResource` has 2 endpoints:"
msgstr "`ProtecedResource` tiene 2 puntos finales:"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:39
#, fuzzy
msgid "`/protected/user-name`"
msgstr "`/protected/user-name`"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:40
#, fuzzy
msgid "`/protected/admin-name`"
msgstr "`/protected/admin-name`"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:42
#, fuzzy
msgid "Both of these endpoints return the username extracted from the incoming access token which was propagated to `ProtectedResource` from `FrontendResource`. The only difference between these endpoints is that calling `/protected/user-name` is only allowed if the current access token has a `user` role and calling `/protected/admin-name` is only allowed if the current access token has an `admin` role."
msgstr "Ambos puntos finales devuelven el nombre de usuario extraído del token de acceso entrante que se propagó a `ProtectedResource` desde `FrontendResource`. La única diferencia entre estos puntos finales es que llamar a `/protected/user-name` sólo se permite si el token de acceso actual tiene un rol de `user` y llamar a `/protected/admin-name` sólo se permite si el token de acceso actual tiene un rol de `admin`."

#. type: Title ==
#: upstream/_guides/security-openid-connect-client.adoc:43
#, fuzzy, no-wrap
msgid "Solution"
msgstr "Solución"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:47
msgid "We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example."
msgstr "Le recomendamos que siga las instrucciones de las siguientes secciones y cree la aplicación paso a paso. Sin embargo, puede ir directamente al ejemplo completado."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:49
msgid "Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive]."
msgstr "Clone el repositorio Git: `git clone {quickstarts-clone-url}` o descargue un {quickstarts-archive-url}[archivo]."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:51
#, fuzzy
msgid "The solution is located in the `security-openid-connect-client-quickstart` {quickstarts-tree-url}/security-openid-connect-client-quickstart[directory]."
msgstr "La solución se encuentra en el `security-openid-connect-quickstart` {quickstarts-tree-url}/security-openid-connect-client-quickstart[directorio]."

#. type: Title ==
#: upstream/_guides/security-openid-connect-client.adoc:52
#, fuzzy, no-wrap
msgid "Creating the Maven Project"
msgstr "Creación del proyecto Maven"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:55
#, fuzzy
msgid "First, we need a new project. Create a new project with the following command:"
msgstr "En primer lugar, necesitamos un nuevo proyecto. Cree un nuevo proyecto con el siguiente comando:"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:61
#, fuzzy
msgid "This command generates a Maven project, importing the `oidc`, `oidc-client-reactive-filter`, `oidc-token-propagation-reactive-filter` and `resteasy-reactive` extensions."
msgstr "Este comando genera un proyecto Maven, importando las extensiones `oidc`, `oidc-client-reactive-filter`, `oidc-client-reactive-filter` y `resteasy-reactive`."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:63
#, fuzzy
msgid "If you already have your Quarkus project configured, you can add these extensions to your project by running the following command in your project base directory:"
msgstr "Si ya tienes configurado tu proyecto Quarkus, puedes añadir estas extensiones a tu proyecto ejecutando el siguiente comando en el directorio base de tu proyecto:"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:68
#, fuzzy
msgid "This will add the following to your build file:"
msgstr "Esto añadirá lo siguiente a su archivo de construcción:"

#. type: Block title
#: upstream/_guides/security-openid-connect-client.adoc:70
#, no-wrap
msgid "pom.xml"
msgstr "pom.xml"

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:88
#, no-wrap
msgid ""
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-oidc</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-oidc-client-reactive-filter</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-oidc-token-propagation-reactive</artifactId>\n"
"</dependency>\n"
"<dependency>\n"
"    <groupId>io.quarkus</groupId>\n"
"    <artifactId>quarkus-resteasy-reactive</artifactId>\n"
"</dependency>\n"
msgstr ""

#. type: Block title
#: upstream/_guides/security-openid-connect-client.adoc:91
#, no-wrap
msgid "build.gradle"
msgstr "build.gradle"

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:94
#, no-wrap
msgid "implementation(\"io.quarkus:quarkus-oidc,oidc-client-reactive-filter,oidc-token-propagation-reactive,resteasy-reactive\")\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/security-openid-connect-client.adoc:96
#, fuzzy, no-wrap
msgid "Writing the application"
msgstr "Escribir la aplicación"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:99
#, fuzzy
msgid "Let's start by implementing `ProtectedResource`:"
msgstr "Empecemos por implementar `ProtectedResource`:"

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:103
#: upstream/_guides/security-openid-connect-client.adoc:147
#: upstream/_guides/security-openid-connect-client.adoc:180
#: upstream/_guides/security-openid-connect-client.adoc:217
#: upstream/_guides/security-openid-connect-client.adoc:274
#, no-wrap
msgid "package org.acme.security.openid.connect.client;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:109
#, no-wrap
msgid ""
"import jakarta.annotation.security.RolesAllowed;\n"
"import jakarta.inject.Inject;\n"
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:112
#, no-wrap
msgid ""
"import io.quarkus.security.Authenticated;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:114
#, no-wrap
msgid "import org.eclipse.microprofile.jwt.JsonWebToken;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:118
#, no-wrap
msgid ""
"@Path(\"/protected\")\n"
"@Authenticated\n"
"public class ProtectedResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:121
#, no-wrap
msgid ""
"    @Inject\n"
"    JsonWebToken principal;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:129
#, no-wrap
msgid ""
"    @GET\n"
"    @RolesAllowed(\"user\")\n"
"    @Produces(\"text/plain\")\n"
"    @Path(\"userName\")\n"
"    public Uni<String> userName() {\n"
"        return Uni.createFrom().item(principal.getName());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:138
#, no-wrap
msgid ""
"    @GET\n"
"    @RolesAllowed(\"admin\")\n"
"    @Produces(\"text/plain\")\n"
"    @Path(\"adminName\")\n"
"    public Uni<String> adminName() {\n"
"        return Uni.createFrom().item(principal.getName());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:141
#, fuzzy
msgid "As you can see `ProtectedResource` returns a name from both `userName()` and `adminName()` methods. The name is extracted from the current `JsonWebToken`."
msgstr "Como puede ver `ProtectedResource` devuelve un nombre de los métodos `userName()` y `adminName()`. El nombre se extrae del `JsonWebToken` actual."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:143
#, fuzzy
msgid "Next let's add a REST Client with `OidcClientRequestReactiveFilter` and another REST Client with `AccessTokenRequestReactiveFilter`. `FrontendResource` will use these two clients to call `ProtectedResource`:"
msgstr "A continuación vamos a añadir un cliente REST con `OpenID Connect Client Reactive Filter` y otro cliente REST con `OpenID Connect Token Propagation Filter`, `FrontendResource` utilizará estos dos clientes para llamar a `ProtectedResource`:"

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:151
#: upstream/_guides/security-openid-connect-client.adoc:184
#, no-wrap
msgid ""
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:154
#: upstream/_guides/security-openid-connect-client.adoc:187
#, no-wrap
msgid ""
"import org.eclipse.microprofile.rest.client.annotation.RegisterProvider;\n"
"import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:157
#, no-wrap
msgid ""
"import io.quarkus.oidc.client.reactive.filter.OidcClientRequestReactiveFilter;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:162
#, no-wrap
msgid ""
"@RegisterRestClient\n"
"@RegisterProvider(OidcClientRequestReactiveFilter.class)\n"
"@Path(\"/\")\n"
"public interface RestClientWithOidcClientFilter {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:167
#: upstream/_guides/security-openid-connect-client.adoc:200
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(\"text/plain\")\n"
"    @Path(\"userName\")\n"
"    Uni<String> getUserName();\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:173
#: upstream/_guides/security-openid-connect-client.adoc:206
#, no-wrap
msgid ""
"    @GET\n"
"    @Produces(\"text/plain\")\n"
"    @Path(\"adminName\")\n"
"    Uni<String> getAdminName();\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:176
#, fuzzy
msgid "where `RestClientWithOidcClientFilter` will depend on `OidcClientRequestReactiveFilter` to acquire and propagate the tokens and"
msgstr "donde `ProtectedResourceOidcClientFilter` dependerá de `OidcClientRequestReactiveFilter` para adquirir y propagar las fichas y"

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:190
#, no-wrap
msgid ""
"import io.quarkus.oidc.token.propagation.reactive.AccessTokenRequestReactiveFilter;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:195
#, no-wrap
msgid ""
"@RegisterRestClient\n"
"@RegisterProvider(AccessTokenRequestReactiveFilter.class)\n"
"@Path(\"/\")\n"
"public interface RestClientWithTokenPropagationFilter {\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:209
#, fuzzy
msgid "where `RestClientWithTokenPropagationFilter` will depend on `AccessTokenRequestReactiveFilter` to propagate the incoming, already existing tokens."
msgstr "donde `ProtectedResourceTokenPropagationFilter` dependerá de `AccessTokenRequestReactiveFilter` para propagar los tokens entrantes ya existentes."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:211
#, fuzzy
msgid "Note that both `RestClientWithOidcClientFilter` and `RestClientWithTokenPropagationFilter` interfaces are identical - the reason behind it is that combining `OidcClientRequestReactiveFilter` and `AccessTokenRequestReactiveFilter` on the same REST Client will cause side effects as both filters can interfere with other, for example, `OidcClientRequestReactiveFilter` may override the token propagated by `AccessTokenRequestReactiveFilter` or `AccessTokenRequestReactiveFilter` can fail if it is called when no token is available to propagate and `OidcClientRequestReactiveFilter` is expected to acquire a new token instead."
msgstr "Tenga en cuenta que ambas interfaces `ProtectedResourceOidcClientFilter` y `ProtectedResourceTokenPropagationFilter` son idénticas - la razón detrás de esto es que la combinación de `OidcClientRequestReactiveFilter` y `AccessTokenRequestReactiveFilter` en el mismo cliente REST causará efectos secundarios ya que ambos filtros pueden interferir con otros, por ejemplo, `OidcClientRequestReactiveFilter` puede anular el token propagado por `AccessTokenRequestReactiveFilter` o `AccessTokenRequestReactiveFilter` puede fallar si se llama cuando no hay token disponible para propagar y se espera que `OidcClientRequestReactiveFilter` adquiera un nuevo token en su lugar."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:213
#, fuzzy
msgid "Now let's complete creating the application with adding `FrontendResource`:"
msgstr "Ahora vamos a completar la creación de la aplicación con la adición de `FrontendResource`:"

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:222
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
"import jakarta.ws.rs.Produces;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:224
#, no-wrap
msgid "import org.eclipse.microprofile.rest.client.inject.RestClient;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:226
#, no-wrap
msgid "import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:232
#, no-wrap
msgid ""
"@Path(\"/frontend\")\n"
"public class FrontendResource {\n"
"    @Inject\n"
"    @RestClient\n"
"    RestClientWithOidcClientFilter restClientWithOidcClientFilter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:236
#, no-wrap
msgid ""
"    @Inject\n"
"    @RestClient\n"
"    RestClientWithTokenPropagationFilter restClientWithTokenPropagationFilter;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:243
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"user-name-with-oidc-client-token\")\n"
"    @Produces(\"text/plain\")\n"
"    public Uni<String> getUserNameWithOidcClientToken() {\n"
"        return restClientWithOidcClientFilter.getUserName();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:250
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"admin-name-with-oidc-client-token\")\n"
"    @Produces(\"text/plain\")\n"
"    public Uni<String> getAdminNameWithOidcClientToken() {\n"
"\t    return restClientWithOidcClientFilter.getAdminName();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:257
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"user-name-with-propagated-token\")\n"
"    @Produces(\"text/plain\")\n"
"    public Uni<String> getUserNameWithPropagatedToken() {\n"
"        return restClientWithTokenPropagationFilter.getUserName();\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:265
#, no-wrap
msgid ""
"    @GET\n"
"    @Path(\"admin-name-with-propagated-token\")\n"
"    @Produces(\"text/plain\")\n"
"    public Uni<String> getAdminNameWithPropagatedToken() {\n"
"        return restClientWithTokenPropagationFilter.getAdminName();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:270
#, fuzzy
msgid "Finally, let's add a Jakarta REST `ExceptionMapper`:"
msgstr "Por último, vamos a añadir un JAX-RS `ExceptionMapper`:"

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:278
#, no-wrap
msgid ""
"import jakarta.ws.rs.core.Response;\n"
"import jakarta.ws.rs.ext.ExceptionMapper;\n"
"import jakarta.ws.rs.ext.Provider;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:280
#, no-wrap
msgid "import org.jboss.resteasy.reactive.ClientWebApplicationException;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:283
#, no-wrap
msgid ""
"@Provider\n"
"public class FrontendExceptionMapper implements ExceptionMapper<ClientWebApplicationException> {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:288
#, no-wrap
msgid ""
"\t@Override\n"
"\tpublic Response toResponse(ClientWebApplicationException t) {\n"
"\t\treturn Response.status(t.getResponse().getStatus()).build();\n"
"\t}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:290
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:293
#, fuzzy
msgid "This exception mapper is only added to verify during the tests that `ProtectedResource` returns `403` when the token has no expected role. Without this mapper `RESTEasy Reactive` will correctly convert the exceptions which will escape from REST Client calls to `500` to avoid leaking the information from the downstream resources such as `ProtectedResource` but in the tests it will not be possible to assert that `500` is in fact caused by an authorization exception as opposed to some internal error."
msgstr "Este mapeador de excepciones sólo se añade para verificar durante las pruebas que `ProtectedResource` devuelve `403` cuando el token no tiene un rol esperado. Sin este mapeador `RESTEasy Reactive` convertirá correctamente las excepciones que se escapen de las llamadas del Cliente REST a `500` para evitar que se filtre la información de los recursos descendentes como `ProtectedResource` pero en las pruebas no será posible afirmar que `500` es de hecho causada por una excepción de autorización en contraposición a algún error interno."

#. type: Title ==
#: upstream/_guides/security-openid-connect-client.adoc:294
#, fuzzy, no-wrap
msgid "Configuring the application"
msgstr "Configuración de la aplicación"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:297
#, fuzzy
msgid "We have prepared the code, and now let's configure the application:"
msgstr "Hemos preparado el código, y ahora vamos a configurar la aplicación:"

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:301
#, no-wrap
msgid "# Configure OIDC\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:305
#, no-wrap
msgid ""
"%prod.quarkus.oidc.auth-server-url=http://localhost:8180/realms/quarkus\n"
"quarkus.oidc.client-id=backend-service\n"
"quarkus.oidc.credentials.secret=secret\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:308
#, no-wrap
msgid ""
"# Tell Dev Services for Keycloak to import the realm file\n"
"# This property is not effective when running the application in JVM or Native modes but only in dev and test modes.\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:310
#, no-wrap
msgid "quarkus.keycloak.devservices.realm-path=quarkus-realm.json\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:312
#, no-wrap
msgid "# Configure OIDC Client\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:319
#, no-wrap
msgid ""
"quarkus.oidc-client.auth-server-url=${quarkus.oidc.auth-server-url}\n"
"quarkus.oidc-client.client-id=${quarkus.oidc.client-id}\n"
"quarkus.oidc-client.credentials.secret=${quarkus.oidc.credentials.secret}\n"
"quarkus.oidc-client.grant.type=password\n"
"quarkus.oidc-client.grant-options.password.username=alice\n"
"quarkus.oidc-client.grant-options.password.password=alice\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:321
#, no-wrap
msgid "# Configure REST Clients\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:325
#, no-wrap
msgid ""
"%prod.port=8080\n"
"%dev.port=8080\n"
"%test.port=8081\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:328
#, no-wrap
msgid ""
"org.acme.security.openid.connect.client.RestClientWithOidcClientFilter/mp-rest/url=http://localhost:${port}/protected\n"
"org.acme.security.openid.connect.client.RestClientWithTokenPropagationFilter/mp-rest/url=http://localhost:${port}/protected\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:331
#, fuzzy
msgid "This configuration references Keycloak which will be used by `ProtectedResource` to verify the incoming access tokens and by `OidcClient` to get the tokens for a user `alice` using a `password` grant. Both RESTClients point to `ProtectedResource`'s HTTP address."
msgstr "Esta configuración hace referencia a Keycloak, que será utilizado por `ProtectedResource` para verificar los tokens de acceso entrantes y por `OidcClient` para obtener los tokens para un usuario `alice` utilizando una concesión de `password`. Ambos RESTClients apuntan a la dirección HTTP de `ProtectedResource."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:333
#, fuzzy
msgid "Adding a `%prod.` profile prefix to `quarkus.oidc.auth-server-url` ensures that `Dev Services for Keycloak` will launch a container for you when the application is run in dev or test modes. See xref:keycloak-dev-mode[Running the Application in Dev mode] section below for more information."
msgstr "Añadir un prefijo de perfil `%prod.` a `quarkus.oidc.auth-server-url` asegura que `Dev Services for Keycloak` lanzará un contenedor por ti cuando la aplicación se ejecute en los modos dev o test. Consulte la sección  link:#keycloak-dev-mode[Ejecutar la aplicación en] modo Dev más abajo para obtener más información."

#. type: Title ==
#: upstream/_guides/security-openid-connect-client.adoc:334
#, fuzzy, no-wrap
msgid "Starting and Configuring the Keycloak Server"
msgstr "Inicio y configuración del servidor Keycloak"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:337
#, fuzzy
msgid "Do not start the Keycloak server when you run the application in dev mode or test modes - `Dev Services for Keycloak` will launch a container. See xref:keycloak-dev-mode[Running the Application in Dev mode] section below for more information. Make sure to put the {quickstarts-tree-url}/security-openid-connect-client-quickstart/config/quarkus-realm.json[realm configuration file] on the classpath (`target/classes` directory) so that it gets imported automatically when running in dev mode - unless you have already built a {quickstarts-tree-url}/security-openid-connect-quickstart[complete solution] in which case this realm file will be added to the classpath during the build."
msgstr "No inicie el servidor Keycloak cuando ejecute la aplicación en modo dev o en modo de prueba - `Dev Services for Keycloak` lanzará un contenedor. Vea la sección  link:#keycloak-dev-mode[Ejecutar la aplicación en] modo Dev más abajo para más información. Asegúrese de poner el {quickstarts-tree-url}/security-openid-connect-client-quickstart/config/quarkus-realm.json[archivo de configuración del reino] en el classpath (directorio `target/classes` ) para que se importe automáticamente cuando se ejecute en modo dev - a menos que ya haya construido un {quickstarts-tree-url}/security-openid-connect-quickstart[solución completa] en cuyo caso este archivo del reino se añadirá al classpath durante la construcción."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:339
#, fuzzy
msgid "To start a Keycloak Server you can use Docker and just run the following command:"
msgstr "Para iniciar un servidor de Keycloak puede utilizar Docker y simplemente ejecutar el siguiente comando:"

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:343
#, no-wrap
msgid "docker run --name keycloak -e KEYCLOAK_ADMIN=admin -e KEYCLOAK_ADMIN_PASSWORD=admin -p 8180:8080 quay.io/keycloak/keycloak:{keycloak.version} start-dev\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:346
#, fuzzy
msgid "where `keycloak.version` should be set to `17.0.0` or higher."
msgstr "donde `keycloak.version` debe estar ajustado a `17.0.0` o superior."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:348
#, fuzzy
msgid "You should be able to access your Keycloak Server at http://localhost:8180[localhost:8180]."
msgstr "Debería poder acceder a su servidor Keycloak en  link:http://localhost:8180[localhost:8180]."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:350
#, fuzzy
msgid "Log in as the `admin` user to access the Keycloak Administration Console. Username should be `admin` and password `admin`."
msgstr "Inicie sesión como el usuario `admin` para acceder a la consola de administración de Keycloak. El nombre de usuario debe ser `admin` y la contraseña `admin`."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:352
#, fuzzy
msgid "Import the {quickstarts-tree-url}/security-openid-connect-client-quickstart/config/quarkus-realm.json[realm configuration file] to create a new realm. For more details, see the Keycloak documentation about how to https://www.keycloak.org/docs/latest/server_admin/index.html#_create-realm[create a new realm]."
msgstr "Importe el {quickstarts-tree-url}/security-openid-connect-client-quickstart/config/quarkus-realm.json[archivo de configuración del reino] para crear un nuevo reino. Para más detalles, consulte la documentación de Keycloak sobre cómo  link:https://www.keycloak.org/docs/latest/server_admin/index.html#_create-realm[crear un] nuevo reino."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:354
#, fuzzy
msgid "This `quarkus` realm file will add a `frontend` client, and `alice` and `admin` users. `alice` has a `user` role, `admin` - both `user` and `admin` roles."
msgstr "Este archivo de reino `quarkus` añadirá un cliente `frontend`, y usuarios `alice` y `admin`. `alice` tiene un rol `user`, `admin` - ambos roles `user` y `admin`."

#. type: Title ==
#: upstream/_guides/security-openid-connect-client.adoc:356
#, fuzzy, no-wrap
msgid "Running the Application in Dev mode"
msgstr "Ejecutar la aplicación en modo Dev"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:359
#, fuzzy
msgid "To run the application in a dev mode, use:"
msgstr "Para ejecutar la aplicación en modo dev, utilice:"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:363
#, fuzzy
msgid "xref:security-openid-connect-dev-services.adoc[Dev Services for Keycloak] will launch a Keycloak container and import a `quarkus-realm.json`."
msgstr "link:security-openid-connect-dev-services.html[Dev Services for Keycloak] lanzará un contenedor Keycloak e importará un `quarkus-realm.json`."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:365
#, fuzzy
msgid "Open a xref:dev-ui.adoc[Dev UI] available at http://localhost:8080/q/dev-v1[/q/dev-v1] and click on a `Provider: Keycloak` link in an `OpenID Connect` `Dev UI` card."
msgstr "Abra una  link:dev-ui.html[interfaz de usuario de desarrollo] disponible en  link:http://localhost:8080/q/dev[/q/dev] y haga clic en un enlace `Provider: Keycloak` en una tarjeta `OpenID Connect` `Dev UI` ."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:367
#, fuzzy
msgid "You will be asked to log in into a `Single Page Application` provided by `OpenID Connect Dev UI`:"
msgstr "Se le pedirá que inicie sesión en un `Single Page Application` proporcionado por `OpenID Connect Dev UI`:"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:369
#, fuzzy
msgid "Login as `alice` (password: `alice`) who has a `user` role"
msgstr "Inicie sesión como `alice` (contraseña: `alice`) que tiene un rol `user`"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:370
#: upstream/_guides/security-openid-connect-client.adoc:373
#, fuzzy
msgid "accessing `/frontend/user-name-with-propagated-token` will return `200`"
msgstr "acceder a `/frontend/user-name-with-propagated-token` devolverá `200`"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:371
#, fuzzy
msgid "accessing `/frontend/admin-name-with-propagated-token` will return `403`"
msgstr "acceder a `/frontend/admin-name-with-propagated-token` devolverá `403`"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:372
#, fuzzy
msgid "Logout and login as `admin` (password: `admin`) who has both `admin` and `user` roles"
msgstr "Salir y entrar como `admin` (contraseña: `admin`) que tiene los roles `admin` y `user`"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:374
#, fuzzy
msgid "accessing `/frontend/admin-name-with-propagated-token` will return `200`"
msgstr "acceder a `/frontend/admin-name-with-propagated-token` devolverá `200`"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:376
#, fuzzy
msgid "In this case you are testing that `FrontendResource` can propagate the access tokens acquired by `OpenID Connect Dev UI`."
msgstr "En este caso se está probando que `FrontendResource` puede propagar los tokens de acceso adquiridos por `OpenID Connect Dev UI`."

#. type: Title ==
#: upstream/_guides/security-openid-connect-client.adoc:377
#, fuzzy, no-wrap
msgid "Running the Application in JVM mode"
msgstr "Ejecutar la aplicación en modo JVM"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:380
#, fuzzy
msgid "When you're done playing with the `dev` mode\" you can run it as a standard Java application."
msgstr "Cuando haya terminado de jugar con el modo `dev` \" puede ejecutarlo como una aplicación Java estándar."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:382
#, fuzzy
msgid "First compile it:"
msgstr "Primero compilarlo:"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:386
#, fuzzy
msgid "Then run it:"
msgstr "Entonces, ejecútalo:"

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:390
#, no-wrap
msgid "java -jar target/quarkus-app/quarkus-run.jar\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/security-openid-connect-client.adoc:392
#, fuzzy, no-wrap
msgid "Running the Application in Native Mode"
msgstr "Ejecutar la aplicación en modo nativo"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:395
#, fuzzy
msgid "This same demo can be compiled into native code: no modifications required."
msgstr "Esta misma demo se puede compilar en código nativo: no requiere modificaciones."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:399
#, fuzzy
msgid "This implies that you no longer need to install a JVM on your production environment, as the runtime technology is included in the produced binary, and optimized to run with minimal resource overhead."
msgstr "Esto implica que ya no es necesario instalar una JVM en su entorno de producción, ya que la tecnología de tiempo de ejecución está incluida en el binario producido, y optimizada para ejecutarse con una sobrecarga mínima de recursos."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:402
#, fuzzy
msgid "Compilation will take a bit longer, so this step is disabled by default; let's build again by enabling the `native` profile:"
msgstr "La compilación tardará un poco más, por lo que este paso está desactivado por defecto; volvamos a compilar activando el perfil `native`:"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:406
#, fuzzy
msgid "After getting a cup of coffee, you'll be able to run this binary directly:"
msgstr "Después de tomar una taza de café, podrás ejecutar este binario directamente:"

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:410
#, no-wrap
msgid "./target/security-openid-connect-quickstart-1.0.0-SNAPSHOT-runner\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/security-openid-connect-client.adoc:412
#, fuzzy, no-wrap
msgid "Testing the Application"
msgstr "Prueba de la aplicación"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:415
#, fuzzy
msgid "See xref:keycloak-dev-mode[Running the Application in Dev mode] section above about testing your application in dev mode."
msgstr "Consulte la sección  link:#keycloak-dev-mode[Ejecutar la aplicación en modo Dev] más arriba sobre cómo probar su aplicación en modo Dev."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:417
#, fuzzy
msgid "You can test the application launched in JVM or Native modes with `curl`."
msgstr "Puede probar la aplicación lanzada en los modos JVM o Nativo con `curl`."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:419
#, fuzzy
msgid "Obtain an access token for `alice`:"
msgstr "Obtenga un token de acceso para `alice`:"

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:428
#, no-wrap
msgid ""
"export access_token=$(\\\n"
"    curl --insecure -X POST http://localhost:8180/realms/quarkus/protocol/openid-connect/token \\\n"
"    --user backend-service:secret \\\n"
"    -H 'content-type: application/x-www-form-urlencoded' \\\n"
"    -d 'username=alice&password=alice&grant_type=password' | jq --raw-output '.access_token' \\\n"
" )\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:431
#, fuzzy
msgid "Now use this token to call `/frontend/user-name-with-propagated-token` and `/frontend/admin-name-with-propagated-token`:"
msgstr "Ahora usa este token para llamar a `/frontend/user-name-with-propagated-token` y `/frontend/admin-name-with-propagated-token`:"

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:437
#: upstream/_guides/security-openid-connect-client.adoc:469
#, no-wrap
msgid ""
"curl -i -X GET \\\n"
"  http://localhost:8080/frontend/user-name-with-propagated-token \\\n"
"  -H \"Authorization: Bearer \"$access_token\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:440
#, fuzzy
msgid "will return `200` status code and the name `alice` while"
msgstr "devolverá el código de estado `200` y el nombre `alice` mientras que"

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:446
#: upstream/_guides/security-openid-connect-client.adoc:478
#, no-wrap
msgid ""
"curl -i -X GET \\\n"
"  http://localhost:8080/frontend/admin-name-with-propagated-token \\\n"
"  -H \"Authorization: Bearer \"$access_token\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:449
#, fuzzy
msgid "will return `403` - recall that `alice` only has a `user` role."
msgstr "devolverá `403` - recuerde que `alice` sólo tiene una función `user`."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:451
#, fuzzy
msgid "Next obtain an access token for `admin`:"
msgstr "A continuación, obtenga un token de acceso para `admin`:"

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:460
#, no-wrap
msgid ""
"export access_token=$(\\\n"
"    curl --insecure -X POST http://localhost:8180/realms/quarkus/protocol/openid-connect/token \\\n"
"    --user backend-service:secret \\\n"
"    -H 'content-type: application/x-www-form-urlencoded' \\\n"
"    -d 'username=admin&password=admin&grant_type=password' | jq --raw-output '.access_token' \\\n"
" )\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:463
#, fuzzy
msgid "and use this token to call `/frontend/user-name-with-propagated-token` and `/frontend/admin-name-with-propagated-token`:"
msgstr "y utilizar este token para llamar a `/frontend/user-name-with-propagated-token` y `/frontend/admin-name-with-propagated-token`:"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:472
#, fuzzy
msgid "will return `200` status code and the name `admin`, and"
msgstr "devolverá el código de estado `200` y el nombre `admin`, y"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:481
#, fuzzy
msgid "will also return `200` status code and the name `admin`, as `admin` has both `user` and `admin` roles."
msgstr "también devolverá el código de estado `200` y el nombre `admin`, ya que `admin` tiene los roles `user` y `admin`."

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:484
#, fuzzy
msgid "Now let's check `FrontendResource` methods which do not propagate the existing tokens but use `OidcClient` to acquire and propagate the tokens. You have seen that `OidcClient` is configured to acquire the tokens for the `alice` user, so:"
msgstr "Ahora vamos a comprobar los métodos de `FrontendResource` que no propagan los tokens existentes sino que utilizan `OidcClient` para adquirir y propagar los tokens. Has visto que `OidcClient` está configurado para adquirir los tokens para el usuario `alice`, así que:"

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:489
#, fuzzy, no-wrap
msgid ""
"curl -i -X GET \\\n"
"  http://localhost:8080/frontend/user-name-with-oidc-client-token\n"
msgstr "`/frontend/user-name-with-oidc-client`"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:492
#, fuzzy
msgid "will return `200` status code and the name `alice`, but"
msgstr "devolverá el código de estado `200` y el nombre `alice`, pero"

#. type: delimited block -
#: upstream/_guides/security-openid-connect-client.adoc:497
#, fuzzy, no-wrap
msgid ""
"curl -i -X GET \\\n"
"  http://localhost:8080/frontend/admin-name-with-oidc-client-token\n"
msgstr "`/frontend/admin-name-with-oidc-client`"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:500
#, fuzzy
msgid "will return `403` status code."
msgstr "devolverá el código de estado `403`."

#. type: Title ==
#: upstream/_guides/security-openid-connect-client.adoc:501
#, fuzzy, no-wrap
msgid "References"
msgstr "Referencias"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:504
#, fuzzy
msgid "xref:security-openid-connect-client-reference.adoc[OpenID Connect Client and Token Propagation Reference Guide]"
msgstr "link:security-openid-connect-client-reference.html[Guía de referencia del cliente de OpenID Connect y de la propagación de tokens]"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:505
#, fuzzy
msgid "xref:security-oidc-bearer-authentication-concept.adoc[OIDC Bearer authentication]"
msgstr "link:security-oidc-bearer-authentication-concept.html[Autenticación del portador OIDC]"

#. type: Plain text
#: upstream/_guides/security-openid-connect-client.adoc:505
#, fuzzy
msgid "xref:security-overview-concept.adoc[Quarkus Security overview]"
msgstr "link:security.html[Seguridad Quarkus]"

#, fuzzy
#~ msgid "xref:security-openid-connect.adoc[Using OpenID Connect to Protect Service Applications]"
#~ msgstr "link:security-openid-connect.html[Quarkus - Uso de OpenID Connect para proteger las aplicaciones de servicios mediante la autorización de tokens de portador]"

#, fuzzy
#~ msgid "Using OpenID Connect (OIDC) and OAuth2 Client and Filters to manage access tokens"
#~ msgstr "Uso de OpenID Connect (OIDC) y OAuth2 Client and Filters para gestionar los tokens de acceso"

#, fuzzy
#~ msgid "This guide explains how to use:"
#~ msgstr "Esta guía explica cómo utilizarlo:"

#, fuzzy
#~ msgid "`quarkus-oidc-client`, `quarkus-oidc-client-reactive-filter` and `quarkus-oidc-client-filter` extensions to acquire and refresh access tokens from OpenID Connect and OAuth 2.0 compliant Authorization Servers such as https://www.keycloak.org[Keycloak]"
#~ msgstr "`quarkus-oidc-client` `quarkus-oidc-client-reactive-filter` y para adquirir y actualizar los tokens de acceso de OpenID Connect y los servidores de autorización compatibles con OAuth 2.0, como `quarkus-oidc-client-filter`  link:https://www.keycloak.org[Keycloak]"

#, fuzzy
#~ msgid "`quarkus-oidc-token-propagation` and `quarkus-oidc-token-propagation-reactive` extensions to propagate the current `Bearer` or `Authorization Code Flow` access tokens"
#~ msgstr "`quarkus-oidc-token-propagation` y `quarkus-oidc-token-propagation-reactive` para propagar los tokens de acceso actuales `Bearer` o `Authorization Code Flow`"

#, fuzzy
#~ msgid "The access tokens managed by these extensions can be used as HTTP Authorization Bearer tokens to access the remote services."
#~ msgstr "Los tokens de acceso gestionados por estas extensiones pueden utilizarse como tokens de portador de autorización HTTP para acceder a los servicios remotos."

#, fuzzy
#~ msgid "OidcClient"
#~ msgstr "OidcClient"

#, fuzzy
#~ msgid "Add the following dependency:"
#~ msgstr "Añade la siguiente dependencia:"

#, fuzzy
#~ msgid "`quarkus-oidc-client` extension provides a reactive `io.quarkus.oidc.client.OidcClient` which can be used to acquire and refresh tokens using SmallRye Mutiny `Uni` and `Vert.x WebClient`."
#~ msgstr "`quarkus-oidc-client` La extensión proporciona un `io.quarkus.oidc.client.OidcClient` reactivo que puede utilizarse para adquirir y refrescar fichas utilizando SmallRye Mutiny `Uni` y `Vert.x WebClient`."

#, fuzzy
#~ msgid "`OidcClient` is initialized at the build time with the IDP token endpoint URL which can be auto-discovered or manually configured and uses this endpoint to acquire access tokens using the token grants such as `client_credentials` or `password` and refresh the tokens using a `refresh_token` grant."
#~ msgstr "`OidcClient` se inicializa en el momento de la compilación con la URL del punto final de IDP, que puede ser autodescubierto o configurado manualmente, y utiliza este punto final para adquirir tokens de acceso utilizando las concesiones de tokens como `client_credentials` o `password` y refrescar los tokens utilizando una concesión `refresh_token`."

#, fuzzy
#~ msgid "Token Endpoint Configuration"
#~ msgstr "Configuración del punto final del token"

#, fuzzy
#~ msgid "By default the token endpoint address is discovered by adding a `/.well-known/openid-configuration` path to the configured `quarkus.oidc-client.auth-server-url`."
#~ msgstr "Por defecto, la dirección del punto final del token se descubre añadiendo una ruta `/.well-known/openid-configuration` al `quarkus.oidc-client.auth-server-url` configurado."

#, fuzzy
#~ msgid "For example, given this Keycloak URL:"
#~ msgstr "Por ejemplo, dada esta URL de Keycloak:"

#, fuzzy
#~ msgid "`OidcClient` will discover that the token endpoint URL is `http://localhost:8180/auth/realms/quarkus/protocol/openid-connect/tokens`."
#~ msgstr "`OidcClient` descubrirá que la URL del punto final del token es `&lt;a href=\"http://localhost:8180/auth/realms/quarkus/protocol/openid-connect/tokens\" class=\"bare\"&gt;http://localhost:8180/auth/realms/quarkus/protocol/openid-connect/tokens&lt;/a&gt;`."

#, fuzzy
#~ msgid "Alternatively, if the discovery endpoint is not available or you would like to save on the discovery endpoint roundtrip, you can disable the discovery and configure the token endpoint address with a relative path value, for example:"
#~ msgstr "Alternativamente, si el punto final de descubrimiento no está disponible o si desea ahorrar en el viaje de ida y vuelta del punto final de descubrimiento, puede desactivar el descubrimiento y configurar la dirección del punto final del token con un valor de ruta relativa, por ejemplo:"

#, fuzzy
#~ msgid "A more compact way to configure the token endpoint URL without the discovery is to set `quarkus.oidc-client.token-path` to an absolute URL:"
#~ msgstr "Una forma más compacta de configurar la URL del punto final del token sin el descubrimiento es establecer `quarkus.oidc-client.token-path` a una URL absoluta:"

#, fuzzy
#~ msgid "Setting 'quarkus.oidc-client.auth-server-url' and 'quarkus.oidc-client.discovery-enabled' is not required in this case."
#~ msgstr "La configuración de 'quarkus.oidc-client.auth-server-url' y 'quarkus.oidc-client.discovery-enabled' no es necesaria en este caso."

#, fuzzy
#~ msgid "Supported Token Grants"
#~ msgstr "Subvenciones de fichas apoyadas"

#, fuzzy
#~ msgid "The main token grants which `OidcClient` can use to acquire the tokens are the `client_credentials` (default) and `password` grants."
#~ msgstr "Las principales concesiones de fichas que `OidcClient` puede utilizar para adquirir las fichas son las concesiones `client_credentials` (por defecto) y `password`."

#, fuzzy
#~ msgid "Client Credentials Grant"
#~ msgstr "Subvención de las credenciales de los clientes"

#, fuzzy
#~ msgid "Here is how `OidcClient` can be configured to use the `client_credentials` grant:"
#~ msgstr "Así es como se puede configurar `OidcClient` para utilizar la subvención `client_credentials`:"

#, fuzzy
#~ msgid "The `client_credentials` grant allows to set extra parameters to the token request via `quarkus.oidc-client.grant-options.client.<param-name>=<value>`. Here is how to set the intended token recipient via the `audience` parameter:"
#~ msgstr "La concesión `client_credentials` permite establecer parámetros adicionales a la solicitud de token a través de `quarkus.oidc-client.grant-options.client.&amp;lt;param-name&amp;gt;=&amp;lt;value&amp;gt;`. A continuación se explica cómo establecer el destinatario del token a través del parámetro `audience`:"

#, fuzzy
#~ msgid "Password Grant"
#~ msgstr "Concesión de la contraseña"

#, fuzzy
#~ msgid "Here is how `OidcClient` can be configured to use the `password` grant:"
#~ msgstr "Así es como se puede configurar `OidcClient` para utilizar la subvención `password`:"

#, fuzzy
#~ msgid "It can be further customized using a `quarkus.oidc-client.grant-options.password` configuration prefix, similarly to how the client credentials grant can be customized."
#~ msgstr "Se puede personalizar aún más utilizando un prefijo de configuración `quarkus.oidc-client.grant-options.password`, de forma similar a como se puede personalizar la concesión de credenciales de cliente."

#, fuzzy
#~ msgid "Other Grants"
#~ msgstr "Otras subvenciones"

#, fuzzy
#~ msgid "`OidcClient` can also help with acquiring the tokens using the grants which require some extra input parameters which can not be captured in the configuration. These grants are `refresh token` (with the external refresh token), `token exchange` and `authorization code`."
#~ msgstr "`OidcClient` también puede ayudar a adquirir los tokens utilizando las subvenciones que requieren algunos parámetros de entrada adicionales que no pueden ser capturados en la configuración. Estas concesiones son `refresh token` (con el token de refresco externo), `token exchange` y `authorization code`."

#, fuzzy
#~ msgid "Using the `refresh_token` grant which uses an out of band refresh token to acquire a new set of tokens will be required if the existing refresh token has been posted to the current Quarkus endpoint for it to acquire the access token. In this case `OidcClient` needs to be configured as follows:"
#~ msgstr "Utilizando la concesión `refresh_token` que utiliza un token de refresco fuera de banda para adquirir un nuevo conjunto de tokens será necesario si el token de refresco existente ha sido publicado en el punto final de Quarkus actual para que adquiera el token de acceso. En este caso, `OidcClient` debe configurarse como sigue:"

#, fuzzy
#~ msgid "and then you can use `OidcClient.refreshTokens` method with a provided refresh token to get the access token."
#~ msgstr "y luego puede utilizar el método `OidcClient.refreshTokens` con un token de actualización proporcionado para obtener el token de acceso."

#, fuzzy
#~ msgid "Using the `token exchange` grant may be required if you are building a complex microservices application and would like to avoid the same `Bearer` token be propagated to and used by more than one service. Please see <<token-propagation,Token Propagation in MicroProfile RestClient client filter>> for more details."
#~ msgstr "El uso de la concesión `token exchange` puede ser necesario si está construyendo una aplicación de microservicios compleja y desea evitar que el mismo token `Bearer` se propague y sea utilizado por más de un servicio. Por favor, vea  link:#token-propagation[Propagación de Token en el filtro de cliente RestClient de MicroProfile] para más detalles."

#, fuzzy
#~ msgid "Using `OidcClient` to support the `authorization code` grant might be required if for some reasons you can not use the xref:security-openid-connect-web-authentication.adoc[Quarkus OpenID Connect extension] to support Authorization Code Flow. If there is a very good reason for you to implement Authorization Code Flow then you can configure `OidcClient` as follows:"
#~ msgstr "El uso de `OidcClient` para apoyar la concesión de `authorization code` puede ser necesario si por algunas razones no se puede utilizar la  link:security-openid-connect-web-authentication.html[extensión Quarkus OpenID] Connect para apoyar el flujo de código de autorización. Si hay una muy buena razón para que usted implemente el Flujo de Código de Autorización, entonces puede configurar `OidcClient` como sigue:"

#, fuzzy
#~ msgid "and then you can use `OidcClient.accessTokens` method accepting a Map of extra properties and pass the current `code` and `redirect_uri` parameters to exchange the authorization code for the tokens."
#~ msgstr "y luego puede utilizar el método `OidcClient.accessTokens` aceptando un Mapa de propiedades extra y pasar los parámetros actuales `code` y `redirect_uri` para intercambiar el código de autorización por los tokens."

#, fuzzy
#~ msgid "Grant scopes"
#~ msgstr "Subvenciones de alcance"

#, fuzzy
#~ msgid "You may need to request that a specific set of scopes is associated with an issued access token.  Use a dedicated `quarkus.oidc-client.scopes` list property, for example: `quarkus.oidc-client.scopes=email,phone`"
#~ msgstr "Es posible que tenga que solicitar que un conjunto específico de ámbitos se asocie con un token de acceso emitido. Utilice una propiedad de la lista `quarkus.oidc-client.scopes` dedicada, por ejemplo: `quarkus.oidc-client.scopes=email,phone`"

#, fuzzy
#~ msgid "Use OidcClient directly"
#~ msgstr "Utilizar directamente OidcClient"

#, fuzzy
#~ msgid "One can use `OidcClient` directly as follows:"
#~ msgstr "Se puede utilizar directamente `OidcClient` de la siguiente manera:"

#, fuzzy
#~ msgid "Inject Tokens"
#~ msgstr "Inyectar fichas"

#, fuzzy
#~ msgid "You can inject `Tokens` which uses `OidcClient` internally. `Tokens` can be used to acquire the access tokens and refresh them if necessary:"
#~ msgstr "Se puede inyectar `Tokens` que utiliza `OidcClient` internamente. `Tokens` puede ser utilizado para adquirir los tokens de acceso y refrescarlos si es necesario:"

#, fuzzy
#~ msgid "Use OidcClients"
#~ msgstr "Utilizar OidcClients"

#, fuzzy
#~ msgid "`io.quarkus.oidc.client.OidcClients` is a container of ``OidcClient``s - it includes a default `OidcClient` and named clients which can be configured like this:"
#~ msgstr "`io.quarkus.oidc.client.OidcClients` es un contenedor de `OidcClient`s - incluye un `OidcClient` por defecto y clientes con nombre que pueden ser configurados así:"

#, fuzzy
#~ msgid "Note in this case the default client is disabled with a `client-enabled=false` property. The `jwt-secret` client can be accessed like this:"
#~ msgstr "Tenga en cuenta que en este caso el cliente por defecto está desactivado con una propiedad `client-enabled=false`. Se puede acceder al cliente `jwt-secret` de la siguiente manera:"

#, fuzzy
#~ msgid "If you also use xref:security-openid-connect-multitenancy.adoc[OIDC multitenancy] and each OIDC tenant has its own associated `OidcClient` then you can use a Vert.x `RoutingContext` `tenantId` attribute, for example:"
#~ msgstr "Si también utiliza  link:security-openid-connect-multitenancy.html[el multitenant OIDC] y cada tenant OIDC tiene su propio `OidcClient` asociado, puede utilizar un atributo Vert.x `RoutingContext` `tenantId` , por ejemplo:"

#, fuzzy
#~ msgid "If you need you can also create new `OidcClient` programmatically like this:"
#~ msgstr "Si lo necesita, también puede crear un nuevo `OidcClient` mediante programación, de la siguiente manera:"

#, fuzzy
#~ msgid "Inject named OidcClient and Tokens"
#~ msgstr "Inyectar el llamado OidcClient y los tokens"

#, fuzzy
#~ msgid "In case of multiple configured ``OidcClient``s you can specify the `OidcClient` injection target by the extra qualifier `@NamedOidcClient` instead of working with `OidcClients`:"
#~ msgstr "En el caso de múltiples `OidcClient`s configurados, puede especificar el objetivo de inyección `OidcClient` mediante el calificador extra `@NamedOidcClient` en lugar de trabajar con `OidcClients`:"

#, fuzzy
#~ msgid "The same qualifier can be used to specify the `OidcClient` used for a `Tokens` injection:"
#~ msgstr "El mismo calificador puede utilizarse para especificar el `OidcClient` utilizado para una inyección de `Tokens`:"

#, fuzzy
#~ msgid "Use OidcClient in RestClient Reactive ClientFilter"
#~ msgstr "Utilizar OidcClient en RestClient Reactive ClientFilter"

#, fuzzy
#~ msgid "Add the following Maven Dependency:"
#~ msgstr "Añade la siguiente dependencia de Maven:"

#, fuzzy
#~ msgid "Note it will also bring `io.quarkus:quarkus-oidc-client`."
#~ msgstr "Tenga en cuenta que también traerá `io.quarkus:quarkus-oidc-client`."

#, fuzzy
#~ msgid "`quarkus-oidc-client-reactive-filter` extension provides `io.quarkus.oidc.client.filter.OidcClientRequestReactiveFilter`."
#~ msgstr "`quarkus-oidc-client-reactive-filter` La extensión proporciona `io.quarkus.oidc.client.filter.OidcClientRequestReactiveFilter`."

#, fuzzy
#~ msgid "It works similarly to the way `OidcClientRequestFilter` does (see <<oidc-client-filter, Use OidcClient in MicroProfile RestClient client filter>>) - it uses `OidcClient` to acquire the access token, refresh it if needed, and set it as an HTTP `Authorization` `Bearer` scheme value. The difference is that it works with xref:rest-client-reactive.adoc[Reactive RestClient] and implements a non-blocking client filter which does not block the current IO thread when acquiring or refreshing the tokens."
#~ msgstr "Funciona de manera similar a como lo hace `OidcClientRequestFilter` (ver  link:#oidc-client-filter[Uso de OidcClient en el filtro de cliente RestClient de MicroProfile]) - utiliza `OidcClient` para adquirir el token de acceso, refrescarlo si es necesario, y establecerlo como un valor de esquema HTTP `Authorization` `Bearer` . La diferencia es que trabaja con RestClient  link:rest-client-reactive.html[Reactivo] e implementa un filtro de cliente no bloqueante que no bloquea el hilo IO actual cuando adquiere o refresca los tokens."

#, fuzzy
#~ msgid "`OidcClientRequestReactiveFilter` delays an initial token acquisition until it is executed to avoid blocking an IO thread and it currently can only be registered with `org.eclipse.microprofile.rest.client.annotation.RegisterProvider` annotation:"
#~ msgstr "`OidcClientRequestReactiveFilter` retrasa la adquisición de un token inicial hasta que se ejecuta para evitar el bloqueo de un hilo IO y actualmente sólo puede registrarse con la anotación `org.eclipse.microprofile.rest.client.annotation.RegisterProvider`:"

#, fuzzy
#~ msgid "`OidcClientRequestReactiveFilter` uses a default `OidcClient` by default. A named `OidcClient` can be selected with a `quarkus.oidc-client-reactive-filter.client-name` configuration property."
#~ msgstr "`OidcClientRequestReactiveFilter` utiliza un `OidcClient` por defecto. Se puede seleccionar un nombre `OidcClient` con una propiedad de configuración `quarkus.oidc-client-reactive-filter.client-name`."

#, fuzzy
#~ msgid "Use OidcClient in RestClient ClientFilter"
#~ msgstr "Utilizar OidcClient en RestClient ClientFilter"

#, fuzzy
#~ msgid "`quarkus-oidc-client-filter` extension provides `io.quarkus.oidc.client.filter.OidcClientRequestFilter` JAX-RS ClientRequestFilter which uses `OidcClient` to acquire the access token, refresh it if needed, and set it as an HTTP `Authorization` `Bearer` scheme value."
#~ msgstr "`quarkus-oidc-client-filter` proporciona `io.quarkus.oidc.client.filter.OidcClientRequestFilter` JAX-RS ClientRequestFilter que utiliza `OidcClient` para adquirir el token de acceso, actualizarlo si es necesario, y establecerlo como un valor del esquema HTTP `Authorization` `Bearer` ."

#, fuzzy
#~ msgid "By default, this filter will get `OidcClient` to acquire the first pair of access and refresh tokens at its initialization time. If the access tokens are short-lived and refresh tokens are not available then the token acquisition should be delayed with `quarkus.oidc-client.early-tokens-acquisition=false`."
#~ msgstr "Por defecto, este filtro obtendrá `OidcClient` para adquirir el primer par de tokens de acceso y refresco en su tiempo de inicialización. Si los tokens de acceso son de corta duración y los tokens de refresco no están disponibles, entonces la adquisición de tokens debe retrasarse con `quarkus.oidc-client.early-tokens-acquisition=false`."

#, fuzzy
#~ msgid "You can selectively register `OidcClientRequestFilter` by using either `io.quarkus.oidc.client.filter.OidcClientFilter` or `org.eclipse.microprofile.rest.client.annotation.RegisterProvider` annotations:"
#~ msgstr "Puede registrar selectivamente `OidcClientRequestFilter` utilizando las anotaciones `io.quarkus.oidc.client.filter.OidcClientFilter` o `org.eclipse.microprofile.rest.client.annotation.RegisterProvider`:"

#, fuzzy
#~ msgid "or"
#~ msgstr "o"

#, fuzzy
#~ msgid "Alternatively, `OidcClientRequestFilter` can be registered automatically with all MP Rest or JAX-RS clients if `quarkus.oidc-client-filter.register-filter=true` property is set."
#~ msgstr "Alternativamente, `OidcClientRequestFilter` puede registrarse automáticamente con todos los clientes de MP Rest o JAX-RS si se establece la propiedad `quarkus.oidc-client-filter.register-filter=true`."

#, fuzzy
#~ msgid "`OidcClientRequestFilter` uses a default `OidcClient` by default. A named `OidcClient` can be selected with a `quarkus.oidc-client-filter.client-name` configuration property."
#~ msgstr "`OidcClientRequestFilter` utiliza un `OidcClient` por defecto. Se puede seleccionar un nombre `OidcClient` con una propiedad de configuración `quarkus.oidc-client-filter.client-name`."

#, fuzzy
#~ msgid "Use Custom RestClient ClientFilter"
#~ msgstr "Utilizar el ClientFilter personalizado de RestClient"

#, fuzzy
#~ msgid "If you prefer you can use your own custom filter and inject `Tokens`:"
#~ msgstr "Si lo prefiere, puede utilizar su propio filtro personalizado e inyectar `Tokens`:"

#, fuzzy
#~ msgid "The `Tokens` producer will acquire and refresh the tokens, and the custom filter will decide how and when to use the token."
#~ msgstr "El productor de `Tokens` adquirirá y actualizará los tokens, y el filtro personalizado decidirá cómo y cuándo utilizar el token."

#, fuzzy
#~ msgid "You can also inject named `Tokens`, see <<named-oidc-clients,Inject named OidcClient and Tokens>>"
#~ msgstr "También se puede inyectar el nombre `Tokens`, ver  link:#named-oidc-clients[Inyectar el nombre OidcClient y Tokens]"

#, fuzzy
#~ msgid "Refreshing Access Tokens"
#~ msgstr "Refrescar los tokens de acceso"

#, fuzzy
#~ msgid "`OidcClientRequestReactiveFilter`, `OidcClientRequestFilter` and `Tokens` producers will refresh the current expired access token if the refresh token is available.  Additionally, `quarkus.oidc-client.refresh-token-time-skew` property can be used for a preemptive access token refreshment to avoid sending nearly expired access tokens which may cause HTTP 401 errors. For example if this property is set to `3S` and the access token will expire in less than 3 seconds then this token will be auto-refreshed."
#~ msgstr "`OidcClientRequestReactiveFilter`Los productores `OidcClientRequestFilter` y `Tokens` refrescarán el token de acceso actual caducado si el token de refresco está disponible. Además, la propiedad `quarkus.oidc-client.refresh-token-time-skew` puede utilizarse para una actualización preventiva de tokens de acceso para evitar el envío de tokens de acceso casi caducados que pueden causar errores HTTP 401. Por ejemplo, si esta propiedad se establece en `3S` y el token de acceso caduca en menos de 3 segundos, este token se actualizará automáticamente."

#, fuzzy
#~ msgid "If the access token needs to be refreshed but no refresh token is available then an attempt will be made to acquire a new token using the configured grant such as `client_credentials`."
#~ msgstr "Si el token de acceso necesita ser refrescado pero no hay ningún token de refresco disponible, entonces se intentará adquirir un nuevo token utilizando la concesión configurada como `client_credentials`."

#, fuzzy
#~ msgid "Please note that some OpenID Connect Providers will not return a refresh token in a `client_credentials` grant response. For example, starting from Keycloak 12 a refresh token will not be returned by default for `client_credentials`. The providers may also restrict a number of times a refresh token can be used."
#~ msgstr "Tenga en cuenta que algunos proveedores de OpenID Connect no devolverán un token de actualización en una respuesta de concesión de `client_credentials`. Por ejemplo, a partir de Keycloak 12 no se devolverá un token de actualización por defecto para `client_credentials`. Los proveedores también pueden restringir el número de veces que se puede utilizar un token de actualización."

#, fuzzy
#~ msgid "OidcClient Authentication"
#~ msgstr "Autenticación OidcClient"

#, fuzzy
#~ msgid "`OidcClient` has to authenticate to the OpenID Connect Provider for the `client_credentials` and other grant requests to succeed.  All the https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication[OIDC Client Authentication] options are supported, for example:"
#~ msgstr "`OidcClient` tiene que autenticarse en el proveedor de OpenID Connect para que las solicitudes de `client_credentials` y otras solicitudes de concesión tengan éxito. Todas las opciones de  link:https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication[autenticación de clientes de OIDC] son compatibles, por ejemplo:"

#, fuzzy
#~ msgid "`client_secret_basic`:"
#~ msgstr "`client_secret_basic`:"

#, fuzzy
#~ msgid "or with the secret retrieved from a xref:credentials-provider.adoc[CredentialsProvider]:"
#~ msgstr "o con el secreto recuperado de un  link:credentials-provider.html[CredentialsProvider]:"

#, fuzzy
#~ msgid "`client_secret_post`:"
#~ msgstr "`client_secret_post`:"

#, fuzzy
#~ msgid "`client_secret_jwt`, signature algorithm is `HS256`:"
#~ msgstr "`client_secret_jwt`El algoritmo de firma es `HS256`:"

#, fuzzy
#~ msgid "or with the secret retrieved from a xref:credentials-provider.adoc[CredentialsProvider], signature algorithm is `HS256`:"
#~ msgstr "o con el secreto recuperado de un  link:credentials-provider.html[CredentialsProvider], el algoritmo de firma es `HS256`:"

#, fuzzy
#~ msgid "`private_key_jwt` with the PEM key file, signature algorithm is `RS256`:"
#~ msgstr "`private_key_jwt` con el archivo de claves PEM, el algoritmo de firma es `RS256`:"

#, fuzzy
#~ msgid "`private_key_jwt` with the key store file, signature algorithm is `RS256`:"
#~ msgstr "`private_key_jwt` con el archivo de almacenamiento de claves, el algoritmo de firma es `RS256`:"

#, fuzzy
#~ msgid "Using `client_secret_jwt` or `private_key_jwt` authentication methods ensures that no client secret goes over the wire."
#~ msgstr "El uso de los métodos de autenticación `client_secret_jwt` o `private_key_jwt` garantiza que ningún secreto del cliente pase por el cable."

#, fuzzy
#~ msgid "Additional JWT Authentication options"
#~ msgstr "Opciones adicionales de autenticación JWT"

#, fuzzy
#~ msgid "If either `client_secret_jwt` or `private_key_jwt` authentication methods are used then the JWT signature algorithm, key identifier, audience, subject and issuer can be customized, for example:"
#~ msgstr "Si se utilizan los métodos de autenticación `client_secret_jwt` o `private_key_jwt`, se pueden personalizar, por ejemplo, el algoritmo de la firma JWT, el identificador de la clave, el público, el sujeto y el emisor:"

#, fuzzy
#~ msgid "Apple POST JWT"
#~ msgstr "Apple POST JWT"

#, fuzzy
#~ msgid "Apple OpenID Connect Provider uses a `client_secret_post` method where a secret is a JWT produced with a `private_key_jwt` authentication method but with Apple account specific issuer and subject properties."
#~ msgstr "El proveedor de Apple OpenID Connect utiliza un método `client_secret_post` en el que un secreto es un JWT producido con un método de autenticación `private_key_jwt` pero con propiedades de emisor y sujeto específicas de la cuenta de Apple."

#, fuzzy
#~ msgid "`quarkus-oidc-client` supports a non-standard `client_secret_post_jwt` authentication method which can be configured as follows:"
#~ msgstr "`quarkus-oidc-client` admite un método de autenticación no estándar `client_secret_post_jwt` que puede configurarse como sigue:"

#, fuzzy
#~ msgid "Mutual TLS"
#~ msgstr "TLS mutuo"

#, fuzzy
#~ msgid "Some OpenID Connect Providers may require that a client is authenticated as part of the `Mutual TLS` (`mTLS`) authentication process."
#~ msgstr "Algunos proveedores de OpenID Connect pueden exigir que el cliente se autentique como parte del proceso de autenticación de `Mutual TLS` ( `mTLS`)."

#, fuzzy
#~ msgid "`quarkus-oidc-client` can be configured as follows to support `mTLS`:"
#~ msgstr "`quarkus-oidc-client` puede configurarse de la siguiente manera para soportar `mTLS`:"

#, fuzzy
#~ msgid "Testing"
#~ msgstr "Probando"

#, fuzzy
#~ msgid "Start by adding the following dependencies to your test project:"
#~ msgstr "Comience por añadir las siguientes dependencias a su proyecto de prueba:"

#, fuzzy
#~ msgid "Wiremock"
#~ msgstr "Wiremock"

#, fuzzy
#~ msgid "Add the following dependencies to your test project:"
#~ msgstr "Añada las siguientes dependencias a su proyecto de prueba:"

#, fuzzy
#~ msgid "Write Wiremock based `QuarkusTestResourceLifecycleManager`, for example:"
#~ msgstr "Escriba un `QuarkusTestResourceLifecycleManager` basado en Wiremock, por ejemplo:"

#, fuzzy
#~ msgid "Prepare the REST test endpoints, you can have the test frontend endpoint which uses the injected MP REST client with a registered OidcClient filter to invoke on the downstream endpoint which echoes the token back, for example, see the `integration-tests/oidc-client-wiremock` in the `main` Quarkus repository."
#~ msgstr "Prepare los puntos finales de prueba REST, puede tener el punto final del frontend de prueba que utiliza el cliente MP REST inyectado con un filtro OidcClient registrado para invocar en el punto final descendente que se hace eco del token de vuelta, por ejemplo, vea el `integration-tests/oidc-client-wiremock` en el repositorio `main` Quarkus."

#, fuzzy
#~ msgid "Set `application.properties`, for example:"
#~ msgstr "Establece `application.properties`, por ejemplo:"

#, fuzzy
#~ msgid "and finally write the test code. Given the Wiremock-based resource above, the first test invocation should return `access_token_1` access token which will expire in 4 seconds. Use `awaitility` to wait for about 5 seconds, and now the next test invocation should return `access_token_2` access token which confirms the expired `access_token_1` access token has been refreshed."
#~ msgstr "y finalmente escribir el código de prueba. Dado el recurso basado en Wiremock anterior, la primera invocación de prueba debería devolver `access_token_1` token de acceso que expirará en 4 segundos. Utiliza `awaitility` para esperar unos 5 segundos, y ahora la siguiente invocación de prueba debería devolver `access_token_2` token de acceso que confirma que el token de acceso `access_token_1` caducado ha sido refrescado."

#, fuzzy
#~ msgid "Keycloak"
#~ msgstr "Keycloak"

#, fuzzy
#~ msgid "If you work with Keycloak then you can use the same approach as described in the xref:security-openid-connect#integration-testing-keycloak.adoc[OpenID Connect Bearer Token Integration testing] Keycloak section."
#~ msgstr "Si trabaja con Keycloak, puede utilizar el mismo enfoque que se describe en la sección de  link:security-openid-connect.html#integration-testing-keycloak.adoc[pruebas de integración del token de portador de OpenID Connect] `Keycloak`."

#, fuzzy
#~ msgid "How to check the errors in the logs"
#~ msgstr "Cómo comprobar los errores en los registros"

#, fuzzy
#~ msgid "Please enable `io.quarkus.oidc.client.runtime.OidcClientImpl` `TRACE` level logging to see more details about the token acquisition and refresh errors:"
#~ msgstr "Por favor, active el registro de nivel `io.quarkus.oidc.client.runtime.OidcClientImpl` `TRACE` para ver más detalles sobre los errores de adquisición y actualización de tokens:"

#, fuzzy
#~ msgid "Please enable `io.quarkus.oidc.client.runtime.OidcClientRecorder` `TRACE` level logging to see more details about the OidcClient initialization errors:"
#~ msgstr "Por favor, active el registro de nivel `io.quarkus.oidc.client.runtime.OidcClientRecorder` `TRACE` para ver más detalles sobre los errores de inicialización de OidcClient:"

#, fuzzy
#~ msgid "Token Propagation"
#~ msgstr "Propagación de fichas"

#, fuzzy
#~ msgid "The `quarkus-oidc-token-propagation` extension provides two JAX-RS `javax.ws.rs.client.ClientRequestFilter` class implementations that simplify the propagation of authentication information.  `io.quarkus.oidc.token.propagation.AccessTokenRequestFilter` propagates the xref:security-openid-connect.adoc[Bearer] token present in the current active request or the token acquired from the xref:security-openid-connect-web-authentication.adoc[Authorization Code Flow], as the HTTP `Authorization` header's `Bearer` scheme value.  The `io.quarkus.oidc.token.propagation.JsonWebTokenRequestFilter` provides the same functionality, but in addition provides support for JWT tokens."
#~ msgstr "La extensión `quarkus-oidc-token-propagation` proporciona dos implementaciones de la clase JAX-RS `javax.ws.rs.client.ClientRequestFilter` que simplifican la propagación de la información de autenticación. `io.quarkus.oidc.token.propagation.AccessTokenRequestFilter` propaga el token de  link:security-openid-connect.html[portador] presente en la solicitud activa actual o el token adquirido desde el  link:security-openid-connect-web-authentication.html[flujo de código de] autorización, como valor de esquema del encabezado HTTP `Authorization` `Bearer` . El `io.quarkus.oidc.token.propagation.JsonWebTokenRequestFilter` proporciona la misma funcionalidad, pero además ofrece soporte para tokens JWT."

#, fuzzy
#~ msgid "When you need to propagate the current Authorization Code Flow access token then the immediate token propagation will work well - as the code flow access tokens (as opposed to ID tokens) are meant to be propagated for the current Quarkus endpoint to access the remote services on behalf of the currently authenticated user."
#~ msgstr "Cuando necesite propagar el token de acceso al flujo de código de autorización actual, la propagación inmediata del token funcionará bien, ya que los tokens de acceso al flujo de código (a diferencia de los tokens de identificación) están destinados a ser propagados para que el punto final de Quarkus actual acceda a los servicios remotos en nombre del usuario autenticado actualmente."

#, fuzzy
#~ msgid "However, the direct end to end Bearer token propagation should be avoided if possible. For example, `Client -> Service A -> Service B` where `Service B` receives a token sent by `Client` to `Service A`. In such cases `Service B` will not be able to distinguish if the token came from `Service A` or from `Client` directly. For `Service B` to verify the token came from `Service A` it should be able to assert a new issuer and audience claims."
#~ msgstr "Sin embargo, la propagación directa de extremo a extremo del token del portador debe evitarse si es posible. Por ejemplo, `Client → Service A → Service B` donde `Service B` recibe un token enviado por `Client` a `Service A`. En estos casos `Service B` no podrá distinguir si el token procede de `Service A` o de `Client` directamente. Para que `Service B` pueda verificar que el token procede de `Service A`, debe ser capaz de hacer valer un nuevo emisor y unas declaraciones de audiencia."

#, fuzzy
#~ msgid "Additionally, a complex application may need to exchange or update the tokens before propagating them. For example, the access context might be different when `Service A` is accessing `Service B`. In this case, `Service A` might be granted a narrow or a completely different set of scopes to access `Service B`."
#~ msgstr "Además, una aplicación compleja puede necesitar intercambiar o actualizar los tokens antes de propagarlos. Por ejemplo, el contexto de acceso podría ser diferente cuando `Service A` accede a `Service B`. En este caso, a `Service A` se le podría conceder un conjunto de ámbitos reducido o completamente diferente para acceder a `Service B`."

#, fuzzy
#~ msgid "The following sections show how `AccessTokenRequestFilter` and `JsonWebTokenRequestFilter` can help."
#~ msgstr "Las siguientes secciones muestran cómo `AccessTokenRequestFilter` y `JsonWebTokenRequestFilter` pueden ayudar."

#, fuzzy
#~ msgid "RestClient AccessTokenRequestFilter"
#~ msgstr "RestClient AccessTokenRequestFilter"

#, fuzzy
#~ msgid "`AccessTokenRequestFilter` treats all tokens as Strings and as such it can work with both JWT and opaque tokens."
#~ msgstr "`AccessTokenRequestFilter` trata todos los tokens como Strings y como tal puede trabajar tanto con JWT como con tokens opacos."

#, fuzzy
#~ msgid "You can selectively register `AccessTokenRequestFilter` by using either `io.quarkus.oidc.token.propagation.AccessToken` or `org.eclipse.microprofile.rest.client.annotation.RegisterProvider`, for example:"
#~ msgstr "Puede registrar selectivamente `AccessTokenRequestFilter` utilizando `io.quarkus.oidc.token.propagation.AccessToken` o `org.eclipse.microprofile.rest.client.annotation.RegisterProvider`, por ejemplo:"

#, fuzzy
#~ msgid "Alternatively, `AccessTokenRequestFilter` can be registered automatically with all MP Rest or JAX-RS clients if `quarkus.oidc-token-propagation.register-filter` property is set to `true` and `quarkus.oidc-token-propagation.json-web-token` property is set to `false` (which is a default value)."
#~ msgstr "Alternativamente, `AccessTokenRequestFilter` puede registrarse automáticamente con todos los clientes MP Rest o JAX-RS si la propiedad `quarkus.oidc-token-propagation.register-filter` se establece como `true` y la propiedad `quarkus.oidc-token-propagation.json-web-token` se establece como `false` (que es un valor por defecto)."

#, fuzzy
#~ msgid "Exchange Token Before Propagation"
#~ msgstr "Intercambio de fichas antes de la propagación"

#, fuzzy
#~ msgid "If the current access token needs to be exchanged before propagation and you work with link:https://www.keycloak.org/docs/latest/securing_apps/#_token-exchange[Keycloak] or other OpenID Connect Provider which supports a link:https://tools.ietf.org/html/rfc8693[Token Exchange] token grant then you can configure `AccessTokenRequestFilter` like this:"
#~ msgstr "Si el token de acceso actual necesita ser intercambiado antes de la propagación y trabajas con  link:https://www.keycloak.org/docs/latest/securing_apps/#_token-exchange[Keycloak] u otro proveedor de OpenID Connect que soporte una concesión de token de  link:https://tools.ietf.org/html/rfc8693[intercambio], entonces puedes configurar `AccessTokenRequestFilter` así:"

#, fuzzy
#~ msgid "Note `AccessTokenRequestFilter` will use `OidcClient` to exchange the current token and you can use `quarkus.oidc-client.grant-options.exchange` to set the additional exchange properties expected by your OpenID Connect Provider."
#~ msgstr "Nota: `AccessTokenRequestFilter` utilizará `OidcClient` para intercambiar el token actual y usted puede utilizar `quarkus.oidc-client.grant-options.exchange` para establecer las propiedades de intercambio adicionales esperadas por su proveedor de OpenID Connect."

#, fuzzy
#~ msgid "`AccessTokenRequestFilter` uses a default `OidcClient` by default. A named `OidcClient` can be selected with a `quarkus.oidc-token-propagation.client-name` configuration property."
#~ msgstr "`AccessTokenRequestFilter` utiliza un `OidcClient` por defecto. Se puede seleccionar un nombre `OidcClient` con una propiedad de configuración `quarkus.oidc-token-propagation.client-name`."

#, fuzzy
#~ msgid "RestClient JsonWebTokenRequestFilter"
#~ msgstr "RestClient JsonWebTokenRequestFilter"

#, fuzzy
#~ msgid "Using `JsonWebTokenRequestFilter` is recommended if you work with Bearer JWT tokens where these tokens can have their claims such as `issuer` and `audience` modified and the updated tokens secured (for example, re-signed) again. It expects an injected `org.eclipse.microprofile.jwt.JsonWebToken` and therefore will not work with the opaque tokens. Also, if your OpenID Connect Provider supports a Token Exchange protocol then it is recommended to use `AccessTokenRequestFilter` instead - as both JWT and opaque bearer tokens can be securely exchanged with `AccessTokenRequestFilter`."
#~ msgstr "El uso de `JsonWebTokenRequestFilter` se recomienda si se trabaja con tokens JWT portadores en los que estos tokens pueden tener sus reclamos como `issuer` y `audience` modificados y los tokens actualizados asegurados (por ejemplo, re-firmados) de nuevo. Espera un `org.eclipse.microprofile.jwt.JsonWebToken` inyectado y por lo tanto no funcionará con los tokens opacos. Además, si tu proveedor de OpenID Connect admite un protocolo de intercambio de tokens, se recomienda utilizar `AccessTokenRequestFilter` en su lugar, ya que tanto los tokens JWT como los opacos se pueden intercambiar de forma segura con `AccessTokenRequestFilter`."

#, fuzzy
#~ msgid "`JsonWebTokenRequestFilter` makes it easy for `Service A` implementations to update the injected `org.eclipse.microprofile.jwt.JsonWebToken` with the new `issuer` and `audience` claim values and secure the updated token again with a new signature. The only difficult step is to ensure `Service A` has a signing key - it should be provisioned from a secure file system or from the remote secure storage such as Vault."
#~ msgstr "`JsonWebTokenRequestFilter` facilita que las implementaciones de `Service A` actualicen el `org.eclipse.microprofile.jwt.JsonWebToken` inyectado con los nuevos valores de reclamación `issuer` y `audience` y aseguren el token actualizado de nuevo con una nueva firma. El único paso difícil es asegurarse de que `Service A` tenga una clave de firma, que debe obtenerse de un sistema de archivos seguro o de un almacenamiento remoto seguro, como Vault."

#, fuzzy
#~ msgid "You can selectively register `JsonWebTokenRequestFilter` by using either `io.quarkus.oidc.token.propagation.JsonWebToken` or `org.eclipse.microprofile.rest.client.annotation.RegisterProvider`, for example:"
#~ msgstr "Puede registrar selectivamente `JsonWebTokenRequestFilter` utilizando `io.quarkus.oidc.token.propagation.JsonWebToken` o `org.eclipse.microprofile.rest.client.annotation.RegisterProvider`, por ejemplo:"

#, fuzzy
#~ msgid "Alternatively, `JsonWebTokenRequestFilter` can be registered automatically with all MP Rest or JAX-RS clients if both `quarkus.oidc-token-propagation.register-filter` and `quarkus.oidc-token-propagation.json-web-token` properties are set to `true`."
#~ msgstr "Como alternativa, `JsonWebTokenRequestFilter` puede registrarse automáticamente con todos los clientes de MP Rest o JAX-RS si las propiedades `quarkus.oidc-token-propagation.register-filter` y `quarkus.oidc-token-propagation.json-web-token` se establecen en `true`."

#, fuzzy
#~ msgid "Update Token Before Propagation"
#~ msgstr "Actualizar el token antes de la propagación"

#, fuzzy
#~ msgid "If the injected token needs to have its `iss` (issuer) and/or `aud` (audience) claims updated and secured again with a new signature then you can configure `JsonWebTokenRequestFilter` like this:"
#~ msgstr "Si el token inyectado necesita que se actualicen sus reivindicaciones `iss` (emisor) y/o `aud` (público) y se asegure de nuevo con una nueva firma, puede configurar `JsonWebTokenRequestFilter` así:"

#, fuzzy
#~ msgid "As already noted above, please use `AccessTokenRequestFilter` if you work with Keycloak or OpenID Connect Provider which supports a Token Exchange protocol."
#~ msgstr "Como ya se ha indicado anteriormente, utilice `AccessTokenRequestFilter` si trabaja con el proveedor Keycloak u OpenID Connect que soporta un protocolo de intercambio de tokens."

#, fuzzy
#~ msgid "You can generate the tokens as described in xref:security-openid-connect.adoc#integration-testing[OpenID Connect Bearer Token Integration testing] section.  Prepare the REST test endpoints, you can have the test frontend endpoint which uses the injected MP REST client with a registered token propagation filter to invoke on the downstream endpoint, for example, see the `integration-tests/oidc-token-propagation` in the `main` Quarkus repository."
#~ msgstr "Puede generar los tokens como se describe en la sección de  link:security-openid-connect.html#integration-testing[pruebas de integración de tokens de portador de OpenID Connect]. Prepare los puntos finales de prueba REST, puede tener el punto final del frontend de prueba que utiliza el cliente MP REST inyectado con un filtro de propagación de tokens registrado para invocar en el punto final descendente, por ejemplo, consulte el `integration-tests/oidc-token-propagation` en el repositorio `main` Quarkus."

#, fuzzy
#~ msgid "Token Propagation Reactive"
#~ msgstr "Propagación de tokens reactiva"

#, fuzzy
#~ msgid "The `quarkus-oidc-token-propagation-reactive` extension provides `io.quarkus.oidc.token.propagation.reactive.AccessTokenRequestReactiveFilter` which can be used to propagate the current `Bearer` or `Authorization Code Flow` access tokens."
#~ msgstr "La extensión `quarkus-oidc-token-propagation-reactive` proporciona `io.quarkus.oidc.token.propagation.reactive.AccessTokenRequestReactiveFilter` que puede utilizarse para propagar los tokens de acceso actuales `Bearer` o `Authorization Code Flow`."

#, fuzzy
#~ msgid "The `quarkus-oidc-token-propagation-reactive` extension (as opposed to the non-reactive `quarkus-oidc-token-propagation` extension) does not currently support the exchanging or resigning the tokens before the propagation.  However these features may be added in the future."
#~ msgstr "La extensión `quarkus-oidc-token-propagation-reactive` (a diferencia de la extensión no reactiva `quarkus-oidc-token-propagation` ) no soporta actualmente el intercambio o la renuncia de los tokens antes de la propagación. Sin embargo, estas características pueden ser añadidas en el futuro."

#, fuzzy
#~ msgid "xref:security-openid-connect-web-authentication.adoc[Quarkus - Using OpenID Connect to Protect Web Applications using Authorization Code Flow]"
#~ msgstr "link:security-openid-connect-web-authentication.html[Quarkus - Uso de OpenID Connect para proteger las aplicaciones web mediante el flujo de código de autorización]"
