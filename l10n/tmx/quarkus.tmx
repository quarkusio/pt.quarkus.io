<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="Translate Toolkit" creationtoolversion="3.10.1" segtype="sentence" o-tmf="UTF-8" adminlang="en" srclang="en" datatype="PlainText"/>
  <body>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Recomendamos que siga as instruções nas seções seguintes e crie a aplicação passo a passo. No entanto, você pode ir diretamente para o exemplo completo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>pom.xml</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>pom.xml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>build.gradle</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>build.gradle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are going to model our increments using the `Increment` POJO.  Create the `src/main/java/org/acme/redis/Increment.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Vamos modelar os nossos incrementos utilizando o POJO `Increment`. Crie o arquivo `src/main/java/org/acme/redis/Increment.java`, com o seguinte conteúdo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are going to create an `IncrementService` class which will play the role of a Redis client.  With this class, we'll be able to perform the `SET`, `GET` , `DEL`, `KEYS` and `INCRBY` Redis commands.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Vamos criar uma classe `IncrementService` que desempenhará o papel de um cliente Redis. Com essa classe, poderemos executar os comandos Redis `SET`, `GET`, `DEL`, `KEYS` e `INCRBY`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/redis/IncrementService.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Criar o arquivo `src/main/java/org/acme/redis/IncrementService.java`, com o seguinte conteúdo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/redis/IncrementResource.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Criar o arquivo `src/main/java/org/acme/redis/IncrementResource.java`, com o seguinte conteúdo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you followed the instructions, you should have the Redis server running.  Then, you just need to run the application using:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se seguiu as instruções, deve ter o servidor Redis funcionando. Depois, você só precisa executar a aplicação utilizando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open another terminal and run the `curl http://localhost:8080/increments` command.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Abra outro terminal e execute o comando `curl http://localhost:8080/increments.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we have seen above, the API exposes five Rest endpoints.  In this section we are going to see how to initialise an increment, see the list of current increments, incrementing a value given its key, retrieving the current value of an increment, and finally deleting a key.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Como vimos acima, a API expõe cinco endpoints Rest. Nesta seção, vamos ver como inicializar um incremento, ver a lista de incrementos atuais, incrementar um valor dado a sua chave, recuperar o valor atual de um incremento e, finalmente, excluir uma chave.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delete the `first` increment.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Excluir o incremento `first`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At this point, Quarkus uses the Redis Dev Service to run a Redis server and configure the application.  However, in production, you will run your own Redis (or used a Cloud offering).</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Neste ponto, o Quarkus usa o Redis Dev Service para executar um servidor Redis e configurar a aplicação. No entanto, em produção, você irá executar o seu próprio Redis (ou utilizar um oferecido por algum serviço de Cloud).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If any Kafka-related extension is present (e.g. `quarkus-smallrye-reactive-messaging-kafka`), Dev Services for Kafka automatically starts a Kafka broker in dev mode and when running tests.  So, you don't have to start a broker manually.  The application is configured automatically.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se qualquer extensão relacionada ao Kafka estiver presente (por exemplo, `quarkus-smallrye-reactive-messaging-kafka`), o Dev Services para  Kafka iniciará automaticamente um broker Kafka no modo de desenvolvimento e ao executar testes. Portanto, não é necessário iniciar um broker manualmente. A aplicação é configurada de forma automática.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because starting a Kafka broker can be long, Dev Services for Kafka uses https://vectorized.io/redpanda[Redpanda], a Kafka compatible broker which starts in ~1 second.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Como a inicialização de um broker Kafka pode ser demorada, o Dev Services para o Kafka usa o  link:https://vectorized.io/redpanda[Redpanda], um broker compatível com o Kafka que inicia em aproximadamente 1 segundo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling / Disabling Dev Services for Kafka</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Ativar/desativar Dev Services para o Kafka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kafka relies on Docker to start the broker.  If your environment does not support Docker, you will need to start the broker manually, or connect to an already running broker.  You can configure the broker address using `kafka.bootstrap.servers`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para o Kafka depende do Docker para iniciar o broker. Se o seu ambiente não for compatível com o Docker, terá de iniciar o broker manualmente ou conectar-se a um broker já em execução. É possível configurar o endereço do broker usando `kafka.bootstrap.servers`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Shared broker</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>broker compartilhado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the broker between applications.  Dev Services for Kafka implements a _service discovery_ mechanism for your multiple Quarkus applications running in _dev_ mode to share a single broker.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Na maioria das vezes, é necessário compartilhar o broker entre as aplicações. O Dev Services para o Kafka implementa um mecanismo de _descoberta de serviços_ para que seus vários aplicativos Quarkus em execução no _modo_ de _desenvolvimento_ compartilhem um único broker.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) brokers, you can configure the `quarkus.kafka.devservices.service-name` attribute and indicate the broker name.  It looks for a container with the same value, or starts a new one if none can be found.  The default service name is `kafka`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você precisar de vários brokers (compartilhados), você pode configurar o atributo `quarkus.kafka.devservices.service-name` e indicar o nome do broker. Este procura um container com o mesmo valor ou inicia um novo se não for encontrado nenhum. O nome de serviço predefinido é `kafka`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing is enabled by default in dev mode, but disabled in test mode.  You can disable the sharing with `quarkus.kafka.devservices.shared=false`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O compartilhamento é ativado por padrão no modo de desenvolvimento, mas desativado no modo de teste. Você pode desativar o compartilhamento com `quarkus.kafka.devservices.shared=false`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Dev Services for Kafka picks a random port and configures the application.  You can set the port by configuring the `quarkus.kafka.devservices.port` property.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, o Dev Services para o Kafka escolhe uma porta aleatória e configura o aplicativo. Você pode definir a porta configurando a propriedade `quarkus.kafka.devservices.port`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kafka supports https://redpanda.com[Redpanda], https://github/ozangunalp/kafka-native[kafka-native] and https://strimzi.io[Strimzi] (in https://github.com/apache/kafka/blob/trunk/config/kraft/README.md[Kraft] mode)  images.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para o Kafka suporta imagens  link:https://redpanda.com[Redpanda],  link:https://github/ozangunalp/kafka-native[kafka-native] e  link:https://strimzi.io[Strimzi] (no modo  link:https://github.com/apache/kafka/blob/trunk/config/kraft/README.md[Kraft] ).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Redpanda** is a Kafka compatible event streaming platform.
Because it provides a fast startup times, dev services defaults to Redpanda images from `vectorized/redpanda`.
You can select any version from https://hub.docker.com/r/vectorized/redpanda.
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>*Redpanda* é uma plataforma de streaming de eventos compatível com o Kafka. Uma vez que proporciona tempos de startup rápidos, o Dev services têm como padrão as imagens Redpanda de `vectorized/redpanda`. Pode selecionar qualquer versão de  https://hub.docker.com/r/vectorized/redpanda
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**kafka-native** provides images of standard Apache Kafka distribution compiled to native binary using Quarkus and GraalVM.
While still being _experimental_, it provides very fast startup times with small footprint.
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>*kafka-native* fornece imagens da distribuição padrão do Apache Kafka compiladas para binário nativo usando Quarkus e GraalVM. Embora ainda esteja em fase _experimental_, fornece tempos de startup muito rápidos e com consumo reduzido.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Strimzi** provides container images and Operators for running Apache Kafka on Kubernetes.
While Strimzi is optimized for Kubernetes, the images work perfectly in classic container environments.
Strimzi container images run "genuine" Kafka broker on JVM, which is slower to start.
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>*O Strimzi* fornece imagens de container e Operadores para executar o Apache Kafka no Kubernetes. Embora o Strimzi seja otimizado para Kubernetes, as imagens funcionam perfeitamente em ambientes de container clássicos. As imagens de container do Strimzi rodam o broker Kafka "genuíno" na JVM, que é mais lento para iniciar.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Strimzi, you can select any image with a Kafka version which has Kraft support (2.8.1 and higher) from https://quay.io/repository/strimzi-test-container/test-container?tab=tags</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para  o Strimzi, você pode selecionar qualquer imagem com uma versão Kafka que tenha suporte para o Kraft (2.8.1 e superior) em  https://quay.io/repository/strimzi-test-container/test-container?tab=tags</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the Dev Services for Kafka to create topics once the broker is started.  Topics are created with given number of partitions and 1 replica.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Você pode configurar os Dev Services para o Kafka para criar tópicos assim que o broker for iniciado. Os tópicos são criados com um determinado número de partições e uma réplica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure timeout for Kafka admin client calls used in topic creation using `quarkus.kafka.devservices.topic-partitions-timeout`, it defaults to 2 seconds.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Você pode configurar o tempo limite para as chamadas do client admin do Kafka utilizadas na criação de tópicos utilizando `quarkus.kafka.devservices.topic-partitions-timeout`. A predefinição é de 2 segundos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the Red Panda broker is configured to enable transactions and idempotence features.  You can disable those using:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, o broker do Red Panda está configurado para ativar as funcionalidades de transações e idempotência. Você pode desativá-las utilizando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Redpanda transactions does not support exactly-once processing.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>As transações Redpanda não suportam um processamento exatamente único.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP automatically starts an AMQP 1.0 broker in dev mode and when running tests.  So, you don't have to start a broker manually.  The application is configured automatically.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para AMQP inicia automaticamente um broker AMQP 1.0 no modo de desenvolvimento e ao executar testes. Assim, não é necessário iniciar um broker manualmente. A aplicação é configurada de forma automática.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling / Disabling Dev Services for AMQP</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Ativação/desativação do Dev Services para AMQP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP is automatically enabled unless:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para AMQP é  ativado automaticamente, a menos que:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP relies on Docker to start the broker.  If your environment does not support Docker, you will need to start the broker manually, or connect to an already running broker.  You can configure the broker access using the `amqp-host`, `amqp-port`, `amqp-user` and `amqp-password` properties.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para AMQP depende do Docker para iniciar o Broker. Se o seu ambiente não for compatível com o Docker, será necessário iniciar o Broker manualmente ou conectar-se a um Broker já em execução. Você pode configurar o acesso ao Broker  utilizando as propriedades `amqp-host`, `amqp-port`, `amqp-user` e `amqp-password`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the broker between applications.  Dev Services for AMQP implements a _service discovery_ mechanism for your multiple Quarkus applications running in _dev_ mode to share a single broker.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Na maioria das vezes, é necessário compartilhar o broker entre as aplicações. O Dev Services para AMQP implementa um mecanismo de _service discovery_ para que as suas múltiplas aplicações Quarkus em execução no _dev_ mode_ compartilhem um único broker.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) brokers, you can configure the `quarkus.amqp.devservices.service-name` attribute and indicate the broker name.  It looks for a container with the same value, or starts a new one if none can be found.  The default service name is `amqp`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você precisar de vários brokers (compartilhados), você pode configurar o atributo `quarkus.amqp.devservices.service-name` e indicar o nome do broker. Este irá buscar  um container com o mesmo valor ou iniciará um novo se não for encontrado nenhum. O nome de serviço predefinido é `amqp`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Dev Services for AMQP picks a random port and configures the application.  You can set the port by configuring the `quarkus.amqp.devservices.port` property.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, o Dev Services para AMQP escolhe uma porta aleatória e configura a aplicação. É possível definir a porta configurando a propriedade `quarkus.amqp.devservices.port`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP uses https://quay.io/repository/artemiscloud/activemq-artemis-broker[activemq-artemis-broker] images.  You can configure the image and version using the `quarkus.amqp.devservices.image-name` property:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para AMQP usa a imagem  link:https://quay.io/repository/artemiscloud/activemq-artemis-broker[activemq-artemis-broker]. É possível configurar a imagem e a versão usando a propriedade `quarkus.amqp.devservices.image-name`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kubernetes automatically starts a Kubernetes API server in dev mode and when running tests.  So you don't have to start a Kubernetes cluster manually.  The application is configured automatically.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para Kubernetes inicia automaticamente um servidor de API do Kubernetes no modo de desenvolvimento e ao executar testes. Assim, não é necessário iniciar um cluster do Kubernetes manualmente. A aplicação é configurada de forma automática.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling / Disabling Dev Services for Kubernetes</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Ativar/desativar Dev Services  para Kubernetes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `api-server-url` is configured</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A URL `api-server-url` esteja configurada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a valid Kube config file is found and `quarkus.kubernetes-client.devservices.override-kubeconfig` is not set to `true`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Um arquivo de configuração Kube válido seja encontrado e `quarkus.kubernetes-client.devservices.override-kubeconfig` não está definido como `true`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you include the `quarkus-test-kubernetes-client` dependency</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Você inclua a dependência `quarkus-test-kubernetes-client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kubernetes relies on Docker to start the API server.  If your environment does not support Docker, you will need to start the Kubernetes cluster manually, or connect to an already running Kubernetes cluster.  You can configure the Kubernetes cluster access using either a Kube config file or the various properties available in the https://github.com/quarkusio/quarkus/blob/main/extensions/kubernetes-client/runtime-internal/src/main/java/io/quarkus/kubernetes/client/runtime/KubernetesClientBuildConfig.java[KubernetesClientBuildConfig] class.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para Kubernetes depende do Docker para iniciar o servidor de API. Se o seu ambiente não suportar o Docker, terá de iniciar o cluster Kubernetes manualmente ou conectar-se a um cluster Kubernetes já em execução. É possível configurar o acesso ao cluster do Kubernetes usando um arquivo de configuração do Kube ou as várias propriedades disponíveis na classe link:https://github.com/quarkusio/quarkus/blob/main/extensions/kubernetes-client/runtime-internal/src/main/java/io/quarkus/kubernetes/client/runtime/KubernetesClientBuildConfig.java[KubernetesClientBuildConfig].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the cluster between applications.  Dev Services for Kubernetes implements a _service discovery_ mechanism for your multiple Quarkus applications running in dev mode to share a single cluster.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Na maioria das vezes, é necessário compartilhar o cluster entre aplicações. O Dev Services para Kubernetes implementaa um mecanismo de _service discovery_ para que suas várias aplicações Quarkus em execução no _dev_ mode_ compartilhem um único cluster.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) clusters, you can configure the `quarkus.kubernetes-client.devservices.service-name` configuration property and indicate the cluster name.  It looks for a container with the name defined, or starts a new one if none can be found.  The default service name is `kubernetes`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg> Se você precisar de vários clusters (compartilhados), você pode configurar o configuration property `quarkus.kubernetes-client.devservices.service-name` e indicar o nome do cluster. Procurar um container com o nome definido ou iniciar um novo se não for encontrado nenhum. O nome do serviço predefinido é `kubernetes`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kubernetes provides three different flavors of Kubernetes cluster. Each flavor supports different Kubernetes API versions.  You can configure the flavor and version using the `quarkus.kubernetes-client.devservices.flavor` and `quarkus.kubernetes-client.devservices.api-version` properties:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para Kubernetes oferece três flavors diferentes de cluster Kubernetes. Cada flavor suporta diferentes versões da API do Kubernetes. Você pode configurar o flavor e a versão usando as propriedades quarkus.kubernetes-client.devservices.flavor e quarkus.kubernetes-client.devservices.api-version:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`api-only` only starts a Kubernetes API Server. If you need a fully-featured Kubernetes cluster that can spin up Pods, you can use `k3s` or `kind`. Note that they both requires to run in Docker privileged mode.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>'api-only' inicia apenas um Servidor de API Kubernetes. Se você precisa de um cluster Kubernetes totalmente funcional que possa criar Pods, você pode usar k3s ou kind. Observe que ambos requerem que sejam executados em modo privilegiado do Docker."</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/about" class="{% if page.url contains '/about/' %}active{% endif %}"&gt;WHAT IS QUARKUS?&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/about" class="{% if page.url contains '/about/' %}active{% endif %}"&gt;O QUE É QUARKUS?&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/developer-joy" class="{% if page.url contains '/developer-joy/' %}active{% endif %}"&gt;DEVELOPER JOY&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/developer-joy" class="{% if page.url contains '/developer-joy/' %}active{% endif %}"&gt;ALEGRIA DO DESENVOLVEDOR&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/get-started" class="{% if page.url contains '/get-started/' %}active{% endif %}"&gt;GET STARTED&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/get-started" class="{% if page.url contains '/get-started/' %}active{% endif %}"&gt;COMEÇAR&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/qtips" class="{% if page.url contains '/qtips/' %}active{% endif %}"&gt;"Q" TIP VIDEOS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/qtips" class="{% if page.url contains '/qtips/' %}active{% endif %}"&gt;VÍDEOS "Q" TIP&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://quarkus.io/extensions/" class="{% if page.url contains '/extensions/' %}active{% endif %}"&gt;BROWSE EXTENSIONS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="https://quarkus.io/extensions/" class="{% if page.url contains '/extensions/' %}active{% endif %}"&gt;PROCURAR EXTENSÕES&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/faq/#what-is-a-quarkus-extension" class="{% if page.url contains 'what-is-a-quarkus-extension' %}active{% endif %}"&gt;USE EXTENSIONS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/faq/#what-is-a-quarkus-extension" class="{% if page.url contains 'what-is-a-quarkus-extension' %}active{% endif %}"&gt;USAR EXTENSÕES&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/writing-extensions" class="{% if page.url contains '/guides/writing-extensions' %}active{% endif %}"&gt;CREATE EXTENSIONS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/guides/writing-extensions" class="{% if page.url contains '/guides/writing-extensions' %}active{% endif %}"&gt;CRIAR EXTENSÕES&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://hub.quarkiverse.io" class="{% if page.url contains 'hub.quarkiverse.io' %}active{% endif %}"&gt;SHARE EXTENSIONS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="https://hub.quarkiverse.io" class="{% if page.url contains 'hub.quarkiverse.io' %}active{% endif %}"&gt;COMPARTILHE EXTENSÕES&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/blog" class="{% if page.url contains '/blog/' %}active{% endif %}"&gt;BLOG&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/blog" class="{% if page.url contains '/blog/' %}active{% endif %}"&gt;BLOG&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/insights" class="{% if page.url contains '/insights/' %}active{% endif %}"&gt;PODCAST&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/insights" class="{% if page.url contains '/insights/' %}active{% endif %}"&gt;PODCAST&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/newsletter" class="{% if page.url contains '/newsletter/' %}active{% endif %}"&gt;NEWSLETTER&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/newsletter" class="{% if page.url contains '/newsletter/' %}active{% endif %}"&gt;BOLETIM INFORMATIVO&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://github.com/orgs/quarkusio/projects/13/views/1" class="{% if page.url contains '/roadmap/' %}active{% endif %}"&gt;ROADMAP&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="https://github.com/orgs/quarkusio/projects/13/views/1" class="{% if page.url contains '/roadmap/' %}active{% endif %}"&gt;ROADMAP&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Kubernetes extension, developers can perform or automate a single-step deployment using Jib, Docker, and Source-to-Image (S2i) including the creation of DeploymentConfig to trigger automatic redeployments. &lt;a href="{{site.baseurl}}/guides/deploying-to-kubernetes"&gt;Read the guide for more details.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Usando a extensão Quarkus Kubernetes, os desenvolvedores podem executar ou automatizar uma implantação de etapa única usando Jib, Docker e Source-to-Image (S2i), incluindo a criação de DeploymentConfig para disparar reimplantações automáticas. &lt;a href="{{site.baseurl}}/guides/deploying-to-kubernetes"&gt;Leia o guia para obter mais detalhes.&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has been designed with this new world in mind and provides first-class support for these different paradigms. That does not mean you cannot build monoliths with Quarkus; you can do it smoothly. On the contrary, it means that the Quarkus development model morphs to adapt itself to the type of application you are developing, monolith, microservice, reactive, event-driven, functions…</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus foi projetado com esse novo mundo em mente e fornece suporte de primeira classe para esses diferentes paradigmas. Isso não significa que você não possa construir monólitos com Quarkus; você pode fazê-lo sem problemas. Pelo contrário, isso significa que o modelo de desenvolvimento do Quarkus se transforma para se adaptar ao tipo de aplicação que você está desenvolvendo, monólito, microsserviço, reativo, orientado a eventos, funções...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Application requirements have changed drastically over the last few years.  For any application to succeed in the era of cloud computing, Big Data, or IoT, going reactive is increasingly becoming the architecture style to follow.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Os requisitos das aplicações mudaram drasticamente nos últimos anos. Para que qualquer aplicação tenha sucesso na era da computação em nuvem, Big Data ou IoT, tornar-se reativo está se tornando cada vez mais o estilo de arquitetura a ser seguido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Today’s users embrace applications with milliseconds of response time, 100% uptime, lower latency, push data instead of pull, higher throughput, and elasticity. However, these features are nearly impossible to achieve using yesterday’s software architecture without a considerable investment in resources, infrastructure, and tooling. The world changed, and having dozens of servers, long response times (&amp;gt; 500 ms), downtime due to maintenance or waterfalls of failures does not meet the expected user experience.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Os usuários de hoje adotam aplicações com milissegundos de tempo de resposta, disponibilidade de 100%, menor latência, dados por push em vez de pull, maior taxa de transferência e elasticidade. No entanto, esses recursos são quase impossíveis de alcançar usando a arquitetura de software de ontem sem um investimento considerável em recursos, infraestrutura e ferramentas. O mundo mudou, e ter dezenas de servidores, longos tempos de resposta (&amp;gt; de 500 ms), tempo de inatividade devido a manutenção ou cascatas de falhas não atende à experiência esperada do usuário.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to the &lt;a href="https://quarkus.io/version/main/guides/mutiny-primer"&gt;Mutiny Reactive API&lt;/a&gt; , you can compose asynchronous operations and complete the result when everything is done without blocking the I/O threads.  This greatly improves resource consumption and elasticity.  Most Quarkus APIs are available in both imperative and reactive.  As example, you can use the reactive version of the REST Client:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Graças à &lt;a href="https://quarkus.io/version/main/guides/mutiny-primer"&gt;Mutiny Reactive API&lt;/a&gt; , você pode compor operações assíncronas e concluir o resultado quando tudo for feito sem bloquear os threads de E/S.  Isso melhora muito o consumo de recursos e a elasticidade.  A maioria das APIs do Quarkus está disponível em imperativa e reativa.  Como exemplo, você pode usar a versão reativa do cliente REST:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As for the reactive APIs exposed by Quarkus, stream manipulation uses the Mutiny API.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Quanto às APIs reativas expostas pelo Quarkus, a manipulação de fluxo usa a API Mutiny .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an Open Source project licensed under the &lt;a href="https://www.apache.org/licenses/LICENSE-2.0"&gt;Apache License version 2.0&lt;/a&gt;. First and foremost, it is an open community where contributions, ideas and discussions are done in the open and contributors are welcome. Let’s join forces in building the future of Java applications.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Quarkus é um projeto Open Source licenciado sob a &lt;a href="https://www.apache.org/licenses/LICENSE-2.0"&gt;Licença Apache versão 2.0.&lt;/a&gt; Em primeiro lugar, é uma comunidade aberta, onde contribuições, ideias e discussões são feitas ao ar livre e os colaboradores são bem-vindos. Vamos unir forças na construção do futuro das aplicações Java.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is designed to seamlessly combine the familiar imperative style code and the non-blocking, reactive style when developing applications.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus foi projetado para combinar perfeitamente o código de estilo imperativo que você já conhece e o estilo reativo sem bloqueio ao desenvolver aplicações.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/developer-joy"&gt;Learn more&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="/developer-joy"&gt;Saiba Mais&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev UI</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Interface do usuário do desenvolvedor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/dev-ui"&gt;Read the Dev UI guide&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/guides/dev-ui"&gt;Leia o guia da interface do usuário do desenvolvedor&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ask on &lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Stack Overflow with the &lt;code&gt;quarkus&lt;/code&gt; tag&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Pergunte no &lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Stack Overflow com a tag &lt;code&gt;quarkus&lt;/code&gt;&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus offers unequaled performance</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus oferece um desempenho inigualável</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SUPERSONIC&lt;span class="light-blue"&gt;/&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>SUPERSÔNICO&lt;span class=“light-blue”&gt;/&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SUBATOMIC&lt;span class="light-blue"&gt;/&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;span class="light-blue"&gt;SUBATÔMICO&lt;/span&gt;/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributions are welcome, please submit pull requests for the `develop` branch.
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Contribuições são bem-vindas, por favor, envie pull-requests para a branch `develop`.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus Cache uses Caffeine as backend.  It's possible to use Redis instead.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, o Quarkus Cache utiliza o Caffeine como backend. É possível usar Redis em vez disso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The backend uses the _&lt;default&gt;_ Redis client (if not configured otherwise), so make sure it's configured (or use the xref:redis-dev-services.adoc[redis dev service])</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O backend utiliza o cliente Redis por padrão (se não estiver configurado de outra forma), por isso certifique-se de que está configurado (ou utilize o xref:redis-dev-services.adoc[redis dev service])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Redis backend uses the `&lt;default&gt;` Redis client.  See the xref:redis-reference.adoc[Redis reference] to configure the access to Redis.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O backend do Redis utiliza o cliente Redis por padrão. Consulte xref:redis-reference.adoc[referência do Redis] para configurar o acesso ao Redis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When writing to Redis or reading from Redis, Quarkus needs to know the type.  Indeed, the objects need to be serialized and deserialized.  For that purpose, you may need to configure type (class names) of the key and value you want to cache.  At build time, Quarkus tries to deduce the types from the application code, but that decision can be overridden using:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Ao escrever ou ler do Redis, o Quarkus precisa saber o tipo. De fato, os objetos têm que ser serializados e desserializados. Para esse efeito, pode ser necessário configurar o tipo (nome das classes) da chave e do valor que pretende armazenar em cache. No momento da construção (at build time), o Quarkus tenta deduzir os tipos a partir do código da aplicação, mas essa decisão pode ser substituída utilizando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `expire-after-write` is not configured, the entry won't be evicted.  You would need to invalidate the values using the `@CacheInvalidateAll` or `@CacheInvalidate` annotations.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se o tempo de vida `expire-after-write` não estiver configurado, a entrada não será excluída. Você terá de invalidar os valores utilizando as anotações `@CacheInvalidateAll` ou `@CacheInvalidate`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the Redis backend stores the entry using the following keys: `cache:$cache-name:$cache-key`, where `cache-key` is the key the application uses.  So, you can find all the entries for a single cache using the Redis `KEYS` command: `KEYS cache:$cache-name:*`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, o Redis backend armazena a entrada utilizando as seguintes chaves: `cache:$cache-name:$cache-key`, onde `cache-key` é a chave que o aplicativo usa. Assim, é possível encontrar todas as entradas de um único cache usando o comando Redis `KEYS`: `KEYS cache:$cache-name:*`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `cache:$cache-name:` segment can be configured using the `prefix` property:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O `cache:$cache-name:` segmento pode ser configurado utilizando a propriedade `prefix`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable optimistic locking</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Ativar o bloqueio otimista (`Optimistic locking`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The access to the cache can be _direct_ or use https://redis.io/docs/manual/transactions/#optimistic-locking-using-check-and-set[optimistic locking].  By default, optimistic locking is disabled.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O acesso ao cache pode ser _direto_ ou utilizar o https://redis.io/docs/manual/transactions/#optimistic-locking-using-check-and-set[bloqueio otimista]. Por padrão, o bloqueio otimista está desativado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When used, the key is _watched_ and the _SET_ command is executed in a transaction (`MULTI/EXEC`).</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Quando utilizado, a chave é _vigiada_ e o comando _SET_ é executado numa transação ( `MULTI/EXEC`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus you can deploy your favorite Java HTTP frameworks as AWS Lambda's using either the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[AWS Gateway HTTP API] or https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[AWS Gateway REST API].  This means that you can deploy your microservices written with RESTEasy Reactive (our Jakarta REST implementation), Undertow (servlet), Reactive Routes, xref:funqy-http.adoc[Funqy HTTP] or any other Quarkus HTTP framework as an AWS Lambda.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Com o Quarkus, é possível fazer o deploy de seu framework Java HTTP favorito como AWS Lambdas usando a  link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[API HTTP do AWS Gateway] ou a  link:https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[API REST do AWS Gateway]. Isto significa que você pode fazer o deploy dos seus microsserviços escritos com RESTEasy Reactive (a nossa implementação Jakarta REST), Undertow (servlet), Reactive Routes,  link:funqy-http.html[Funqy HTTP] ou qualquer outra estrutura HTTP Quarkus como um AWS Lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has a different extension for each Gateway API.  The HTTP Gateway API is implemented within the `quarkus-amazon-lambda-http` extension.  The REST Gateway API is implemented within the `quarkus-amazon-lambda-rest` extension.  If you are confused on which Gateway product to use, Amazon has a https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[great guide] to help you navigate this decision.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus tem uma extensão diferente para cada API de gateway. A API de Gateway HTTP é implementada na extensão `quarkus-amazon-lambda-http`. A API do Gateway REST é implementada na extensão `quarkus-amazon-lambda-rest`. Se estiver confuso quanto a qual Gateway utilizar, a Amazon tem um  link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[excelente guia] para ajudar você a tomar esta decisão.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps for installing AWS SAM CLI.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A instalação de todos os componentes AWS é provavelmente a parte mais difícil deste guia. Certifique-se de que ter seguido todos os passos para instalar o AWS SAM CLI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will compile the code and run the unit tests included within the generated project.  Unit testing is the same as any other Java project and does not require running on Amazon.  Quarkus dev mode is also available with this extension.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Isto irá compilar o código e executar os testes de unitários incluídos no projeto gerado. O teste unitário é o mesmo que qualquer outro projeto Java e não requer a execução na Amazon. O _dev_ _mode_ do Quarkus também está disponível com esta extensão.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building on a non-Linux system, you will need to also pass in a property instructing quarkus to use a Docker build as Amazon Lambda requires Linux binaries.  You can do this by passing `-Dquarkus.native.container-build=true` to your build command.  This requires you to have Docker installed locally, however.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se voê estiver construindo em um sistema que não seja Linux, terá de passar também uma propriedade que instrua o quarkus a utilizar uma compilação Docker, uma vez que o Amazon Lambda requer binários Linux. Você pode fazer isso passando `-Dquarkus.native.container-build=true` para o seu comando de compilação. No entanto, isso requer que você tenha o Docker instalado localmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After you run the build, there are a few extra files generated by the Quarkus lambda extension you are using.  These files are in the build directory: `target/` for Maven, `build/` for Gradle.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Depois de executar a compilação, existem alguns arquivos extras gerados pela extensão lambda Quarkus que você esta usando. Estes arquivos encontram-se no diretório de compilação: `target/` para Maven, `build/` para Gradle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In dev and test mode, Quarkus will start a mock AWS Lambda event server that will convert HTTP requests to the corresponding API Gateway event types and post them to the underlying Quarkus HTTP lambda environment for processing.  This simulates the AWS Lambda environment as much as possible locally without requiring tools like Docker and SAM CLI.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>No modo de desenvolvimento e teste, o Quarkus iniciará um servidor de eventos AWS Lambda simulado que converterá solicitações HTTP para os tipos de eventos correspondentes do API Gateway e os publicará no ambiente lambda HTTP subjacente do Quarkus para processamento. Isso simula o ambiente do AWS Lambda o máximo possível localmente sem exigir ferramentas como Docker e SAM CLI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Quarkus Dev Mode just invoke HTTP requests on `http://localhost:8080` as you normally would when testing your REST endpoints.  This request will hit the Mock Event Server and will be converted to the API Gateway json message that is consumed by the Quarkus Lambda Poll loop.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Ao usar o _dev_ _mode_ do Quarkus, basta invocar pedidos HTTP em `&amp;lt;a href="http://localhost:8080" class="bare"&amp;gt;http://localhost:8080&amp;lt;/a&amp;gt;` como você faria normalmente ao testar seus endpoints REST. Este pedido chegará ao Mock Event Server e será convertido na mensagem json do API Gateway que é consumida pelo Quarkus Lambda Poll loop.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For testing, Quarkus starts up a separate Mock Event server under port 8081.  The default port for Rest Assured is automatically set to 8081 by Quarkus, so you don't have to worry about setting this up.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para testes, o Quarkus inicia um servidor Mock Event separado na porta 8081. A porta predefinida para o Rest Assured é automaticamente definida para 8081 pelo Quarkus, para que você não tenha que se preocupar configurando isto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to simulate more complex API Gateway events in your tests, then manually do an HTTP POST to `http://localhost:8080/\_lambda_` (port 8081 in test mode) with the raw API Gateway json events.  These events will be placed directly on the Quarkus Lambda poll loop for processing.  Here's an example of that:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você quiser simular eventos mais complexos do API Gateway em seus testes, faça manualmente um HTTP POST para `&amp;lt;a href="http://localhost:8080/_lambda_" class="bare"&amp;gt;http://localhost:8080/_lambda_&amp;lt;/a&amp;gt;` (porta 8081 no modo de teste) com os eventos json brutos do API Gateway. Esses eventos serão colocados diretamente no Quarkus Lambda poll loop  para processamento. Aqui está um exemplo disso:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to hand code raw events for the AWS HTTP API, the AWS Lambda library has the request event type which is `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` and the response event type of `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse`.  This corresponds to the `quarkus-amazon-lambda-http` extension and the AWS HTTP API.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você quiser codificar manualmente eventos brutos para a API HTTP da AWS, a biblioteca Lambda da AWS tem o tipo de evento de request que é `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` e o tipo de evento de response de `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse`. Isto corresponde à extensão `quarkus-amazon-lambda-http` e à API HTTP da AWS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to hand code raw events for the AWS REST API, Quarkus has its own implementation: `io.quarkus.amazon.lambda.http.model.AwsProxyRequest` and `io.quarkus.amazon.lambda.http.model.AwsProxyResponse`.  This corresponds to `quarkus-amazon-lambda-rest` extension and the AWS REST API.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você quiser codificar manualmente eventos brutos para a API REST do AWS, o Quarkus tem a sua própria implementação: `io.quarkus.amazon.lambda.http.model.AwsProxyRequest` e `io.quarkus.amazon.lambda.http.model.AwsProxyResponse`. Isto corresponde à extensão `quarkus-amazon-lambda-rest` e à API REST da AWS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The mock event server is also started for `@QuarkusIntegrationTest` tests so will work with native binaries too.  All this provides similar functionality to the SAM CLI local testing, without the overhead of Docker.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O mock event server também é iniciado para os testes `@QuarkusIntegrationTest`, pelo que também funcionará com binários nativos. Tudo isso fornece uma funcionalidade semelhante ao teste local do SAM CLI, sem a sobrecarga do Docker.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AWS SAM CLI allows you to run your lambda's locally on your laptop in a simulated Lambda environment.  This requires Docker to be installed.  After you have built your Maven project, execute this command:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O AWS SAM CLI permite que você execute seus lambda's localmente no seu laptop em um ambiente Lambda simulado. Para isso, é necessário que o Docker esteja instalado. Depois de criar seu projeto Maven, execute este comando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://127.0.0.1:3000/hello</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>http://127.0.0.1:3000/hello</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the console you'll see startup messages from the lambda.  This particular deployment starts a JVM and loads your lambda as pure Java.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>No console, você verá mensagens de inicialização do lambda. Esse deployment específico inicia uma JVM e carrega seu lambda como Java puro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Answer all the questions and your lambda will be deployed and the necessary hooks to the API Gateway will be set up. If everything deploys successfully, the root URL of your microservice will be output to the console.  Something like this:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Responda a todas as perguntas e seu lambda será implantado e os hooks necessários para o API Gateway serão configurados. Se tudo for implantado com sucesso, o URL raiz do seu microsserviço será enviado para o console. Algo parecido com isto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Responses for binary types will be automatically encoded with base64.  This is different from the behavior using `quarkus:dev` which will return the raw bytes.  Amazon's API has additional restrictions requiring the base64 encoding.  In general, client code will automatically handle this encoding but in certain custom situations, you should be aware you may need to manually manage that encoding.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>As respostas para tipos binários serão automaticamente codificadas com base64. Isso é diferente do comportamento usando `quarkus:dev`, que retornará os bytes brutos. A API da Amazon tem restrições adicionais que exigem a codificação base64. Em geral, o código do cliente tratará automaticamente desta codificação, mas em determinadas situações personalizadas, deve estar ciente de que poderá ter de gerir manualmente essa codificação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda-http` extension (if you are deploying an AWS Gateway HTTP API) or the `quarkus-amazon-lambda-rest` extension (if you are deploying an AWS Gateway REST API).  These extensions automatically generate everything you might need for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Não há nada de especial no POM além da inclusão da extensão `quarkus-amazon-lambda-http` (se estiver implantando uma API HTTP do AWS Gateway) ou da extensão `quarkus-amazon-lambda-rest` (se estiver implantando uma API REST do AWS Gateway). Essas extensões geram automaticamente tudo o que pode ser necessário para o deploy do lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, at least in the generated Maven archetype `pom.xml`, the `quarkus-resteasy-reactive`, `quarkus-reactive-routes`, and `quarkus-undertow` dependencies are all optional.  Pick which HTTP framework(s) you want to use (Jakarta REST, Reactive Routes, and/or Servlet) and remove the other dependencies to shrink your deployment.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Além disso, pelo menos no arquétipo Maven gerado `pom.xml`, as dependências `quarkus-resteasy-reactive`, `quarkus-reactive-routes` e `quarkus-undertow` são todas opcionais. Escolha o(s) framework(s) HTTP que deseja usar (Jakarta REST, Rotas Reativas e/ou Servlet) e remova as outras dependências para reduzir sua implantação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `sam.yaml` syntax is beyond the scope of this document.  There's a couple of things that must be highlighted just in case you are going to craft your own custom `sam.yaml` deployment files.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A sintaxe do `sam.yaml` está além do escopo deste documento. Há alguns aspectos que devem ser destacados, caso pretenda criar os seus próprios arquivos de deployment `sam.yaml` personalizados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first thing to note is that for pure Java lambda deployments require a specific handler class.  Do not change the Lambda handler name.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A primeira coisa a observar é que, para deployments lambda Java puros, é necessário um handler class específico. Não altere o nome do handler Lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to go native, there's an environment variable that must be set for native GraalVM deployments.  If you look at `sam.native.yaml` you'll see this:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você deseja usar uma compilação nativa, há uma variável de ambiente que deve ser definida para deployments nativos do GraalVM. Se olhares para `sam.native.yaml` verás isto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, there is one specific thing for AWS Gateway REST API deployments.  That API assumes that HTTP response bodies are text unless you explicitly tell it which media types are binary through configuration.  To make things easier, the Quarkus extension forces a binary (base 64) encoding of all HTTP response messages and the `sam.yaml` file must configure the API Gateway to assume all media types are binary:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por fim, há um aspeto específico para o deploy da API REST do AWS Gateway. Essa API assume que os corpos de resposta HTTP são texto, a menos que se diga explicitamente quais tipos de mídia são binários por meio de configuração. Para facilitar as coisas, a extensão Quarkus obriga a uma codificação binária (base 64) de todas as mensagens de resposta HTTP e o ficheiro `sam.yaml` tem de configurar a API Gateway para assumir que todos os tipos de media são binários:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using RESTEasy Reactive and Jakarta REST, you can inject various AWS Context variables into your Jakarta REST resource classes using the Jakarta REST `@Context` annotation or anywhere else with the CDI `@Inject` annotation.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se estiver utilizando o RESTEasy Reactive e o Jakarta REST, pode injetar várias variáveis de contexto AWS nas suas resource classes Jakarta REST utilizando a anotação Jakarta REST `@Context` ou em qualquer outro lugar com a anotação CDI `@Inject`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the AWS HTTP API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent`.  Here is an example:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para a API HTTP do AWS, você pode injetar as variáveis do AWS `com.amazonaws.services.lambda.runtime.Context` e `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent`. Eis um exemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the AWS REST API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext`.  Here is an example:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para a API REST do AWS, você pode injetar as variáveis do AWS `com.amazonaws.services.lambda.runtime.Context` e `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext`. Eis um exemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you invoke an HTTP request on the API Gateway, the Gateway turns that HTTP request into a JSON event document that is forwarded to a Quarkus Lambda.  The Quarkus Lambda parses this json and converts in into an internal representation of an HTTP request that can be consumed by any HTTP framework Quarkus supports (Jakarta REST, servlet, Reactive Routes).</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Quando você invoca um pedido HTTP no API Gateway, o Gateway transforma esse pedido HTTP num documento de evento JSON que é reencaminhado para um Quarkus Lambda. O Quarkus Lambda analisa este json e o converte em uma representação interna de um pedido HTTP que pode ser consumido por qualquer estrutura HTTP suportada pelo Quarkus (Jakarta REST, servlet, Reactive Routes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>API Gateway supports many ways to securely invoke on your HTTP endpoints that are backed by Lambda and Quarkus.  If you enable it, Quarkus will automatically parse relevant parts of the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html[event json document] and look for security based metadata and register a `java.security.Principal` internally that can be looked up in Jakarta REST by injecting a `jakarta.ws.rs.core.SecurityContext`, via `HttpServletRequest.getUserPrincipal()` in servlet, and `RouteContext.user()` in Reactive Routes.  If you want more security information, the `Principal` object can be typecast to a class that will give you more information.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O API Gateway suporta muitas formas de invocar com segurança os seus endpoints HTTP que são apoiados pelo Lambda e pelo Quarkus. Se o ativar, o Quarkus analisará automaticamente as partes relevantes do  link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html[documento json do evento] e procurará metadados baseados na segurança e registará internamente um `java.security.Principal` que pode ser consultado no Jakarta REST injectando um `jakarta.ws.rs.core.SecurityContext`, através de `HttpServletRequest.getUserPrincipal()` no servlet e `RouteContext.user()` nas rotas reactivas. Se quiser mais informações de segurança, o objeto `Principal` pode ser convertido para uma classe que lhe dará mais informações.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable this security feature, add this to your `application.properties` file:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para ativar esta funcionalidade de segurança, adicione isto ao seu arquivo `application.properties`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HTTP `quarkus-amazon-lambda-http`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>HTTP `quarkus-amazon-lambda-http`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Auth Type</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Auth Type</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cognito JWT</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Cognito JWT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.amazon.lambda.http.CognitoPrincipal`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`io.quarkus.amazon.lambda.http.CognitoPrincipal`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.jwt.claims.cognito:username`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`requestContext.authorizer.jwt.claims.cognito:username`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.amazon.lambda.http.IAMPrincipal`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`io.quarkus.amazon.lambda.http.IAMPrincipal`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.iam.userId`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`requestContext.authorizer.iam.userId`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.amazon.lambda.http.CustomPrincipal`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`io.quarkus.amazon.lambda.http.CustomPrincipal`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.lambda.principalId`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`requestContext.authorizer.lambda.principalId`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST `quarkus-amazon-lambda-rest`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>REST `quarkus-amazon-lambda-rest`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cognito</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Cognito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.claims.cognito:username`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`requestContext.authorizer.claims.cognito:username`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `cognito:groups` claim is present, then Quarkus will extract and map those groups to Quarkus roles which can then be used in authorization with annotations like `@RolesAllowed`.  If you do not want to map `cognito:groups` to Quarkus roles, then you must explicitly disable it in configuration:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se a reivindicação `cognito:groups` estiver presente, o Quarkus extrairá e mapeará esses grupos para as funções do Quarkus que podem então ser utilizadas na autorização com anotações como `@RolesAllowed`. Se não pretender mapear `cognito:groups` para as funções do Quarkus, você terá que desativar explicitamente na configuração:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, it expects roles in a space delimited list enclosed in brackets i.e. `[ user admin ]`.  You can specify the regular expression to use to find individual roles in the claim string too:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, ele espera funções numa lista delimitada por espaços entre parênteses, ou seja, `[ user admin ]`. Também pode especificar a expressão regular a utilizar para encontrar funções individuais na cadeia de reivindicação:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default support for AWS security only maps the principal name to Quarkus security APIs and does nothing to map claims or roles or permissions.  You have full control on how security metadata in the lambda HTTP event is mapped to Quarkus Security APIs using implementations of the `io.quarkus.amazon.lambda.http.LambdaIdentityProvider` interface.  By implementing this interface, you can do things like define role mappings for your principal or publish additional attributes provided by IAM or Cognito or your Custom Lambda security integration.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O suporte padrão para a segurança AWS apenas mapeia o nome principal para as APIs de segurança do Quarkus e não faz nada para mapear reivindicações, funções ou permissões. Você tem total controle sobre a forma como os metadados de segurança no evento HTTP lambda são mapeados para as APIs de segurança do Quarkus utilizando implementações da interface `io.quarkus.amazon.lambda.http.LambdaIdentityProvider`. Ao implementar esta interface, pode fazer coisas como definir mapeamentos de funções para o seu principal ou publicar atributos adicionais fornecidos pelo IAM ou Cognito ou pela sua integração de segurança Lambda personalizada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For HTTP, the important method to override is `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)`.  From this you will allocate a SecurityIdentity based on how you want to map security data from `APIGatewayV2HTTPEvent`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para HTTP, o método importante para ser substituído é o `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)`. A partir daí, atribuirá uma SecurityIdentity com base na forma como pretende mapear os dados de segurança de `APIGatewayV2HTTPEvent`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For REST, the important method to override is `LambdaIdentityProvider.authenticate(AwsProxyRequest event)`.  From this you will allocate a SecurityIdentity based on how you want to map security data from `AwsProxyRequest`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para REST, o método importante para ser substituído é o `LambdaIdentityProvider.authenticate(AwsProxyRequest event)`. A partir daí, atribuirá uma SecurityIdentity com base na forma como pretende mapear os dados de segurança de `AwsProxyRequest`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your implemented provider must be a CDI bean.  Here's an example:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O seu provider implementado deve ser um bean CDI. Eis um exemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus should automatically discover this implementation and use it instead of the default implementation discussed earlier.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus deve descobrir automaticamente esta implementação e utilizá-la em vez da implementação padrão referida anteriormente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are testing your application with `sam local` you can hardcode a principal name to use when your application runs by setting the `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME` environment variable</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você estiver testando a sua aplicação com `sam local`, pode definir um nome principal para utilizar quando a sua aplicação for executada, definindo a variável de ambiente `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SnapStart</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>SnapStart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To optimize your application for Lambda SnapStart, check xref:amazon-snapstart.adoc[the SnapStart Configuration Documentation].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para otimizar a sua aplicação para o Lambda SnapStart, consulte  link:amazon-snapstart.html[a documentação de configuração do SnapStart].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html[SnapStart] is a snapshotting and restore mechanism reducing drastically the cold startup time of Java functions on AWS.  This document explains the various settings you can use to leverage this feature.  It is not a reference documentation on SnapStart, and it will not cover how SnapStart works in details.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>link:https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html[O SnapStart] é um mecanismo de _snapshotting_ e restauração que reduz drasticamente o tempo de inicialização a frio das funções Java na AWS. Este documento explica as várias configurações que podem ser usadas para aproveitar esse recurso. Não se trata de uma documentação de referência sobre o SnapStart e não abordará como o SnapStart funciona em detalhes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This feature is only available on AWS Lambda, and not in all regions.  Please check the AWS documentation to verify the eligibility of your AWS region.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Esta funcionalidade só está disponível na AWS Lambda e não em todas as regiões. Consulte a documentação da AWS para verificar a elegibilidade da sua região da AWS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the Quarkus AWS Lambda extension, SnapStart optimizations are automatically enabled.  However, you can enable/disable it explicitly using:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você utilizar a extensão Quarkus AWS Lambda, as otimizações do SnapStart são automaticamente ativadas. No entanto, você pode ativar/desativar explicitamente utilizando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Classloading has a huge impact on your function execution time.  This optimization allows preloading classes during the snapshotting process of SnapStart.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O _classloading_ tem um enorme impacto no tempo de execução da sua função. Esta otimização permite pré-carregar classes durante o processo de _snapshotting_ do SnapStart.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To compute the list of classes, we recommend deploying your function and setting the `JAVA_TOOL_OPTIONS` environment variable to `-verbose:class`.  Then execute your function and retrieve the log (in CloudWatch).  You should be able to extract the class names using sed/awk or any text editor.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para calcular a lista de classes, recomendamos fazer o _deploy_ da sua função e definir a variável de ambiente JAVA_TOOL_OPTIONS como -verbose:class. Em seguida, execute sua função e recupere o registro (no CloudWatch). Você deverá ser capaz de extrair os nomes das classes usando o sed/awk ou qualquer editor de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus generates the class list of the classes included in your application (including the classes generated by Quarkus).  So, you do not have to repeat them in the `quarkus-preload-classes.txt` file.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, o Quarkus gera a lista de classes das classes incluídas na sua aplicação (incluindo as classes geradas pelo Quarkus). Assim, você não precisa repeti-las no arquivo `quarkus-preload-classes.txt`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, when the classes are preloaded, they are also _initialized_, meaning it also resolves the dependent classes.  You can disable this behavior using:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, quando as classes são pré-carregadas, elas também são _inicializadas_, o que significa que também resolve as classes dependentes. É possível desativar este comportamento utilizando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Client _priming_ is a technique that allows initializing a client during the snapshotting process, so it's already fully functional during the application runtime.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Client _priming_ é uma técnica que permite inicializar um client durante o processo de _snapshotting,_ para que já esteja totalmente funcional durante o tempo de execução da aplicação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>initialize the client in a `static` block, which, thanks to class preloading will be executed before the snapshot</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>inicializar o client num bloco `static`, que, graças ao pré-carregamento da classe, será executado antes do snapshot</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing priming using a static block may prevent the native compilation of your application.  Client initialization may start threads or open connections which are not compatible with the native compilation if the class is initialized at build time.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Implementar o priming usando um bloco estático pode impedir a compilação nativa da sua aplicação. A inicialização do client pode iniciar threads ou abrir conexões que não são compatíveis com a compilação nativa se a classe for inicializada no momento da compilação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also recommended to use _tiered compilation_ when using SnapStart.  To achieve this, set the `JAVA_TOOL_OPTIONS` environment property to `-XX:+TieredCompilation -XX:TieredStopAtLevel=1`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Também é recomendável usar _tiered compilation_ ao usar o SnapStart. Para isso, defina a propriedade de ambiente `JAVA_TOOL_OPTIONS` como `-XX:+TieredCompilation -XX:TieredStopAtLevel=1`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Identity providers</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Identity providers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the Quarkus Security framework, identity providers play a crucial role in authentication and authorization by verifying user identities.  `IdentityProvider` creates a `SecurityIdentity` instance, which gets used during user authentication to verify and authorize access requests to your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>No Quarkus Security framework, os identity providers desempenham um papel crucial na autenticação e autorização, verificando as identidades dos usuários. `IdentityProvider` cria uma instância `SecurityIdentity`, que é utilizada durante a autenticação do usuário para verificar e autorizar os pedidos de acesso à sua aplicação Quarkus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`IdentityProvider` converts the authentication credentials provided by `HttpAuthenticationMechanism` to a `SecurityIdentity` instance.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`IdentityProvider` converte as credenciais de autenticação fornecidas por `HttpAuthenticationMechanism` para uma instância `SecurityIdentity`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some extensions, for example, `OIDC`, `OAuth2`, and `SmallRye JWT`, have inline `IdentityProvider` implementations specific to the supported authentication flow.  For example, `quarkus-oidc` uses its own `IdentityProvider` to convert a token to a `SecurityIdentity` instance.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Algumas extensões, por exemplo, `OIDC`, `OAuth2`, e `SmallRye JWT`, têm implementações em linha `IdentityProvider` específicas para o fluxo de autenticação suportado. Por exemplo, `quarkus-oidc` usa seu próprio `IdentityProvider` para converter um token em uma instância `SecurityIdentity`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use Basic or form-based authentication, you must add an `IdentityProvider` instance to convert a username and password to a `SecurityIdentity` instance.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você utilizar a Basic ou form-based, você precisará adicionar uma instãncia `IdentityProvider` para converter um username e um password em uma instância `SecurityIdentity`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications are optimised for low memory usage and fast startup times.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Aplicações Quarkus são otimizadas para baixo uso de memória e tempos de inicialização rápidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>/guias/começar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus DI solution is based on the [Contexts and Dependency Injection for Java 2.0](https://docs.jboss.org/cdi/spec/2.0/cdi-spec) specification. This guide explains the basics of CDI.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A solução Quarkus DI é baseada na especificação [Contexts and Dependency Injection for Java 2.0] https://docs.jboss.org/cdi/spec/2.0/cdi-spec . Este guia explica os princípios básicos do CDI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Testing in JVM mode
* Testing in native mode
* Injection of resources into tests
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia aborda: 
* Testes no modo JVM 
* Testes no modo nativo 
* Injeção de recursos nos testes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the OpenAPI extension to generate an OpenAPI descriptor and get a Swagger UI frontend to test your REST endpoints.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia explica como usar a extensão OpenAPI para gerar um descritor OpenAPI e obter um front-end da interface do usuário do Swagger para testar seus endpoints REST.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about configuring Quarkus' Vert.x based HTTP layer - and Undertow if you are using servlets.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Saiba mais sobre como configurar a camada HTTP baseada em Vert.x do Quarkus - e Undertow se você estiver usando servlets.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Automatically start database containers with Dev Services.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Inicie automaticamente contêineres de banco de dados com Dev Services</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Liquibase MongoDB</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Liquibase MongoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the usage of MongoDB using active records and repositories.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia aborda o uso do MongoDB usando &lt;i&gt;active records&lt;/i&gt; e repositórios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the usage of MongoDB using active records and repositories in a Kotlin project.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia aborda o uso do MongoDB usando &lt;i&gt;active records&lt;/i&gt; e repositórios em um projeto Kotlin.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Secure your web endpoints with authorizations.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Proteja os seus Web Endpoints com autorizações.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Customize Quarkus' security layer behavior.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Personalize o comportamento da camada de segurança do Quarkus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through the process of creating a Quarkus application with OptaPlanner's constraint solving Artificial Intelligence (AI).</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia orienta você pelo processo de criação de um aplicativo Quarkus com a Inteligência Artificial (IA) de resolução de restrições do OptaPlanner.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using AI to optimize a schedule with OptaPlanner</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Usando IA para otimizar um cronograma com o OptaPlanner</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>command-line</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Quarkus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>jbang Integration</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Integração jbang</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gRPC</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>gRPC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Maven configuration
* Creating a new project
* Dealing with extensions
* Development mode
* Debugging
* Import in your IDE
* Building a native executable
* Build a container friendly executable
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia abrange:
* Configuração do Maven
* Criação de um novo projeto
* Lidar com extensões
* Modo de desenvolvimento
*Depuração
* Importar em seu IDE
* Construção de um executável nativo
* Construa um executável amigável para contêineres
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Gradle configuration
* Creating a new project
* Dealing with extensions
* Development mode
* Debugging
* Import in your IDE
* Building a native executable
* Build a container friendly executable
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia abrange:
* Configuração Gradle
* Criação de um novo projeto
* Lidar com extensões
* Modo de desenvolvimento
*Depuração
* Importar em seu IDE
* Construção de um executável nativo
* Construa um executável amigável para contêineres
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use mutable jars to rebuild your application with different build time configurations.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Use JARs mutáveis para reconstruir sua aplicação com diferentes configurações de tempo de compilação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Spring Boot's `@ConfigurationProperties` in place of MicroProfile Config annotations</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Use o '@ConfigurationProperties' do Spring Boot no lugar das anotações do MicroProfile Config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP Secret Manager in Quarkus to consume configuration properties directly or via your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia aborda como usar o GCP Secret Manager no Quarkus para consumir propriedades de configuração diretamente ou por meio de seu 'application.properties'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to integrate your extension with Quarkus' CDI container.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Saiba como integrar sua extensão com o contêiner CDI do Quarkus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to get your extension contribute features to the Dev UI.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Saiba como fazer com que a sua extensão contribua com funcionalidades para a interface do usuário do desenvolvedor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributing to Dev UI</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Contribuindo para a interface do usuário do desenvolvedor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple ways to connect with others via forum, stack, chat, or email groups.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Várias maneiras de se conectar com outras pessoas por meio de fóruns, Stack Overflow, bate-papo ou grupos de e-mail.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications are designed to run in containers.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Aplicações Quarkus são projetadas para serem executadas em contêineres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is published in Maven Central, check out link:/extensions[which extensions] you need and just import them in your `pom.xml` to get Quarkus. We recommend you start your Quarkus experience via our link:/get-started[Getting Started guides].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus é publicado no Maven Central, confira link:/extensions[quais extensões] você precisa e basta importá-los em seu 'pom.xml' para obter o Quarkus. Recomendamos que você comece sua experiência com o Quarkus através do nosso link:/get-started[Guias de introdução].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Think of Quarkus extensions as your project dependencies. Extensions configure, boot and integrate a framework or technology into your Quarkus application. They also do all of the heavy lifting of providing the right information to GraalVM for your application to compile natively. This will allow 3rd party projects to easily take advantage of the work we have done to make it easier to target GraalVM.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Pense nas extensões do Quarkus como suas dependências de projeto. As extensões configuram, inicializam e integram uma estrutura ou tecnologia em seu aplicativo Quarkus. Eles também fazem todo o trabalho pesado de fornecer as informações certas para GraalVM para sua aplicação compilar nativamente. Isso permitirá que os projetos de terceiros aproveitem facilmente o trabalho que fizemos para facilitar o direcionamento do GraalVM.</seg>
      </tuv>
    </tu>
  </body>
</tmx>
