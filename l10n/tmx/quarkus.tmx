<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="Translate Toolkit" creationtoolversion="3.10.1" segtype="sentence" o-tmf="UTF-8" adminlang="en" srclang="en" datatype="PlainText"/>
  <body>
    <tu>
      <tuv xml:lang="en">
        <seg>/newsletter/</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>/newsletter/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gRPC</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>gRPC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To write duration values, use the standard `java.time.Duration` format.  See the link:https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/Duration.html#parse(java.lang.CharSequence)[Duration#parse() javadoc] for more information.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para valores de duração, use o formato padrão 'java.time.Duration'.  Consulte o link:https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/Duration.html#parse(java.lang.CharSequence)[Duration#parse() javadoc] para obter mais informações.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the value is a number followed by `ms`, it represents time in milliseconds.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se o valor for um número seguido de 'ms', ele representa o tempo em milissegundos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In other cases, the simplified format is translated to the `java.time.Duration` format for parsing:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Em outros casos, o formato simplificado é traduzido para o formato 'java.time.Duration' para análise:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the value is a number followed by `h`, `m`, or `s`, it is prefixed with `PT`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se o valor for um número seguido de 'h', 'm' ou 's', ele é prefixado com 'PT'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the value is a number followed by `d`, it is prefixed with `P`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se o valor for um número seguido de 'd', ele é prefixado com 'P'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Recomendamos que siga as instruções nas seções seguintes e crie a aplicação passo a passo. No entanto, você pode ir diretamente para o exemplo completo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>pom.xml</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>pom.xml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>build.gradle</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>build.gradle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If any Kafka-related extension is present (e.g. `quarkus-smallrye-reactive-messaging-kafka`), Dev Services for Kafka automatically starts a Kafka broker in dev mode and when running tests.  So, you don't have to start a broker manually.  The application is configured automatically.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se qualquer extensão relacionada ao Kafka estiver presente (por exemplo, `quarkus-smallrye-reactive-messaging-kafka`), o Dev Services para  Kafka iniciará automaticamente um broker Kafka no modo de desenvolvimento e ao executar testes. Portanto, não é necessário iniciar um broker manualmente. A aplicação é configurada de forma automática.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because starting a Kafka broker can be long, Dev Services for Kafka uses https://vectorized.io/redpanda[Redpanda], a Kafka compatible broker which starts in ~1 second.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Como a inicialização de um broker Kafka pode ser demorada, o Dev Services para o Kafka usa o  link:https://vectorized.io/redpanda[Redpanda], um broker compatível com o Kafka que inicia em aproximadamente 1 segundo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling / Disabling Dev Services for Kafka</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Ativar/desativar Dev Services para o Kafka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kafka relies on Docker to start the broker.  If your environment does not support Docker, you will need to start the broker manually, or connect to an already running broker.  You can configure the broker address using `kafka.bootstrap.servers`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para o Kafka depende do Docker para iniciar o broker. Se o seu ambiente não for compatível com o Docker, terá de iniciar o broker manualmente ou conectar-se a um broker já em execução. É possível configurar o endereço do broker usando `kafka.bootstrap.servers`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Shared broker</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>broker compartilhado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the broker between applications.  Dev Services for Kafka implements a _service discovery_ mechanism for your multiple Quarkus applications running in _dev_ mode to share a single broker.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Na maioria das vezes, é necessário compartilhar o broker entre as aplicações. O Dev Services para o Kafka implementa um mecanismo de _descoberta de serviços_ para que seus vários aplicativos Quarkus em execução no _modo_ de _desenvolvimento_ compartilhem um único broker.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) brokers, you can configure the `quarkus.kafka.devservices.service-name` attribute and indicate the broker name.  It looks for a container with the same value, or starts a new one if none can be found.  The default service name is `kafka`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você precisar de vários brokers (compartilhados), você pode configurar o atributo `quarkus.kafka.devservices.service-name` e indicar o nome do broker. Este procura um container com o mesmo valor ou inicia um novo se não for encontrado nenhum. O nome de serviço predefinido é `kafka`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing is enabled by default in dev mode, but disabled in test mode.  You can disable the sharing with `quarkus.kafka.devservices.shared=false`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O compartilhamento é ativado por padrão no modo de desenvolvimento, mas desativado no modo de teste. Você pode desativar o compartilhamento com `quarkus.kafka.devservices.shared=false`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Dev Services for Kafka picks a random port and configures the application.  You can set the port by configuring the `quarkus.kafka.devservices.port` property.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, o Dev Services para o Kafka escolhe uma porta aleatória e configura o aplicativo. Você pode definir a porta configurando a propriedade `quarkus.kafka.devservices.port`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Strimzi, you can select any image with a Kafka version which has Kraft support (2.8.1 and higher) from https://quay.io/repository/strimzi-test-container/test-container?tab=tags</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para  o Strimzi, você pode selecionar qualquer imagem com uma versão Kafka que tenha suporte para o Kraft (2.8.1 e superior) em  https://quay.io/repository/strimzi-test-container/test-container?tab=tags</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the Dev Services for Kafka to create topics once the broker is started.  Topics are created with given number of partitions and 1 replica.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Você pode configurar os Dev Services para o Kafka para criar tópicos assim que o broker for iniciado. Os tópicos são criados com um determinado número de partições e uma réplica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure timeout for Kafka admin client calls used in topic creation using `quarkus.kafka.devservices.topic-partitions-timeout`, it defaults to 2 seconds.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Você pode configurar o tempo limite para as chamadas do client admin do Kafka utilizadas na criação de tópicos utilizando `quarkus.kafka.devservices.topic-partitions-timeout`. A predefinição é de 2 segundos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the Red Panda broker is configured to enable transactions and idempotence features.  You can disable those using:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, o broker do Red Panda está configurado para ativar as funcionalidades de transações e idempotência. Você pode desativá-las utilizando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Redpanda transactions does not support exactly-once processing.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>As transações Redpanda não suportam um processamento exatamente único.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enables (default) or disables the Cloud Event support. If enabled on an _incoming_ channel, the connector analyzes the incoming records and try to create Cloud Event metadata. If enabled on an _outgoing_, the connector sends the outgoing messages as Cloud Event if the message includes Cloud Event Metadata.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Habilita (padrão) ou desabilita o suporte a Cloud Event. Se habilitado em um canal _incoming_, o conector analisará os registros de entrada e tentará criar metadados do Cloud Event. Se habilitado em um _outgoing_, o conector enviará as mensagens de saída como Cloud Event se a mensagem incluir Metadados de Evento de Nuvem.

Tipo: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `datacontenttype` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `datacontenttype` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Configura o atributo 'datacontenttype' padrão do evento de nuvem de saída. Requer que 'cloud-events' seja definido como 'true'. Esse valor será usado se a mensagem não configurar o próprio atributo 'datacontenttype'

Tipo: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `dataschema` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `dataschema` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Configura o atributo 'dataschema' padrão do evento de nuvem de saída. Requer que 'cloud-events' seja definido como 'true'. Esse valor será usado se a mensagem não configurar o próprio atributo 'dataschema'

Tipo: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the connector should insert automatically the `time` attribute into the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `time` attribute itself

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se o conector deve inserir automaticamente o atributo 'time' no evento de nuvem de saída. Requer que 'cloud-events' seja definido como 'true'. Esse valor será usado se a mensagem não configurar o próprio atributo 'time'

Tipo: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Cloud Event mode (`structured` or `binary` (default)). Indicates how are written the cloud events in the outgoing record

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O modo Cloud Event ('estruturado' ou 'binário' (padrão)). Indica como são gravados os eventos de nuvem no registro de saída

Tipo: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `source` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `source` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Configure o atributo 'source' padrão do evento de nuvem de saída. Requer que 'cloud-events' seja definido como 'true'. Esse valor será usado se a mensagem não configurar o próprio atributo 'source'

Tipo: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `subject` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `subject` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Configure o atributo 'subject' padrão do evento de nuvem de saída. Requer que 'cloud-events' seja definido como 'true'. Esse valor será usado se a mensagem não configurar o próprio atributo 'subject'

Tipo: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `type` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `type` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Configure o atributo 'type' padrão do evento de nuvem de saída. Requer que 'cloud-events' seja definido como 'true'. Esse valor será usado se a mensagem não configurar o próprio atributo 'type'

Tipo: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.test.junit.QuarkusTest;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>import io.quarkus.test.junit.QuarkusTest;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import org.junit.jupiter.api.Test;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>import org.junit.jupiter.api.Test;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.smallrye.mutiny.Uni;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>import io.smallrye.mutiny.Uni;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Kafka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>OS thread</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Thread do SO</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Lightweight, JVM-managed threads. They extend the link:{thread}[Thread] class but are not tied to one specific OS thread.  Thus, scheduling virtual threads is the responsibility of the JVM.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Threads leves e gerenciadas pela JVM. Elas estendem a classe link:{thread}[Thread], mas não estão vinculadas a uma thread específica do sistema operacional. Portanto, o agendamento de threads virtuais é de responsabilidade da JVM.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Carrier thread</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Carrier thread</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Pinning cases</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Casos de fixação (pinning)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>According to link:{vthreadjep}[JEP 425] this can happen in two situations:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Segundo o link:{vthreadjep}[JEP 425], isto pode acontecer em duas situações:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has a different extension for each Gateway API.  The HTTP Gateway API is implemented within the `quarkus-amazon-lambda-http` extension.  The REST Gateway API is implemented within the `quarkus-amazon-lambda-rest` extension.  If you are confused on which Gateway product to use, Amazon has a https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[great guide] to help you navigate this decision.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus tem uma extensão diferente para cada API de gateway. A API de Gateway HTTP é implementada na extensão `quarkus-amazon-lambda-http`. A API do Gateway REST é implementada na extensão `quarkus-amazon-lambda-rest`. Se estiver confuso quanto a qual Gateway utilizar, a Amazon tem um  link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[excelente guia] para ajudar você a tomar esta decisão.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps for installing AWS SAM CLI.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A instalação de todos os componentes AWS é provavelmente a parte mais difícil deste guia. Certifique-se de que ter seguido todos os passos para instalar o AWS SAM CLI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will compile the code and run the unit tests included within the generated project.  Unit testing is the same as any other Java project and does not require running on Amazon.  Quarkus dev mode is also available with this extension.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Isto irá compilar o código e executar os testes de unitários incluídos no projeto gerado. O teste unitário é o mesmo que qualquer outro projeto Java e não requer a execução na Amazon. O _dev_ _mode_ do Quarkus também está disponível com esta extensão.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building on a non-Linux system, you will need to also pass in a property instructing quarkus to use a Docker build as Amazon Lambda requires Linux binaries.  You can do this by passing `-Dquarkus.native.container-build=true` to your build command.  This requires you to have Docker installed locally, however.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se voê estiver construindo em um sistema que não seja Linux, terá de passar também uma propriedade que instrua o quarkus a utilizar uma compilação Docker, uma vez que o Amazon Lambda requer binários Linux. Você pode fazer isso passando `-Dquarkus.native.container-build=true` para o seu comando de compilação. No entanto, isso requer que você tenha o Docker instalado localmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After you run the build, there are a few extra files generated by the Quarkus lambda extension you are using.  These files are in the build directory: `target/` for Maven, `build/` for Gradle.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Depois de executar a compilação, existem alguns arquivos extras gerados pela extensão lambda Quarkus que você esta usando. Estes arquivos encontram-se no diretório de compilação: `target/` para Maven, `build/` para Gradle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In dev and test mode, Quarkus will start a mock AWS Lambda event server that will convert HTTP requests to the corresponding API Gateway event types and post them to the underlying Quarkus HTTP lambda environment for processing.  This simulates the AWS Lambda environment as much as possible locally without requiring tools like Docker and SAM CLI.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>No modo de desenvolvimento e teste, o Quarkus iniciará um servidor de eventos AWS Lambda simulado que converterá solicitações HTTP para os tipos de eventos correspondentes do API Gateway e os publicará no ambiente lambda HTTP subjacente do Quarkus para processamento. Isso simula o ambiente do AWS Lambda o máximo possível localmente sem exigir ferramentas como Docker e SAM CLI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Quarkus Dev Mode just invoke HTTP requests on `http://localhost:8080` as you normally would when testing your REST endpoints.  This request will hit the Mock Event Server and will be converted to the API Gateway json message that is consumed by the Quarkus Lambda Poll loop.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Ao usar o _dev_ _mode_ do Quarkus, basta invocar pedidos HTTP em `&amp;lt;a href="http://localhost:8080" class="bare"&amp;gt;http://localhost:8080&amp;lt;/a&amp;gt;` como você faria normalmente ao testar seus endpoints REST. Este pedido chegará ao Mock Event Server e será convertido na mensagem json do API Gateway que é consumida pelo Quarkus Lambda Poll loop.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For testing, Quarkus starts up a separate Mock Event server under port 8081.  The default port for Rest Assured is automatically set to 8081 by Quarkus, so you don't have to worry about setting this up.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para testes, o Quarkus inicia um servidor Mock Event separado na porta 8081. A porta predefinida para o Rest Assured é automaticamente definida para 8081 pelo Quarkus, para que você não tenha que se preocupar configurando isto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to simulate more complex API Gateway events in your tests, then manually do an HTTP POST to `http://localhost:8080/\_lambda_` (port 8081 in test mode) with the raw API Gateway json events.  These events will be placed directly on the Quarkus Lambda poll loop for processing.  Here's an example of that:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você quiser simular eventos mais complexos do API Gateway em seus testes, faça manualmente um HTTP POST para `&amp;lt;a href="http://localhost:8080/_lambda_" class="bare"&amp;gt;http://localhost:8080/_lambda_&amp;lt;/a&amp;gt;` (porta 8081 no modo de teste) com os eventos json brutos do API Gateway. Esses eventos serão colocados diretamente no Quarkus Lambda poll loop  para processamento. Aqui está um exemplo disso:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to hand code raw events for the AWS HTTP API, the AWS Lambda library has the request event type which is `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` and the response event type of `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse`.  This corresponds to the `quarkus-amazon-lambda-http` extension and the AWS HTTP API.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você quiser codificar manualmente eventos brutos para a API HTTP da AWS, a biblioteca Lambda da AWS tem o tipo de evento de request que é `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` e o tipo de evento de response de `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse`. Isto corresponde à extensão `quarkus-amazon-lambda-http` e à API HTTP da AWS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to hand code raw events for the AWS REST API, Quarkus has its own implementation: `io.quarkus.amazon.lambda.http.model.AwsProxyRequest` and `io.quarkus.amazon.lambda.http.model.AwsProxyResponse`.  This corresponds to `quarkus-amazon-lambda-rest` extension and the AWS REST API.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você quiser codificar manualmente eventos brutos para a API REST do AWS, o Quarkus tem a sua própria implementação: `io.quarkus.amazon.lambda.http.model.AwsProxyRequest` e `io.quarkus.amazon.lambda.http.model.AwsProxyResponse`. Isto corresponde à extensão `quarkus-amazon-lambda-rest` e à API REST da AWS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AWS SAM CLI allows you to run your lambda's locally on your laptop in a simulated Lambda environment.  This requires Docker to be installed.  After you have built your Maven project, execute this command:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O AWS SAM CLI permite que você execute seus lambda's localmente no seu laptop em um ambiente Lambda simulado. Para isso, é necessário que o Docker esteja instalado. Depois de criar seu projeto Maven, execute este comando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://127.0.0.1:3000/hello</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>http://127.0.0.1:3000/hello</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the console you'll see startup messages from the lambda.  This particular deployment starts a JVM and loads your lambda as pure Java.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>No console, você verá mensagens de inicialização do lambda. Esse deployment específico inicia uma JVM e carrega seu lambda como Java puro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Answer all the questions and your lambda will be deployed and the necessary hooks to the API Gateway will be set up. If everything deploys successfully, the root URL of your microservice will be output to the console.  Something like this:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Responda a todas as perguntas e seu lambda será implantado e os hooks necessários para o API Gateway serão configurados. Se tudo for implantado com sucesso, o URL raiz do seu microsserviço será enviado para o console. Algo parecido com isto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Responses for binary types will be automatically encoded with base64.  This is different from the behavior using `quarkus:dev` which will return the raw bytes.  Amazon's API has additional restrictions requiring the base64 encoding.  In general, client code will automatically handle this encoding but in certain custom situations, you should be aware you may need to manually manage that encoding.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>As respostas para tipos binários serão automaticamente codificadas com base64. Isso é diferente do comportamento usando `quarkus:dev`, que retornará os bytes brutos. A API da Amazon tem restrições adicionais que exigem a codificação base64. Em geral, o código do cliente tratará automaticamente desta codificação, mas em determinadas situações personalizadas, deve estar ciente de que poderá ter de gerir manualmente essa codificação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda-http` extension (if you are deploying an AWS Gateway HTTP API) or the `quarkus-amazon-lambda-rest` extension (if you are deploying an AWS Gateway REST API).  These extensions automatically generate everything you might need for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Não há nada de especial no POM além da inclusão da extensão `quarkus-amazon-lambda-http` (se estiver implantando uma API HTTP do AWS Gateway) ou da extensão `quarkus-amazon-lambda-rest` (se estiver implantando uma API REST do AWS Gateway). Essas extensões geram automaticamente tudo o que pode ser necessário para o deploy do lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `sam.yaml` syntax is beyond the scope of this document.  There's a couple of things that must be highlighted just in case you are going to craft your own custom `sam.yaml` deployment files.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A sintaxe do `sam.yaml` está além do escopo deste documento. Há alguns aspectos que devem ser destacados, caso pretenda criar os seus próprios arquivos de deployment `sam.yaml` personalizados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first thing to note is that for pure Java lambda deployments require a specific handler class.  Do not change the Lambda handler name.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A primeira coisa a observar é que, para deployments lambda Java puros, é necessário um handler class específico. Não altere o nome do handler Lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to go native, there's an environment variable that must be set for native GraalVM deployments.  If you look at `sam.native.yaml` you'll see this:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você deseja usar uma compilação nativa, há uma variável de ambiente que deve ser definida para deployments nativos do GraalVM. Se olhares para `sam.native.yaml` verás isto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, there is one specific thing for AWS Gateway REST API deployments.  That API assumes that HTTP response bodies are text unless you explicitly tell it which media types are binary through configuration.  To make things easier, the Quarkus extension forces a binary (base 64) encoding of all HTTP response messages and the `sam.yaml` file must configure the API Gateway to assume all media types are binary:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por fim, há um aspeto específico para o deploy da API REST do AWS Gateway. Essa API assume que os corpos de resposta HTTP são texto, a menos que se diga explicitamente quais tipos de mídia são binários por meio de configuração. Para facilitar as coisas, a extensão Quarkus obriga a uma codificação binária (base 64) de todas as mensagens de resposta HTTP e o ficheiro `sam.yaml` tem de configurar a API Gateway para assumir que todos os tipos de media são binários:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the AWS HTTP API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent`.  Here is an example:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para a API HTTP do AWS, você pode injetar as variáveis do AWS `com.amazonaws.services.lambda.runtime.Context` e `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent`. Eis um exemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the AWS REST API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext`.  Here is an example:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para a API REST do AWS, você pode injetar as variáveis do AWS `com.amazonaws.services.lambda.runtime.Context` e `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext`. Eis um exemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable this security feature, add this to your `application.properties` file:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para ativar esta funcionalidade de segurança, adicione isto ao seu arquivo `application.properties`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HTTP `quarkus-amazon-lambda-http`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>HTTP `quarkus-amazon-lambda-http`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Auth Type</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Auth Type</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cognito JWT</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Cognito JWT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.amazon.lambda.http.CognitoPrincipal`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`io.quarkus.amazon.lambda.http.CognitoPrincipal`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.jwt.claims.cognito:username`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`requestContext.authorizer.jwt.claims.cognito:username`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.amazon.lambda.http.IAMPrincipal`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`io.quarkus.amazon.lambda.http.IAMPrincipal`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.iam.userId`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`requestContext.authorizer.iam.userId`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.amazon.lambda.http.CustomPrincipal`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`io.quarkus.amazon.lambda.http.CustomPrincipal`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.lambda.principalId`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`requestContext.authorizer.lambda.principalId`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST `quarkus-amazon-lambda-rest`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>REST `quarkus-amazon-lambda-rest`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cognito</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Cognito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.claims.cognito:username`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`requestContext.authorizer.claims.cognito:username`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For HTTP, the important method to override is `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)`.  From this you will allocate a SecurityIdentity based on how you want to map security data from `APIGatewayV2HTTPEvent`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para HTTP, o método importante para ser substituído é o `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)`. A partir daí, atribuirá uma SecurityIdentity com base na forma como pretende mapear os dados de segurança de `APIGatewayV2HTTPEvent`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For REST, the important method to override is `LambdaIdentityProvider.authenticate(AwsProxyRequest event)`.  From this you will allocate a SecurityIdentity based on how you want to map security data from `AwsProxyRequest`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para REST, o método importante para ser substituído é o `LambdaIdentityProvider.authenticate(AwsProxyRequest event)`. A partir daí, atribuirá uma SecurityIdentity com base na forma como pretende mapear os dados de segurança de `AwsProxyRequest`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your implemented provider must be a CDI bean.  Here's an example:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O seu provider implementado deve ser um bean CDI. Eis um exemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus should automatically discover this implementation and use it instead of the default implementation discussed earlier.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus deve descobrir automaticamente esta implementação e utilizá-la em vez da implementação padrão referida anteriormente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are testing your application with `sam local` you can hardcode a principal name to use when your application runs by setting the `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME` environment variable</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você estiver testando a sua aplicação com `sam local`, pode definir um nome principal para utilizar quando a sua aplicação for executada, definindo a variável de ambiente `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you ever want to build a native container image and already have an existing native image you can set `-Dquarkus.native.reuse-existing=true` and the native image build will not be re-run.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você quiser construir uma imagem de contêiner nativa e já tiver uma imagem nativa existente, você pode definir `-Dquarkus.native.reuse-existing=true`. Isso evitará que a imagem nativa seja construída novamente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP automatically starts an AMQP 1.0 broker in dev mode and when running tests.  So, you don't have to start a broker manually.  The application is configured automatically.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para AMQP inicia automaticamente um broker AMQP 1.0 no modo de desenvolvimento e ao executar testes. Assim, não é necessário iniciar um broker manualmente. A aplicação é configurada de forma automática.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling / Disabling Dev Services for AMQP</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Ativação/desativação do Dev Services para AMQP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP is automatically enabled unless:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para AMQP é  ativado automaticamente, a menos que:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP relies on Docker to start the broker.  If your environment does not support Docker, you will need to start the broker manually, or connect to an already running broker.  You can configure the broker access using the `amqp-host`, `amqp-port`, `amqp-user` and `amqp-password` properties.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para AMQP depende do Docker para iniciar o Broker. Se o seu ambiente não for compatível com o Docker, será necessário iniciar o Broker manualmente ou conectar-se a um Broker já em execução. Você pode configurar o acesso ao Broker  utilizando as propriedades `amqp-host`, `amqp-port`, `amqp-user` e `amqp-password`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the broker between applications.  Dev Services for AMQP implements a _service discovery_ mechanism for your multiple Quarkus applications running in _dev_ mode to share a single broker.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Na maioria das vezes, é necessário compartilhar o broker entre as aplicações. O Dev Services para AMQP implementa um mecanismo de _service discovery_ para que as suas múltiplas aplicações Quarkus em execução no _dev_ mode_ compartilhem um único broker.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) brokers, you can configure the `quarkus.amqp.devservices.service-name` attribute and indicate the broker name.  It looks for a container with the same value, or starts a new one if none can be found.  The default service name is `amqp`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você precisar de vários brokers (compartilhados), você pode configurar o atributo `quarkus.amqp.devservices.service-name` e indicar o nome do broker. Este irá buscar  um container com o mesmo valor ou iniciará um novo se não for encontrado nenhum. O nome de serviço predefinido é `amqp`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing is enabled by default in dev mode, but disabled in test mode.  You can disable the sharing with `quarkus.amqp.devservices.shared=false`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O compartilhamento é ativado por padrão no modo _dev_, mas desativada no modo _test_. Você pode desativar o compartilhamento com `quarkus.amqp.devservices.shared=false`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Dev Services for AMQP picks a random port and configures the application.  You can set the port by configuring the `quarkus.amqp.devservices.port` property.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, o Dev Services para AMQP escolhe uma porta aleatória e configura a aplicação. É possível definir a porta configurando a propriedade `quarkus.amqp.devservices.port`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP uses https://quay.io/repository/artemiscloud/activemq-artemis-broker[activemq-artemis-broker] images.  You can configure the image and version using the `quarkus.amqp.devservices.image-name` property:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para AMQP usa a imagem  link:https://quay.io/repository/artemiscloud/activemq-artemis-broker[activemq-artemis-broker]. É possível configurar a imagem e a versão usando a propriedade `quarkus.amqp.devservices.image-name`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are going to model our increments using the `Increment` POJO.  Create the `src/main/java/org/acme/redis/Increment.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Vamos modelar os nossos incrementos utilizando o POJO `Increment`. Crie o arquivo `src/main/java/org/acme/redis/Increment.java`, com o seguinte conteúdo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package org.acme.redis;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>package org.acme.redis;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public Increment(String key, long value) {
        this.key = key;
        this.value = value;
    }
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    public Incremento(String chave, long valor) {
        this.chave = chave;
        this.valor = valor;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are going to create an `IncrementService` class which will play the role of a Redis client.  With this class, we'll be able to perform the `SET`, `GET` , `DEL`, `KEYS` and `INCRBY` Redis commands.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Vamos criar uma classe `IncrementService` que desempenhará o papel de um cliente Redis. Com essa classe, poderemos executar os comandos Redis `SET`, `GET`, `DEL`, `KEYS` e `INCRBY`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/redis/IncrementService.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Criar o arquivo `src/main/java/org/acme/redis/IncrementService.java`, com o seguinte conteúdo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.redis.datasource.ReactiveRedisDataSource;
import io.quarkus.redis.datasource.RedisDataSource;
import io.quarkus.redis.datasource.keys.KeyCommands;
import io.quarkus.redis.datasource.keys.ReactiveKeyCommands;
import io.quarkus.redis.datasource.string.StringCommands;
import io.smallrye.mutiny.Uni;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>import io.quarkus.redis.datasource.ReactiveRedisDataSource;
import io.quarkus.redis.datasource.RedisDataSource;
import io.quarkus.redis.datasource.keys.KeyCommands;
import io.quarkus.redis.datasource.keys.ReactiveKeyCommands;
import io.quarkus.redis.datasource.string.StringCommands;
import io.smallrye.mutiny.Uni;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    // This quickstart demonstrates both the imperative
    // and reactive Redis data sources
    // Regular applications will pick one of them.
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    // Esse exemplo demonstra tanto a instanciação imperativa
    // quanto reativa do seu datasource Redis.
    // Sua aplicação geralmente precisará de uma delas.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    long get(String key) {
        Long value = countCommands.get(key); // &lt;6&gt;
        if (value == null) {
            return 0L;
        }
        return value;
    }
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    long get(String chave) {
        Long valor = contadorValueCommands.get(chave); // &lt;6&gt;
        if (valor == null) {
            return 0L;
        }
        return valor;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    void set(String key, Long value) {
        countCommands.set(key, value); // &lt;7&gt;
    }
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    void set(String chave, Long valor) {
        contadorValueCommands.set(chave, valor); // &lt;7&gt;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    void increment(String key, Long incrementBy) {
        countCommands.incrby(key, incrementBy); // &lt;8&gt;
    }
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    void incrementar(String chave, Long valor) {
        contadorValueCommands.incrby(chave, valor); // &lt;8&gt;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    Uni&lt;Void&gt; del(String key) {
        return keyCommands.del(key) // &lt;9&gt;
            .replaceWithVoid();
    }
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    Uni&lt;Void&gt; deletar(String chave) {
        return chaveKeyCommands.del(chave) // &lt;9&gt;
            .replaceWithVoid();
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    Uni&lt;List&lt;String&gt;&gt; keys() {
        return keyCommands.keys("*"); // &lt;10&gt;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    Uni&lt;List&lt;String&gt;&gt; chaves() {
        return chaveKeyCommands.keys("*"); // &lt;10&gt;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/redis/IncrementResource.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Criar o arquivo `src/main/java/org/acme/redis/IncrementResource.java`, com o seguinte conteúdo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @GET
    public Uni&lt;List&lt;String&gt;&gt; keys() {
        return service.keys();
    }
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    @GET
    public Uni&lt;List&lt;String&gt;&gt; chaves() {
        return service.chaves();
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @POST
    public Increment create(Increment increment) {
        service.set(increment.key, increment.value);
        return increment;
    }
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    @POST
    public Incremento create(Incremento incremento) {
        service.set(incremento.chave, incremento.valor);
        return incremento;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @GET
    @Path("/{key}")
    public Increment get(String key) {
        return new Increment(key, service.get(key));
    }
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    @GET
    @Path("/{chave}")
    public Incremento get(String chave) {
        return new Incremento(key, service.get(chave));
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @PUT
    @Path("/{key}")
    public void increment(String key, long value) {
        service.increment(key, value);
    }
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    @PUT
    @Path("/{chave}")
    public void incrementar(String chave, long valor) {
        service.incrementar(chave, valor);
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @DELETE
    @Path("/{key}")
    public Uni&lt;Void&gt; delete(String key) {
        return service.del(key);
    }
}
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    @DELETE
    @Path("/{chave}")
    public Uni&lt;Void&gt; delete(String chave) {
        return service.del(chave);
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import static org.hamcrest.Matchers.is;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>import static org.hamcrest.Matchers.is;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import static io.restassured.RestAssured.given;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>import static io.restassured.RestAssured.given;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.restassured.http.ContentType;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>import io.restassured.http.ContentType;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Test
    public void testRedisOperations() {
        // verify that we have nothing
        given()
                .accept(ContentType.JSON)
                .when()
                .get("/increments")
                .then()
                .statusCode(200)
                .body("size()", is(0));
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    @Test
    public void testOperacoesRedis() {
        // verifique que está vazio
        given()
                .accept(ContentType.JSON)
                .when()
                .get("/incrementos")
                .then()
                .statusCode(200)
                .body("size()", is(0));
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        // create a first increment key with an initial value of 0
        given()
                .contentType(ContentType.JSON)
                .accept(ContentType.JSON)
                .body("{\"key\":\"first-key\",\"value\":0}")
                .when()
                .post("/increments")
                .then()
                .statusCode(200)
                .body("key", is("first-key"))
                .body("value", is(0));
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>        // cria a primeira chave de incremento com valor inicial 0
        given()
                .contentType(ContentType.JSON)
                .accept(ContentType.JSON)
                .body("{\"chave\":\"primeira-chave\",\"valor\":0}")
                .when()
                .post("/incrementos")
                .then()
                .statusCode(200)
                .body("chave", is("primeira-chave"))
                .body("valor", is(0));
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        // create a second increment key with an initial value of 10
        given()
                .contentType(ContentType.JSON)
                .accept(ContentType.JSON)
                .body("{\"key\":\"second-key\",\"value\":10}")
                .when()
                .post("/increments")
                .then()
                .statusCode(200)
                .body("key", is("second-key"))
                .body("value", is(10));
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>        // cria a primeira chave de incremento com valor inicial 10
        given()
                .contentType(ContentType.JSON)
                .accept(ContentType.JSON)
                .body("{\"chave\":\"segunda-chave\",\"valor\":10}")
                .when()
                .post("/incrementos")
                .then()
                .statusCode(200)
                .body("chave", is("segunda-chave"))
                .body("valor", is(10));
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        // verify that there is no key left
        given()
                .accept(ContentType.JSON)
                .when()
                .get("/increments")
                .then()
                .statusCode(200)
                .body("size()", is(0));
    }
}
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>        // verifica que não existem mais chaves
        given()
                .accept(ContentType.JSON)
                .when()
                .get("/incrementos")
                .then()
                .statusCode(200)
                .body("size()", is(0));
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you followed the instructions, you should have the Redis server running.  Then, you just need to run the application using:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se seguiu as instruções, deve ter o servidor Redis funcionando. Depois, você só precisa executar a aplicação utilizando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open another terminal and run the `curl http://localhost:8080/increments` command.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Abra outro terminal e execute o comando `curl http://localhost:8080/increments.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we have seen above, the API exposes five Rest endpoints.  In this section we are going to see how to initialise an increment, see the list of current increments, incrementing a value given its key, retrieving the current value of an increment, and finally deleting a key.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Como vimos acima, a API expõe cinco endpoints Rest. Nesta seção, vamos ver como inicializar um incremento, ver a lista de incrementos atuais, incrementar um valor dado a sua chave, recuperar o valor atual de um incremento e, finalmente, excluir uma chave.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>curl -X POST -H "Content-Type: application/json" -d '{"key":"first","value":10}' http://localhost:8080/increments &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>curl -X POST -H "Content-Type: application/json" -d '{"chave":"primeira","valor":10}' http://localhost:8080/incrementos &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{
  "key": "first",
  "value": 10
}
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>{
  "chave": "primeira",
  "valor": 10
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>curl http://localhost:8080/increments
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>curl http://localhost:8080/incrementos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>curl http://localhost:8080/increments/first &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>curl http://localhost:8080/increments/primeira &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>curl -X PUT -H "Content-Type: application/json" -d '27' http://localhost:8080/increments/first &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>curl -X PUT -H "Content-Type: application/json" -d '27' http://localhost:8080/incrementos/primeira &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, running the command `curl http://localhost:8080/increments/first` should return the following result:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Agora, ao executar o comando `curl http://localhost:8080/incrementos/primeira` deve retornar o seguinte resultado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{
  "key": "first",
  "value": 37 &lt;1&gt;
}
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>{
  "chave": "primeira",
  "valor": 37 &lt;1&gt;
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>curl -X DELETE  http://localhost:8080/increments/first &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>curl -X DELETE  http://localhost:8080/increments/primeira &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delete the `first` increment.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Excluir o incremento `first`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, running the command `curl http://localhost:8080/increments` should return an empty list `[]`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Agora, ao executar o comando `curl http://localhost:8080/incrementos` deve retornar uma lista vazia `[]`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At this point, Quarkus uses the Redis Dev Service to run a Redis server and configure the application.  However, in production, you will run your own Redis (or used a Cloud offering).</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Neste ponto, o Quarkus usa o Redis Dev Service para executar um servidor Redis e configurar a aplicação. No entanto, em produção, você irá executar o seu próprio Redis (ou utilizar um oferecido por algum serviço de Cloud).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev UI</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Interface do usuário do desenvolvedor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The support for Apache Camel on top of Quarkus is provided by the https://github.com/apache/camel-quarkus[Apache Camel Quarkus project]. Please refer to https://camel.apache.org/camel-quarkus/[their documentation] for more information.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O suporte para o Apache Camel em cima do Quarkus é fornecido pelo  link:https://github.com/apache/camel-quarkus[projeto Apache Camel Quarkus]. Para mais informações, consulte a  link:https://camel.apache.org/camel-quarkus/[respectiva documentação].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to use xref:maven-tooling.adoc[Maven] as a build tool</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>como utilizar  link:maven-tooling.html[o Maven] como ferramenta de construção</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to use xref:gradle-tooling.adoc[Gradle] as a build tool</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>como utilizar  link:gradle-tooling.html[o Gradle] como uma ferramenta de construção</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to use the xref:cli-tooling.adoc[CLI] for your toolchain</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>como utilizar o  link:cli-tooling.html[CLI] para o seu conjunto de ferramentas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>how to set up Quarkus tools in xref:ide-tooling.adoc[Visual Studio Code, Eclipse IDE, Eclipse Che and IntelliJ IDEA]</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>como configurar as ferramentas Quarkus no  link:ide-tooling.html[Visual Studio Code, Eclipse IDE, Eclipse Che e IntelliJ IDEA]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus comes with a toolchain to help you at all development stages.  You can use Maven or Gradle as build tool.  And we offer a CLI that is convenient to use (coming soon).</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus é fornecido com um conjunto de ferramentas para ajudá-lo em todas as fases de desenvolvimento. Você pode utilizar o Maven ou o Gradle como ferramenta de construção. E nós oferecemos um CLI que é conveniente de usar (em breve).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Identity providers</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Identity providers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`IdentityProvider` converts the authentication credentials provided by `HttpAuthenticationMechanism` to a `SecurityIdentity` instance.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`IdentityProvider` converte as credenciais de autenticação fornecidas por `HttpAuthenticationMechanism` para uma instância `SecurityIdentity`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDK 11+ installed with `JAVA_HOME` configured appropriately</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>JDK 11+ instalado com 'JAVA_HOME' configurado adequadamente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Docker and Docker Compose or xref:podman.adoc[Podman], and Docker Compose</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Docker e Docker Compose ou xref:podman.adoc[Podman] e Docker Compose</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name set in `@Identifier` of a bean that implements `io.smallrye.reactive.messaging.kafka.SerializationFailureHandler`. If set, serialization failure happening when serializing keys are delegated to this handler which may provide a fallback value.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O nome definido em '@Identifier' de um bean que implementa 'io.smallrye.reactive.messaging.kafka.SerializationFailureHandler'. Se definido, a falha de serialização que ocorre quando as chaves de serialização são delegadas a esse manipulador, que pode fornecer um valor de fallback.

Tipo: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The maximum number of messages to be written to Kafka concurrently. It limits the number of messages waiting to be written and acknowledged by the broker. You can set this attribute to `0` remove the limit

Type: _long_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O número máximo de mensagens a serem gravadas em Kafka simultaneamente. Ele limita o número de mensagens aguardando para serem escritas e reconhecidas pelo corretor. Você pode definir esse atributo como '0' remover o limite

Tipo: _long_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If set to a positive number, the connector will try to resend any record that was not delivered successfully (with a potentially transient error) until the number of retries is reached. If set to 0, retries are disabled. If not set, the connector tries to resend any record that failed to be delivered (because of a potentially transient error) during an amount of time configured by `delivery.timeout.ms`.

Type: _long_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se definido como um número positivo, o conector tentará reenviar qualquer registro que não tenha sido entregue com êxito (com um erro potencialmente transitório) até que o número de tentativas seja atingido. Se definido como 0, as novas tentativas serão desabilitadas. Se não estiver definido, o conector tentará reenviar qualquer registro que não tenha sido entregue (devido a um erro potencialmente transitório) durante um período de tempo configurado por 'delivery.timeout.ms'.

Tipo: _long_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The consumed / populated Kafka topic. If neither this property nor the `topics` properties are set, the channel name is used

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O tema Kafka consumido/populado. Se nem essa propriedade nem as propriedades 'topics' estiverem definidas, o nome do canal será usado

Tipo: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name set in `@Identifier` of a bean that implements `io.smallrye.reactive.messaging.kafka.SerializationFailureHandler`. If set, serialization failure happening when serializing values are delegated to this handler which may provide a fallback value.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O nome definido em '@Identifier' de um bean que implementa 'io.smallrye.reactive.messaging.kafka.SerializationFailureHandler'. Se definido, a falha de serialização que ocorre quando os valores de serialização são delegados a esse manipulador, que pode fornecer um valor de fallback.

Tipo: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following will build all modules in the Quarkus repository except docs and test modules and install them in your local maven repository with the `999-SNAPSHOT` version:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O seguinte comando irá construir todos os módulos no repositório Quarkus, exceto os módulos docs e de teste, e instalá-los no seu repositório Maven local com a versão `999-SNAPSHOT`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following will build all modules in the Quarkus repository (except test modules) and install them in your local maven repository with the `999-SNAPSHOT` version:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O seguinte comando irá construir todos os módulos no repositório do Quarkus (exceto módulos de teste) e instalá-los em seu repositório maven local com a versão '999-SNAPSHOT':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create a Gradle project, add the `--gradle` or `--gradle-kotlin-dsl` option.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para criar um projeto Gradle, adicione a opção `--gradle` ou `--gradle-kotlin-dsl`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create a Gradle project, add the `-DbuildTool=gradle` or `-DbuildTool=gradle-kotlin-dsl` option.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para criar um projeto Gradle, adicione a opção '-DbuildTool=gradle' ou '-DbuildTool=gradle-kotlin-dsl'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In _experimental_ mode, early feedback is requested to mature the idea.  There is no guarantee of stability nor long term presence in the platform until the solution matures.  Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>No modo _experimental_, o feedback antecipado é solicitado para amadurecer a idéia.  Não há garantia de estabilidade nem presença de longo prazo na plataforma até que a solução amadureça.  Comentários são bem-vindos em nosso https://groups.google.com/d/forum/quarkus-dev[mailing list] ou como issues em nosso https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have installed at least one extension that provides an `IdentityProvider` based on username and password, such as xref:security-jdbc.adoc[Elytron JDBC].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Você instalou pelo menos uma extensão que fornece um `IdentityProvider` baseado no usename e no password, como o  link:security-jdbc.html[Elytron JDBC].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to allow HTTP clients to invoke your Funqy functions on Google Cloud Functions, Quarkus allows you to expose multiple Funqy functions through HTTP deployed as one Google Cloud Function.  This approach does add overhead over the regular Funqy Google Cloud Function integration.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você quiser permitir que os clientes HTTP invoquem suas funções Funqy no Google Cloud Functions, o Quarkus permite expor várias funções Funqy por meio de HTTP implantado como um Google Cloud Function. Essa abordagem adiciona uma sobrecarga em relação à integração regular do Funqy com o Google Cloud Function.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Beyond generating a Google Cloud Functions project that is covered in the xref:gcp-functions-http.adoc[Google Cloud Functions HTTP Guide], there's also a quickstart for running Funqy HTTP on Google Cloud Functions.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Além de gerar um projeto do Google Cloud Functions que é abordado no  link:gcp-functions-http.html[Guia HTTP do Google Cloud Functions], há também um Quickstart para executar o Funqy HTTP no Google Cloud Functions.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kafka supports https://redpanda.com[Redpanda], https://github/ozangunalp/kafka-native[kafka-native] and https://strimzi.io[Strimzi] (in https://github.com/apache/kafka/blob/trunk/config/kraft/README.md[Kraft] mode)  images.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para o Kafka suporta imagens  link:https://redpanda.com[Redpanda],  link:https://github/ozangunalp/kafka-native[kafka-native] e  link:https://strimzi.io[Strimzi] (no modo  link:https://github.com/apache/kafka/blob/trunk/config/kraft/README.md[Kraft] ).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Redpanda** is a Kafka compatible event streaming platform.
Because it provides a fast startup times, dev services defaults to Redpanda images from `vectorized/redpanda`.
You can select any version from https://hub.docker.com/r/vectorized/redpanda.
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>*Redpanda* é uma plataforma de streaming de eventos compatível com o Kafka. Uma vez que proporciona tempos de startup rápidos, o Dev services têm como padrão as imagens Redpanda de `vectorized/redpanda`. Pode selecionar qualquer versão de  https://hub.docker.com/r/vectorized/redpanda
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**kafka-native** provides images of standard Apache Kafka distribution compiled to native binary using Quarkus and GraalVM.
While still being _experimental_, it provides very fast startup times with small footprint.
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>*kafka-native* fornece imagens da distribuição padrão do Apache Kafka compiladas para binário nativo usando Quarkus e GraalVM. Embora ainda esteja em fase _experimental_, fornece tempos de startup muito rápidos e com consumo reduzido.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Strimzi** provides container images and Operators for running Apache Kafka on Kubernetes.
While Strimzi is optimized for Kubernetes, the images work perfectly in classic container environments.
Strimzi container images run "genuine" Kafka broker on JVM, which is slower to start.
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>*O Strimzi* fornece imagens de container e Operadores para executar o Apache Kafka no Kubernetes. Embora o Strimzi seja otimizado para Kubernetes, as imagens funcionam perfeitamente em ambientes de container clássicos. As imagens de container do Strimzi rodam o broker Kafka "genuíno" na JVM, que é mais lento para iniciar.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This Quarkus xDS gRPC integration currently doesn't support building native executables due to the issues with shaded grpc-netty library while running native IT tests.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Atualmente, essa integração Quarkus xDS gRPC não suporta a construção de executáveis nativos devido a problemas com a biblioteca grpc-netty sombreada ao executar testes de integração nativos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This transitively adds `io.quarkus:quarkus-grpc` extension dependency.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Isso adiciona de forma transitiva a dependência da extensão `io.quarkus:quarkus-grpc`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable server xDS, use the following configuration.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para habilitar o servidor xDS, utilize a seguinte configuração:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xDS must be explicitly enabled on the server, then verify you use it on the right xDS server port (default is 9000).  If you want to use `XdsServerCredentials` set `xds.secure` to `true`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O xDS deve estar explicitamente habilitado no servidor e, em seguida, verifique se você o usa na porta correta do servidor xDS (o padrão é 9000). Se você quiser usar `XdsServerCredentials`, defina `xds.secure` como `true`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When xDS is configured, `plain-text` is automatically disabled.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Quando o xDS está configurado, o modo "plain-text" é automaticamente desabilitado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When xDS target property is used, name resolver, host, and port are not used</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Quando a propriedade de destino do xDS é utilizada, o resolvedor de nomes, host e porta não são utilizados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable client xDS, use the following configuration.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para ativar o xDS do cliente, utilize a seguinte configuração:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can either explicitly enable xDS or you use `xds` name resolver, and make sure you point it to the right xDS server port (default is 9000).  If you want to use `XdsChannelCredentials` set `xds.secure` to `true`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Você pode tanto habilitar explicitamente o xDS quanto utilizar o name resolver `xds`, assegurando-se de configurá-lo para a porta correta do servidor xDS (o default é 9000). Se desejar utilizar `XdsChannelCredentials`, defina `xds.secure` como `true`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kubernetes configuration example</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Exemplo de configuração do Kubernetes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `cognito:groups` claim is present, then Quarkus will extract and map those groups to Quarkus roles which can then be used in authorization with annotations like `@RolesAllowed`.  If you do not want to map `cognito:groups` to Quarkus roles, then you must explicitly disable it in configuration:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se a reivindicação `cognito:groups` estiver presente, o Quarkus extrairá e mapeará esses grupos para as funções do Quarkus que podem então ser utilizadas na autorização com anotações como `@RolesAllowed`. Se não pretender mapear `cognito:groups` para as funções do Quarkus, você terá que desativar explicitamente na configuração:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, it expects roles in a space delimited list enclosed in brackets i.e. `[ user admin ]`.  You can specify the regular expression to use to find individual roles in the claim string too:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, ele espera funções numa lista delimitada por espaços entre parênteses, ou seja, `[ user admin ]`. Também pode especificar a expressão regular a utilizar para encontrar funções individuais na cadeia de reivindicação:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SnapStart</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>SnapStart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To optimize your application for Lambda SnapStart, check xref:amazon-snapstart.adoc[the SnapStart Configuration Documentation].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para otimizar a sua aplicação para o Lambda SnapStart, consulte  link:amazon-snapstart.html[a documentação de configuração do SnapStart].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html[SnapStart] is a snapshotting and restore mechanism reducing drastically the cold startup time of Java functions on AWS.  This document explains the various settings you can use to leverage this feature.  It is not a reference documentation on SnapStart, and it will not cover how SnapStart works in details.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>link:https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html[O SnapStart] é um mecanismo de _snapshotting_ e restauração que reduz drasticamente o tempo de inicialização a frio das funções Java na AWS. Este documento explica as várias configurações que podem ser usadas para aproveitar esse recurso. Não se trata de uma documentação de referência sobre o SnapStart e não abordará como o SnapStart funciona em detalhes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This feature is only available on AWS Lambda, and not in all regions.  Please check the AWS documentation to verify the eligibility of your AWS region.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Esta funcionalidade só está disponível na AWS Lambda e não em todas as regiões. Consulte a documentação da AWS para verificar a elegibilidade da sua região da AWS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Classloading has a huge impact on your function execution time.  This optimization allows preloading classes during the snapshotting process of SnapStart.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O _classloading_ tem um enorme impacto no tempo de execução da sua função. Esta otimização permite pré-carregar classes durante o processo de _snapshotting_ do SnapStart.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To compute the list of classes, we recommend deploying your function and setting the `JAVA_TOOL_OPTIONS` environment variable to `-verbose:class`.  Then execute your function and retrieve the log (in CloudWatch).  You should be able to extract the class names using sed/awk or any text editor.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para calcular a lista de classes, recomendamos fazer o _deploy_ da sua função e definir a variável de ambiente JAVA_TOOL_OPTIONS como -verbose:class. Em seguida, execute sua função e recupere o registro (no CloudWatch). Você deverá ser capaz de extrair os nomes das classes usando o sed/awk ou qualquer editor de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus generates the class list of the classes included in your application (including the classes generated by Quarkus).  So, you do not have to repeat them in the `quarkus-preload-classes.txt` file.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, o Quarkus gera a lista de classes das classes incluídas na sua aplicação (incluindo as classes geradas pelo Quarkus). Assim, você não precisa repeti-las no arquivo `quarkus-preload-classes.txt`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, when the classes are preloaded, they are also _initialized_, meaning it also resolves the dependent classes.  You can disable this behavior using:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, quando as classes são pré-carregadas, elas também são _inicializadas_, o que significa que também resolve as classes dependentes. É possível desativar este comportamento utilizando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Client _priming_ is a technique that allows initializing a client during the snapshotting process, so it's already fully functional during the application runtime.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Client _priming_ é uma técnica que permite inicializar um client durante o processo de _snapshotting,_ para que já esteja totalmente funcional durante o tempo de execução da aplicação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>initialize the client in a `static` block, which, thanks to class preloading will be executed before the snapshot</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>inicializar o client num bloco `static`, que, graças ao pré-carregamento da classe, será executado antes do snapshot</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing priming using a static block may prevent the native compilation of your application.  Client initialization may start threads or open connections which are not compatible with the native compilation if the class is initialized at build time.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Implementar o priming usando um bloco estático pode impedir a compilação nativa da sua aplicação. A inicialização do client pode iniciar threads ou abrir conexões que não são compatíveis com a compilação nativa se a classe for inicializada no momento da compilação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also recommended to use _tiered compilation_ when using SnapStart.  To achieve this, set the `JAVA_TOOL_OPTIONS` environment property to `-XX:+TieredCompilation -XX:TieredStopAtLevel=1`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Também é recomendável usar _tiered compilation_ ao usar o SnapStart. Para isso, defina a propriedade de ambiente `JAVA_TOOL_OPTIONS` como `-XX:+TieredCompilation -XX:TieredStopAtLevel=1`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Prefix for Kafka client `client.id` attribute. If defined configured or generated `client.id` will be prefixed with the given value, otherwise `kafka-producer-` is the prefix.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Prefixo para o atributo 'client.id' do cliente Kafka. Se definido configurado ou gerado 'client.id' será prefixado com o valor dado, caso contrário 'kafka-producer-' é o prefixo.

Tipo: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kubernetes automatically starts a Kubernetes API server in dev mode and when running tests.  So you don't have to start a Kubernetes cluster manually.  The application is configured automatically.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para Kubernetes inicia automaticamente um servidor de API do Kubernetes no modo de desenvolvimento e ao executar testes. Assim, não é necessário iniciar um cluster do Kubernetes manualmente. A aplicação é configurada de forma automática.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling / Disabling Dev Services for Kubernetes</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Ativar/desativar Dev Services  para Kubernetes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a valid Kube config file is found and `quarkus.kubernetes-client.devservices.override-kubeconfig` is not set to `true`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Um arquivo de configuração Kube válido seja encontrado e `quarkus.kubernetes-client.devservices.override-kubeconfig` não está definido como `true`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you include the `quarkus-test-kubernetes-client` dependency</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Você inclua a dependência `quarkus-test-kubernetes-client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kubernetes relies on Docker to start the API server.  If your environment does not support Docker, you will need to start the Kubernetes cluster manually, or connect to an already running Kubernetes cluster.  You can configure the Kubernetes cluster access using either a Kube config file or the various properties available in the https://github.com/quarkusio/quarkus/blob/main/extensions/kubernetes-client/runtime-internal/src/main/java/io/quarkus/kubernetes/client/runtime/KubernetesClientBuildConfig.java[KubernetesClientBuildConfig] class.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para Kubernetes depende do Docker para iniciar o servidor de API. Se o seu ambiente não suportar o Docker, terá de iniciar o cluster Kubernetes manualmente ou conectar-se a um cluster Kubernetes já em execução. É possível configurar o acesso ao cluster do Kubernetes usando um arquivo de configuração do Kube ou as várias propriedades disponíveis na classe link:https://github.com/quarkusio/quarkus/blob/main/extensions/kubernetes-client/runtime-internal/src/main/java/io/quarkus/kubernetes/client/runtime/KubernetesClientBuildConfig.java[KubernetesClientBuildConfig].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the cluster between applications.  Dev Services for Kubernetes implements a _service discovery_ mechanism for your multiple Quarkus applications running in dev mode to share a single cluster.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Na maioria das vezes, é necessário compartilhar o cluster entre aplicações. O Dev Services para Kubernetes implementaa um mecanismo de _service discovery_ para que suas várias aplicações Quarkus em execução no _dev_ mode_ compartilhem um único cluster.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) clusters, you can configure the `quarkus.kubernetes-client.devservices.service-name` configuration property and indicate the cluster name.  It looks for a container with the name defined, or starts a new one if none can be found.  The default service name is `kubernetes`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg> Se você precisar de vários clusters (compartilhados), você pode configurar o configuration property `quarkus.kubernetes-client.devservices.service-name` e indicar o nome do cluster. Procurar um container com o nome definido ou iniciar um novo se não for encontrado nenhum. O nome do serviço predefinido é `kubernetes`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kubernetes provides three different flavors of Kubernetes cluster. Each flavor supports different Kubernetes API versions.  You can configure the flavor and version using the `quarkus.kubernetes-client.devservices.flavor` and `quarkus.kubernetes-client.devservices.api-version` properties:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para Kubernetes oferece três flavors diferentes de cluster Kubernetes. Cada flavor suporta diferentes versões da API do Kubernetes. Você pode configurar o flavor e a versão usando as propriedades quarkus.kubernetes-client.devservices.flavor e quarkus.kubernetes-client.devservices.api-version:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`api-only` only starts a Kubernetes API Server. If you need a fully-featured Kubernetes cluster that can spin up Pods, you can use `k3s` or `kind`. Note that they both requires to run in Docker privileged mode.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>'api-only' inicia apenas um Servidor de API Kubernetes. Se você precisa de um cluster Kubernetes totalmente funcional que possa criar Pods, você pode usar k3s ou kind. Observe que ambos requerem que sejam executados em modo privilegiado do Docker."</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka Dev UI</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Kafka Dev UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If any Kafka-related extension is present (e.g. `quarkus-smallrye-reactive-messaging-kafka`), the Quarkus Dev UI is extended with a Kafka broker management UI.  It is connected automatically to the Kafka broker configured for the application.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se estiver presente uma extensão relacionada com o Kafka (por exemplo, `quarkus-smallrye-reactive-messaging-kafka`), a Quarkus Dev UI é estendida com uma interface de gestão do corretor Kafka. Esta é ligada automaticamente ao corretor Kafka configurado para a aplicação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>kafka-dev-ui-link.png</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>kafka-dev-ui-link.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>kafka-dev-ui-records.png</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>kafka-dev-ui-records.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus Cache uses Caffeine as backend.  It's possible to use Redis instead.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, o Quarkus Cache utiliza o Caffeine como backend. É possível usar Redis em vez disso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The backend uses the _&lt;default&gt;_ Redis client (if not configured otherwise), so make sure it's configured (or use the xref:redis-dev-services.adoc[redis dev service])</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O backend utiliza o cliente Redis por padrão (se não estiver configurado de outra forma), por isso certifique-se de que está configurado (ou utilize o xref:redis-dev-services.adoc[redis dev service])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Redis backend uses the `&lt;default&gt;` Redis client.  See the xref:redis-reference.adoc[Redis reference] to configure the access to Redis.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O backend do Redis utiliza o cliente Redis por padrão. Consulte xref:redis-reference.adoc[referência do Redis] para configurar o acesso ao Redis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When writing to Redis or reading from Redis, Quarkus needs to know the type.  Indeed, the objects need to be serialized and deserialized.  For that purpose, you may need to configure type (class names) of the key and value you want to cache.  At build time, Quarkus tries to deduce the types from the application code, but that decision can be overridden using:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Ao escrever ou ler do Redis, o Quarkus precisa saber o tipo. De fato, os objetos têm que ser serializados e desserializados. Para esse efeito, pode ser necessário configurar o tipo (nome das classes) da chave e do valor que pretende armazenar em cache. No momento da construção (at build time), o Quarkus tenta deduzir os tipos a partir do código da aplicação, mas essa decisão pode ser substituída utilizando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the Redis backend stores the entry using the following keys: `cache:$cache-name:$cache-key`, where `cache-key` is the key the application uses.  So, you can find all the entries for a single cache using the Redis `KEYS` command: `KEYS cache:$cache-name:*`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, o Redis backend armazena a entrada utilizando as seguintes chaves: `cache:$cache-name:$cache-key`, onde `cache-key` é a chave que o aplicativo usa. Assim, é possível encontrar todas as entradas de um único cache usando o comando Redis `KEYS`: `KEYS cache:$cache-name:*`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `cache:$cache-name:` segment can be configured using the `prefix` property:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O `cache:$cache-name:` segmento pode ser configurado utilizando a propriedade `prefix`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable optimistic locking</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Ativar o bloqueio otimista (`Optimistic locking`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The access to the cache can be _direct_ or use https://redis.io/docs/manual/transactions/#optimistic-locking-using-check-and-set[optimistic locking].  By default, optimistic locking is disabled.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O acesso ao cache pode ser _direto_ ou utilizar o https://redis.io/docs/manual/transactions/#optimistic-locking-using-check-and-set[bloqueio otimista]. Por padrão, o bloqueio otimista está desativado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When used, the key is _watched_ and the _SET_ command is executed in a transaction (`MULTI/EXEC`).</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Quando utilizado, a chave é _vigiada_ e o comando _SET_ é executado numa transação ( `MULTI/EXEC`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The update command primarily employs OpenRewrite recipes to automate updates for most project dependencies, source code, and documentation.  Although these recipes update many migration items, they do not cover all the items detailed in the {quarkus-migration-guide}.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O comando update utiliza principalmente `receitas` OpenRewrite para automatizar atualizações para a maioria das dependências do projeto, código-fonte e documentação. Embora essas `receitas` atualizem muitos itens de migração, elas não cobrem todos os itens detalhados no {quarkus-migration-guide}.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The recipe might not include a specific item in your project.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A receita OpenRewrite pode não incluir um item específico do seu projeto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your project might use an extension that is incompatible with the latest {project-name} version.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O seu projeto pode estar utilizando uma extensão que é incompatível com a versão mais recente do {project-name}.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For projects that use Hibernate ORM or Hibernate Reactive, review the link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-3.0:-Hibernate-ORM-5-to-6-migration[Hibernate ORM 5 to 6 migration] quick reference.  The following update command covers only a subset of this guide.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para projetos que usam o Hibernate ORM ou o Hibernate Reactive, consulte a referência  link:https://github.com/quarkusio/quarkus/wiki/Migration-Guide-3.0:-Hibernate-ORM-5-to-6-migration[migração do ORM Hibernate 5 para 6]. O comando de atualização a seguir abrange apenas um subconjunto deste guia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A project based on {project-name} version 2.13 or later.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Um projeto baseado na versão 2.13 ou posterior de {project-name}.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optional: To specify a particular stream, use the `stream` option; for example: `--stream=3.0`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Opcional: Para especificar uma versão, utilize a opção `stream`; por exemplo: `--stream=3.0`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Optional: To specify a particular stream, use the `Dstream` option; for example: `-Dstream=3.0`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Opcional: Para especificar uma versão, utilize a opção `Dstream`; por exemplo: `-Dstream=3.0`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Review the {quarkus-migration-guide} for items that were not updated by the update command.  If your project has such items, implement the additional steps advised in these topics.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Revisite o {quarkus-migration-guide} para itens que não foram atualizados pelo comando `update`. Se o seu projeto tiver esses itens, implemente os passos adicionais aconselhados nestes tópicos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The mock event server is also started for `@QuarkusIntegrationTest` tests so will work with native binaries too.  All this provides similar functionality to the SAM CLI local testing, without the overhead of Docker.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O mock event server também é iniciado para os testes `@QuarkusIntegrationTest`, pelo que também funcionará com binários nativos. Tudo isso fornece uma funcionalidade semelhante ao teste local do SAM CLI, sem a sobrecarga do Docker.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, at least in the generated Maven archetype `pom.xml`, the `quarkus-resteasy-reactive`, `quarkus-reactive-routes`, and `quarkus-undertow` dependencies are all optional.  Pick which HTTP framework(s) you want to use (Jakarta REST, Reactive Routes, and/or Servlet) and remove the other dependencies to shrink your deployment.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Além disso, pelo menos no arquétipo Maven gerado `pom.xml`, as dependências `quarkus-resteasy-reactive`, `quarkus-reactive-routes` e `quarkus-undertow` são todas opcionais. Escolha o(s) framework(s) HTTP que deseja usar (Jakarta REST, Rotas Reativas e/ou Servlet) e remova as outras dependências para reduzir sua implantação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using RESTEasy Reactive and Jakarta REST, you can inject various AWS Context variables into your Jakarta REST resource classes using the Jakarta REST `@Context` annotation or anywhere else with the CDI `@Inject` annotation.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se estiver utilizando o RESTEasy Reactive e o Jakarta REST, pode injetar várias variáveis de contexto AWS nas suas resource classes Jakarta REST utilizando a anotação Jakarta REST `@Context` ou em qualquer outro lugar com a anotação CDI `@Inject`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you invoke an HTTP request on the API Gateway, the Gateway turns that HTTP request into a JSON event document that is forwarded to a Quarkus Lambda.  The Quarkus Lambda parses this json and converts in into an internal representation of an HTTP request that can be consumed by any HTTP framework Quarkus supports (Jakarta REST, servlet, Reactive Routes).</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Quando você invoca um pedido HTTP no API Gateway, o Gateway transforma esse pedido HTTP num documento de evento JSON que é reencaminhado para um Quarkus Lambda. O Quarkus Lambda analisa este json e o converte em uma representação interna de um pedido HTTP que pode ser consumido por qualquer estrutura HTTP suportada pelo Quarkus (Jakarta REST, servlet, Reactive Routes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>API Gateway supports many ways to securely invoke on your HTTP endpoints that are backed by Lambda and Quarkus.  If you enable it, Quarkus will automatically parse relevant parts of the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html[event json document] and look for security based metadata and register a `java.security.Principal` internally that can be looked up in Jakarta REST by injecting a `jakarta.ws.rs.core.SecurityContext`, via `HttpServletRequest.getUserPrincipal()` in servlet, and `RouteContext.user()` in Reactive Routes.  If you want more security information, the `Principal` object can be typecast to a class that will give you more information.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O API Gateway suporta muitas formas de invocar com segurança os seus endpoints HTTP que são apoiados pelo Lambda e pelo Quarkus. Se o ativar, o Quarkus analisará automaticamente as partes relevantes do  link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html[documento json do evento] e procurará metadados baseados na segurança e registará internamente um `java.security.Principal` que pode ser consultado no Jakarta REST injectando um `jakarta.ws.rs.core.SecurityContext`, através de `HttpServletRequest.getUserPrincipal()` no servlet e `RouteContext.user()` nas rotas reactivas. Se quiser mais informações de segurança, o objeto `Principal` pode ser convertido para uma classe que lhe dará mais informações.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default support for AWS security only maps the principal name to Quarkus security APIs and does nothing to map claims or roles or permissions.  You have full control on how security metadata in the lambda HTTP event is mapped to Quarkus Security APIs using implementations of the `io.quarkus.amazon.lambda.http.LambdaIdentityProvider` interface.  By implementing this interface, you can do things like define role mappings for your principal or publish additional attributes provided by IAM or Cognito or your Custom Lambda security integration.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O suporte padrão para a segurança AWS apenas mapeia o nome principal para as APIs de segurança do Quarkus e não faz nada para mapear reivindicações, funções ou permissões. Você tem total controle sobre a forma como os metadados de segurança no evento HTTP lambda são mapeados para as APIs de segurança do Quarkus utilizando implementações da interface `io.quarkus.amazon.lambda.http.LambdaIdentityProvider`. Ao implementar esta interface, pode fazer coisas como definir mapeamentos de funções para o seu principal ou publicar atributos adicionais fornecidos pelo IAM ou Cognito ou pela sua integração de segurança Lambda personalizada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For testing purposes, you can configure the required user credentials, user name, secret, and roles, in the `application.properties` file.  For example:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para efeitos de teste, você pode configurar as credenciais de usuário necessárias, username, secret e roles no arquivo `application.properties`. Por exemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For information about other methods that you can use to configure the required user credentials, see the xref:security-testing.adoc#configuring-user-information[Configuring User Information] section of the Quarkus "Security Testing" guide.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para obter informações sobre outros métodos que você pode utilizar para configurar as credenciais de usuário necessárias, consulte a seção  link:security-testing.html#configuring-user-information[Configurar as informações do usuario] do guia "Teste de segurança" do Quarkus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring user names, secrets, and roles in the `application.properties` file is only suitable for testing scenarios.  If you are securing a production application, always use a database to store this information.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A configuração de nomes de username, secrets e roles no arquivo `application.properties` só é adequada para cenários de teste. Se estiver protegendo uma aplicação em produção, utilize sempre uma base de dados para armazenar estas informações.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a more detailed walk-through that shows you how to configure Basic authentication together with Jakarta Persistence for storing user credentials in a database, see the xref:security-basic-authentication-tutorial.adoc[Secure a Quarkus application with Basic authentication and Jakarta Persistence] guide.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para obter um guia mais detalhado que mostra como configurar a autenticação básica juntamente com o Jakarta Persistence para armazenar credenciais de usuário numa base de dados, consulte o guia  link:security-basic-authentication-tutorial.html[Proteger uma aplicação Quarkus com autenticação básica e o Jakarta Persistence].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `redis-quickstart` link:{quickstarts-tree-url}/redis-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A solução está localizada no link:{quickstarts-tree-url}/redis-quickstart[diretório] `redis-quickstart` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.PUT;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.DELETE;
import java.util.List;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.PUT;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.DELETE;
import java.util.List;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the Quarkus Security framework, identity providers play a crucial role in authentication and authorization by verifying user identities.  `IdentityProvider` creates a `SecurityIdentity` instance, which gets used during user authentication to verify and authorize access requests to your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>No Quarkus Security framework, os identity providers desempenham um papel crucial na autenticação e autorização, verificando as identidades dos usuários. `IdentityProvider` cria uma instância `SecurityIdentity`, que é utilizada durante a autenticação do usuário para verificar e autorizar os pedidos de acesso à sua aplicação Quarkus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some extensions, for example, `OIDC`, `OAuth2`, and `SmallRye JWT`, have inline `IdentityProvider` implementations specific to the supported authentication flow.  For example, `quarkus-oidc` uses its own `IdentityProvider` to convert a token to a `SecurityIdentity` instance.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Algumas extensões, por exemplo, `OIDC`, `OAuth2`, e `SmallRye JWT`, têm implementações em linha `IdentityProvider` específicas para o fluxo de autenticação suportado. Por exemplo, `quarkus-oidc` usa seu próprio `IdentityProvider` para converter um token em uma instância `SecurityIdentity`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use Basic or form-based authentication, you must add an `IdentityProvider` instance to convert a username and password to a `SecurityIdentity` instance.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você utilizar a Basic ou form-based, você precisará adicionar uma instãncia `IdentityProvider` para converter um username e um password em uma instância `SecurityIdentity`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about how to install and use the Quarkus CLI, see the xref:cli-tooling.adoc[Quarkus CLI] guide.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para obter mais informações sobre como instalar e usar a CLI do Quarkus, consulte o guia xref:cli-tooling.adoc[Quarkus CLI].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As a Quarkus developer, you configure the Quarkus OpenID Connect (OIDC) extension by setting the following properties in the `src/main/resources/application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Como programador do Quarkus, você configura a extensão Quarkus OpenID Connect (OIDC) definindo as seguintes propriedades no diretório `src/main/resources/application.properties`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:security-oidc-bearer-token-authentication-tutorial.adoc[Protect a service application by using OpenID Connect (OIDC) Bearer token authentication]</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>link:security-oidc-bearer-token-authentication-tutorial.html[Proteger uma aplicação de serviço usando a autenticação de token Bearer OpenID Connect (OIDC)]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `api-server-url` is configured</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A URL `api-server-url` esteja configurada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Funqy HTTP + Google Cloud Functions binding is not a replacement for REST over HTTP.  Because Funqy needs to be portable across a lot of different protocols and function providers its HTTP binding is very minimalistic and you will lose REST features like linking and the ability to leverage HTTP features like cache-control and conditional GETs.  You may want to consider using Quarkus's Jakarta REST, Spring MVC, or Vert.x Web Reactive Route xref:gcp-functions-http.adoc[support] instead.  They also work with Quarkus and Google Cloud Functions.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A integração Funqy HTTP + Google Cloud Functions não é um substituto para REST sobre HTTP. Como o Funqy precisa ser portátil em vários protocolos e provedores de funções diferentes, sua vinculação HTTP é muito minimalista e você perderá os recursos REST, como linking e a capacidade de aproveitar os recursos HTTP, como controle de cache e GETs condicionais. Em vez disso, pode considerar usar o  link:gcp-functions-http.html[suporte a] Jakarta REST, Spring MVC ou Rota reativa da Web Vert.x do Quarkus. Eles também funcionam com o Quarkus e o Google Cloud Functions.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `funqy-google-cloud-functions-http-quickstart` link:{quickstarts-tree-url}/funqy-quickstarts/funqy-google-cloud-functions-http-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A solução está localizada no  link:{quickstarts-tree-url}/funqy-quickstarts/funqy-google-cloud-functions-http-quickstart[diretório] `funqy-google-cloud-functions-http-quickstart`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about the code and more importantly nothing Google Cloud specific.  Funqy functions can be deployed to many environments and Google Cloud Functions is one of them.  The Java code is actually the same exact code as the link:{quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[funqy-http-quickstart].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Não há nada de especial no código e, mais importante, nada específico do Google Cloud. As funções Funqy podem ser implantadas em muitos ambientes e o Google Cloud Functions é um deles. O código Java é, na verdade, exatamente o mesmo código do  link:{quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[funqy-http-quickstart].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `expire-after-write` is not configured, the entry won't be evicted.  You would need to invalidate the values using the `@CacheInvalidateAll` or `@CacheInvalidate` annotations.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se o tempo de vida `expire-after-write` não estiver configurado, a entrada não será excluída. Você terá de invalidar os valores utilizando as anotações `@CacheInvalidateAll` ou `@CacheInvalidate`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Until Java 19, every instance of the link:{thread}[Thread] class was a platform thread, a wrapper around an OS thread.  Creating a platform thread creates an OS thread, and blocking a platform thread blocks an OS thread.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Até o Java 19, cada instância da classe link:{thread}[Thread] era uma thread de plataforma, um wrapper em torno de uma thread do sistema operacional. A criação de uma thread de plataforma cria uma thread de SO, e o bloqueio de uma thread de plataforma bloqueia uma thread de SO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A platform thread used to execute a virtual thread is called a **carrier** thread.  It isn't a class distinct from link:{Thread}[Thread] or `VirtualThread` but rather a functional denomination.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Uma thread de plataforma usada para executar uma thread virtual é chamada de **carrier** thread. Não se trata de uma classe distinta da link:{Thread}[Thread] ou `VirtualThread`, mas sim de uma denominação funcional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We will give a brief overview of the topic here; please refer to the link:{vthreadjep}[JEP 425] for more information.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Faremos aqui um breve resumo do tema; para mais informações, consulte o link:{vthreadjep}[JEP 425].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Until now, platform threads were the concurrency unit of the JVM.  They are a wrapper over OS structures.  Creating a Java platform thread creates a "thread-like" structure in your operating system.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Até agora, as threads de plataforma eram a unidade de concorrência da JVM. Elas são um invólucro sobre as estruturas do sistema operacional. A criação de uma thread de plataforma Java cria uma estrutura "semelhante a uma thread" no seu sistema operacional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Virtual threads, on the other hand, are managed by the JVM. To be executed, they need to be mounted on a platform thread (which acts as a carrier to that virtual thread).  As such, they have been designed to offer the following characteristics:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>As threads virtuais, por outro lado, são gerenciadas pela JVM. Para serem executadas, elas têm de ser montadas numa thread de plataforma (que atua como um suporte para essa thread virtual). Como tal, elas foram concebidas para oferecer as seguintes características:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Virtual threads occupy less space than platform threads in memory.  Hence, it becomes possible to use more virtual threads than platform threads simultaneously without blowing up the memory.  By default, platform threads are created with a stack of about 1 MB, whereas virtual threads stack is "pay-as-you-go." You can find these numbers and other motivations for virtual threads in this https://youtu.be/lIq-x_iI-kc?t=543[presentation] given by the lead developer of project Loom (the project that added the virtual thread support to the JVM).</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>As threads virtuais ocupam menos espaço na memória do que as threads de plataforma. Por isso, torna-se possível usar mais threads virtuais do que threads de plataforma simultaneamente sem estourar a memória. Por definição, as threads de plataforma são criadas com uma pilha de cerca de 1 MB, ao passo que a pilha das threads virtuais é "paga à medida que se usa". Você pode encontrar estes números e outras motivações para as threads virtuais nesta  link:https://youtu.be/lIq-x_iI-kc?t=543[apresentação] feita pelo programador principal do projeto Loom (o projeto que adicionou o suporte de threads virtuais à JVM).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Creating a platform thread in Java takes time.  Currently, techniques such as pooling, where threads are created once and then reused, are strongly encouraged to minimize the time lost in starting them (as well as limiting the maximum number of threads to keep memory consumption low).  Virtual threads are supposed to be disposable entities that we create when we need them, it is discouraged to pool them or reuse them for different tasks.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Criar uma thread de plataforma em Java leva tempo. Atualmente, técnicas como o pooling, em que as threads são criadas uma vez e depois reutilizadas, são fortemente encorajadas para minimizar o tempo perdido ao iniciá-las (bem como limitar o número máximo de threads para manter o consumo de memória baixo). As threads virtuais devem ser entidades descartáveis que criamos quando precisamos delas, não sendo aconselhável agrupá-las ou reutilizá-las para diferentes tarefas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When performing blocking I/O, the underlying OS thread wrapped by the Java platform thread is put in a wait queue, and a context switch occurs to load a new thread context onto the CPU core. This operation takes time.  Since the JVM manages virtual threads, no underlying OS thread is blocked when they perform a blocking operation.  Their state is stored in the heap, and another virtual thread is executed on the same Java platform (carrier) thread.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Ao executar E/S bloqueante, a thread do SO relacionada à thread da plataforma Java é colocada numa fila de espera e ocorre uma troca de contexto para carregar um novo contexto de thread no núcleo da CPU. Essa operação leva tempo. Uma vez que a JVM gerencia threads virtuais, nenhuma thread do SO é bloqueada quando uma operação de bloqueio é realizada. O seu estado é armazenado na heap e outra thread virtual é executada na mesma thread (carrier) da plataforma Java.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above, the JVM schedules the virtual threads. These virtual threads are mounted on carrier threads. The scheduling comes with a pinch of magic. When the virtual thread attempts to use blocking I/O, the JVM _transforms_ this call into a non-blocking one, unmounts the virtual thread, and mounts another virtual thread on the carrier thread. When the I/O completes, the _waiting_ virtual thread becomes eligible again and will be re-mounted on a carrier thread to continue its execution. For the user, all this dance is invisible. Your synchronous code is executed asynchronously.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Como mencionado acima, a JVM agenda as threads virtuais. Essas threads virtuais são montadas em carrier threads. O agendamento vem com uma pitada de magia. Quando a thread virtual tenta utilizar E/S bloqueante, a JVM _transforma_ esta chamada numa chamada não bloqueante, desmonta a thread virtual e monta outra thread virtual na carrier thread. Quando a E/S é concluída, a thread virtual _em espera_ torna-se novamente elegível e será montada novamente numa carrier thread para continuar a sua execução. Para o usuário, todo esse processo é invisível. O seu código síncrono é executado de forma assíncrona.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We now know we can create more virtual threads than platform threads. One could be tempted to use virtual threads to perform long computations (CPU-bound workload).  It is useless and counterproductive.  CPU-bound doesn't consist of quickly swapping threads while they need to wait for the completion of an I/O, but in leaving them attached to a CPU core to compute something.  In this scenario, it is worse than useless to have thousands of threads if we have tens of CPU cores, virtual threads won't enhance the performance of CPU-bound workloads.  Even worse, when running a CPU-bound workload on a virtual thread, the virtual thread monopolizes the carrier thread on which it is mounted.  It will either reduce the chance for the other virtual thread to run or will start creating new carrier threads, leading to high memory usage.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Agora sabemos que podemos criar mais threads virtuais do que threads de plataforma. Poderíamos sentir-nos tentados a utilizar threads virtuais para efetuar cálculos longos (carga de trabalho ligada à CPU). Isso é inútil e contraproducente. Trabalhos que exigem muita CPU não se beneficiam de alternar rapidamente entre threads enquanto esperam pela conclusão de uma operação de E/S, mas sim de manter as threads conectadas a um núcleo de CPU para realizar cálculos. Neste cenário, é péssimo ter milhares de threads se temos dezenas de núcleos de CPU, ou seja, threads virtuais não vão melhorar o desempenho de cargas de trabalho CPU-bound. Pior ainda, ao executar uma carga de trabalho CPU-bound em uma thread virtual, a thread virtual monopoliza a carrier thread na qual está montada. Isso quer dizer que ela reduzirá a chance de execução de outra thread virtual ou começará a criar novas carrier threads, levando a um alto uso de memória.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As mentioned above, not everything can run safely on virtual threads.  The risk of **monopolization** can lead to high-memory usage.  Also, there are situations where the virtual thread cannot be unmounted from the carrier thread.  This is called **pinning**.  Finally, some libraries use `ThreadLocal` to store and reuse objects.  Using virtual threads with these libraries will lead to massive allocation, as the intentionally pooled objects will be instantiated for every (disposable and generally short-lived) virtual thread.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Como mencionado acima, nem tudo pode ser executado com segurança em threads virtuais. O risco de *monopolização* pode levar a um alto uso de memória. Além disso, há situações em que a thread virtual não pode ser desmontada da carrier thread. Isso é chamado de *pinning*. Finalmente, algumas bibliotecas utilizam `ThreadLocal` para armazenar e reutilizar objetos. O uso de threads virtuais com essas bibliotecas levará a uma alocação massiva, pois os objetos intencionalmente agrupados serão instanciados para cada thread virtual (descartável e geralmente de curta duração).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As of today, it is not possible to use virtual threads in a carefree manner.  Following such a laissez-faire approach could quickly lead to memory and resource starvation issues.  Thus, Quarkus uses an explicit model until the aforementioned issues disappear (as the Java ecosystem matures).  It is also the reason why _reactive_ extensions have the virtual thread support, and rarely the _classic_ ones.  We need to know when to dispatch on a virtual thread.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Atualmente, não é possível utilizar threads virtuais de uma forma despreocupada. Seguir uma abordagem tão "descuidada" poderia rapidamente levar a problemas de falta de memória e de recursos. Dessa forma, o Quarkus utiliza um modelo explícito até que os problemas acima mencionados desapareçam (à medida que o ecossistema Java amadurece). É também a razão pela qual as extensões _reativas_ têm o suporte de threads virtuais e raramente as _clássicas_. Precisamos saber quando despachar em uma thread virtual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To learn more about the internal design and choices, check the https://dl.acm.org/doi/10.1145/3583678.3596895[Considerations for integrating virtual threads in a Java framework: a Quarkus example in a resource-constrained environment] paper.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para saber mais sobre o design interno e as escolhas, consulte o documento https://dl.acm.org/doi/10.1145/3583678.3596895[Considerações sobre a integração de threads virtuais numa estrutura Java: um exemplo Quarkus num ambiente com recursos limitados].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The monopolization has been explained in the xref:cpu-bound[Virtual threads are useful for I/O-bound workloads only] section.  When running long computations, we do not allow the JVM to unmount and switch to another virtual thread until the virtual thread terminates.  Indeed, the current scheduler does not support preempting tasks.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A monopolização foi explicada na seção xref:#cpu-bound[Threads virtuais são úteis apenas para cargas de trabalho ligadas a E/S]. Ao executar cálculos longos, não permitimos que a JVM desmonte e mude para outra thread virtual até que a thread virtual atual termine. De fato, o agendador atual não suporta a interrupção de tarefas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This monopolization can lead to the creation of new carrier threads to execute other virtual threads.  Creating carrier threads results in creating platform threads.  So, there is a memory cost associated with this creation.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Esta monopolização pode levar à criação de novas carrier threads para executar outras threads virtuais. A criação de carrier threads resulta na criação de threads de plataforma. Portanto, há um custo de memória associado a essa criação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Suppose you run in a constrained environment, such as containers. In that case, monopolization can quickly become a concern, as the high memory usage can lead to out-of-memory issues and container termination.  The memory usage may be higher than with regular worker threads because of the inherent cost of the scheduling and virtual threads.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Suponha que você execute em um ambiente restrito, como contêineres. Nesse caso, a monopolização pode rapidamente se tornar uma preocupação, pois o alto uso de memória pode levar a problemas de falta de memória e ao encerramento do contêiner. O uso de memória pode ser maior do que com worker threads regulares devido ao custo inerente do agendamento e das threads virtuais.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The promise of "cheap blocking" might not always hold: a virtual thread might _pin_ its carrier on certain occasions.  The platform thread is blocked in this situation, precisely as it would have been in a typical blocking scenario.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A promessa de "bloqueio barato" pode nem sempre ser cumprida: uma thread virtual pode _fixar_ o seu portador (carrier) em determinadas ocasiões. A thread da plataforma fica bloqueada nesta situação, exatamente como teria sido num cenário de bloqueio típico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The pooling case</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O caso do agrupamento (pooling)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some libraries are using `ThreadLocal` as an object pooling mechanism.  Extremely popular libraries like https://github.com/FasterXML/jackson-core/issues/919[Jackson] and Netty assume that the application uses a limited number of threads, which are recycled (using a thread pool) to run multiple (unrelated but sequential) tasks.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Algumas bibliotecas utilizam `ThreadLocal` como um mecanismo de pooling de objetos. Bibliotecas extremamente populares como link:https://github.com/FasterXML/jackson-core/issues/919[Jackson] e Netty assumem que a aplicação utiliza um número limitado de threads, que são reciclados (usando um pool de threads) para executar múltiplas tarefas (não relacionadas, mas sequenciais).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>However, this pattern is counter-productive when using virtual threads.  Virtual threads are not pooled and generally short-lived.  So, instead of a few of them, we now have many of them.  For each of them, the object stored in the `ThreadLocal` is created (often large and expensive) and won't be reused, as the virtual thread is not pooled (and won't be used to run another task once the execution completes).  This problem leads to high memory usage.  Unfortunately, it requires sophisticated code changes in the libraries themselves.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>No entanto, esse padrão é contraproducente ao usar threads virtuais. Threads virtuais não são agrupadas e geralmente têm vida curta. Portanto, em vez de algumas threads virtuais, agora temos muitas. Para cada uma delas, o objeto armazenado no `ThreadLocal` é criado (geralmente grande e caro) e não será reutilizado, pois a thread virtual não é gerenciada em um pool (e não será utilizada para executar outra tarefa quando a execução for concluída). Esse problema leva a um alto uso de memória. Infelizmente, requer mudanças significativas no código dessas bibliotecas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This section shows a brief example of using the link:{runonvthread}[@RunOnVirtualThread] annotation.  It also explains the various development and execution models offered by Quarkus.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Esta seção mostra um breve exemplo de utilização da anotação link:{runonvthread}[@RunOnVirtualThread]. Ela também explica os vários modelos de desenvolvimento e execução oferecidos pelo Quarkus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@RunOnVirtualThread` annotation instructs Quarkus to invoke the annotated method on a **new** virtual thread instead of the current one.  Quarkus handles the creation of the virtual thread and the offloading.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A anotação `@RunOnVirtualThread` dá instruções ao Quarkus para invocar o método anotado numa **nova** thread virtual em vez da atual. O Quarkus trata da criação da thread virtual e do descarregamento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the case of RESTEasy Reactive, this annotation can only be used on endpoints annotated with link:{blockingannotation}[@Blocking] or considered blocking because of their signature.  You can visit xref:resteasy-reactive.adoc#execution-model-blocking-non-blocking[Execution model, blocking, non-blocking] for more information.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>No caso do RESTEasy Reactive, essa anotação só pode ser usada em endpoints anotados com link:{blockingannotation}[@Blocking] ou considerados bloqueantes devido à sua assinatura. Para mais informações, visite xref:resteasy-reactive.adoc#execution-model-blocking-non-blocking[Modelo de execução, bloqueio, não-bloqueio].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the third one uses Mutiny but in a synchronous way, since it doesn't return a "reactive type" it is considered blocking and the link:{runonvthread}[@RunOnVirtualThread] annotation can be used.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>a terceira utiliza Mutiny, mas de forma síncrona, uma vez que não devolve um "tipo reativo", é considerada bloqueante e pode ser utilizada a anotação link:{runonvthread}[@RunOnVirtualThread].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Risk of pinning, monopolization and under-efficient object pooling</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Risco de fixação (pinning), monopolização e agrupamento de objetos pouco eficiente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Fortunately, Quarkus provides a massive ecosystem that is ready to be used in virtual threads.  Mutiny, the reactive programming library used in Quarkus, and the Vert.x Mutiny bindings provides the ability to write blocking code (so, no fear, no learning curve) which do not pin the carrier thread.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Felizmente, o Quarkus oferece um ecossistema enorme que está pronto para ser usado em threads virtuais. O Mutiny, a biblioteca de programação reativa utilizada no Quarkus, e as ligações Mutiny do Vert.x permitem escrever código bloqueante (sem medo, sem curva de aprendizado) que não bloqueia a carrier thread.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus extensions providing blocking APIs on top of reactive APIs can be used in virtual threads.  This includes the reactive rest client, the redis client, the mailer...</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>As extensões Quarkus que fornecem APIs bloqueantes em cima de APIs reativas podem ser utilizadas em threads virtuais. Isto inclui o cliente reativo rest, o cliente redis, o mailer...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>API returning `Uni` can be used directly using `uni.await().atMost(...)`. It blocks the virtual thread, without blocking the carrier thread, and also improves the resilience of your application with an easy (non-blocking) timeout support.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A API que retornar `Uni` pode ser utilizada diretamente através de `uni.await().atMost(…​)`. Bloqueia a thread virtual, sem bloquear a carrier thread, e também melhora a resiliência da sua aplicação com um suporte fácil de timeout (não bloqueante).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend to use the following configuration when running tests in application using virtual threads.  If would not fail the tests, but at least dump start traces if the code pins the carrier thread:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Recomendamos a utilização da seguinte configuração ao executar testes em aplicações que utilizam threads virtuais. Isso não fará os testes falharem, mas, pelo menos, gerará os rastros (dumps) de início se o código fixar a carrier thread:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Prior to Java 21, virtual threads are still an experimental feature, you need to start your application with the `--enable-preview` flag:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Antes de Java 21, as threads virtuais ainda são uma funcionalidade experimental, portanto é necessário iniciar a aplicação com o parâmetro `--enable-preview`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this section, we use JIB to build the container.  Refer to the xref:./container-image.adoc[containerization guide] to learn more about the alternatives.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Nesta seção, utilizamos o JIB para construir o contêiner. Consulte o xref:./container-image.html[guia de conteinerização] para saber mais sobre as alternativas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, build your container as you would do usually.  For example, if you are using Maven, run:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Em seguida, construa o seu contêiner como faria normalmente. Por exemplo, se estiver a utilizar o Maven, execute:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Build the native executable as indicated on xref:./building-native-image.adoc[the native compilation guide].  For example, with Maven, run:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Construa o executável nativo conforme indicado no xref:./building-native-image.html[guia de compilação nativa]. Por exemplo, com o Maven, execute:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In-container build allows building Linux 64 executables by using a `native-image` compiler running in a container.  It avoids having to install `native-image` on your machine, and also allows configuring the GraalVM version you need.  Note that, to use in-container build, you must have Docker or Podman installed on your machine.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A construção em contêiner permite construir executáveis Linux 64 utilizando um compilador `native-image` em execução num contêiner. Isso evita ter que instalar `native-image` na sua máquina e também permite configurar a versão do GraalVM que você precisa. Note que, para usar a construção em contêiner, você precisa ter o Docker ou o Podman instalado na sua máquina.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Then, add to your `application.properties` file:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Em seguida, adicione ao seu arquivo `application.properties`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using a Mac M1 or M2 (using an ARM64 CPU), you need to be aware that the native executable you will get using an in-container build will be a Linux executable, but using your host (ARM 64) architecture.  You can use emulation to force the architecture when using Docker with the following property:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se estiver utilizando um Mac M1 ou M2 (utilizando uma CPU ARM64), esteja ciente de que o executável nativo que obterá utilizando uma compilação dentro do contêiner será um executável Linux, mas utilizando a arquitetura do seu host (ARM 64). Você pode forçar a arquitetura usando emulação ao usar o Docker com a seguinte propriedade:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To build a container running a Quarkus application using virtual threads compiled into a native executable, you must make sure you have a Linux/AMD64 executable (or ARM64 if you are targeting ARM machines).</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para construir um contêiner que executa uma aplicação Quarkus com threads virtuais compiladas em um executável nativo, primeiro certifique-se de ter um executável Linux/AMD64. Se o seu objetivo são máquinas ARM, você precisará de um executável ARM64.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Methods annotated with `@RunOnVirtualThread` inherit from the original duplicated context (See the xref:duplicated-context.adoc[duplicated context reference guide] for details).  So, the data written in the duplicated context (and the request scope, as the request scoped is stored in the duplicated context) by filters and interceptors are available during the method execution (even if the filters and interceptors are not run on the virtual thread).</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Os métodos anotados com `@RunOnVirtualThread` herdam do contexto duplicado original (consulte o xref:duplicated-context.adoc[guia de referência do contexto duplicado] para mais detalhes). Portanto, os dados escritos no contexto duplicado (e o escopo da requisição, uma vez que o escopo da requisição é armazenado no contexto duplicado) por filtros e interceptadores estão disponíveis durante a execução do método (mesmo que os filtros e interceptadores não sejam executados na thread virtual).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Virtual threads are created without a thread name by default, which is not practical to identify the execution for debugging and logging purposes.  Quarkus managed virtual threads are named and prefixed with `quarkus-virtual-thread-`.  You can customize this prefix, or disable the naming altogether configuring an empty value:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>As threads virtuais são criadas sem um nome, o que pode dificultar a identificação da execução para fins de depuração e registro. As threads virtuais gerenciadas pelo Quarkus são nomeadas e prefixadas com `quarkus-virtual-thread-`. É possível personalizar esse prefixo ou desativar a nomeação configurando um valor vazio:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The configured image must be _compatible_ with the `activemq-artemis-broker` one.  The container is launched with the `AMQ_USER`, `AMQ_PASSWORD` and `AMQ_EXTRA_ARGS` environment variables.  The ports 5672 and 8161 (web console) are exposed.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A imagem configurada deve ser _compatível_ com `activemq-artemis-broker`. O container é iniciado com as variáveis ​​de ambiente `AMQ_USER`, `AMQ_PASSWORD` e `AMQ_EXTRA_ARGS`. As portas 5672 e 8161 (console web) serão expostas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specify the commit strategy to apply when a message produced from a record is acknowledged. Values can be `ack`, `cumulative`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Especifique a estratégia de confirmação a ser aplicada quando uma mensagem produzida a partir de um registro for reconhecida. Os valores podem ser 'ack', 'cumulativos'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specify the failure strategy to apply when a message produced from a record is acknowledged negatively (nack). Values can be `nack` (default), `fail`, `ignore` or `reconsume-later</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Especifique a estratégia de falha a ser aplicada quando uma mensagem produzida a partir de um registro for reconhecida negativamente (nack). Os valores podem ser 'nack' (padrão), 'fail', 'ignore' ou 'reconsume-later</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Pulsar schema type of this channel. When configured a schema is built with the given SchemaType and used for the channel. When absent, the schema is resolved searching for a CDI bean typed `Schema` qualified with `@Identifier` and the channel name. As a fallback AUTO_CONSUME or AUTO_PRODUCE are used.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O tipo de esquema Pulsar deste canal. Quando configurado, um esquema é criado com o SchemaType fornecido e usado para o canal. Quando ausente, o esquema é resolvido procurando um bean CDI digitado 'Esquema' qualificado com '@Identifier' e o nome do canal. Como fallback AUTO_CONSUME ou AUTO_PRODUCE são usados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The consumed / populated Pulsar topic. If not set, the channel name is used</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O tópico Pulsar consumido/povoado. Se não estiver definido, o nome do canal será usado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Number of IO threads.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Número de threads de E/S.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Release the connection if it is not used for more than [connectionMaxIdleSeconds] seconds. If  [connectionMaxIdleSeconds] &lt; 0, disabled the feature that auto release the idle connections</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Solte a conexão se ela não for usada por mais de [connectionMaxIdleSeconds] segundos. Se [connectionMaxIdleSeconds] &lt; 0, desabilitado o recurso que libera automaticamente as conexões ociosas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Duration of waiting for a connection to a broker to be established.If the duration passes without a response from a broker, the connection attempt is dropped.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Duração da espera para que uma conexão com um broker seja estabelecida. Se a duração passar sem uma resposta de um broker, a tentativa de conexão será descartada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Listener name for lookup. Clients can use listenerName to choose one of the listeners as the service URL to create a connection to the broker as long as the network is accessible."advertisedListeners" must enabled in broker side.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Nome do ouvinte para pesquisa. Os clientes podem usar listenerName para escolher um dos ouvintes como a URL do serviço para criar uma conexão com o broker, desde que a rede esteja acessível." advertisedListeners" deve ser habilitado no lado do corretor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Limit of client memory usage (in byte). The 64M default can guarantee a high producer throughput.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Limite de uso de memória do cliente (em byte). O padrão de 64 milhões pode garantir uma alta taxa de transferência do produtor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interface for custom message is negativeAcked policy. You can specify `RedeliveryBackoff` for a consumer.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Interface para mensagem personalizada é política negativeAcked. Você pode especificar 'RedeliveryBackoff' para um consumidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interface for custom message is ackTimeout policy. You can specify `RedeliveryBackoff` for a consumer.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Interface para mensagem personalizada é a política ackTimeout. Você pode especificar 'RedeliveryBackoff' para um consumidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Size of a consumer's receiver queue. +
For example, the number of messages accumulated by a consumer before an application calls `Receive`. +
A value higher than the default value increases consumer throughput, though at the expense of more memory utilization.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Tamanho da fila de destinatários de um consumidor. +
Por exemplo, o número de mensagens acumuladas por um consumidor antes de um aplicativo chamar 'Receber'. +
Um valor maior que o valor padrão aumenta a taxa de transferência do consumidor, embora às custas de mais utilização de memória.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delay to wait before redelivering messages that failed to be processed. +
When an application uses `Consumer#negativeAcknowledge(Message)`, failed messages are redelivered after a fixed timeout.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Atraso para aguardar antes de entregar novamente as mensagens que não puderam ser processadas. +
Quando um aplicativo usa 'Consumer#negativeAcknowledge(Message)', as mensagens com falha são entregues novamente após um tempo limite fixo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Granularity of the ack-timeout redelivery. +
Using an higher `tickDurationMillis` reduces the memory overhead to track messages when setting ack-timeout to a bigger value (for example, 1 hour).</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Granularidade da reentrega do tempo limite de ack. +
Usar um 'tickDurationMillis' mais alto reduz a sobrecarga de memória para rastrear mensagens ao definir o tempo limite de ack-para um valor maior (por exemplo, 1 hora).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Priority level for a consumer to which a broker gives more priority while dispatching messages in Shared subscription type. +
The broker follows descending priorities. For example, 0=max-priority, 1, 2,... +
In Shared subscription type, the broker **first dispatches messages to the max priority level consumers if they have permits**. Otherwise, the broker considers next priority level consumers. +
**Example 1** +
If a subscription has consumerA with `priorityLevel` 0 and consumerB with `priorityLevel` 1, then the broker **only dispatches messages to consumerA until it runs out permits** and then starts dispatching messages to consumerB. +
**Example 2** +
Consumer Priority, Level, Permits +
C1, 0, 2 +
C2, 0, 1 +
C3, 0, 1 +
C4, 1, 2 +
C5, 1, 1 +

Order in which a broker dispatches messages to consumers is: C1, C2, C3, C1, C4, C5, C4.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Nível de prioridade para um consumidor ao qual um corretor dá mais prioridade ao enviar mensagens no tipo de assinatura compartilhada. +
O corretor segue prioridades decrescentes. Por exemplo, 0=max-priority, 1, 2,... +
No tipo de assinatura compartilhada, o corretor **primeiro envia mensagens para os consumidores de nível máximo de prioridade se eles tiverem permissões**. Caso contrário, o corretor considera os consumidores de nível de prioridade seguinte. +
**Exemplo 1** +
Se uma assinatura tiver consumerA com 'priorityLevel' 0 e consumerB com 'priorityLevel' 1, o corretor **somente despachará mensagens para consumerA até que ele esgote as permissões** e, em seguida, começará a enviar mensagens para consumerB. +
**Exemplo 2** +
Prioridade do Consumidor, Nível, Licenças +
C1, 0, 2 +
C2, 0, 1 +
C3, 0, 1 +
C4, 1, 2 +
C5, 1, 1 +

A ordem em que um corretor envia mensagens para os consumidores é: C1, C2, C3, C1, C4, C5, C4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether to automatically acknowledge pending chunked messages when the threshold of `maxPendingChunkedMessage` is reached. If set to `false`, these messages will be redelivered by their broker.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se as mensagens em bloco pendentes devem ser confirmadas automaticamente quando o limite de 'maxPendingChunkedMessage' for atingido. Se definido como 'false', essas mensagens serão reentregues pelo corretor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consumer should take action when it receives a message that can not be decrypted. +
* **FAIL**: this is the default option to fail messages until crypto succeeds. +
* **DISCARD**:silently acknowledge and not deliver message to an application. +
* **CONSUME**: deliver encrypted messages to applications. It is the application's responsibility to decrypt the message.

The decompression of message fails.

If messages contain batch messages, a client is not be able to retrieve individual messages in batch.

Delivered encrypted message contains `EncryptionContext` which contains encryption and compression information in it using which application can decrypt consumed message payload.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O consumidor deve agir quando receber uma mensagem que não pode ser descriptografada. +
* **FAIL**: esta é a opção padrão para falhar mensagens até que a criptografia seja bem-sucedida. +
* **DESCARTAR**:reconhecer silenciosamente e não entregar mensagem a um aplicativo. +
* **CONSUME**: entregar mensagens criptografadas para aplicativos. É responsabilidade do aplicativo descriptografar a mensagem.

A descompactação da mensagem falha.

Se as mensagens contiverem mensagens em lote, um cliente não poderá recuperar mensagens individuais em lote.

A mensagem criptografada entregue contém 'EncryptionContext' que contém informações de criptografia e compactação usando qual aplicativo pode descriptografar a carga útil da mensagem consumida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A name or value property of this consumer.

`properties` is application defined metadata attached to a consumer.

When getting a topic stats, associate this metadata with the consumer stats for easier identification.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Um nome ou propriedade de valor desse consumidor.

'propriedades' são metadados definidos pelo aplicativo anexados a um consumidor.

Ao obter estatísticas de tópico, associe esses metadados às estatísticas do consumidor para facilitar a identificação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If enabling `readCompacted`, a consumer reads messages from a compacted topic rather than reading a full message backlog of a topic.

A consumer only sees the latest value for each key in the compacted topic, up until reaching the point in the topic message when compacting backlog. Beyond that point, send messages as normal.

Only enabling `readCompacted` on subscriptions to persistent topics, which have a single active consumer (like failure or exclusive subscriptions).

Attempting to enable it on subscriptions to non-persistent topics or on shared subscriptions leads to a subscription call throwing a `PulsarClientException`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se habilitar 'readCompacted', um consumidor lerá mensagens de um tópico compactado em vez de ler uma lista de pendências de mensagens completa de um tópico.

Um consumidor só vê o valor mais recente para cada chave no tópico compactado, até chegar ao ponto na mensagem de tópico ao compactar a lista de pendências. Além desse ponto, envie mensagens normalmente.

Habilitar apenas 'readCompacted' em assinaturas de tópicos persistentes, que tenham um único consumidor ativo (como falha ou assinaturas exclusivas).

A tentativa de habilitá-lo em assinaturas de tópicos não persistentes ou em assinaturas compartilhadas leva a uma chamada de assinatura lançando um 'PulsarClientException'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dead letter policy for consumers.

By default, some messages are probably redelivered many times, even to the extent that it never stops.

By using the dead letter mechanism, messages have the max redelivery count. **When exceeding the maximum number of redeliveries, messages are sent to the Dead Letter Topic and acknowledged automatically**.

You can enable the dead letter mechanism by setting `deadLetterPolicy`.

When specifying the dead letter policy while not specifying `ackTimeoutMillis`, you can set the ack timeout to 30000 millisecond.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Política de dead letter para os consumidores.

Por padrão, algumas mensagens provavelmente são reentregues muitas vezes, até mesmo na medida em que nunca param.

Usando o mecanismo de dead letter, as mensagens têm a contagem máxima de reentrega. **Ao exceder o número máximo de reentregas, as mensagens são enviadas para o Tópico de Dead Letter e reconhecidas automaticamente**.

Você pode ativar o mecanismo de letra morta definindo 'deadLetterPolicy'.

Ao especificar a política de dead letter enquanto não especifica 'ackTimeoutMillis', você pode definir o tempo limite de ack para 30000 milissegundos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If `replicateSubscriptionState` is enabled, a subscription state is replicated to geo-replicated clusters.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se 'replicateSubscriptionState' estiver habilitado, um estado de assinatura será replicado para clusters replicados geograficamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Message send timeout in ms. +
If a message is not acknowledged by a server before the `sendTimeout` expires, an error occurs.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Tempo limite de envio de mensagem em ms. +
Se uma mensagem não for reconhecida por um servidor antes que o 'sendTimeout' expire, ocorrerá um erro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it is set to `true`, when the outgoing message queue is full, the `Send` and `SendAsync` methods of producer block, rather than failing and throwing errors. +
If it is set to `false`, when the outgoing message queue is full, the `Send` and `SendAsync` methods of producer fail and `ProducerQueueIsFullError` exceptions occur.

The `MaxPendingMessages` parameter determines the size of the outgoing message queue.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se estiver definido como 'true', quando a fila de mensagens de saída estiver cheia, os métodos 'Send' e 'SendAsync' do produtor bloqueiam, em vez de falhar e lançar erros. +
Se ele estiver definido como 'false', quando a fila de mensagens de saída estiver cheia, os métodos 'Send' e 'SendAsync' do produtor falham e as exceções 'ProducerQueueIsFullError' ocorrem.

O parâmetro 'MaxPendingMessages' determina o tamanho da fila de mensagens de saída.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The maximum size of a queue holding pending messages.

For example, a message waiting to receive an acknowledgment from a https://pulsar.apache.org/docs/reference-terminology#broker[broker].

By default, when the queue is full, all calls to the `Send` and `SendAsync` methods fail **unless** you set `BlockIfQueueFull` to `true`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O tamanho máximo de uma fila que contém mensagens pendentes.

Por exemplo, uma mensagem aguardando para receber uma confirmação de um https://pulsar.apache.org/docs/reference-terminologia#broker[broker].

Por padrão, quando a fila está cheia, todas as chamadas para os métodos 'Send' e 'SendAsync' falham **a menos que você defina 'BlockIfQueueFull' como 'true'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The maximum number of pending messages across partitions.

Use the setting to lower the max pending messages for each partition (`#setMaxPendingMessages(int)`) if the total number exceeds the configured value.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O número máximo de mensagens pendentes entre partições.

Use a configuração para diminuir o máximo de mensagens pendentes para cada partição ('#setMaxPendingMessages(int)') se o número total exceder o valor configurado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Message routing logic for producers on https://pulsar.apache.org/docs/concepts-architecture-overview#partitioned-topics[partitioned topics]. +
Apply the logic only when setting no key on messages. +
Available options are as follows: +
* `pulsar.RoundRobinDistribution`: round robin +
* `pulsar.UseSinglePartition`: publish all messages to a single partition +
* `pulsar.CustomPartition`: a custom partitioning scheme</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Lógica de roteamento de mensagens para produtores em https://pulsar.apache.org/docs/concepts-architecture-overview#partitioned-topics[partitioned topics]. +
Aplique a lógica somente ao definir nenhuma tecla nas mensagens. +
As opções disponíveis são as seguintes: +
* 'pulsar. RoundRobinDistribution': round robin +
* 'pulsar. UseSinglePartition': publicar todas as mensagens em uma única partição +
* 'pulsar. CustomPartition': um esquema de particionamento personalizado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hashing function determining the partition where you publish a particular message (partitioned topics only). +
Available options are as follows: +
* `pulsar.JavastringHash`: the equivalent of `string.hashCode()` in Java +
* `pulsar.Murmur3_32Hash`: applies the https://en.wikipedia.org/wiki/MurmurHash[Murmur3] hashing function +
* `pulsar.BoostHash`: applies the hashing function from C++'s https://www.boost.org/doc/libs/1_62_0/doc/html/hash.html[Boost] library</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Função de hash que determina a partição onde você publica uma mensagem específica (somente tópicos particionados). +
As opções disponíveis são as seguintes: +
* 'pulsar. JavastringHash': o equivalente a 'string.hashCode()' em Java +
* 'pulsar. Murmur3_32Hash': aplica a função de hash https://en.wikipedia.org/wiki/MurmurHash[Murmur3] +
* 'pulsar. BoostHash': aplica a função de hash da biblioteca https://www.boost.org/doc/libs/1_62_0/doc/html/hash.html[Boost] do C++</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using cmd, (don't use backward slash `\` and put everything on the same line)</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se estiver usando cmd, (não use barra invertida '\' e coloque tudo na mesma linha)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Powershell, wrap `-D` parameters in double quotes e.g. `"-DprojectArtifactId={create-app-artifact-id}"`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se estiver usando o Powershell, envolva os parâmetros '-D' entre aspas duplas, por exemplo, '"-DprojectArtifactId={create-app-artifact-id}"'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus Smallrye Reactive Messaging Pulsar extension (`quarkus-smallrye-reactive-messaging-pulsar`)  Dev Services for Pulsar automatically starts a Pulsar broker in dev mode and when running tests.  So, you don't have to start a broker manually.  The application is configured automatically.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Com a extensão Quarkus Smallrye Reactive Messaging Pulsar ( `quarkus-smallrye-reactive-messaging-pulsar`), o Dev Services para Pulsar inicia automaticamente um `broker` Pulsar em modo de desenvolvimento e durante a execução de testes. Assim, não é necessário iniciar um `broker` manualmente. A aplicação é configurada automaticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Pulsar relies on Docker to start the broker.  If your environment does not support Docker, you will need to start the broker manually, or connect to an already running broker.  You can configure the broker address using `pulsar.client.`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para Pulsar depende do Docker para iniciar o broker. Se o seu ambiente não suportar o Docker, será necessário iniciar o broker manualmente ou conectar-se a um broker já em execução. É possível configurar o endereço do broker usando `pulsar.client.`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the broker between applications.  Dev Services for Pulsar implements a _service discovery_ mechanism for your multiple Quarkus applications running in _dev_ mode to share a single broker.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Na maioria das vezes, é necessário compartilhar o broker entre as aplicações. O Dev Services para Pulsar implementa um mecanismo de _service discovery_ para que suas múltiplas aplicações Quarkus rodando em modo _dev_ compartilhem um único broker.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) brokers, you can configure the `quarkus.pulsar.devservices.service-name` attribute and indicate the broker name.  It looks for a container with the same value, or starts a new one if none can be found.  The default service name is `pulsar`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se precisar de vários brokers (partilhados), pode configurar o atributo `quarkus.pulsar.devservices.service-name` e indicar o nome do broker. Este procura um broker com o mesmo valor ou inicia um novo se não for encontrado nenhum. O nome de serviço predefinido é `pulsar`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing is enabled by default in dev mode, but disabled in test mode.  You can disable the sharing with `quarkus.pulsar.devservices.shared=false`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O compartilhamento é ativado em _dev_ mode_ por padrão , mas desativado no modo de teste. É possível desabilitar este compartilhamento com `quarkus.pulsar.devservices.shared=false`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Dev Services for Pulsar picks a random port and configures the application.  You can set the port by configuring the `quarkus.pulsar.devservices.port` property.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, o Dev Services for Pulsar escolhe uma porta aleatória e configura o aplicativo. É possível definir a porta configurando a propriedade `quarkus.pulsar.devservices.port`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Pulsar supports the https://hub.docker.com/r/apachepulsar/pulsar[official Apache Pulsar image].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para Pulsar suporta a  link:https://hub.docker.com/r/apachepulsar/pulsar[imagem oficial do Apache Pulsar].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A custom image name can be configured as such:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Um nome de imagem personalizado pode ser configurado. Por exemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the Quarkus AWS Lambda extension, SnapStart optimizations are automatically enabled.  However, you can enable/disable it explicitly using:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você utilizar a extensão Quarkus AWS Lambda, as otimizações do SnapStart são automaticamente ativadas. No entanto, você pode ativar/desativar explicitamente utilizando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus you can deploy your favorite Java HTTP frameworks as AWS Lambda's using either the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[AWS Gateway HTTP API] or https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[AWS Gateway REST API].  This means that you can deploy your microservices written with RESTEasy Reactive (our Jakarta REST implementation), Undertow (servlet), Reactive Routes, xref:funqy-http.adoc[Funqy HTTP] or any other Quarkus HTTP framework as an AWS Lambda.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Com o Quarkus, é possível fazer o deploy de seu framework Java HTTP favorito como AWS Lambdas usando a  link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[API HTTP do AWS Gateway] ou a  link:https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[API REST do AWS Gateway]. Isto significa que você pode fazer o deploy dos seus microsserviços escritos com RESTEasy Reactive (a nossa implementação Jakarta REST), Undertow (servlet), Reactive Routes,  link:funqy-http.html[Funqy HTTP] ou qualquer outra estrutura HTTP Quarkus como um AWS Lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications are optimised for low memory usage and fast startup times.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Aplicações Quarkus são otimizadas para baixo uso de memória e tempos de inicialização rápidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is published in Maven Central, check out link:/extensions[which extensions] you need and just import them in your `pom.xml` to get Quarkus. We recommend you start your Quarkus experience via our link:/get-started[Getting Started guides].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus é publicado no Maven Central, confira link:/extensions[quais extensões] você precisa e basta importá-los em seu 'pom.xml' para obter o Quarkus. Recomendamos que você comece sua experiência com o Quarkus através do nosso link:/get-started[Guias de introdução].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Think of Quarkus extensions as your project dependencies. Extensions configure, boot and integrate a framework or technology into your Quarkus application. They also do all of the heavy lifting of providing the right information to GraalVM for your application to compile natively. This will allow 3rd party projects to easily take advantage of the work we have done to make it easier to target GraalVM.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Pense nas extensões do Quarkus como suas dependências de projeto. As extensões configuram, inicializam e integram uma estrutura ou tecnologia em seu aplicativo Quarkus. Eles também fazem todo o trabalho pesado de fornecer as informações certas para GraalVM para sua aplicação compilar nativamente. Isso permitirá que os projetos de terceiros aproveitem facilmente o trabalho que fizemos para facilitar o direcionamento do GraalVM.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributions are welcome, please submit pull requests for the `develop` branch.
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Contribuições são bem-vindas, por favor, envie pull-requests para a branch `develop`.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has been designed with this new world in mind and provides first-class support for these different paradigms. That does not mean you cannot build monoliths with Quarkus; you can do it smoothly. On the contrary, it means that the Quarkus development model morphs to adapt itself to the type of application you are developing, monolith, microservice, reactive, event-driven, functions…</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus foi projetado com esse novo mundo em mente e fornece suporte de primeira classe para esses diferentes paradigmas. Isso não significa que você não possa construir monólitos com Quarkus; você pode fazê-lo sem problemas. Pelo contrário, isso significa que o modelo de desenvolvimento do Quarkus se transforma para se adaptar ao tipo de aplicação que você está desenvolvendo, monólito, microsserviço, reativo, orientado a eventos, funções...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Application requirements have changed drastically over the last few years.  For any application to succeed in the era of cloud computing, Big Data, or IoT, going reactive is increasingly becoming the architecture style to follow.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Os requisitos das aplicações mudaram drasticamente nos últimos anos. Para que qualquer aplicação tenha sucesso na era da computação em nuvem, Big Data ou IoT, tornar-se reativo está se tornando cada vez mais o estilo de arquitetura a ser seguido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Today’s users embrace applications with milliseconds of response time, 100% uptime, lower latency, push data instead of pull, higher throughput, and elasticity. However, these features are nearly impossible to achieve using yesterday’s software architecture without a considerable investment in resources, infrastructure, and tooling. The world changed, and having dozens of servers, long response times (&amp;gt; 500 ms), downtime due to maintenance or waterfalls of failures does not meet the expected user experience.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Os usuários de hoje adotam aplicações com milissegundos de tempo de resposta, disponibilidade de 100%, menor latência, dados por push em vez de pull, maior taxa de transferência e elasticidade. No entanto, esses recursos são quase impossíveis de alcançar usando a arquitetura de software de ontem sem um investimento considerável em recursos, infraestrutura e ferramentas. O mundo mudou, e ter dezenas de servidores, longos tempos de resposta (&amp;gt; de 500 ms), tempo de inatividade devido a manutenção ou cascatas de falhas não atende à experiência esperada do usuário.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to the &lt;a href="https://quarkus.io/version/main/guides/mutiny-primer"&gt;Mutiny Reactive API&lt;/a&gt; , you can compose asynchronous operations and complete the result when everything is done without blocking the I/O threads.  This greatly improves resource consumption and elasticity.  Most Quarkus APIs are available in both imperative and reactive.  As example, you can use the reactive version of the REST Client:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Graças à &lt;a href="https://quarkus.io/version/main/guides/mutiny-primer"&gt;Mutiny Reactive API&lt;/a&gt; , você pode compor operações assíncronas e concluir o resultado quando tudo for feito sem bloquear os threads de E/S.  Isso melhora muito o consumo de recursos e a elasticidade.  A maioria das APIs do Quarkus está disponível em imperativa e reativa.  Como exemplo, você pode usar a versão reativa do cliente REST:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As for the reactive APIs exposed by Quarkus, stream manipulation uses the Mutiny API.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Quanto às APIs reativas expostas pelo Quarkus, a manipulação de fluxo usa a API Mutiny .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Kubernetes extension, developers can perform or automate a single-step deployment using Jib, Docker, and Source-to-Image (S2i) including the creation of DeploymentConfig to trigger automatic redeployments. &lt;a href="{{site.baseurl}}/guides/deploying-to-kubernetes"&gt;Read the guide for more details.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Usando a extensão Quarkus Kubernetes, os desenvolvedores podem executar ou automatizar uma implantação de etapa única usando Jib, Docker e Source-to-Image (S2i), incluindo a criação de DeploymentConfig para disparar reimplantações automáticas. &lt;a href="{{site.baseurl}}/guides/deploying-to-kubernetes"&gt;Leia o guia para obter mais detalhes.&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/developer-joy"&gt;Learn more&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="/developer-joy"&gt;Saiba Mais&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SUPERSONIC&lt;span class="light-blue"&gt;/&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>SUPERSÔNICO&lt;span class=“light-blue”&gt;/&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SUBATOMIC&lt;span class="light-blue"&gt;/&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;span class="light-blue"&gt;SUBATÔMICO&lt;/span&gt;/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an Open Source project licensed under the &lt;a href="https://www.apache.org/licenses/LICENSE-2.0"&gt;Apache License version 2.0&lt;/a&gt;. First and foremost, it is an open community where contributions, ideas and discussions are done in the open and contributors are welcome. Let’s join forces in building the future of Java applications.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Quarkus é um projeto Open Source licenciado sob a &lt;a href="https://www.apache.org/licenses/LICENSE-2.0"&gt;Licença Apache versão 2.0.&lt;/a&gt; Em primeiro lugar, é uma comunidade aberta, onde contribuições, ideias e discussões são feitas ao ar livre e os colaboradores são bem-vindos. Vamos unir forças na construção do futuro das aplicações Java.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is designed to seamlessly combine the familiar imperative style code and the non-blocking, reactive style when developing applications.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus foi projetado para combinar perfeitamente o código de estilo imperativo que você já conhece e o estilo reativo sem bloqueio ao desenvolver aplicações.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We have a lot of documentation. Be sure to check our &lt;a href="{{site.baseurl}}/get-started/"&gt;Getting started page&lt;/a&gt;, and all our &lt;a href="{{site.baseurl}}/guides/"&gt;guides&lt;/a&gt;. Also check out our &lt;a href="{{site.baseurl}}/faq/"&gt;FAQ section&lt;/a&gt; and &lt;a href="https://www.youtube.com/playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO"&gt;Quarkus Tips Playlist&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Temos muita documentação. Certifique-se de verificar nossa &lt;a href="{{site.baseurl}}/get-started/"&gt;página de Introdução&lt;/a&gt; e todos os nossos &lt;a href="{{site.baseurl}}/guides/"&gt;guias&lt;/a&gt;. Confira também nossa &lt;a href="{{site.baseurl}}/faq/"&gt;seção FAQ&lt;/a&gt; e &lt;a href="https://www.youtube.com/playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO"&gt;Quarkus Tips Playlist&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus offers unequaled performance</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus oferece um desempenho inigualável</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this session the Quarkus Team will give you a unique, hands-on experience: An introduction to Quarkus, a follow-along hands-on demo or two and then a Q&amp;A with some of the band, umm, developers involved.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Nesta sessão, a Equipe do Quarkus lhe dará uma experiência prática única: uma introdução ao Quarkus, uma demonstração prática subsequente ou duas e, em seguida, uma sessão de perguntas e respostas com alguns dos desenvolvedores envolvidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So join us as we explore how Quarkus helps Java developers everywhere to be more productive, create modern masterpieces and, well, have more fun: 90 odd minutes of technical discussion, some live coding and a Q&amp;A - it’s going to be a blast.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Então junte-se a nós enquanto exploramos como o Quarkus ajuda desenvolvedores Java em todos os lugares a serem mais produtivos, criar obras-primas modernas e, bem, se divertir mais: 90 minutos ímpares de discussão técnica, alguma codificação ao vivo e uma sessão de perguntas e respostas - vai ser uma explosão.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Time to rock the Java world 2023 style…</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Hora de arrasar no estilo Java World 2023...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ask on &lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Stack Overflow with the &lt;code&gt;quarkus&lt;/code&gt; tag&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Pergunte no &lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Stack Overflow com a tag &lt;code&gt;quarkus&lt;/code&gt;&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/about" class="{% if page.url contains '/about/' %}active{% endif %}"&gt;WHAT IS QUARKUS?&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/about" class="{% if page.url contains '/about/' %}active{% endif %}"&gt;O QUE É QUARKUS?&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/developer-joy" class="{% if page.url contains '/developer-joy/' %}active{% endif %}"&gt;DEVELOPER JOY&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/developer-joy" class="{% if page.url contains '/developer-joy/' %}active{% endif %}"&gt;ALEGRIA DO DESENVOLVEDOR&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/get-started" class="{% if page.url contains '/get-started/' %}active{% endif %}"&gt;GET STARTED&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/get-started" class="{% if page.url contains '/get-started/' %}active{% endif %}"&gt;COMEÇAR&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/qtips" class="{% if page.url contains '/qtips/' %}active{% endif %}"&gt;"Q" TIP VIDEOS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/qtips" class="{% if page.url contains '/qtips/' %}active{% endif %}"&gt;VÍDEOS "Q" TIP&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://quarkus.io/extensions/" class="{% if page.url contains '/extensions/' %}active{% endif %}"&gt;BROWSE EXTENSIONS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="https://quarkus.io/extensions/" class="{% if page.url contains '/extensions/' %}active{% endif %}"&gt;PROCURAR EXTENSÕES&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/faq/#what-is-a-quarkus-extension" class="{% if page.url contains 'what-is-a-quarkus-extension' %}active{% endif %}"&gt;USE EXTENSIONS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/faq/#what-is-a-quarkus-extension" class="{% if page.url contains 'what-is-a-quarkus-extension' %}active{% endif %}"&gt;USAR EXTENSÕES&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/writing-extensions" class="{% if page.url contains '/guides/writing-extensions' %}active{% endif %}"&gt;CREATE EXTENSIONS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/guides/writing-extensions" class="{% if page.url contains '/guides/writing-extensions' %}active{% endif %}"&gt;CRIAR EXTENSÕES&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://hub.quarkiverse.io" class="{% if page.url contains 'hub.quarkiverse.io' %}active{% endif %}"&gt;SHARE EXTENSIONS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="https://hub.quarkiverse.io" class="{% if page.url contains 'hub.quarkiverse.io' %}active{% endif %}"&gt;COMPARTILHE EXTENSÕES&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/blog" class="{% if page.url contains '/blog/' %}active{% endif %}"&gt;BLOG&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/blog" class="{% if page.url contains '/blog/' %}active{% endif %}"&gt;BLOG&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/insights" class="{% if page.url contains '/insights/' %}active{% endif %}"&gt;PODCAST&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/insights" class="{% if page.url contains '/insights/' %}active{% endif %}"&gt;PODCAST&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/newsletter" class="{% if page.url contains '/newsletter/' %}active{% endif %}"&gt;NEWSLETTER&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/newsletter" class="{% if page.url contains '/newsletter/' %}active{% endif %}"&gt;BOLETIM INFORMATIVO&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://github.com/orgs/quarkusio/projects/13/views/1" class="{% if page.url contains '/roadmap/' %}active{% endif %}"&gt;ROADMAP&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="https://github.com/orgs/quarkusio/projects/13/views/1" class="{% if page.url contains '/roadmap/' %}active{% endif %}"&gt;ROADMAP&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/dev-ui"&gt;Read the Dev UI guide&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/guides/dev-ui"&gt;Leia o guia da interface do usuário do desenvolvedor&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>/guias/começar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus DI solution is based on the [Contexts and Dependency Injection for Java 2.0](https://docs.jboss.org/cdi/spec/2.0/cdi-spec) specification. This guide explains the basics of CDI.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A solução Quarkus DI é baseada na especificação [Contexts and Dependency Injection for Java 2.0] https://docs.jboss.org/cdi/spec/2.0/cdi-spec . Este guia explica os princípios básicos do CDI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Testing in JVM mode
* Testing in native mode
* Injection of resources into tests
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia aborda: 
* Testes no modo JVM 
* Testes no modo nativo 
* Injeção de recursos nos testes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the OpenAPI extension to generate an OpenAPI descriptor and get a Swagger UI frontend to test your REST endpoints.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia explica como usar a extensão OpenAPI para gerar um descritor OpenAPI e obter um front-end da interface do usuário do Swagger para testar seus endpoints REST.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about configuring Quarkus' Vert.x based HTTP layer - and Undertow if you are using servlets.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Saiba mais sobre como configurar a camada HTTP baseada em Vert.x do Quarkus - e Undertow se você estiver usando servlets.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Liquibase MongoDB</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Liquibase MongoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the usage of MongoDB using active records and repositories.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia aborda o uso do MongoDB usando &lt;i&gt;active records&lt;/i&gt; e repositórios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the usage of MongoDB using active records and repositories in a Kotlin project.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia aborda o uso do MongoDB usando &lt;i&gt;active records&lt;/i&gt; e repositórios em um projeto Kotlin.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Secure your web endpoints with authorizations.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Proteja os seus Web Endpoints com autorizações.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Customize Quarkus' security layer behavior.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Personalize o comportamento da camada de segurança do Quarkus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through the process of creating a Quarkus application with OptaPlanner's constraint solving Artificial Intelligence (AI).</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia orienta você pelo processo de criação de um aplicativo Quarkus com a Inteligência Artificial (IA) de resolução de restrições do OptaPlanner.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using AI to optimize a schedule with OptaPlanner</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Usando IA para otimizar um cronograma com o OptaPlanner</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>jbang Integration</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>integração jbang</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Maven configuration
* Creating a new project
* Dealing with extensions
* Development mode
* Debugging
* Import in your IDE
* Building a native executable
* Build a container friendly executable
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia abrange:
* Configuração do Maven
* Criação de um novo projeto
* Lidar com extensões
* Modo de desenvolvimento
*Depuração
* Importar em seu IDE
* Construção de um executável nativo
* Construa um executável amigável para contêineres
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Gradle configuration
* Creating a new project
* Dealing with extensions
* Development mode
* Debugging
* Import in your IDE
* Building a native executable
* Build a container friendly executable
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia abrange:
* Configuração Gradle
* Criação de um novo projeto
* Lidar com extensões
* Modo de desenvolvimento
*Depuração
* Importar em seu IDE
* Construção de um executável nativo
* Construa um executável amigável para contêineres
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use mutable jars to rebuild your application with different build time configurations.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Use JARs mutáveis para reconstruir sua aplicação com diferentes configurações de tempo de compilação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Spring Boot's `@ConfigurationProperties` in place of MicroProfile Config annotations</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Use o '@ConfigurationProperties' do Spring Boot no lugar das anotações do MicroProfile Config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP Secret Manager in Quarkus to consume configuration properties directly or via your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia aborda como usar o GCP Secret Manager no Quarkus para consumir propriedades de configuração diretamente ou por meio de seu 'application.properties'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to integrate your extension with Quarkus' CDI container.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Saiba como integrar sua extensão com o contêiner CDI do Quarkus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to get your extension contribute features to the Dev UI.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Saiba como fazer com que a sua extensão contribua com funcionalidades para a interface do usuário do desenvolvedor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributing to Dev UI</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Contribuindo para a interface do usuário do desenvolvedor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>November 19, 2019</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>19 de novembro de 2019</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>December 6, 2019</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>6 de dezembro de 2019</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>May 2, 2019</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>maio 2, 2019</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>September 24, 2019</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>24 de setembro de 2019</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://grpc.io/[gRPC] is a high-performance RPC framework.  It can efficiently connect services implemented using various languages and frameworks.  It is also applicable in the last mile of distributed computing to connect devices, mobile applications, and browsers to backend services.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>link:https://grpc.io/[O gRPC] é um framework RPC de alto desempenho. É capaz de fazer a comunicação de forma eficiente entre serviços utilizando várias linguagens e frameworks É também aplicável em alguns casos da computação distribuída para interligar dispositivos, aplicações móveis e navegadores a serviços de backend.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus gRPC extension integrate gRPC in Quarkus application.  It:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A extensão gRPC do Quarkus integra o gRPC na aplicação Quarkus. Este plugin:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>supports https://grpc.github.io/grpc/core/md_doc_grpc_xds_features.html[xDS gRPC] integration</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>suporta a integração  link:https://grpc.github.io/grpc/core/md_doc_grpc_xds_features.html[xDS gRPC]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>supports https://grpc.github.io/grpc-java/javadoc/io/grpc/inprocess/InProcessServerBuilder.html[InProcess] gRPC development</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>suporta o desenvolvimento de gRPC  link:https://grpc.github.io/grpc-java/javadoc/io/grpc/inprocess/InProcessServerBuilder.html[InProcess]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus gRPC is based on https://vertx.io/docs/vertx-grpc/java/[Vert.x gRPC].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus gRPC é baseado no  link:https://vertx.io/docs/vertx-grpc/java/[Vert.x gRPC].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can define your transaction boundaries either declaratively with `@Transactional` or programmatically with `QuarkusTransaction`. You can also use the JTA `UserTransaction` API directly, however this is less user-friendly than `QuarkusTransaction`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Você pode definir seus limites de transação declarativamente com '@Transactional' ou programaticamente com 'QuarkusTransaction'. Você também pode usar a API JTA 'UserTransaction' diretamente, no entanto, isso é menos amigável do que 'QuarkusTransaction'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The easiest way to define your transaction boundaries is to use the `@Transactional` annotation on your entry method (`jakarta.transaction.Transactional`).</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A forma mais fácil de definir os limites da sua transação é utilizar a anotação `@Transactional` no seu método de entrada ( `jakarta.transaction.Transactional`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A `RuntimeException` crossing the transaction boundaries will roll back the transaction.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Um 'RuntimeException' cruzando os limites da transação reverterá a transação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional` can be used to control transaction boundaries on any CDI bean at the method level or at the class level to ensure every method is transactional.  That includes REST endpoints.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>'@Transactional' pode ser usado para controlar limites de transação em qualquer bean CDI no nível do método ou no nível da classe para garantir que cada método seja transacional.  Isso inclui pontos de extremidade REST.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can control whether and how the transaction is started with parameters on `@Transactional`:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Você pode controlar se e como a transação é iniciada com parâmetros em '@Transactional':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(REQUIRED)` (default): starts a transaction if none was started, stays with the existing one otherwise.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>'@Transactional(REQUIRED)' (padrão): inicia uma transação se nenhuma foi iniciada, permanece com a existente caso contrário.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`@Transactional(REQUIRES_NEW)`: starts a transaction if none was started ; if an existing one was started, suspends it and starts a new one for the boundary of that method.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>«@Transactional(REQUIRES_NEW)»: inicia uma transação se não tiver sido iniciada nenhuma; se um existente foi iniciado, suspende-o e inicia um novo para o limite desse método.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`REQUIRED` or `NOT_SUPPORTED` are probably the most useful ones.  This is how you decide whether a method is to be running within or outside a transaction.  Make sure to check the JavaDoc for the precise semantic.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>‘REQUIRED’ ou 'NOT_SUPPORTED' são provavelmente os mais úteis.  É assim que você decide se um método deve ser executado dentro ou fora de uma transação.  Certifique-se de verificar o JavaDoc para a semântica precisa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The transaction context is propagated to all calls nested in the `@Transactional` method as you would expect (in this example `childDAO.addToGiftList()` and `santaDAO.addToSantaTodoList()`).  The transaction will commit unless a runtime exception crosses the method boundary.  You can override whether an exception forces the rollback or not by using `@Transactional(dontRollbackOn=SomeException.class)` (or `rollbackOn`).</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O contexto da transação é propagado a todas as chamadas aninhadas no método `@Transactional` como seria de esperar (neste exemplo `childDAO.addToGiftList()` e `santaDAO.addToSantaTodoList()`). A transação será confirmada a menos que uma exceção de tempo de execução atravesse o limite do método. É possível substituir se uma exceção força ou não a reversão utilizando `@Transactional(dontRollbackOn=SomeException.class)` (ou `rollbackOn`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can also programmatically ask for a transaction to be marked for rollback.  Inject a `TransactionManager` for this.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Você também pode solicitar programaticamente que uma transação seja marcada para reversão.  Injete um 'TransactionManager' para isso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Inject the `TransactionManager` to be able to activate `setRollbackOnly` semantic.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Injete o `TransactionManager` para poder ativar a semântica `setRollbackOnly`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `@TransactionConfiguration` annotation allows to set a timeout property, in seconds, that applies to transactions created within the annotated method.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A anotação '@TransactionConfiguration' permite definir uma propriedade de tempo limite, em segundos, que se aplica a transações criadas dentro do método anotado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If defined on a class, it is equivalent to defining it on all the methods of the class marked with `@Transactional`.  The configuration defined on a method takes precedence over the configuration defined on a class.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se for definida numa classe, é equivalente a defini-la em todos os métodos da classe marcados com `@Transactional`. A configuração definida num método tem precedência sobre a configuração definida numa classe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your `@Transactional`-annotated method returns a reactive value, such as:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se o método anotado '@Transactional' retornar um valor reativo, como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can use static methods on `QuarkusTransaction` to define transaction boundaries. This provides two different options, a functional approach that allows you to run a lambda within the scope of a transaction, or by using explicit `begin`, `commit` and `rollback` methods.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Você pode usar métodos estáticos em 'QuarkusTransaction' para definir limites de transação. Isso fornece duas opções diferentes, uma abordagem funcional que permite executar um lambda dentro do escopo de uma transação ou usando métodos explícitos 'begin', 'commit' e 'rollback'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first method simply calls begin, does some work and commits it.  This created transaction is tied to the CDI request scope, so if it is still active when the request scope is destroyed then it will be automatically rolled back. This removes the need to explicitly catch exceptions and call `rollback`, and acts as a safety net against inadvertent transaction leaks, however it does mean that this can only be used when the request scope is active. The second example in the method calls begin with a timeout option, and then rolls back the transaction.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O primeiro método simplesmente chama começar, faz algum trabalho e o compromete.  Essa transação criada está vinculada ao escopo de requisição do CDI, portanto, se ainda estiver ativa quando o escopo for destruído, ela será revertida automaticamente. Isso elimina a necessidade de capturar explicitamente exceções e chamar `rollback` e atua como uma rede de segurança contra vazamentos inadvertidos de transações, no entanto, significa que isso só pode ser usado quando o escopo da solicitação estiver ativo. O segundo exemplo nas chamadas de método começa com uma opção de tempo limite e, em seguida, reverte a transação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The second method shows the use of lambda scoped transactions with `QuarkusTransaction.runner(...)`; the first example just runs a `Runnable` within a new transaction, the second does the same but joining the existing transaction (if any), and the third calls a `Callable` with some specific options.  In particular the `exceptionHandler` method can be used to control if the transaction is rolled back or not on exception.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O segundo método mostra o uso de transações com escopo lambda com 'QuarkusTransaction.runner(...) `; o primeiro exemplo apenas executa um 'Runnable' dentro de uma nova transação, o segundo faz o mesmo, mas juntando-se à transação existente (se houver), e o terceiro chama um 'Callable' com algumas opções específicas.  Em particular, o método 'exceptionHandler' pode ser usado para controlar se a transação é revertida ou não na exceção.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If a transaction is already associated with the current thread a `QuarkusTransactionException` will be thrown, otherwise a new transaction is started, and follows all the normal lifecycle rules.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se uma transação já estiver associada à thread atual, será lançado um `QuarkusTransactionException`. Caso contrário, é iniciada uma nova transação, que segue todas as regras normais do ciclo de vida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no transaction is active then a new transaction will be started, and committed when the method ends.  If an exception is thrown the exception handler registered by `#exceptionHandler(Function)` will be called to decide if the TX should be committed or rolled back.  If an existing transaction is active then the method is run in the context of the existing transaction. If an exception is thrown the exception handler will be called, however a result of `ExceptionResult#ROLLBACK` will result in the TX marked as rollback only, while a result of `ExceptionResult#COMMIT` will result in no action being taken.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se nenhuma transação estiver ativa, será iniciada uma nova transação, que será confirmada quando o método terminar. Se for lançada uma exceção, o gestor de excepções registado em `#exceptionHandler(Function)` será chamado para decidir se a TX deve ser confirmada ou revertida. Se uma transação existente estiver ativa, o método é executado no contexto da transação existente. Se for lançada uma exceção, o gestor de excepções será chamado, mas um resultado de `ExceptionResult#ROLLBACK` fará com que o TX seja marcado apenas como reversão, enquanto um resultado de `ExceptionResult#COMMIT` fará com que não seja tomada qualquer ação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If an existing transaction is already associated with the current thread then the transaction is suspended, then a new transaction is started which follows all the normal lifecycle rules, and when it's complete the original transaction is resumed.  Otherwise, a new transaction is started, and follows all the normal lifecycle rules.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se uma transação existente já estiver associada ao thread atual, a transação é suspensa, é iniciada uma nova transação que segue todas as regras normais do ciclo de vida e, quando estiver concluída, a transação original é retomada. Caso contrário, é iniciada uma nova transação, que segue todas as regras normais do ciclo de vida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If no transaction is active then these semantics are basically a no-op.  If a transaction is active then it is suspended, and resumed after the task is run.  The exception handler will never be consulted when these semantics are in use, specifying both an exception handler and these semantics are considered an error.  These semantics allows for code to easily be run outside the scope of a transaction.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se nenhuma transação estiver ativa, estas semânticas são basicamente um no-op. Se estiver ativa uma transação, esta é suspensa e retomada após a execução da tarefa. O manipulador de exceção nunca será consultado quando estas semânticas estiverem a ser utilizadas, especificando um manipulador de exceção e estas semânticas são consideradas um erro. Esta semântica permite que o código seja facilmente executado fora do âmbito de uma transação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You cannot use `UserTransaction` in a method having a transaction started by a `@Transactional` call.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Não é possível utilizar `UserTransaction` num método com uma transação iniciada por uma chamada `@Transactional`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The node name identifier plays a crucial part in the identification of a transaction.  The node name identifier is forged into the transaction id when the transaction is created.  Based on the node name identifier, the transaction manager is capable of recognizing the XA transaction counterparts created in database or JMS broker. The identifier makes possible for the transaction manager to roll back the transaction counterparts during recovery.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O identificador do nome do nó desempenha um papel crucial na identificação de uma transação. O identificador do nome do nó é forjado na identificação da transação quando esta é criada. Com base no identificador do nome do nó, o gestor de transacções é capaz de reconhecer as contrapartidas da transação XA criadas na base de dados ou no corretor JMS. O identificador permite que o gestor de transacções reverta as contrapartes da transação durante a recuperação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The node name identifier needs to be unique per transaction manager deployment.  And the node identifier needs to be stable over the transaction manager restarts.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O identificador do nome do nó tem de ser único por cada implementação do gestor de transacções. E o identificador do nó tem de ser estável durante os reinícios do gestor de transacções.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Just assign the transaction xref:cdi.adoc#bean-scope[scope] to such beans using the `@TransactionScoped` annotation:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Basta atribuir o  link:cdi.html#bean-scope[âmbito] da transação a esses beans utilizando a anotação `@TransactionScoped`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `event` object represents the transaction ID, and defines `toString()`/`equals()`/`hashCode()` accordingly.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O objeto `event` representa o ID da transação e define `toString()`/ `equals()`/ `hashCode()` em conformidade.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus allows the following JDBC-specific configuration of the object store included in `quarkus.transaction-manager.object-store.&lt;property&gt;` properties, where &lt;property&gt; can be:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus permite a seguinte configuração específica de JDBC do armazenamento de objectos incluída em `quarkus.transacion-manager.object-store.&amp;amp;lt;property&amp;amp;gt;` propriedades, onde &amp;lt;property&amp;gt; pode ser:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`type` (_string_): Configure this property to `jdbc` to enable usage of a Quarkus JDBC datasource for transaction logging.  The default value is `file-system`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`type` _(string_): Configure esta propriedade para `jdbc` para permitir a utilização de uma fonte de dados JDBC do Quarkus para registo de transacções. O valor predefinido é `file-system`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`datasource` (_string_): Specify the name of the datasource for the transaction log storage.  If no value is provided for the `datasource` property, Quarkus uses the xref:datasource.adoc#configure-datasources[default datasource].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`datasource` _(string_): Especifique o nome da fonte de dados para o armazenamento do registo de transacções. Se não for fornecido nenhum valor para a propriedade `datasource`, o Quarkus utiliza a  link:datasource.html#configure-datasources[fonte de dados predefinida].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`create-table` (_boolean_): When set to `true`, the transaction log table gets automatically created if it does not already exist.  The default value is `false`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`create-table` _(booleano_): Quando definido para `true`, a tabela do registo de transacções é criada automaticamente se ainda não existir. O valor predefinido é `false`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`drop-table` (_boolean_): When set to `true`, the tables are dropped on startup if they already exist.  The default value is `false`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`drop-table` _(booleano_): Quando definido para `true`, as tabelas são eliminadas no arranque se já existirem. O valor predefinido é `false`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`table-prefix` (string): Specify the prefix for a related table name.  The default value is `quarkus_`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`table-prefix` (string): Especifique o prefixo para um nome de tabela relacionado. O valor padrão é `quarkus_`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDBC datasources is part of `quarkus-agroal`, and it needs to use `quarkus.datasource.jdbc.transactions=XA`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Os recursos de dados JDBC fazem parte de `quarkus-agroal` e precisam ser usados em `quarkus.datasource.jdbc.transactions=XA`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>ActiveMQ Artemis is part of `quarkus-pooled-jms`, and it needs to use `quarkus.pooled-jms.transaction=XA`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O ActiveMQ Artemis faz parte do `quarkus-pooled-jms` e precisa usar o `quarkus.pooled-jms.transaction=XA`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If your application employs eXtended Architecture (XA) transactions, enable the transaction crash recovery feature by using `quarkus.transaction-manager.enable-recovery=true`, to safeguard your data in the event of application crashes or failures. The default value for XA Recovery is `false`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se seu aplicativo empregar transações XA (eXtended Architecture), habilite o recurso de recuperação de falhas de transação usando `quarkus.transaction-manager.enable-recovery=true`, para proteger seus dados em caso de falhas ou falhas do aplicativo. O valor padrão para XA Recovery é `false`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To work around the current known issue of link:https://issues.redhat.com/browse/AG-209[Agroal having a different view on running transaction checks], set the datasource transaction type for the datasource responsible for writing the transaction logs to `disabled`:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para contornar o problema conhecido atual de link:https://issues.redhat.com/browse/AG-209[Agroal tendo uma exibição diferente sobre a execução de verificações de transação], defina o tipo de transação de fonte de dados para a fonte de dados responsável por gravar os logs de transação como 'disabled':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Yep, it works in your Quarkus application, in your IDE, in your tests, because all of these are Quarkus applications.  JTA has some bad press for some people.  I don't know why.  Let's just say that this is not your grandpa's JTA implementation.  What we have is perfectly embeddable and lean.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Sim, funciona na sua aplicação Quarkus, no seu IDE, nos seus testes, porque todas estas são aplicações Quarkus. O JTA tem má fama para algumas pessoas. Não sei porquê. Digamos apenas que esta não é a implementação JTA do seu avô. O que temos é perfeitamente incorporável e simples.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Wrong. + First off, just disable the transaction by marking your transaction boundary with `@Transactional(NOT_SUPPORTED)` (or `NEVER` or `SUPPORTS` depending on the semantic you want). + Second, it's again fairy tale that not using transaction is faster.  The answer is, it depends on your DB and how many SQL SELECTs you are making.  No transaction means the DB does have a single operation transaction context anyway. + Third, when you do several SELECTs, it's better to wrap them in a single transaction because they will all be consistent with one another.  Say your DB represents your car dashboard, you can see the number of kilometers remaining and the fuel gauge level.  By reading it in one transaction, they will be consistent.  If you read one and the other from two different transactions, then they can be inconsistent.  It can be more dramatic if you read data related to rights and access management for example.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Errado. + Primeiro, basta desativar a transação marcando seu limite de transação com '@Transactional(NOT_SUPPORTED)' (ou ‘NEVER’ ou 'SUPPORTS', dependendo da semântica desejada). + Segundo, é novamente um conto de fadas que não usar transação é mais rápido.  A resposta é, depende do seu banco de dados e quantos SQL SELECTs você está fazendo.  Nenhuma transação significa que o banco de dados tem um único contexto de transação de operação de qualquer maneira. + Terceiro, quando você faz vários SELECTs, é melhor envolvê-los em uma única transação, porque todos eles serão consistentes uns com os outros.  Digamos que seu DB representa o painel do seu carro, você pode ver o número de quilômetros restantes e o nível do medidor de combustível.  Ao lê-lo em uma transação, eles serão consistentes.  Se você ler uma e outra de duas transações diferentes, elas podem ser inconsistentes.  Pode ser mais dramático se você ler dados relacionados a direitos e gerenciamento de acesso, por exemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Managing the transactions manually via `entityManager.getTransaction().begin()` and friends lead to a butt ugly code with tons of try catch finally that people get wrong.  Transactions are also about JMS and other database access, so one API makes more sense.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Gerenciar as transações manualmente via 'entityManager.getTransaction().begin()' e os amigos levam a um código feio com toneladas de tentativa de pegar finalmente que as pessoas erram.  As transações também são sobre JMS e outros acessos ao banco de dados, portanto, uma API faz mais sentido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's a mess because I don't know if my Jakarta Persistence persistence unit is using `JTA` or `Resource-level` Transaction</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>É uma bagunça porque não sei se minha unidade de persistência Jakarta Persistence está usando a transação 'JTA' ou 'Resource-level'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It's not a mess in Quarkus :)  Resource-level was introduced to support Jakarta Persistence in a non managed environment.  But Quarkus is both lean and a managed environment, so we can safely always assume we are in JTA mode.  The end result is that the difficulties of running Hibernate ORM + CDI + a transaction manager in Java SE mode are solved by Quarkus.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Não é uma confusão no Quarkus :) O Resource-level foi introduzido para suportar a Jakarta Persistence num ambiente não gerido. Mas o Quarkus é um ambiente gerido e não gerido, pelo que podemos sempre assumir que estamos em modo JTA. O resultado final é que as dificuldades de executar o Hibernate ORM + CDI + um gestor de transacções no modo Java SE são resolvidas pelo Quarkus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It can be reasonably easy to avoid these situations in your code, but verifying every dependency you use is hard.  Typically, while experimenting with virtual threads, we realized that old versions of the link:{pgsql-driver}[postgresql-JDBC driver] results in frequent pinning.  Most JDBC drivers still pin the carrier thread.  Even worse, lots of widespread libraries are pinning and would require code changes.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Pode ser razoavelmente fácil evitar essas situações no seu código, mas verificar cada dependência que você usa é difícil. Tipicamente, enquanto experimentávamos com threads virtuais, percebemos que as versões antigas do  link:{pgsql-driver}[driver postgresql-JDBC] resultavam em pinagem frequente. A maioria dos drivers JDBC ainda fixam a carrier thread. Pior ainda, muitas bibliotecas comuns estão fixando e exigiriam alterações no código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide takes as input the application developed in the xref:getting-started.adoc[Getting Started Guide].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia utiliza como base a aplicação desenvolvida no  link:getting-started.html[Guia de Iniciação].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A xref:configuring-c-development[working C development environment]</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Um  link:#configuring-c-development[ambiente de desenvolvimento em C]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The code of the application developed in the xref:getting-started.adoc[Getting Started Guide].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O código da aplicação desenvolvida no  link:getting-started.html[Guia de Iniciação].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Windows, you will need to install the https://aka.ms/vs/15/release/vs_buildtools.exe[Visual Studio 2017 Visual C++ Build Tools]</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>No Windows, terá de instalar  link:https://aka.ms/vs/15/release/vs_buildtools.exe[Visual Studio 2017 Visual C++ Build Tools]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Background</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Background</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Building a native executable requires using a distribution of GraalVM.  There are three distributions: Oracle GraalVM Community Edition (CE), Oracle GraalVM Enterprise Edition (EE) and Mandrel.  The differences between the Oracle and Mandrel distributions are as follows:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Desenvolver um executável nativo requer o uso de uma distribuição do GraalVM. Existem três distribuições: Oracle GraalVM Community Edition (CE), Oracle GraalVM Enterprise Edition (EE) e Mandrel. As diferenças entre as distribuições Oracle e Mandrel são:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is a downstream distribution of the Oracle GraalVM CE.  Mandrel's main goal is to provide a way to build native executables specifically designed to support Quarkus.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Mandrel é uma distribuição posterior ao Oracle GraalVM CE. O principal objetivo do Mandrel é fornecer uma maneira de construir executáveis nativos especificamente projetados para suportar o Quarkus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel releases are built from a code base derived from the upstream Oracle GraalVM CE code base, with only minor changes but some significant exclusions that are not necessary for Quarkus native apps.  They support the same capabilities to build native executables as Oracle GraalVM CE, with no significant changes to functionality.  Notably, they do not include support for polyglot programming.  The reason for these exclusions is to provide a better level of support for the majority of Quarkus users.  These exclusions also mean Mandrel offers a considerable reduction in its distribution size when compared with Oracle GraalVM CE/EE.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>As versões Mandrel são construídas a partir de uma base de código derivada da Oracle GraalVM CE, com apenas pequenas alterações, mas algumas exclusões significativas que não são necessárias para aplicativos nativos Quarkus. Eles suportam os mesmos recursos para construir executáveis nativos como o Oracle GraalVM CE, sem mudanças significativas na funcionalidade. Notavelmente, eles não incluem suporte para múltiplas linguagens de programação. A razão para essas exclusões é fornecer um melhor nível de suporte para a maioria dos usuários do Quarkus. Essas exclusões também significam que o Mandrel oferece uma redução considerável no tamanho de sua distribuição quando comparado com o Oracle GraalVM CE/EE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is built slightly differently to Oracle GraalVM CE, using the standard OpenJDK project.  This means that it does not profit from a few small enhancements that Oracle have added to the version of OpenJDK used to build their own GraalVM downloads.  These enhancements are omitted because upstream OpenJDK does not manage them, and cannot vouch for.  This is particularly important when it comes to conformance and security.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Mandrel é construído de forma ligeiramente diferente do Oracle GraalVM CE, usando o projeto padrão OpenJDK. Isso significa que ele não se beneficia de algumas pequenas melhorias que a Oracle adicionou à versão do OpenJDK usada para construir seus próprios downloads do GraalVM. Essas melhorias são omitidas porque o OpenJDK não as gerencia e não pode garantir. Isto é particularmente importante quando se trata de conformidade e segurança.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Mandrel is recommended for building native executables that target Linux containerized environments.  This means that Mandrel users are encouraged to use containers to build their native executables.  If you are building native executables for macOS, you should consider using Oracle GraalVM instead, because Mandrel does not currently target this platform.  Building native executables directly on bare metal Linux or Windows is possible, with details available in the https://github.com/graalvm/mandrel/blob/default/README.md[Mandrel README] and https://github.com/graalvm/mandrel/releases[Mandrel releases].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Mandrel é recomendado para a criação de executáveis nativos voltados para ambientes em contêineres Linux. Isso significa que os usuários do Mandrel são incentivados a usar contêineres para criar seus executáveis nativos. Se você estiver criando executáveis nativos para o macOS, considere usar o Oracle GraalVM, pois o Mandrel não tem como alvo essa plataforma. É possível criar executáveis nativos diretamente no Linux ou Windows bare metal, com detalhes disponíveis no  link:https://github.com/graalvm/mandrel/blob/default/README.md[README do Mandrel] e nas  link:https://github.com/graalvm/mandrel/releases[versões do Mandrel].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This step is only required for generating native executables targeting non-Linux operating systems.  For generating native executables targeting Linux, you can optionally skip this section and xref:container-runtime[use a builder image] instead.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este passo só é necessário para a geração de executáveis nativos visando sistemas operacionais que não sejam Linux. Para gerar executáveis nativos visando o Linux, pode pular esta etapa e link:#container-runtime[construir uma imagem].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Version {graalvm-version} is required.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>É necessária a versão {graalvm-version}.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Download the appropriate archive from &lt;https://github.com/graalvm/mandrel/releases&gt; or &lt;https://github.com/graalvm/graalvm-ce-builds/releases&gt;, and unpack it like you would any other JDK.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Download do arquivo apropriado de  https://github.com/graalvm/mandrel/releases  ou  https://github.com/graalvm/graalvm-ce-builds/releases  e descompacte-o como faria com qualquer outro JDK.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use platform-specific install tools like https://sdkman.io/jdks#Oracle[sdkman], https://github.com/graalvm/homebrew-tap[homebrew], or https://github.com/ScoopInstaller/Java[scoop].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Use ferramentas de instalação específicas, como  link:https://sdkman.io/jdks#Oracle[sdkman],  link:https://github.com/graalvm/homebrew-tap[homebrew] ou  link:https://github.com/ScoopInstaller/Java[scoop].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On macOS (not supported by Mandrel), point the variable to the `Home` sub-directory:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>No macOS (não suportado pelo Mandrel), aponte a variável para o subdiretório `Home`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>(Optional) Add the GraalVM `bin` directory to the path</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>(Opcional) Adicione o diretório `bin` GraalVM `bin` no PATH</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM binaries are not (yet) notarized for macOS as reported in this https://github.com/oracle/graal/issues/1724[GraalVM issue]. This means that you may see the following error when using `native-image`:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Os binários do GraalVM não estão (ainda) certificados para macOS, conforme relatado nesta  link:https://github.com/oracle/graal/issues/1724[issue do GraalVM]. Isso significa que pode ocorrer o seguinte erro ao usar `native-image`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `getting-started` directory.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A solução está localizada no diretório `getting-started`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can provide custom options for the `native-image` command using the `&lt;quarkus.native.additional-build-args&gt;` property.  Multiple options may be separated by a comma.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Você pode fornecer opções personalizadas para o native-image utilizando a seguinte propriedade `&amp;amp;lt;quarkus.native.additional-build-args&amp;amp;gt;`. Várias opções devem ser separadas por  vírgula.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can find more information about how to configure the native image building process in the xref:configuration-reference[Configuring the Native Executable] section below.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Você pode encontrar mais informações sobre como configurar o processo de construção de uma imagem nativa na secção  link:#configuration-reference[Configurando o executável nativo] abaixo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Microsoft Native Tools for Visual Studio must first be initialized before packaging.  You can do this by starting the `x64 Native Tools Command Prompt` that was installed with the Visual Studio Build Tools.  At the `x64 Native Tools Command Prompt`, you can navigate to your project folder and run `./mvnw package -Dnative`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>As Ferramentas Nativas da Microsoft para o Visual Studio devem ser inicializadas antes do empacotamento. Isso pode ser feito iniciando o `x64 Native Tools Command Prompt` que foi instalado com o Visual Studio Build Tools. Em `x64 Native Tools Command Prompt`, você pode navegar até a pasta do projeto e executar `./mvnw package -Dnative`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In addition to the regular files, the build also produces `target/getting-started-1.0.0-SNAPSHOT-runner`.  You can run it using: `./target/getting-started-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para além dos arquivos normais, a compilação também cria `target/getting-started-1.0.0-SNAPSHOT-runner`. Pode executá-lo utilizando: `./target/getting-started-1.0.0-SNAPSHOT-runner`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java preview features</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Java preview features</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java code that relies on preview features requires special attention.  To produce a native executable, this means that the `--enable-preview` flag needs to be passed to the underlying native image invocation.  You can do so by prepending the flag with `-J` and passing it as additional native build argument: `-Dquarkus.native.additional-build-args=-J--enable-preview`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O código Java que se baseia em funcionalidades de preview requerem uma atenção especial. Para produzir um executável nativo, isto significa que a flag `--enable-preview` tem de ser passado para a criação da imagem nativa. Você pode fazer isso acrescentando a flag com `-J` e passando-o como argumento adicional de compilação nativa: `-Dquarkus.native.additional-build-args=-J—​enable-preview`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>On Linux it's possible to package a native executable that doesn't depend on any system shared library.  There are link:https://www.graalvm.org/latest/reference-manual/native-image/guides/build-static-executables/#prerequisites-and-preparation[some system requirements] to be fulfilled and additional build arguments to be used along with the `native-image` invocation, a minimum is `-Dquarkus.native.additional-build-args="--static","--libc=musl"`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>No Linux é possível empacotar um executável nativo que não depende de nenhuma biblioteca compartilhada com o sistema. Existem  link:https://www.graalvm.org/latest/reference-manual/native-image/guides/build-static-executables/#prerequisites-and-preparation[alguns requisitos] a serem cumpridos e argumentos de compilação adicionais a serem usados junto com a invocação `native-image`, o mínimo é `-Dquarkus.native.additional-build-args="--static","--libc=musl"`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus waits for 60 seconds for the native image to start before automatically failing the native tests. This duration can be changed using the `quarkus.test.wait-time` system property. For example, to increase the duration to 300 seconds, use: `./mvnw verify -Dnative -Dquarkus.test.wait-time=300`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, o Quarkus espera 60 segundos para que a imagem nativa seja iniciada antes de falhar automaticamente nos testes nativos. Esta duração pode ser alterada utilizando a propriedade `quarkus.test.wait-time`. Por exemplo, para aumentar a duração para 300 segundos, use: `./mvnw verify -Dnative -Dquarkus.test.wait-time=300`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This procedure was formerly accomplished using the `@NativeImageTest` annotation. `@NativeImageTest` was replaced by `@QuarkusIntegrationTest` which provides a superset of the testing capabilities of `@NativeImageTest`. More information about `@QuarkusIntegrationTest` can be found in the xref:getting-started-testing.adoc#quarkus-integration-test[Testing Guide].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Esse processo era anteriormente utilizado com a anotação `@NativeImageTest`. `@NativeImageTest` foi substituído pela `@QuarkusIntegrationTest` que fornece um superconjunto das capacidades de teste da `@NativeImageTest`. Mais informações sobre `@QuarkusIntegrationTest` podem ser encontradas no  link:getting-started-testing.html#quarkus-integration-test[Guia de Testes].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Profiles</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Profiles</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, integration tests both *build* and *run* the native executable using the `prod` profile.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, os testes de integração *build* e *run* são feitos usando o profile `prod`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can override the profile the executable *runs* with during the test using the `quarkus.test.native-image-profile` property.  Either by adding it to `application.properties` or by appending it to the command line: `./mvnw verify -Dnative -Dquarkus.test.native-image-profile=test`.  Your `%test.` prefixed properties will be used at the test runtime.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Pode substituir o profile que o executável *é feito o build* durante o teste utilizando a propriedade `quarkus.test.native-image-profile`. Adicionando no `application.properties` ou anexando-a à linha de comando: `./mvnw verify -Dnative -Dquarkus.test.native-image-profile=test`. As suas propriedades colocadas no `%test.` serão utilizadas no tempo de execução do teste.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can override the profile the executable is *built* with and *runs* with using the `quarkus.profile=test` property, e.g.  `./mvnw clean verify -Dnative -Dquarkus.profile=test`. This might come handy if there are test specific resources to be processed, such as importing test data into the database.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>É possível substituir o profile que o executável faz *o build* e *run* utilizando a propriedade `quarkus.profile=test`, por exemplo, `./mvnw clean verify -Dnative -Dquarkus.profile=test`. Isto pode ser útil se houver recursos específicos de teste a serem processados, como a importação de dados de teste para o banco de dados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With the aforementioned example in your `application.properties`, your Hibernate ORM managed database will be populated with test data both during the JVM mode test run and during the native mode test run. The production executable will contain only the `version.txt` resource, no superfluous test data.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Com o exemplo acima no seu `application.properties`, o Hibernate ORM que está controlando o banco de dados irá popular com dados de teste durante o modo de teste JVM e durante a execução de teste do modo nativo. O executável de produção conterá apenas o recurso `version.txt`, sem dados de teste.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The executable built with `-Dquarkus.profile=test` is not suitable for production deployment.  It contains your test resources files and settings. Once the testing is done, the executable would have to be built again, using the default, `prod` profile.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O executável criado com `-Dquarkus.profile=test` não é adequado para o deploy em produção. Contém os seus arquivos, configurações e definições de teste. Quando o teste estiver concluído, o executável terá que fzer a build novamente, utilizando o profile padrão `prod`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Alternatively, if you need to specify specific properties when running tests against the native executable built using the `prod` profile, an option is to put those properties in file `src/test/resources/application-nativeit.yaml`, and refer to it from the `failsafe` plugin configuration using the `QUARKUS_CONFIG_LOCATIONS` environment variable. For instance:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Como alternativa, se precisar de propriedades específicas ao executar testes contra o executável nativo que foi construído utilizando o profile `prod`, uma opção é colocar essas propriedades no arquivo `src/test/resources/application-nativeit.yaml`, e fazer referência a partir da configuração do plugin `failsafe` utilizando a variável de ambiente `QUARKUS_CONFIG_LOCATIONS`. Por exemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Java code that relies on preview features requires special attention.  To test a native executable, this means that the `--enable-preview` flag needs to be passed to the Surefire plugin.  Adding `&lt;argLine&gt;--enable-preview&lt;/argLine&gt;` to its `configuration` section is one way to do so.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O código Java que depende de preview features requer atenção especial. Para testar um executável nativo, isso significa que a flag `--enable-preview` precisa ser passado para o plug-in Surefire. Adicionando `&amp;amp;lt;argLine&amp;amp;gt;--enable-preview&amp;amp;lt;/argLine&amp;amp;gt;` à sua secção `configuration` é uma forma de o fazer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the process cannot find the native image for some reason, or you want to test a native image that is no longer in the target directory you can specify the executable with the `-Dnative.image.path=` system property.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se o processo não encontrar a imagem nativa por alguma razão, ou você quer testar uma imagem nativa que não está mais disponível na pasta target, você pode especificar o executável com o parâmetro `-Dnative.image.path=`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before going further, be sure to have a working container runtime (Docker, podman) environment. If you use Docker on Windows you should share your project's drive at Docker Desktop file share settings and restart Docker Desktop.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Antes de prosseguir, certifique-se de que tem um container sendo executado (Docker, podman). Se você utiliza o Docker no Windows, deve compartilhar o drive do seu projeto nas definições de partilha de arquivos do Docker Desktop e reiniciar o Docker Desktop.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To this end, Quarkus provides a very convenient way of creating a native Linux executable by leveraging a container runtime such as Docker or podman.  The easiest way of accomplishing this task is to execute:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para isso, o Quarkus fornece uma maneira muito conveniente de criar um executável nativo do Linux, aproveitando um contêiner que esteja em execução, como o Docker ou o podman. A maneira mais fácil de realizar essa tarefa é executar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus automatically detects the container runtime.  If you want to explicitly select the container runtime, you can do it with:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, o Quarkus detecta automaticamente contêiner em execução. Se pretender escolher explicitamente o contêiner, pode fazê-lo com:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Please note that the above command points to a floating tag.  It is highly recommended to use the floating tag, so that your builder image remains up-to-date and secure.  If you absolutely must, you may hard-code to a specific tag (see https://quay.io/repository/quarkus/ubi-quarkus-mandrel-builder-image?tab=tags[here] for available tags), but be aware that you won't get security updates that way and it's unsupported.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Observe que o comando acima aponta para uma floating tag. É altamente recomendado que utilize a floating tag, para que a imagem permaneça atualizada e segura. Se você realmente necessita, você pode especificar a tag de forma hard-coded (veja link:https://quay.io/repository/quarkus/ubi-quarkus-mandrel-builder-image?tab=tags[aqui] as tags disponíveis), mas esteja ciente de que você não terá atualizações de segurança e não é suportado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can run the application in a container using the JAR produced by the Quarkus Maven Plugin.  However, in this section we focus on creating a container image using the produced native executable.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>É possível executar a aplicação em um contêiner utilizando o JAR produzido pelo plug-in Maven do Quarkus. No entanto, nesta seção, iremos focar na criação de um container--image utilizando o executável nativo produzido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using a local GraalVM installation, the native executable targets your local operating system (Linux, macOS, Windows etc).  However, as a container may not use the same _executable_ format as the one produced by your operating system, we will instruct the Maven build to produce an executable by leveraging a container runtime (as described in xref:container-runtime[this section]):</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Ao usar uma instalação local do GraalVM, o executável nativo tem como alvo o seu sistema operacional local (Linux, macOS, Windows etc.). No entanto, como um contêiner pode não utilizar o mesmo formato de executável que o produzido pelo seu sistema operacional, iremos fazer que o Maven faça a build para produzir um executável aproveitando o tempo de execução do contêiner (conforme descrito nesta link:#container-runtime[secção]):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The produced executable will be a 64-bit Linux executable, so depending on your operating system it may no longer be runnable.  However, it's not an issue as we are going to copy it to a container.  The project generation has provided a `Dockerfile.native-micro` in the `src/main/docker` directory with the following content:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O executável produzido será um executável Linux de 64 bits, pelo que, dependendo do seu sistema operacional, poderá não ser executado. No entanto, isso não é um problema, pois vamos copiá-lo para um contêiner. A geração do projeto forneceu um `Dockerfile.native-micro` no diretório `src/main/docker` com o seguinte conteúdo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus Micro Image?</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Quarkus Micro Image?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Quarkus Micro Image is a small container image providing the right set of dependencies to run your native application.  It is based on https://catalog.redhat.com/software/containers/ubi8-micro/601a84aadd19c7786c47c8ea?container-tabs=overview[UBI Micro].  This base image has been tailored to work perfectly in containers.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A imagem Quarkus Micro é uma pequena imagem de contêiner que fornece o conjunto certo de dependências para executar a sua aplicação nativa. Ela é baseada na link:https://catalog.redhat.com/software/containers/ubi8-micro/601a84aadd19c7786c47c8ea?container-tabs=overview[UBI Micro]. Esta imagem base foi adaptada para funcionar perfeitamente em contêiner.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://catalog.redhat.com/software/container-stacks/detail/5ec53f50ef29fd35586d9a56[Red Hat Universal Base Image 8]</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>link:https://catalog.redhat.com/software/container-stacks/detail/5ec53f50ef29fd35586d9a56[Imagem Base Universal da Red Hat]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The UBI minimal image is bigger than the micro one mentioned above.  It contains more utilities such as the `microdnf` package manager.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A imagem mínima do UBI é maior que a micro mencionada acima. Ela contém mais utilitários, como o gerenciador de pacotes `microdnf`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The previous section showed you how to build a native executable using Maven or Gradle, but it requires you to have created the native executable first.  In addition, this native executable must be a Linux 64 bits executable.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A seção anterior mostrou como construir um executável nativo utilizando o Maven ou o Gradle, mas isso requer que tenha criado primeiro o executável nativo. Além disso, esse executável nativo deve ser um executável Linux de 64 bits.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You may want to build the native executable directly in a container without having a final container containing the build tools.  That approach is possible with a multi-stage Docker build:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Você pode querer fazer o build do executável nativo diretamente no contêiner sem ter um contêiner final que contenha as ferramentas de build. Essa abordagem é possível com uma compilação do Docker em vários estágios:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Before building a container image from the Dockerfiles shown below, you need to update the default `.dockerignore` file, as it filters everything except the `target` directory. In order to build inside a container, you need to copy the `src` directory. Thus, edit your `.dockerignore` and remove the `*` line.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Antes de construir uma imagem de contêiner a partir dos Dockerfiles mostrados abaixo, é necessário atualizar o arquivo `.dockerignore`, uma vez que este filtra tudo exceto o diretório `target`. Para fazer o build dentro de um contêiner, é necessário copiar o diretório `src`. Portanto, edite seu `.dockerignore` e remova a linha `*`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## Stage 1 : build with maven builder image with native capabilities
FROM quay.io/quarkus/ubi-quarkus-mandrel-builder-image:{mandrel-flavor} AS build
COPY --chown=quarkus:quarkus mvnw /code/mvnw
COPY --chown=quarkus:quarkus .mvn /code/.mvn
COPY --chown=quarkus:quarkus pom.xml /code/
USER quarkus
WORKDIR /code
RUN ./mvnw -B org.apache.maven.plugins:maven-dependency-plugin:3.1.2:go-offline
COPY src /code/src
RUN ./mvnw package -Dnative
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>## Estágio 1 : build com maven-builder-image com capacidades nativa
FROM quay.io/quarkus/ubi-quarkus-mandrel-builder-image:{mandrel-flavor} AS build
COPY --chown=quarkus:quarkus mvnw /code/mvnw
COPY --chown=quarkus:quarkus .mvn /code/.mvn
COPY --chown=quarkus:quarkus pom.xml /code/
USER quarkus
WORKDIR /code
RUN ./mvnw -B org.apache.maven.plugins:maven-dependency-plugin:3.1.2:go-offline
COPY src /code/src
RUN ./mvnw package -Dnative
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## Stage 2 : create the docker final image
FROM quay.io/quarkus/quarkus-micro-image:2.0
WORKDIR /work/
COPY --from=build /code/target/*-runner /work/application
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>## Estágio 2 : Criar a imagem final no docker
FROM quay.io/quarkus/quarkus-micro-image:2.0
WORKDIR /work/
COPY --from=build /code/target/*-runner /work/application
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This multi-stage Docker build copies the Maven wrapper from the host machine.  The Maven wrapper (or the Gradle wrapper) is a convenient way to provide a specific version of Maven/Gradle.  It avoids having to create a base image with Maven and Gradle.  To provision the Maven Wrapper in your project, use: `mvn -N org.apache.maven.plugins:maven-wrapper-plugin:3.1.1:wrapper`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Esta compilação Docker de vários estágios copia o wrapper Maven da máquina host. O wrapper do Maven (ou o wrapper do Gradle) é uma maneira conveniente de fornecer uma versão específica do Maven/Gradle. Ele evita a necessidade de criar uma imagem de base com o Maven e o Gradle. Para fornecer o Maven Wrapper em seu projeto, use: `mvn -N org.apache.maven.plugins:maven-wrapper-plugin:3.1.1:wrapper`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Save this file in `src/main/docker/Dockerfile.multistage` as it is not included in the getting started quickstart.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Salve esse arquivo em `src/main/docker/Dockerfile.multistage`, uma vez que não está incluído no startup rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## Stage 1 : build with maven builder image with native capabilities
FROM quay.io/quarkus/ubi-quarkus-mandrel-builder-image:{mandrel-flavor} AS build
USER root
RUN microdnf install findutils
COPY --chown=quarkus:quarkus gradlew /code/gradlew
COPY --chown=quarkus:quarkus gradle /code/gradle
COPY --chown=quarkus:quarkus build.gradle /code/
COPY --chown=quarkus:quarkus settings.gradle /code/
COPY --chown=quarkus:quarkus gradle.properties /code/
USER quarkus
WORKDIR /code
COPY src /code/src
RUN ./gradlew build -Dquarkus.package.type=native
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>## Estágio 1 : build com gradle-builder-image com capacidades nativa
FROM quay.io/quarkus/ubi-quarkus-mandrel-builder-image:{mandrel-flavor} AS build
USER root
RUN microdnf install findutils
COPY --chown=quarkus:quarkus gradlew /code/gradlew
COPY --chown=quarkus:quarkus gradle /code/gradle
COPY --chown=quarkus:quarkus build.gradle /code/
COPY --chown=quarkus:quarkus settings.gradle /code/
COPY --chown=quarkus:quarkus gradle.properties /code/
USER quarkus
WORKDIR /code
COPY src /code/src
RUN ./gradlew build -Dquarkus.package.type=native
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## Stage 2 : create the docker final image
FROM quay.io/quarkus/quarkus-micro-image:2.0
WORKDIR /work/
COPY --from=build /code/build/*-runner /work/application
RUN chmod 775 /work
EXPOSE 8080
CMD ["./application", "-Dquarkus.http.host=0.0.0.0"]
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>## Estágio 2 : Criar a imagem final do docker
FROM quay.io/quarkus/quarkus-micro-image:2.0
WORKDIR /work/
COPY --from=build /code/build/*-runner /work/application
RUN chmod 775 /work
EXPOSE 8080
CMD ["./application", "-Dquarkus.http.host=0.0.0.0"]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using Gradle in your project, you can use this sample Dockerfile.  Save it in `src/main/docker/Dockerfile.multistage`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se estiver utilizando o Gradle no seu projeto, pode utilizar este exemplo de Dockerfile. Salve-o em `src/main/docker/Dockerfile.multistage`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are looking for small container images, the https://github.com/GoogleContainerTools/distroless[distroless] approach reduces the size of the base layer.  The idea behind _distroless_ is the usage of a single and minimal base image containing all the requirements, and sometimes even the application itself.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se estiver à procura de pequenas imagens de contêiner, a abordagem link:https://github.com/GoogleContainerTools/distroless[sem] distribuição reduz o tamanho da camada de base. A ideia por trás do _distroless_ é a utilização de uma imagem de base única e mínima que contém todos os requisitos e, por vezes, até a própria aplicação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides a distroless base image that you can use in your `Dockerfile`.  You only need to copy your application, and you are done:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus fornece uma imagem de base sem distribuição que pode utilizar no seu `Dockerfile`. Só precisa copiar a sua aplicação e está feito:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus provides the `quay.io/quarkus/quarkus-distroless-image:2.0` image.  It contains the required packages to run a native executable and is only **9Mb**.  Just add your application on top of this image, and you will get a tiny container image.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus fornece a imagem `quay.io/quarkus/quarkus-distroless-image:2.0`. Ela contém os pacotes necessários para executar um executável nativo e tem apenas *9Mb*. Basta adicionar a sua aplicação em cima desta imagem e obterá uma pequena imagem de contêiner.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## Stage 1 : build with maven builder image with native capabilities
FROM quay.io/quarkus/ubi-quarkus-graalvmce-builder-image:{graalvm-flavor} AS build
USER root
RUN microdnf install make gcc
COPY --chown=quarkus:quarkus mvnw /code/mvnw
COPY --chown=quarkus:quarkus .mvn /code/.mvn
COPY --chown=quarkus:quarkus pom.xml /code/
RUN mkdir /musl &amp;&amp; \
    curl -L -o musl.tar.gz https://more.musl.cc/11.2.1/x86_64-linux-musl/x86_64-linux-musl-native.tgz &amp;&amp; \
    tar -xvzf musl.tar.gz -C /musl --strip-components 1 &amp;&amp; \
    curl -L -o zlib.tar.gz https://www.zlib.net/zlib-1.2.13.tar.gz &amp;&amp; \
    mkdir zlib &amp;&amp; tar -xvzf zlib.tar.gz -C zlib --strip-components 1 &amp;&amp; \
    cd zlib &amp;&amp; ./configure --static --prefix=/musl &amp;&amp; \
    make &amp;&amp; make install &amp;&amp; \
    cd .. &amp;&amp; rm -rf zlib &amp;&amp; rm -f zlib.tar.gz &amp;&amp; rm -f musl.tar.gz
ENV PATH="/musl/bin:${PATH}"
USER quarkus
WORKDIR /code
RUN ./mvnw -B org.apache.maven.plugins:maven-dependency-plugin:3.1.2:go-offline
COPY src /code/src
RUN ./mvnw package -Dnative -DskipTests -Dquarkus.native.additional-build-args="--static","--libc=musl"
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>## Estágio 1 : build com maven-builder-image com capacidades nativa
FROM quay.io/quarkus/ubi-quarkus-graalvmce-builder-image:{graalvm-flavor} AS build
USER root
RUN microdnf install make gcc
COPY --chown=quarkus:quarkus mvnw /code/mvnw
COPY --chown=quarkus:quarkus .mvn /code/.mvn
COPY --chown=quarkus:quarkus pom.xml /code/
RUN mkdir /musl &amp;&amp; \
    curl -L -o musl.tar.gz https://more.musl.cc/11.2.1/x86_64-linux-musl/x86_64-linux-musl-native.tgz &amp;&amp; \
    tar -xvzf musl.tar.gz -C /musl --strip-components 1 &amp;&amp; \
    curl -L -o zlib.tar.gz https://www.zlib.net/zlib-1.2.13.tar.gz &amp;&amp; \
    mkdir zlib &amp;&amp; tar -xvzf zlib.tar.gz -C zlib --strip-components 1 &amp;&amp; \
    cd zlib &amp;&amp; ./configure --static --prefix=/musl &amp;&amp; \
    make &amp;&amp; make install &amp;&amp; \
    cd .. &amp;&amp; rm -rf zlib &amp;&amp; rm -f zlib.tar.gz &amp;&amp; rm -f musl.tar.gz
ENV PATH="/musl/bin:${PATH}"
USER quarkus
WORKDIR /code
RUN ./mvnw -B org.apache.maven.plugins:maven-dependency-plugin:3.1.2:go-offline
COPY src /code/src
RUN ./mvnw package -Dnative -DskipTests -Dquarkus.native.additional-build-args="--static","--libc=musl"
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>## Stage 2 : create the final image
FROM scratch
COPY --from=build /code/target/*-runner /application
EXPOSE 8080
ENTRYPOINT [ "/application" ]
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>## Stage 2 : Criação da imagem final
FROM scratch
COPY --from=build /code/target/*-runner /application
EXPOSE 8080
ENTRYPOINT [ "/application" ]
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Scratch images should not be used in production without rigorous testing.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>As imagens Scratch não devem ser utilizadas em produção sem um teste rigoroso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In certain circumstances, you may want to build the native image in a separate step.  For example, in a CI/CD pipeline, you may want to have one step to generate the source that will be used for the native image generation and another step to use these sources to actually build the native executable.  For this use case, you can set the `quarkus.package.type=native-sources`.  This will execute the java compilation as if you had started native compilation (`-Dnative`), but stops before triggering the actual call to GraalVM's `native-image`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Em algumas circunstâncias, você pode querer criar a imagem nativa em uma etapa separada. Por exemplo, em um pipeline de CI/CD, você pode querer ter uma etapa para gerar o fonte que será usada para a geração da imagem nativa e outra etapa para usar esses fontes para realmente criar o executável nativo. Para este caso de utilização, pode definir `quarkus.package.type=native-sources`. Isto irá executar a compilação java como se tivesse iniciado a compilação nativa ( `-Dnative`), mas irá parar antes de ativar a chamada real para `native-image` do GraalVM .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>From the output above one can see that, in addition to the produced jar file and the associated lib directory, a text file named `native-image.args` was created.  This file holds all parameters (including the name of the JAR to compile) to pass along to GraalVM's `native-image` command.  A text file named `graalvm.version` was also created and holds the GraalVM version that should be used.  If you have GraalVM installed and it matches this version, you can start the native compilation by executing:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A partir do output acima, pode-se ver que, além do arquivo jar produzido e do diretório lib associado, um arquivo de texto chamado `native-image.args` foi criado. Este arquivo contém todos os parâmetros (incluindo o nome do JAR para compilar) para utilizar no comando `native-image` do GraalVM. Um arquivo de texto chamado `graalvm.version` também foi criado e contém a versão do GraalVM que deve ser usada. Se tiver o GraalVM instalado e corresponder a esta versão, pode iniciar a compilação nativa executando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are running on a Windows machine, please keep in mind that the binary was created within a Linux docker container.  Hence, the binary will not be executable on the host Windows machine.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se estiver executando em uma máquina Windows, tenha em conta que o binário foi criado num contêiner docker Linux. Por isso, o binário não será executável na máquina Windows.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Require this artifact in the step executing the `native-image ...` command, and</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Exigir este artefacto no passo que executa o comando `native-image …​`, e</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Native executables can be debugged using tools such as `gdb`.  For this to be possible native executables need to be generated with debug symbols.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Os executáveis nativos podem ser debugados utilizando ferramentas como `gdb`. Para que isso seja possível, os executáveis nativos têm de ser gerados com símbolos de debug.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Debug symbol generation is only supported on Linux.  Windows support is still under development, while macOS is not supported.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A geração de símbolos de debug só é suportada no Linux. O suporte ao Windows ainda está em desenvolvimento, enquanto o macOS não é suportado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To generate debug symbols, add `-Dquarkus.native.debug.enabled=true` flag when generating the native executable.  You will find the debug symbols for the native executable in a `.debug` file next to the native executable.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para gerar símbolos de debug, adicione a flag `-Dquarkus.native.debug.enabled=true` ao gerar o executável nativo. Encontrará os símbolos de debug para o executável nativo num arquivo `.debug` junto ao executável nativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The generation of the `.debug` file depends on `objcopy`.  As a result, when using a local GraalVM installation on common Linux distributions you will need to install the `binutils` package:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A geração do arquivo `.debug` depende de `objcopy`. Como resultado, ao usar uma instalação local do GraalVM em distribuições comuns do Linux, será necessário instalar o pacote `binutils`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Aside from debug symbols, setting `-Dquarkus.native.debug.enabled=true` flag generates a cache of source files for any JDK runtime classes, GraalVM classes and application classes resolved during native executable generation.  This source cache is useful for native debugging tools, to establish the link between the symbols and matching source code.  It provides a convenient way of making just the necessary sources available to the debugger/IDE when debugging a native executable.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Além dos símbolos de debug, a configuração da flag `-Dquarkus.native.debug.enabled=true` cria um cache de arquivos de fonte para qualquer classe de tempo de execução da JDK, classes do GraalVM e classes da aplicação são resolvidas durante a geração do executável nativo. Esse cache do código-fonte é útil para ferramentas de depuração nativas, para estabelecer o link entre os símbolos e o código-fonte correspondente. Ele fornece uma maneira conveniente de disponibilizar apenas as fontes necessárias para o debugger/IDE ao debugar um executável nativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sources for third party jar dependencies, including Quarkus source code, are not added to the source cache by default.  To include those, make sure you invoke `mvn dependency:sources` first.  This step is required in order to pull the sources for these dependencies, and get them included in the source cache.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>As fontes para dependências jar de terceiros, incluindo o código fonte do Quarkus, não são adicionadas ao cache de fontes por padrão. Para incluí-los, certifique-se de executar o comando `mvn dependency:sources` primeiro. Este passo é necessário para obter as fontes para estas dependências e incluí-las na cache de fontes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The source cache is located in the `target/sources` folder.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A cache de fonte está localizado na pasta `target/sources`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>in the `gdb` prompt.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>no prompt `gdb`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Monitoring options such as JDK flight recorder, jvmstat, heap dumps, and remote JMX (experimental in Mandrel 23)  can be added to the native executable build. Simply supply a comma separated list of the monitoring options you wish to include at build time.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>As opções de monitoração, como o JDK flight recorder, o jvmstat, heap dumps e o JMX remoto (experimental no Mandrel 23), podem ser adicionadas à compilação do executável nativo. Basta fornecer uma lista separada por vírgulas das opções de monitoração que deseja incluir no momento da compilação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>jfr</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>jfr</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>jvmstat</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>jvmstat</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>GraalVM 22.3, GraalVM CE 17.0.7 Mandrel 22.3 Mandrel 23.0 (17.0.7)</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>GraalVM 22.3, GraalVM CE 17.0.7 Mandrel 22.3 Mandrel 23.0 (17.0.7)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>heapdump</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>heapdump</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>jmxclient</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>jmxclient</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>jmxserver</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>jmxserver</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There are a lot of different configuration options that can affect how the native executable is generated.  These are provided in `application.properties` the same as any other config property.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Existem muitas opções de configuração diferentes que podem afetar a forma como o executável nativo é gerado. Elas são fornecidas no `application.properties` da mesma forma que qualquer outra propriedade de configuração.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covered the creation of a native (binary) executable for your application.  It provides an application exhibiting a swift startup time and consuming less memory.  However, there is much more.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia abordou a criação de um executável nativo (binário) para a sua aplicação. Ele fornece uma aplicação que possui um startup mais rápido e consome menos memória. No entanto, há muito mais.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend continuing the journey with the xref:deploying-to-kubernetes.adoc[deployment to Kubernetes and OpenShift].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Recomendamos continuar a jornada com a  link:deploying-to-kubernetes.html[implantação no Kubernetes e no OpenShift].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple ways to connect with others via forum, stack, chat, or email groups.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Várias maneiras de se conectar com outras pessoas por meio de fóruns, Stack Overflow, bate-papo ou grupos de e-mail.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications are designed to run in containers.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Aplicações Quarkus são projetadas para serem executadas em contêineres.</seg>
      </tuv>
    </tu>
  </body>
</tmx>
