<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="Translate Toolkit" creationtoolversion="3.10.1" segtype="sentence" o-tmf="UTF-8" adminlang="en" srclang="en" datatype="PlainText"/>
  <body>
    <tu>
      <tuv xml:lang="en">
        <seg>We recommend that you follow the instructions in the next sections and create the application step by step.  However, you can go right to the completed example.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Recomendamos que siga as instruções nas seções seguintes e crie a aplicação passo a passo. No entanto, você pode ir diretamente para o exemplo completo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>pom.xml</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>pom.xml</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>build.gradle</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>build.gradle</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are going to model our increments using the `Increment` POJO.  Create the `src/main/java/org/acme/redis/Increment.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Vamos modelar os nossos incrementos utilizando o POJO `Increment`. Crie o arquivo `src/main/java/org/acme/redis/Increment.java`, com o seguinte conteúdo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We are going to create an `IncrementService` class which will play the role of a Redis client.  With this class, we'll be able to perform the `SET`, `GET` , `DEL`, `KEYS` and `INCRBY` Redis commands.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Vamos criar uma classe `IncrementService` que desempenhará o papel de um cliente Redis. Com essa classe, poderemos executar os comandos Redis `SET`, `GET`, `DEL`, `KEYS` e `INCRBY`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/redis/IncrementService.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Criar o arquivo `src/main/java/org/acme/redis/IncrementService.java`, com o seguinte conteúdo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Create the `src/main/java/org/acme/redis/IncrementResource.java` file, with the following content:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Criar o arquivo `src/main/java/org/acme/redis/IncrementResource.java`, com o seguinte conteúdo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you followed the instructions, you should have the Redis server running.  Then, you just need to run the application using:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se seguiu as instruções, deve ter o servidor Redis funcionando. Depois, você só precisa executar a aplicação utilizando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Open another terminal and run the `curl http://localhost:8080/increments` command.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Abra outro terminal e execute o comando `curl http://localhost:8080/increments.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As we have seen above, the API exposes five Rest endpoints.  In this section we are going to see how to initialise an increment, see the list of current increments, incrementing a value given its key, retrieving the current value of an increment, and finally deleting a key.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Como vimos acima, a API expõe cinco endpoints Rest. Nesta seção, vamos ver como inicializar um incremento, ver a lista de incrementos atuais, incrementar um valor dado a sua chave, recuperar o valor atual de um incremento e, finalmente, excluir uma chave.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delete the `first` increment.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Excluir o incremento `first`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>At this point, Quarkus uses the Redis Dev Service to run a Redis server and configure the application.  However, in production, you will run your own Redis (or used a Cloud offering).</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Neste ponto, o Quarkus usa o Redis Dev Service para executar um servidor Redis e configurar a aplicação. No entanto, em produção, você irá executar o seu próprio Redis (ou utilizar um oferecido por algum serviço de Cloud).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If any Kafka-related extension is present (e.g. `quarkus-smallrye-reactive-messaging-kafka`), Dev Services for Kafka automatically starts a Kafka broker in dev mode and when running tests.  So, you don't have to start a broker manually.  The application is configured automatically.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se qualquer extensão relacionada ao Kafka estiver presente (por exemplo, `quarkus-smallrye-reactive-messaging-kafka`), o Dev Services para  Kafka iniciará automaticamente um broker Kafka no modo de desenvolvimento e ao executar testes. Portanto, não é necessário iniciar um broker manualmente. A aplicação é configurada de forma automática.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Because starting a Kafka broker can be long, Dev Services for Kafka uses https://vectorized.io/redpanda[Redpanda], a Kafka compatible broker which starts in ~1 second.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Como a inicialização de um broker Kafka pode ser demorada, o Dev Services para o Kafka usa o  link:https://vectorized.io/redpanda[Redpanda], um broker compatível com o Kafka que inicia em aproximadamente 1 segundo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling / Disabling Dev Services for Kafka</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Ativar/desativar Dev Services para o Kafka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kafka relies on Docker to start the broker.  If your environment does not support Docker, you will need to start the broker manually, or connect to an already running broker.  You can configure the broker address using `kafka.bootstrap.servers`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para o Kafka depende do Docker para iniciar o broker. Se o seu ambiente não for compatível com o Docker, terá de iniciar o broker manualmente ou conectar-se a um broker já em execução. É possível configurar o endereço do broker usando `kafka.bootstrap.servers`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Shared broker</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>broker compartilhado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the broker between applications.  Dev Services for Kafka implements a _service discovery_ mechanism for your multiple Quarkus applications running in _dev_ mode to share a single broker.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Na maioria das vezes, é necessário compartilhar o broker entre as aplicações. O Dev Services para o Kafka implementa um mecanismo de _descoberta de serviços_ para que seus vários aplicativos Quarkus em execução no _modo_ de _desenvolvimento_ compartilhem um único broker.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) brokers, you can configure the `quarkus.kafka.devservices.service-name` attribute and indicate the broker name.  It looks for a container with the same value, or starts a new one if none can be found.  The default service name is `kafka`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você precisar de vários brokers (compartilhados), você pode configurar o atributo `quarkus.kafka.devservices.service-name` e indicar o nome do broker. Este procura um container com o mesmo valor ou inicia um novo se não for encontrado nenhum. O nome de serviço predefinido é `kafka`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Sharing is enabled by default in dev mode, but disabled in test mode.  You can disable the sharing with `quarkus.kafka.devservices.shared=false`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O compartilhamento é ativado por padrão no modo de desenvolvimento, mas desativado no modo de teste. Você pode desativar o compartilhamento com `quarkus.kafka.devservices.shared=false`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Dev Services for Kafka picks a random port and configures the application.  You can set the port by configuring the `quarkus.kafka.devservices.port` property.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, o Dev Services para o Kafka escolhe uma porta aleatória e configura o aplicativo. Você pode definir a porta configurando a propriedade `quarkus.kafka.devservices.port`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kafka supports https://redpanda.com[Redpanda], https://github/ozangunalp/kafka-native[kafka-native] and https://strimzi.io[Strimzi] (in https://github.com/apache/kafka/blob/trunk/config/kraft/README.md[Kraft] mode)  images.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para o Kafka suporta imagens  link:https://redpanda.com[Redpanda],  link:https://github/ozangunalp/kafka-native[kafka-native] e  link:https://strimzi.io[Strimzi] (no modo  link:https://github.com/apache/kafka/blob/trunk/config/kraft/README.md[Kraft] ).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Redpanda** is a Kafka compatible event streaming platform.
Because it provides a fast startup times, dev services defaults to Redpanda images from `vectorized/redpanda`.
You can select any version from https://hub.docker.com/r/vectorized/redpanda.
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>*Redpanda* é uma plataforma de streaming de eventos compatível com o Kafka. Uma vez que proporciona tempos de startup rápidos, o Dev services têm como padrão as imagens Redpanda de `vectorized/redpanda`. Pode selecionar qualquer versão de  https://hub.docker.com/r/vectorized/redpanda
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**kafka-native** provides images of standard Apache Kafka distribution compiled to native binary using Quarkus and GraalVM.
While still being _experimental_, it provides very fast startup times with small footprint.
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>*kafka-native* fornece imagens da distribuição padrão do Apache Kafka compiladas para binário nativo usando Quarkus e GraalVM. Embora ainda esteja em fase _experimental_, fornece tempos de startup muito rápidos e com consumo reduzido.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>**Strimzi** provides container images and Operators for running Apache Kafka on Kubernetes.
While Strimzi is optimized for Kubernetes, the images work perfectly in classic container environments.
Strimzi container images run "genuine" Kafka broker on JVM, which is slower to start.
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>*O Strimzi* fornece imagens de container e Operadores para executar o Apache Kafka no Kubernetes. Embora o Strimzi seja otimizado para Kubernetes, as imagens funcionam perfeitamente em ambientes de container clássicos. As imagens de container do Strimzi rodam o broker Kafka "genuíno" na JVM, que é mais lento para iniciar.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For Strimzi, you can select any image with a Kafka version which has Kraft support (2.8.1 and higher) from https://quay.io/repository/strimzi-test-container/test-container?tab=tags</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para  o Strimzi, você pode selecionar qualquer imagem com uma versão Kafka que tenha suporte para o Kraft (2.8.1 e superior) em  https://quay.io/repository/strimzi-test-container/test-container?tab=tags</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure the Dev Services for Kafka to create topics once the broker is started.  Topics are created with given number of partitions and 1 replica.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Você pode configurar os Dev Services para o Kafka para criar tópicos assim que o broker for iniciado. Os tópicos são criados com um determinado número de partições e uma réplica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You can configure timeout for Kafka admin client calls used in topic creation using `quarkus.kafka.devservices.topic-partitions-timeout`, it defaults to 2 seconds.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Você pode configurar o tempo limite para as chamadas do client admin do Kafka utilizadas na criação de tópicos utilizando `quarkus.kafka.devservices.topic-partitions-timeout`. A predefinição é de 2 segundos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the Red Panda broker is configured to enable transactions and idempotence features.  You can disable those using:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, o broker do Red Panda está configurado para ativar as funcionalidades de transações e idempotência. Você pode desativá-las utilizando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Redpanda transactions does not support exactly-once processing.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>As transações Redpanda não suportam um processamento exatamente único.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP automatically starts an AMQP 1.0 broker in dev mode and when running tests.  So, you don't have to start a broker manually.  The application is configured automatically.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para AMQP inicia automaticamente um broker AMQP 1.0 no modo de desenvolvimento e ao executar testes. Assim, não é necessário iniciar um broker manualmente. A aplicação é configurada de forma automática.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling / Disabling Dev Services for AMQP</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Ativação/desativação do Dev Services para AMQP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP is automatically enabled unless:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para AMQP é  ativado automaticamente, a menos que:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP relies on Docker to start the broker.  If your environment does not support Docker, you will need to start the broker manually, or connect to an already running broker.  You can configure the broker access using the `amqp-host`, `amqp-port`, `amqp-user` and `amqp-password` properties.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para AMQP depende do Docker para iniciar o Broker. Se o seu ambiente não for compatível com o Docker, será necessário iniciar o Broker manualmente ou conectar-se a um Broker já em execução. Você pode configurar o acesso ao Broker  utilizando as propriedades `amqp-host`, `amqp-port`, `amqp-user` e `amqp-password`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the broker between applications.  Dev Services for AMQP implements a _service discovery_ mechanism for your multiple Quarkus applications running in _dev_ mode to share a single broker.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Na maioria das vezes, é necessário compartilhar o broker entre as aplicações. O Dev Services para AMQP implementa um mecanismo de _service discovery_ para que as suas múltiplas aplicações Quarkus em execução no _dev_ mode_ compartilhem um único broker.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) brokers, you can configure the `quarkus.amqp.devservices.service-name` attribute and indicate the broker name.  It looks for a container with the same value, or starts a new one if none can be found.  The default service name is `amqp`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você precisar de vários brokers (compartilhados), você pode configurar o atributo `quarkus.amqp.devservices.service-name` e indicar o nome do broker. Este irá buscar  um container com o mesmo valor ou iniciará um novo se não for encontrado nenhum. O nome de serviço predefinido é `amqp`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Dev Services for AMQP picks a random port and configures the application.  You can set the port by configuring the `quarkus.amqp.devservices.port` property.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, o Dev Services para AMQP escolhe uma porta aleatória e configura a aplicação. É possível definir a porta configurando a propriedade `quarkus.amqp.devservices.port`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for AMQP uses https://quay.io/repository/artemiscloud/activemq-artemis-broker[activemq-artemis-broker] images.  You can configure the image and version using the `quarkus.amqp.devservices.image-name` property:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para AMQP usa a imagem  link:https://quay.io/repository/artemiscloud/activemq-artemis-broker[activemq-artemis-broker]. É possível configurar a imagem e a versão usando a propriedade `quarkus.amqp.devservices.image-name`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kubernetes automatically starts a Kubernetes API server in dev mode and when running tests.  So you don't have to start a Kubernetes cluster manually.  The application is configured automatically.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para Kubernetes inicia automaticamente um servidor de API do Kubernetes no modo de desenvolvimento e ao executar testes. Assim, não é necessário iniciar um cluster do Kubernetes manualmente. A aplicação é configurada de forma automática.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enabling / Disabling Dev Services for Kubernetes</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Ativar/desativar Dev Services  para Kubernetes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>the `api-server-url` is configured</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A URL `api-server-url` esteja configurada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>a valid Kube config file is found and `quarkus.kubernetes-client.devservices.override-kubeconfig` is not set to `true`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Um arquivo de configuração Kube válido seja encontrado e `quarkus.kubernetes-client.devservices.override-kubeconfig` não está definido como `true`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>you include the `quarkus-test-kubernetes-client` dependency</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Você inclua a dependência `quarkus-test-kubernetes-client`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kubernetes relies on Docker to start the API server.  If your environment does not support Docker, you will need to start the Kubernetes cluster manually, or connect to an already running Kubernetes cluster.  You can configure the Kubernetes cluster access using either a Kube config file or the various properties available in the https://github.com/quarkusio/quarkus/blob/main/extensions/kubernetes-client/runtime-internal/src/main/java/io/quarkus/kubernetes/client/runtime/KubernetesClientBuildConfig.java[KubernetesClientBuildConfig] class.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para Kubernetes depende do Docker para iniciar o servidor de API. Se o seu ambiente não suportar o Docker, terá de iniciar o cluster Kubernetes manualmente ou conectar-se a um cluster Kubernetes já em execução. É possível configurar o acesso ao cluster do Kubernetes usando um arquivo de configuração do Kube ou as várias propriedades disponíveis na classe link:https://github.com/quarkusio/quarkus/blob/main/extensions/kubernetes-client/runtime-internal/src/main/java/io/quarkus/kubernetes/client/runtime/KubernetesClientBuildConfig.java[KubernetesClientBuildConfig].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Most of the time you need to share the cluster between applications.  Dev Services for Kubernetes implements a _service discovery_ mechanism for your multiple Quarkus applications running in dev mode to share a single cluster.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Na maioria das vezes, é necessário compartilhar o cluster entre aplicações. O Dev Services para Kubernetes implementaa um mecanismo de _service discovery_ para que suas várias aplicações Quarkus em execução no _dev_ mode_ compartilhem um único cluster.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you need multiple (shared) clusters, you can configure the `quarkus.kubernetes-client.devservices.service-name` configuration property and indicate the cluster name.  It looks for a container with the name defined, or starts a new one if none can be found.  The default service name is `kubernetes`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg> Se você precisar de vários clusters (compartilhados), você pode configurar o configuration property `quarkus.kubernetes-client.devservices.service-name` e indicar o nome do cluster. Procurar um container com o nome definido ou iniciar um novo se não for encontrado nenhum. O nome do serviço predefinido é `kubernetes`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev Services for Kubernetes provides three different flavors of Kubernetes cluster. Each flavor supports different Kubernetes API versions.  You can configure the flavor and version using the `quarkus.kubernetes-client.devservices.flavor` and `quarkus.kubernetes-client.devservices.api-version` properties:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Dev Services para Kubernetes oferece três flavors diferentes de cluster Kubernetes. Cada flavor suporta diferentes versões da API do Kubernetes. Você pode configurar o flavor e a versão usando as propriedades quarkus.kubernetes-client.devservices.flavor e quarkus.kubernetes-client.devservices.api-version:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`api-only` only starts a Kubernetes API Server. If you need a fully-featured Kubernetes cluster that can spin up Pods, you can use `k3s` or `kind`. Note that they both requires to run in Docker privileged mode.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>'api-only' inicia apenas um Servidor de API Kubernetes. Se você precisa de um cluster Kubernetes totalmente funcional que possa criar Pods, você pode usar k3s ou kind. Observe que ambos requerem que sejam executados em modo privilegiado do Docker."</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/about" class="{% if page.url contains '/about/' %}active{% endif %}"&gt;WHAT IS QUARKUS?&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/about" class="{% if page.url contains '/about/' %}active{% endif %}"&gt;O QUE É QUARKUS?&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/developer-joy" class="{% if page.url contains '/developer-joy/' %}active{% endif %}"&gt;DEVELOPER JOY&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/developer-joy" class="{% if page.url contains '/developer-joy/' %}active{% endif %}"&gt;ALEGRIA DO DESENVOLVEDOR&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/get-started" class="{% if page.url contains '/get-started/' %}active{% endif %}"&gt;GET STARTED&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/get-started" class="{% if page.url contains '/get-started/' %}active{% endif %}"&gt;COMEÇAR&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/qtips" class="{% if page.url contains '/qtips/' %}active{% endif %}"&gt;"Q" TIP VIDEOS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/qtips" class="{% if page.url contains '/qtips/' %}active{% endif %}"&gt;VÍDEOS "Q" TIP&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://quarkus.io/extensions/" class="{% if page.url contains '/extensions/' %}active{% endif %}"&gt;BROWSE EXTENSIONS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="https://quarkus.io/extensions/" class="{% if page.url contains '/extensions/' %}active{% endif %}"&gt;PROCURAR EXTENSÕES&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/faq/#what-is-a-quarkus-extension" class="{% if page.url contains 'what-is-a-quarkus-extension' %}active{% endif %}"&gt;USE EXTENSIONS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/faq/#what-is-a-quarkus-extension" class="{% if page.url contains 'what-is-a-quarkus-extension' %}active{% endif %}"&gt;USAR EXTENSÕES&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/writing-extensions" class="{% if page.url contains '/guides/writing-extensions' %}active{% endif %}"&gt;CREATE EXTENSIONS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/guides/writing-extensions" class="{% if page.url contains '/guides/writing-extensions' %}active{% endif %}"&gt;CRIAR EXTENSÕES&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://hub.quarkiverse.io" class="{% if page.url contains 'hub.quarkiverse.io' %}active{% endif %}"&gt;SHARE EXTENSIONS&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="https://hub.quarkiverse.io" class="{% if page.url contains 'hub.quarkiverse.io' %}active{% endif %}"&gt;COMPARTILHE EXTENSÕES&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/blog" class="{% if page.url contains '/blog/' %}active{% endif %}"&gt;BLOG&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/blog" class="{% if page.url contains '/blog/' %}active{% endif %}"&gt;BLOG&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/insights" class="{% if page.url contains '/insights/' %}active{% endif %}"&gt;PODCAST&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/insights" class="{% if page.url contains '/insights/' %}active{% endif %}"&gt;PODCAST&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/newsletter" class="{% if page.url contains '/newsletter/' %}active{% endif %}"&gt;NEWSLETTER&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/newsletter" class="{% if page.url contains '/newsletter/' %}active{% endif %}"&gt;BOLETIM INFORMATIVO&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="https://github.com/orgs/quarkusio/projects/13/views/1" class="{% if page.url contains '/roadmap/' %}active{% endif %}"&gt;ROADMAP&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="https://github.com/orgs/quarkusio/projects/13/views/1" class="{% if page.url contains '/roadmap/' %}active{% endif %}"&gt;ROADMAP&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using the Quarkus Kubernetes extension, developers can perform or automate a single-step deployment using Jib, Docker, and Source-to-Image (S2i) including the creation of DeploymentConfig to trigger automatic redeployments. &lt;a href="{{site.baseurl}}/guides/deploying-to-kubernetes"&gt;Read the guide for more details.&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Usando a extensão Quarkus Kubernetes, os desenvolvedores podem executar ou automatizar uma implantação de etapa única usando Jib, Docker e Source-to-Image (S2i), incluindo a criação de DeploymentConfig para disparar reimplantações automáticas. &lt;a href="{{site.baseurl}}/guides/deploying-to-kubernetes"&gt;Leia o guia para obter mais detalhes.&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has been designed with this new world in mind and provides first-class support for these different paradigms. That does not mean you cannot build monoliths with Quarkus; you can do it smoothly. On the contrary, it means that the Quarkus development model morphs to adapt itself to the type of application you are developing, monolith, microservice, reactive, event-driven, functions…</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus foi projetado com esse novo mundo em mente e fornece suporte de primeira classe para esses diferentes paradigmas. Isso não significa que você não possa construir monólitos com Quarkus; você pode fazê-lo sem problemas. Pelo contrário, isso significa que o modelo de desenvolvimento do Quarkus se transforma para se adaptar ao tipo de aplicação que você está desenvolvendo, monólito, microsserviço, reativo, orientado a eventos, funções...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Application requirements have changed drastically over the last few years.  For any application to succeed in the era of cloud computing, Big Data, or IoT, going reactive is increasingly becoming the architecture style to follow.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Os requisitos das aplicações mudaram drasticamente nos últimos anos. Para que qualquer aplicação tenha sucesso na era da computação em nuvem, Big Data ou IoT, tornar-se reativo está se tornando cada vez mais o estilo de arquitetura a ser seguido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Today’s users embrace applications with milliseconds of response time, 100% uptime, lower latency, push data instead of pull, higher throughput, and elasticity. However, these features are nearly impossible to achieve using yesterday’s software architecture without a considerable investment in resources, infrastructure, and tooling. The world changed, and having dozens of servers, long response times (&amp;gt; 500 ms), downtime due to maintenance or waterfalls of failures does not meet the expected user experience.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Os usuários de hoje adotam aplicações com milissegundos de tempo de resposta, disponibilidade de 100%, menor latência, dados por push em vez de pull, maior taxa de transferência e elasticidade. No entanto, esses recursos são quase impossíveis de alcançar usando a arquitetura de software de ontem sem um investimento considerável em recursos, infraestrutura e ferramentas. O mundo mudou, e ter dezenas de servidores, longos tempos de resposta (&amp;gt; de 500 ms), tempo de inatividade devido a manutenção ou cascatas de falhas não atende à experiência esperada do usuário.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Thanks to the &lt;a href="https://quarkus.io/version/main/guides/mutiny-primer"&gt;Mutiny Reactive API&lt;/a&gt; , you can compose asynchronous operations and complete the result when everything is done without blocking the I/O threads.  This greatly improves resource consumption and elasticity.  Most Quarkus APIs are available in both imperative and reactive.  As example, you can use the reactive version of the REST Client:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Graças à &lt;a href="https://quarkus.io/version/main/guides/mutiny-primer"&gt;Mutiny Reactive API&lt;/a&gt; , você pode compor operações assíncronas e concluir o resultado quando tudo for feito sem bloquear os threads de E/S.  Isso melhora muito o consumo de recursos e a elasticidade.  A maioria das APIs do Quarkus está disponível em imperativa e reativa.  Como exemplo, você pode usar a versão reativa do cliente REST:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As for the reactive APIs exposed by Quarkus, stream manipulation uses the Mutiny API.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Quanto às APIs reativas expostas pelo Quarkus, a manipulação de fluxo usa a API Mutiny .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is an Open Source project licensed under the &lt;a href="https://www.apache.org/licenses/LICENSE-2.0"&gt;Apache License version 2.0&lt;/a&gt;. First and foremost, it is an open community where contributions, ideas and discussions are done in the open and contributors are welcome. Let’s join forces in building the future of Java applications.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Quarkus é um projeto Open Source licenciado sob a &lt;a href="https://www.apache.org/licenses/LICENSE-2.0"&gt;Licença Apache versão 2.0.&lt;/a&gt; Em primeiro lugar, é uma comunidade aberta, onde contribuições, ideias e discussões são feitas ao ar livre e os colaboradores são bem-vindos. Vamos unir forças na construção do futuro das aplicações Java.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is designed to seamlessly combine the familiar imperative style code and the non-blocking, reactive style when developing applications.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus foi projetado para combinar perfeitamente o código de estilo imperativo que você já conhece e o estilo reativo sem bloqueio ao desenvolver aplicações.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="/developer-joy"&gt;Learn more&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="/developer-joy"&gt;Saiba Mais&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dev UI</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Interface do usuário do desenvolvedor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>&lt;a href="{{site.baseurl}}/guides/dev-ui"&gt;Read the Dev UI guide&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;a href="{{site.baseurl}}/guides/dev-ui"&gt;Leia o guia da interface do usuário do desenvolvedor&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In this session the Quarkus Team will give you a unique, hands-on experience: An introduction to Quarkus, a follow-along hands-on demo or two and then a Q&amp;A with some of the band, umm, developers involved.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Nesta sessão, a Equipe do Quarkus lhe dará uma experiência prática única: uma introdução ao Quarkus, uma demonstração prática subsequente ou duas e, em seguida, uma sessão de perguntas e respostas com alguns dos desenvolvedores envolvidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>So join us as we explore how Quarkus helps Java developers everywhere to be more productive, create modern masterpieces and, well, have more fun: 90 odd minutes of technical discussion, some live coding and a Q&amp;A - it’s going to be a blast.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Então junte-se a nós enquanto exploramos como o Quarkus ajuda desenvolvedores Java em todos os lugares a serem mais produtivos, criar obras-primas modernas e, bem, se divertir mais: 90 minutos ímpares de discussão técnica, alguma codificação ao vivo e uma sessão de perguntas e respostas - vai ser uma explosão.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Time to rock the Java world 2023 style…</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Hora de arrasar no estilo Java World 2023...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Ask on &lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Stack Overflow with the &lt;code&gt;quarkus&lt;/code&gt; tag&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Pergunte no &lt;a href="https://stackoverflow.com/questions/tagged/quarkus"&gt;Stack Overflow com a tag &lt;code&gt;quarkus&lt;/code&gt;&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus offers unequaled performance</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus oferece um desempenho inigualável</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>We have a lot of documentation. Be sure to check our &lt;a href="{{site.baseurl}}/get-started/"&gt;Getting started page&lt;/a&gt;, and all our &lt;a href="{{site.baseurl}}/guides/"&gt;guides&lt;/a&gt;. Also check out our &lt;a href="{{site.baseurl}}/faq/"&gt;FAQ section&lt;/a&gt; and &lt;a href="https://www.youtube.com/playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO"&gt;Quarkus Tips Playlist&lt;/a&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Temos muita documentação. Certifique-se de verificar nossa &lt;a href="{{site.baseurl}}/get-started/"&gt;página de Introdução&lt;/a&gt; e todos os nossos &lt;a href="{{site.baseurl}}/guides/"&gt;guias&lt;/a&gt;. Confira também nossa &lt;a href="{{site.baseurl}}/faq/"&gt;seção FAQ&lt;/a&gt; e &lt;a href="https://www.youtube.com/playlist?list=PLsM3ZE5tGAVbMz1LJqc8L5LpnfxPPKloO"&gt;Quarkus Tips Playlist&lt;/a&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SUPERSONIC&lt;span class="light-blue"&gt;/&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>SUPERSÔNICO&lt;span class=“light-blue”&gt;/&lt;/span&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SUBATOMIC&lt;span class="light-blue"&gt;/&lt;/span&gt;</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>&lt;span class="light-blue"&gt;SUBATÔMICO&lt;/span&gt;/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributions are welcome, please submit pull requests for the `develop` branch.
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Contribuições são bem-vindas, por favor, envie pull-requests para a branch `develop`.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka Dev UI</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Kafka Dev UI</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If any Kafka-related extension is present (e.g. `quarkus-smallrye-reactive-messaging-kafka`), the Quarkus Dev UI is extended with a Kafka broker management UI.  It is connected automatically to the Kafka broker configured for the application.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se estiver presente uma extensão relacionada com o Kafka (por exemplo, `quarkus-smallrye-reactive-messaging-kafka`), a Quarkus Dev UI é estendida com uma interface de gestão do corretor Kafka. Esta é ligada automaticamente ao corretor Kafka configurado para a aplicação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Kafka</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Kafka</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>kafka-dev-ui-link.png</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>kafka-dev-ui-link.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>kafka-dev-ui-records.png</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>kafka-dev-ui-records.png</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Message send timeout in ms. +
If a message is not acknowledged by a server before the `sendTimeout` expires, an error occurs.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Tempo limite de envio de mensagem em ms. +
Se uma mensagem não for reconhecida por um servidor antes que o 'sendTimeout' expire, ocorrerá um erro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If it is set to `true`, when the outgoing message queue is full, the `Send` and `SendAsync` methods of producer block, rather than failing and throwing errors. +
If it is set to `false`, when the outgoing message queue is full, the `Send` and `SendAsync` methods of producer fail and `ProducerQueueIsFullError` exceptions occur.

The `MaxPendingMessages` parameter determines the size of the outgoing message queue.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se estiver definido como 'true', quando a fila de mensagens de saída estiver cheia, os métodos 'Send' e 'SendAsync' do produtor bloqueiam, em vez de falhar e lançar erros. +
Se ele estiver definido como 'false', quando a fila de mensagens de saída estiver cheia, os métodos 'Send' e 'SendAsync' do produtor falham e as exceções 'ProducerQueueIsFullError' ocorrem.

O parâmetro 'MaxPendingMessages' determina o tamanho da fila de mensagens de saída.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The maximum size of a queue holding pending messages.

For example, a message waiting to receive an acknowledgment from a https://pulsar.apache.org/docs/reference-terminology#broker[broker].

By default, when the queue is full, all calls to the `Send` and `SendAsync` methods fail **unless** you set `BlockIfQueueFull` to `true`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O tamanho máximo de uma fila que contém mensagens pendentes.

Por exemplo, uma mensagem aguardando para receber uma confirmação de um https://pulsar.apache.org/docs/reference-terminologia#broker[broker].

Por padrão, quando a fila está cheia, todas as chamadas para os métodos 'Send' e 'SendAsync' falham **a menos que você defina 'BlockIfQueueFull' como 'true'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The maximum number of pending messages across partitions.

Use the setting to lower the max pending messages for each partition (`#setMaxPendingMessages(int)`) if the total number exceeds the configured value.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O número máximo de mensagens pendentes entre partições.

Use a configuração para diminuir o máximo de mensagens pendentes para cada partição ('#setMaxPendingMessages(int)') se o número total exceder o valor configurado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Message routing logic for producers on https://pulsar.apache.org/docs/concepts-architecture-overview#partitioned-topics[partitioned topics]. +
Apply the logic only when setting no key on messages. +
Available options are as follows: +
* `pulsar.RoundRobinDistribution`: round robin +
* `pulsar.UseSinglePartition`: publish all messages to a single partition +
* `pulsar.CustomPartition`: a custom partitioning scheme</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Lógica de roteamento de mensagens para produtores em https://pulsar.apache.org/docs/concepts-architecture-overview#partitioned-topics[partitioned topics]. +
Aplique a lógica somente ao definir nenhuma tecla nas mensagens. +
As opções disponíveis são as seguintes: +
* 'pulsar. RoundRobinDistribution': round robin +
* 'pulsar. UseSinglePartition': publicar todas as mensagens em uma única partição +
* 'pulsar. CustomPartition': um esquema de particionamento personalizado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Hashing function determining the partition where you publish a particular message (partitioned topics only). +
Available options are as follows: +
* `pulsar.JavastringHash`: the equivalent of `string.hashCode()` in Java +
* `pulsar.Murmur3_32Hash`: applies the https://en.wikipedia.org/wiki/MurmurHash[Murmur3] hashing function +
* `pulsar.BoostHash`: applies the hashing function from C++'s https://www.boost.org/doc/libs/1_62_0/doc/html/hash.html[Boost] library</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Função de hash que determina a partição onde você publica uma mensagem específica (somente tópicos particionados). +
As opções disponíveis são as seguintes: +
* 'pulsar. JavastringHash': o equivalente a 'string.hashCode()' em Java +
* 'pulsar. Murmur3_32Hash': aplica a função de hash https://en.wikipedia.org/wiki/MurmurHash[Murmur3] +
* 'pulsar. BoostHash': aplica a função de hash da biblioteca https://www.boost.org/doc/libs/1_62_0/doc/html/hash.html[Boost] do C++</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following will build all modules in the Quarkus repository except docs and test modules and install them in your local maven repository with the `999-SNAPSHOT` version:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O seguinte comando irá construir todos os módulos no repositório Quarkus, exceto os módulos docs e de teste, e instalá-los no seu repositório Maven local com a versão `999-SNAPSHOT`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The following will build all modules in the Quarkus repository (except test modules) and install them in your local maven repository with the `999-SNAPSHOT` version:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O seguinte comando irá construir todos os módulos no repositório do Quarkus (exceto módulos de teste) e instalá-los em seu repositório maven local com a versão '999-SNAPSHOT':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Number of IO threads.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Número de threads de E/S.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Release the connection if it is not used for more than [connectionMaxIdleSeconds] seconds. If  [connectionMaxIdleSeconds] &lt; 0, disabled the feature that auto release the idle connections</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Solte a conexão se ela não for usada por mais de [connectionMaxIdleSeconds] segundos. Se [connectionMaxIdleSeconds] &lt; 0, desabilitado o recurso que libera automaticamente as conexões ociosas</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Duration of waiting for a connection to a broker to be established.If the duration passes without a response from a broker, the connection attempt is dropped.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Duração da espera para que uma conexão com um broker seja estabelecida. Se a duração passar sem uma resposta de um broker, a tentativa de conexão será descartada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Listener name for lookup. Clients can use listenerName to choose one of the listeners as the service URL to create a connection to the broker as long as the network is accessible."advertisedListeners" must enabled in broker side.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Nome do ouvinte para pesquisa. Os clientes podem usar listenerName para escolher um dos ouvintes como a URL do serviço para criar uma conexão com o broker, desde que a rede esteja acessível." advertisedListeners" deve ser habilitado no lado do corretor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Limit of client memory usage (in byte). The 64M default can guarantee a high producer throughput.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Limite de uso de memória do cliente (em byte). O padrão de 64 milhões pode garantir uma alta taxa de transferência do produtor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To write duration values, use the standard `java.time.Duration` format.  See the link:https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/Duration.html#parse(java.lang.CharSequence)[Duration#parse() javadoc] for more information.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para valores de duração, use o formato padrão 'java.time.Duration'.  Consulte o link:https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/Duration.html#parse(java.lang.CharSequence)[Duration#parse() javadoc] para obter mais informações.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the value is a number followed by `ms`, it represents time in milliseconds.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se o valor for um número seguido de 'ms', ele representa o tempo em milissegundos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In other cases, the simplified format is translated to the `java.time.Duration` format for parsing:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Em outros casos, o formato simplificado é traduzido para o formato 'java.time.Duration' para análise:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the value is a number followed by `h`, `m`, or `s`, it is prefixed with `PT`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se o valor for um número seguido de 'h', 'm' ou 's', ele é prefixado com 'PT'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the value is a number followed by `d`, it is prefixed with `P`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se o valor for um número seguido de 'd', ele é prefixado com 'P'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specify the commit strategy to apply when a message produced from a record is acknowledged. Values can be `ack`, `cumulative`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Especifique a estratégia de confirmação a ser aplicada quando uma mensagem produzida a partir de um registro for reconhecida. Os valores podem ser 'ack', 'cumulativos'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Specify the failure strategy to apply when a message produced from a record is acknowledged negatively (nack). Values can be `nack` (default), `fail`, `ignore` or `reconsume-later</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Especifique a estratégia de falha a ser aplicada quando uma mensagem produzida a partir de um registro for reconhecida negativamente (nack). Os valores podem ser 'nack' (padrão), 'fail', 'ignore' ou 'reconsume-later</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Pulsar schema type of this channel. When configured a schema is built with the given SchemaType and used for the channel. When absent, the schema is resolved searching for a CDI bean typed `Schema` qualified with `@Identifier` and the channel name. As a fallback AUTO_CONSUME or AUTO_PRODUCE are used.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O tipo de esquema Pulsar deste canal. Quando configurado, um esquema é criado com o SchemaType fornecido e usado para o canal. Quando ausente, o esquema é resolvido procurando um bean CDI digitado 'Esquema' qualificado com '@Identifier' e o nome do canal. Como fallback AUTO_CONSUME ou AUTO_PRODUCE são usados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The consumed / populated Pulsar topic. If not set, the channel name is used</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O tópico Pulsar consumido/povoado. Se não estiver definido, o nome do canal será usado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The consumed / populated Kafka topic. If neither this property nor the `topics` properties are set, the channel name is used

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O tema Kafka consumido/populado. Se nem essa propriedade nem as propriedades 'topics' estiverem definidas, o nome do canal será usado

Tipo: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interface for custom message is negativeAcked policy. You can specify `RedeliveryBackoff` for a consumer.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Interface para mensagem personalizada é política negativeAcked. Você pode especificar 'RedeliveryBackoff' para um consumidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Interface for custom message is ackTimeout policy. You can specify `RedeliveryBackoff` for a consumer.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Interface para mensagem personalizada é a política ackTimeout. Você pode especificar 'RedeliveryBackoff' para um consumidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Size of a consumer's receiver queue. +
For example, the number of messages accumulated by a consumer before an application calls `Receive`. +
A value higher than the default value increases consumer throughput, though at the expense of more memory utilization.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Tamanho da fila de destinatários de um consumidor. +
Por exemplo, o número de mensagens acumuladas por um consumidor antes de um aplicativo chamar 'Receber'. +
Um valor maior que o valor padrão aumenta a taxa de transferência do consumidor, embora às custas de mais utilização de memória.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Delay to wait before redelivering messages that failed to be processed. +
When an application uses `Consumer#negativeAcknowledge(Message)`, failed messages are redelivered after a fixed timeout.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Atraso para aguardar antes de entregar novamente as mensagens que não puderam ser processadas. +
Quando um aplicativo usa 'Consumer#negativeAcknowledge(Message)', as mensagens com falha são entregues novamente após um tempo limite fixo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Granularity of the ack-timeout redelivery. +
Using an higher `tickDurationMillis` reduces the memory overhead to track messages when setting ack-timeout to a bigger value (for example, 1 hour).</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Granularidade da reentrega do tempo limite de ack. +
Usar um 'tickDurationMillis' mais alto reduz a sobrecarga de memória para rastrear mensagens ao definir o tempo limite de ack-para um valor maior (por exemplo, 1 hora).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Priority level for a consumer to which a broker gives more priority while dispatching messages in Shared subscription type. +
The broker follows descending priorities. For example, 0=max-priority, 1, 2,... +
In Shared subscription type, the broker **first dispatches messages to the max priority level consumers if they have permits**. Otherwise, the broker considers next priority level consumers. +
**Example 1** +
If a subscription has consumerA with `priorityLevel` 0 and consumerB with `priorityLevel` 1, then the broker **only dispatches messages to consumerA until it runs out permits** and then starts dispatching messages to consumerB. +
**Example 2** +
Consumer Priority, Level, Permits +
C1, 0, 2 +
C2, 0, 1 +
C3, 0, 1 +
C4, 1, 2 +
C5, 1, 1 +

Order in which a broker dispatches messages to consumers is: C1, C2, C3, C1, C4, C5, C4.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Nível de prioridade para um consumidor ao qual um corretor dá mais prioridade ao enviar mensagens no tipo de assinatura compartilhada. +
O corretor segue prioridades decrescentes. Por exemplo, 0=max-priority, 1, 2,... +
No tipo de assinatura compartilhada, o corretor **primeiro envia mensagens para os consumidores de nível máximo de prioridade se eles tiverem permissões**. Caso contrário, o corretor considera os consumidores de nível de prioridade seguinte. +
**Exemplo 1** +
Se uma assinatura tiver consumerA com 'priorityLevel' 0 e consumerB com 'priorityLevel' 1, o corretor **somente despachará mensagens para consumerA até que ele esgote as permissões** e, em seguida, começará a enviar mensagens para consumerB. +
**Exemplo 2** +
Prioridade do Consumidor, Nível, Licenças +
C1, 0, 2 +
C2, 0, 1 +
C3, 0, 1 +
C4, 1, 2 +
C5, 1, 1 +

A ordem em que um corretor envia mensagens para os consumidores é: C1, C2, C3, C1, C4, C5, C4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether to automatically acknowledge pending chunked messages when the threshold of `maxPendingChunkedMessage` is reached. If set to `false`, these messages will be redelivered by their broker.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se as mensagens em bloco pendentes devem ser confirmadas automaticamente quando o limite de 'maxPendingChunkedMessage' for atingido. Se definido como 'false', essas mensagens serão reentregues pelo corretor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Consumer should take action when it receives a message that can not be decrypted. +
* **FAIL**: this is the default option to fail messages until crypto succeeds. +
* **DISCARD**:silently acknowledge and not deliver message to an application. +
* **CONSUME**: deliver encrypted messages to applications. It is the application's responsibility to decrypt the message.

The decompression of message fails.

If messages contain batch messages, a client is not be able to retrieve individual messages in batch.

Delivered encrypted message contains `EncryptionContext` which contains encryption and compression information in it using which application can decrypt consumed message payload.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O consumidor deve agir quando receber uma mensagem que não pode ser descriptografada. +
* **FAIL**: esta é a opção padrão para falhar mensagens até que a criptografia seja bem-sucedida. +
* **DESCARTAR**:reconhecer silenciosamente e não entregar mensagem a um aplicativo. +
* **CONSUME**: entregar mensagens criptografadas para aplicativos. É responsabilidade do aplicativo descriptografar a mensagem.

A descompactação da mensagem falha.

Se as mensagens contiverem mensagens em lote, um cliente não poderá recuperar mensagens individuais em lote.

A mensagem criptografada entregue contém 'EncryptionContext' que contém informações de criptografia e compactação usando qual aplicativo pode descriptografar a carga útil da mensagem consumida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>A name or value property of this consumer.

`properties` is application defined metadata attached to a consumer.

When getting a topic stats, associate this metadata with the consumer stats for easier identification.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Um nome ou propriedade de valor desse consumidor.

'propriedades' são metadados definidos pelo aplicativo anexados a um consumidor.

Ao obter estatísticas de tópico, associe esses metadados às estatísticas do consumidor para facilitar a identificação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If enabling `readCompacted`, a consumer reads messages from a compacted topic rather than reading a full message backlog of a topic.

A consumer only sees the latest value for each key in the compacted topic, up until reaching the point in the topic message when compacting backlog. Beyond that point, send messages as normal.

Only enabling `readCompacted` on subscriptions to persistent topics, which have a single active consumer (like failure or exclusive subscriptions).

Attempting to enable it on subscriptions to non-persistent topics or on shared subscriptions leads to a subscription call throwing a `PulsarClientException`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se habilitar 'readCompacted', um consumidor lerá mensagens de um tópico compactado em vez de ler uma lista de pendências de mensagens completa de um tópico.

Um consumidor só vê o valor mais recente para cada chave no tópico compactado, até chegar ao ponto na mensagem de tópico ao compactar a lista de pendências. Além desse ponto, envie mensagens normalmente.

Habilitar apenas 'readCompacted' em assinaturas de tópicos persistentes, que tenham um único consumidor ativo (como falha ou assinaturas exclusivas).

A tentativa de habilitá-lo em assinaturas de tópicos não persistentes ou em assinaturas compartilhadas leva a uma chamada de assinatura lançando um 'PulsarClientException'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Dead letter policy for consumers.

By default, some messages are probably redelivered many times, even to the extent that it never stops.

By using the dead letter mechanism, messages have the max redelivery count. **When exceeding the maximum number of redeliveries, messages are sent to the Dead Letter Topic and acknowledged automatically**.

You can enable the dead letter mechanism by setting `deadLetterPolicy`.

When specifying the dead letter policy while not specifying `ackTimeoutMillis`, you can set the ack timeout to 30000 millisecond.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Política de dead letter para os consumidores.

Por padrão, algumas mensagens provavelmente são reentregues muitas vezes, até mesmo na medida em que nunca param.

Usando o mecanismo de dead letter, as mensagens têm a contagem máxima de reentrega. **Ao exceder o número máximo de reentregas, as mensagens são enviadas para o Tópico de Dead Letter e reconhecidas automaticamente**.

Você pode ativar o mecanismo de letra morta definindo 'deadLetterPolicy'.

Ao especificar a política de dead letter enquanto não especifica 'ackTimeoutMillis', você pode definir o tempo limite de ack para 30000 milissegundos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If `replicateSubscriptionState` is enabled, a subscription state is replicated to geo-replicated clusters.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se 'replicateSubscriptionState' estiver habilitado, um estado de assinatura será replicado para clusters replicados geograficamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In _experimental_ mode, early feedback is requested to mature the idea.  There is no guarantee of stability nor long term presence in the platform until the solution matures.  Feedback is welcome on our https://groups.google.com/d/forum/quarkus-dev[mailing list] or as issues in our https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>No modo _experimental_, o feedback antecipado é solicitado para amadurecer a idéia.  Não há garantia de estabilidade nem presença de longo prazo na plataforma até que a solução amadureça.  Comentários são bem-vindos em nosso https://groups.google.com/d/forum/quarkus-dev[mailing list] ou como issues em nosso https://github.com/quarkusio/quarkus/issues[GitHub issue tracker].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create a Gradle project, add the `--gradle` or `--gradle-kotlin-dsl` option.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para criar um projeto Gradle, adicione a opção `--gradle` ou `--gradle-kotlin-dsl`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For more information about how to install and use the Quarkus CLI, see the xref:cli-tooling.adoc[Quarkus CLI] guide.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para obter mais informações sobre como instalar e usar a CLI do Quarkus, consulte o guia xref:cli-tooling.adoc[Quarkus CLI].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To create a Gradle project, add the `-DbuildTool=gradle` or `-DbuildTool=gradle-kotlin-dsl` option.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para criar um projeto Gradle, adicione a opção '-DbuildTool=gradle' ou '-DbuildTool=gradle-kotlin-dsl'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using cmd, (don't use backward slash `\` and put everything on the same line)</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se estiver usando cmd, (não use barra invertida '\' e coloque tudo na mesma linha)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If using Powershell, wrap `-D` parameters in double quotes e.g. `"-DprojectArtifactId={create-app-artifact-id}"`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se estiver usando o Powershell, envolva os parâmetros '-D' entre aspas duplas, por exemplo, '"-DprojectArtifactId={create-app-artifact-id}"'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Prefix for Kafka client `client.id` attribute. If defined configured or generated `client.id` will be prefixed with the given value, otherwise `kafka-producer-` is the prefix.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Prefixo para o atributo 'client.id' do cliente Kafka. Se definido configurado ou gerado 'client.id' será prefixado com o valor dado, caso contrário 'kafka-producer-' é o prefixo.

Tipo: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enables (default) or disables the Cloud Event support. If enabled on an _incoming_ channel, the connector analyzes the incoming records and try to create Cloud Event metadata. If enabled on an _outgoing_, the connector sends the outgoing messages as Cloud Event if the message includes Cloud Event Metadata.

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Habilita (padrão) ou desabilita o suporte a Cloud Event. Se habilitado em um canal _incoming_, o conector analisará os registros de entrada e tentará criar metadados do Cloud Event. Se habilitado em um _outgoing_, o conector enviará as mensagens de saída como Cloud Event se a mensagem incluir Metadados de Evento de Nuvem.

Tipo: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `datacontenttype` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `datacontenttype` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Configura o atributo 'datacontenttype' padrão do evento de nuvem de saída. Requer que 'cloud-events' seja definido como 'true'. Esse valor será usado se a mensagem não configurar o próprio atributo 'datacontenttype'

Tipo: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `dataschema` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `dataschema` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Configura o atributo 'dataschema' padrão do evento de nuvem de saída. Requer que 'cloud-events' seja definido como 'true'. Esse valor será usado se a mensagem não configurar o próprio atributo 'dataschema'

Tipo: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Whether the connector should insert automatically the `time` attribute into the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `time` attribute itself

Type: _boolean_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se o conector deve inserir automaticamente o atributo 'time' no evento de nuvem de saída. Requer que 'cloud-events' seja definido como 'true'. Esse valor será usado se a mensagem não configurar o próprio atributo 'time'

Tipo: _boolean_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Cloud Event mode (`structured` or `binary` (default)). Indicates how are written the cloud events in the outgoing record

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O modo Cloud Event ('estruturado' ou 'binário' (padrão)). Indica como são gravados os eventos de nuvem no registro de saída

Tipo: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `source` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `source` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Configure o atributo 'source' padrão do evento de nuvem de saída. Requer que 'cloud-events' seja definido como 'true'. Esse valor será usado se a mensagem não configurar o próprio atributo 'source'

Tipo: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `subject` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `subject` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Configure o atributo 'subject' padrão do evento de nuvem de saída. Requer que 'cloud-events' seja definido como 'true'. Esse valor será usado se a mensagem não configurar o próprio atributo 'subject'

Tipo: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configure the default `type` attribute of the outgoing Cloud Event. Requires `cloud-events` to be set to `true`. This value is used if the message does not configure the `type` attribute itself

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Configure o atributo 'type' padrão do evento de nuvem de saída. Requer que 'cloud-events' seja definido como 'true'. Esse valor será usado se a mensagem não configurar o próprio atributo 'type'

Tipo: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name set in `@Identifier` of a bean that implements `io.smallrye.reactive.messaging.kafka.SerializationFailureHandler`. If set, serialization failure happening when serializing keys are delegated to this handler which may provide a fallback value.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O nome definido em '@Identifier' de um bean que implementa 'io.smallrye.reactive.messaging.kafka.SerializationFailureHandler'. Se definido, a falha de serialização que ocorre quando as chaves de serialização são delegadas a esse manipulador, que pode fornecer um valor de fallback.

Tipo: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The maximum number of messages to be written to Kafka concurrently. It limits the number of messages waiting to be written and acknowledged by the broker. You can set this attribute to `0` remove the limit

Type: _long_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O número máximo de mensagens a serem gravadas em Kafka simultaneamente. Ele limita o número de mensagens aguardando para serem escritas e reconhecidas pelo corretor. Você pode definir esse atributo como '0' remover o limite

Tipo: _long_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If set to a positive number, the connector will try to resend any record that was not delivered successfully (with a potentially transient error) until the number of retries is reached. If set to 0, retries are disabled. If not set, the connector tries to resend any record that failed to be delivered (because of a potentially transient error) during an amount of time configured by `delivery.timeout.ms`.

Type: _long_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se definido como um número positivo, o conector tentará reenviar qualquer registro que não tenha sido entregue com êxito (com um erro potencialmente transitório) até que o número de tentativas seja atingido. Se definido como 0, as novas tentativas serão desabilitadas. Se não estiver definido, o conector tentará reenviar qualquer registro que não tenha sido entregue (devido a um erro potencialmente transitório) durante um período de tempo configurado por 'delivery.timeout.ms'.

Tipo: _long_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The name set in `@Identifier` of a bean that implements `io.smallrye.reactive.messaging.kafka.SerializationFailureHandler`. If set, serialization failure happening when serializing values are delegated to this handler which may provide a fallback value.

Type: _string_</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O nome definido em '@Identifier' de um bean que implementa 'io.smallrye.reactive.messaging.kafka.SerializationFailureHandler'. Se definido, a falha de serialização que ocorre quando os valores de serialização são delegados a esse manipulador, que pode fornecer um valor de fallback.

Tipo: _string_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>JDK 11+ installed with `JAVA_HOME` configured appropriately</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>JDK 11+ instalado com 'JAVA_HOME' configurado adequadamente</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Docker and Docker Compose or xref:podman.adoc[Podman], and Docker Compose</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Docker e Docker Compose ou xref:podman.adoc[Podman] e Docker Compose</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The solution is located in the `redis-quickstart` link:{quickstarts-tree-url}/redis-quickstart[directory].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A solução está localizada no link:{quickstarts-tree-url}/redis-quickstart[diretório] `redis-quickstart` .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>package org.acme.redis;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>package org.acme.redis;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    public Increment(String key, long value) {
        this.key = key;
        this.value = value;
    }
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    public Incremento(String chave, long valor) {
        this.chave = chave;
        this.valor = valor;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.redis.datasource.ReactiveRedisDataSource;
import io.quarkus.redis.datasource.RedisDataSource;
import io.quarkus.redis.datasource.keys.KeyCommands;
import io.quarkus.redis.datasource.keys.ReactiveKeyCommands;
import io.quarkus.redis.datasource.string.StringCommands;
import io.smallrye.mutiny.Uni;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>import io.quarkus.redis.datasource.ReactiveRedisDataSource;
import io.quarkus.redis.datasource.RedisDataSource;
import io.quarkus.redis.datasource.keys.KeyCommands;
import io.quarkus.redis.datasource.keys.ReactiveKeyCommands;
import io.quarkus.redis.datasource.string.StringCommands;
import io.smallrye.mutiny.Uni;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    // This quickstart demonstrates both the imperative
    // and reactive Redis data sources
    // Regular applications will pick one of them.
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    // Esse exemplo demonstra tanto a instanciação imperativa
    // quanto reativa do seu datasource Redis.
    // Sua aplicação geralmente precisará de uma delas.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    long get(String key) {
        Long value = countCommands.get(key); // &lt;6&gt;
        if (value == null) {
            return 0L;
        }
        return value;
    }
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    long get(String chave) {
        Long valor = contadorValueCommands.get(chave); // &lt;6&gt;
        if (valor == null) {
            return 0L;
        }
        return valor;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    void set(String key, Long value) {
        countCommands.set(key, value); // &lt;7&gt;
    }
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    void set(String chave, Long valor) {
        contadorValueCommands.set(chave, valor); // &lt;7&gt;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    void increment(String key, Long incrementBy) {
        countCommands.incrby(key, incrementBy); // &lt;8&gt;
    }
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    void incrementar(String chave, Long valor) {
        contadorValueCommands.incrby(chave, valor); // &lt;8&gt;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    Uni&lt;Void&gt; del(String key) {
        return keyCommands.del(key) // &lt;9&gt;
            .replaceWithVoid();
    }
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    Uni&lt;Void&gt; deletar(String chave) {
        return chaveKeyCommands.del(chave) // &lt;9&gt;
            .replaceWithVoid();
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    Uni&lt;List&lt;String&gt;&gt; keys() {
        return keyCommands.keys("*"); // &lt;10&gt;
    }
}
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    Uni&lt;List&lt;String&gt;&gt; chaves() {
        return chaveKeyCommands.keys("*"); // &lt;10&gt;
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.PUT;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.DELETE;
import java.util.List;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.PUT;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.DELETE;
import java.util.List;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.smallrye.mutiny.Uni;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>import io.smallrye.mutiny.Uni;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @GET
    public Uni&lt;List&lt;String&gt;&gt; keys() {
        return service.keys();
    }
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    @GET
    public Uni&lt;List&lt;String&gt;&gt; chaves() {
        return service.chaves();
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @POST
    public Increment create(Increment increment) {
        service.set(increment.key, increment.value);
        return increment;
    }
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    @POST
    public Incremento create(Incremento incremento) {
        service.set(incremento.chave, incremento.valor);
        return incremento;
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @GET
    @Path("/{key}")
    public Increment get(String key) {
        return new Increment(key, service.get(key));
    }
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    @GET
    @Path("/{chave}")
    public Incremento get(String chave) {
        return new Incremento(key, service.get(chave));
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @PUT
    @Path("/{key}")
    public void increment(String key, long value) {
        service.increment(key, value);
    }
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    @PUT
    @Path("/{chave}")
    public void incrementar(String chave, long valor) {
        service.incrementar(chave, valor);
    }
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @DELETE
    @Path("/{key}")
    public Uni&lt;Void&gt; delete(String key) {
        return service.del(key);
    }
}
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    @DELETE
    @Path("/{chave}")
    public Uni&lt;Void&gt; delete(String chave) {
        return service.del(chave);
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import static org.hamcrest.Matchers.is;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>import static org.hamcrest.Matchers.is;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import org.junit.jupiter.api.Test;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>import org.junit.jupiter.api.Test;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.quarkus.test.junit.QuarkusTest;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>import io.quarkus.test.junit.QuarkusTest;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import static io.restassured.RestAssured.given;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>import static io.restassured.RestAssured.given;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>import io.restassured.http.ContentType;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>import io.restassured.http.ContentType;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>    @Test
    public void testRedisOperations() {
        // verify that we have nothing
        given()
                .accept(ContentType.JSON)
                .when()
                .get("/increments")
                .then()
                .statusCode(200)
                .body("size()", is(0));
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>    @Test
    public void testOperacoesRedis() {
        // verifique que está vazio
        given()
                .accept(ContentType.JSON)
                .when()
                .get("/incrementos")
                .then()
                .statusCode(200)
                .body("size()", is(0));
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        // create a first increment key with an initial value of 0
        given()
                .contentType(ContentType.JSON)
                .accept(ContentType.JSON)
                .body("{\"key\":\"first-key\",\"value\":0}")
                .when()
                .post("/increments")
                .then()
                .statusCode(200)
                .body("key", is("first-key"))
                .body("value", is(0));
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>        // cria a primeira chave de incremento com valor inicial 0
        given()
                .contentType(ContentType.JSON)
                .accept(ContentType.JSON)
                .body("{\"chave\":\"primeira-chave\",\"valor\":0}")
                .when()
                .post("/incrementos")
                .then()
                .statusCode(200)
                .body("chave", is("primeira-chave"))
                .body("valor", is(0));
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        // create a second increment key with an initial value of 10
        given()
                .contentType(ContentType.JSON)
                .accept(ContentType.JSON)
                .body("{\"key\":\"second-key\",\"value\":10}")
                .when()
                .post("/increments")
                .then()
                .statusCode(200)
                .body("key", is("second-key"))
                .body("value", is(10));
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>        // cria a primeira chave de incremento com valor inicial 10
        given()
                .contentType(ContentType.JSON)
                .accept(ContentType.JSON)
                .body("{\"chave\":\"segunda-chave\",\"valor\":10}")
                .when()
                .post("/incrementos")
                .then()
                .statusCode(200)
                .body("chave", is("segunda-chave"))
                .body("valor", is(10));
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>        // verify that there is no key left
        given()
                .accept(ContentType.JSON)
                .when()
                .get("/increments")
                .then()
                .statusCode(200)
                .body("size()", is(0));
    }
}
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>        // verifica que não existem mais chaves
        given()
                .accept(ContentType.JSON)
                .when()
                .get("/incrementos")
                .then()
                .statusCode(200)
                .body("size()", is(0));
    }
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>curl -X POST -H "Content-Type: application/json" -d '{"key":"first","value":10}' http://localhost:8080/increments &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>curl -X POST -H "Content-Type: application/json" -d '{"chave":"primeira","valor":10}' http://localhost:8080/incrementos &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{
  "key": "first",
  "value": 10
}
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>{
  "chave": "primeira",
  "valor": 10
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>curl http://localhost:8080/increments
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>curl http://localhost:8080/incrementos
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>curl http://localhost:8080/increments/first &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>curl http://localhost:8080/increments/primeira &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>curl -X PUT -H "Content-Type: application/json" -d '27' http://localhost:8080/increments/first &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>curl -X PUT -H "Content-Type: application/json" -d '27' http://localhost:8080/incrementos/primeira &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, running the command `curl http://localhost:8080/increments/first` should return the following result:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Agora, ao executar o comando `curl http://localhost:8080/incrementos/primeira` deve retornar o seguinte resultado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>{
  "key": "first",
  "value": 37 &lt;1&gt;
}
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>{
  "chave": "primeira",
  "valor": 37 &lt;1&gt;
}
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>curl -X DELETE  http://localhost:8080/increments/first &lt;1&gt;
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>curl -X DELETE  http://localhost:8080/increments/primeira &lt;1&gt;
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Now, running the command `curl http://localhost:8080/increments` should return an empty list `[]`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Agora, ao executar o comando `curl http://localhost:8080/incrementos` deve retornar uma lista vazia `[]`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus Cache uses Caffeine as backend.  It's possible to use Redis instead.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, o Quarkus Cache utiliza o Caffeine como backend. É possível usar Redis em vez disso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The backend uses the _&lt;default&gt;_ Redis client (if not configured otherwise), so make sure it's configured (or use the xref:redis-dev-services.adoc[redis dev service])</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O backend utiliza o cliente Redis por padrão (se não estiver configurado de outra forma), por isso certifique-se de que está configurado (ou utilize o xref:redis-dev-services.adoc[redis dev service])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The Redis backend uses the `&lt;default&gt;` Redis client.  See the xref:redis-reference.adoc[Redis reference] to configure the access to Redis.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O backend do Redis utiliza o cliente Redis por padrão. Consulte xref:redis-reference.adoc[referência do Redis] para configurar o acesso ao Redis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When writing to Redis or reading from Redis, Quarkus needs to know the type.  Indeed, the objects need to be serialized and deserialized.  For that purpose, you may need to configure type (class names) of the key and value you want to cache.  At build time, Quarkus tries to deduce the types from the application code, but that decision can be overridden using:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Ao escrever ou ler do Redis, o Quarkus precisa saber o tipo. De fato, os objetos têm que ser serializados e desserializados. Para esse efeito, pode ser necessário configurar o tipo (nome das classes) da chave e do valor que pretende armazenar em cache. No momento da construção (at build time), o Quarkus tenta deduzir os tipos a partir do código da aplicação, mas essa decisão pode ser substituída utilizando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `expire-after-write` is not configured, the entry won't be evicted.  You would need to invalidate the values using the `@CacheInvalidateAll` or `@CacheInvalidate` annotations.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se o tempo de vida `expire-after-write` não estiver configurado, a entrada não será excluída. Você terá de invalidar os valores utilizando as anotações `@CacheInvalidateAll` ou `@CacheInvalidate`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, the Redis backend stores the entry using the following keys: `cache:$cache-name:$cache-key`, where `cache-key` is the key the application uses.  So, you can find all the entries for a single cache using the Redis `KEYS` command: `KEYS cache:$cache-name:*`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, o Redis backend armazena a entrada utilizando as seguintes chaves: `cache:$cache-name:$cache-key`, onde `cache-key` é a chave que o aplicativo usa. Assim, é possível encontrar todas as entradas de um único cache usando o comando Redis `KEYS`: `KEYS cache:$cache-name:*`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `cache:$cache-name:` segment can be configured using the `prefix` property:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O `cache:$cache-name:` segmento pode ser configurado utilizando a propriedade `prefix`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Enable optimistic locking</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Ativar o bloqueio otimista (`Optimistic locking`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The access to the cache can be _direct_ or use https://redis.io/docs/manual/transactions/#optimistic-locking-using-check-and-set[optimistic locking].  By default, optimistic locking is disabled.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O acesso ao cache pode ser _direto_ ou utilizar o https://redis.io/docs/manual/transactions/#optimistic-locking-using-check-and-set[bloqueio otimista]. Por padrão, o bloqueio otimista está desativado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When used, the key is _watched_ and the _SET_ command is executed in a transaction (`MULTI/EXEC`).</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Quando utilizado, a chave é _vigiada_ e o comando _SET_ é executado numa transação ( `MULTI/EXEC`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>With Quarkus you can deploy your favorite Java HTTP frameworks as AWS Lambda's using either the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[AWS Gateway HTTP API] or https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[AWS Gateway REST API].  This means that you can deploy your microservices written with RESTEasy Reactive (our Jakarta REST implementation), Undertow (servlet), Reactive Routes, xref:funqy-http.adoc[Funqy HTTP] or any other Quarkus HTTP framework as an AWS Lambda.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Com o Quarkus, é possível fazer o deploy de seu framework Java HTTP favorito como AWS Lambdas usando a  link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html[API HTTP do AWS Gateway] ou a  link:https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html[API REST do AWS Gateway]. Isto significa que você pode fazer o deploy dos seus microsserviços escritos com RESTEasy Reactive (a nossa implementação Jakarta REST), Undertow (servlet), Reactive Routes,  link:funqy-http.html[Funqy HTTP] ou qualquer outra estrutura HTTP Quarkus como um AWS Lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus has a different extension for each Gateway API.  The HTTP Gateway API is implemented within the `quarkus-amazon-lambda-http` extension.  The REST Gateway API is implemented within the `quarkus-amazon-lambda-rest` extension.  If you are confused on which Gateway product to use, Amazon has a https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[great guide] to help you navigate this decision.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus tem uma extensão diferente para cada API de gateway. A API de Gateway HTTP é implementada na extensão `quarkus-amazon-lambda-http`. A API do Gateway REST é implementada na extensão `quarkus-amazon-lambda-rest`. Se estiver confuso quanto a qual Gateway utilizar, a Amazon tem um  link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html[excelente guia] para ajudar você a tomar esta decisão.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps for installing AWS SAM CLI.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A instalação de todos os componentes AWS é provavelmente a parte mais difícil deste guia. Certifique-se de que ter seguido todos os passos para instalar o AWS SAM CLI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This will compile the code and run the unit tests included within the generated project.  Unit testing is the same as any other Java project and does not require running on Amazon.  Quarkus dev mode is also available with this extension.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Isto irá compilar o código e executar os testes de unitários incluídos no projeto gerado. O teste unitário é o mesmo que qualquer outro projeto Java e não requer a execução na Amazon. O _dev_ _mode_ do Quarkus também está disponível com esta extensão.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are building on a non-Linux system, you will need to also pass in a property instructing quarkus to use a Docker build as Amazon Lambda requires Linux binaries.  You can do this by passing `-Dquarkus.native.container-build=true` to your build command.  This requires you to have Docker installed locally, however.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se voê estiver construindo em um sistema que não seja Linux, terá de passar também uma propriedade que instrua o quarkus a utilizar uma compilação Docker, uma vez que o Amazon Lambda requer binários Linux. Você pode fazer isso passando `-Dquarkus.native.container-build=true` para o seu comando de compilação. No entanto, isso requer que você tenha o Docker instalado localmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>After you run the build, there are a few extra files generated by the Quarkus lambda extension you are using.  These files are in the build directory: `target/` for Maven, `build/` for Gradle.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Depois de executar a compilação, existem alguns arquivos extras gerados pela extensão lambda Quarkus que você esta usando. Estes arquivos encontram-se no diretório de compilação: `target/` para Maven, `build/` para Gradle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In dev and test mode, Quarkus will start a mock AWS Lambda event server that will convert HTTP requests to the corresponding API Gateway event types and post them to the underlying Quarkus HTTP lambda environment for processing.  This simulates the AWS Lambda environment as much as possible locally without requiring tools like Docker and SAM CLI.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>No modo de desenvolvimento e teste, o Quarkus iniciará um servidor de eventos AWS Lambda simulado que converterá solicitações HTTP para os tipos de eventos correspondentes do API Gateway e os publicará no ambiente lambda HTTP subjacente do Quarkus para processamento. Isso simula o ambiente do AWS Lambda o máximo possível localmente sem exigir ferramentas como Docker e SAM CLI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When using Quarkus Dev Mode just invoke HTTP requests on `http://localhost:8080` as you normally would when testing your REST endpoints.  This request will hit the Mock Event Server and will be converted to the API Gateway json message that is consumed by the Quarkus Lambda Poll loop.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Ao usar o _dev_ _mode_ do Quarkus, basta invocar pedidos HTTP em `&amp;lt;a href="http://localhost:8080" class="bare"&amp;gt;http://localhost:8080&amp;lt;/a&amp;gt;` como você faria normalmente ao testar seus endpoints REST. Este pedido chegará ao Mock Event Server e será convertido na mensagem json do API Gateway que é consumida pelo Quarkus Lambda Poll loop.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For testing, Quarkus starts up a separate Mock Event server under port 8081.  The default port for Rest Assured is automatically set to 8081 by Quarkus, so you don't have to worry about setting this up.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para testes, o Quarkus inicia um servidor Mock Event separado na porta 8081. A porta predefinida para o Rest Assured é automaticamente definida para 8081 pelo Quarkus, para que você não tenha que se preocupar configurando isto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to simulate more complex API Gateway events in your tests, then manually do an HTTP POST to `http://localhost:8080/\_lambda_` (port 8081 in test mode) with the raw API Gateway json events.  These events will be placed directly on the Quarkus Lambda poll loop for processing.  Here's an example of that:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você quiser simular eventos mais complexos do API Gateway em seus testes, faça manualmente um HTTP POST para `&amp;lt;a href="http://localhost:8080/_lambda_" class="bare"&amp;gt;http://localhost:8080/_lambda_&amp;lt;/a&amp;gt;` (porta 8081 no modo de teste) com os eventos json brutos do API Gateway. Esses eventos serão colocados diretamente no Quarkus Lambda poll loop  para processamento. Aqui está um exemplo disso:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to hand code raw events for the AWS HTTP API, the AWS Lambda library has the request event type which is `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` and the response event type of `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse`.  This corresponds to the `quarkus-amazon-lambda-http` extension and the AWS HTTP API.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você quiser codificar manualmente eventos brutos para a API HTTP da AWS, a biblioteca Lambda da AWS tem o tipo de evento de request que é `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent` e o tipo de evento de response de `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPResponse`. Isto corresponde à extensão `quarkus-amazon-lambda-http` e à API HTTP da AWS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to hand code raw events for the AWS REST API, Quarkus has its own implementation: `io.quarkus.amazon.lambda.http.model.AwsProxyRequest` and `io.quarkus.amazon.lambda.http.model.AwsProxyResponse`.  This corresponds to `quarkus-amazon-lambda-rest` extension and the AWS REST API.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você quiser codificar manualmente eventos brutos para a API REST do AWS, o Quarkus tem a sua própria implementação: `io.quarkus.amazon.lambda.http.model.AwsProxyRequest` e `io.quarkus.amazon.lambda.http.model.AwsProxyResponse`. Isto corresponde à extensão `quarkus-amazon-lambda-rest` e à API REST da AWS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The mock event server is also started for `@QuarkusIntegrationTest` tests so will work with native binaries too.  All this provides similar functionality to the SAM CLI local testing, without the overhead of Docker.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O mock event server também é iniciado para os testes `@QuarkusIntegrationTest`, pelo que também funcionará com binários nativos. Tudo isso fornece uma funcionalidade semelhante ao teste local do SAM CLI, sem a sobrecarga do Docker.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The AWS SAM CLI allows you to run your lambda's locally on your laptop in a simulated Lambda environment.  This requires Docker to be installed.  After you have built your Maven project, execute this command:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O AWS SAM CLI permite que você execute seus lambda's localmente no seu laptop em um ambiente Lambda simulado. Para isso, é necessário que o Docker esteja instalado. Depois de criar seu projeto Maven, execute este comando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>http://127.0.0.1:3000/hello</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>http://127.0.0.1:3000/hello</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the console you'll see startup messages from the lambda.  This particular deployment starts a JVM and loads your lambda as pure Java.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>No console, você verá mensagens de inicialização do lambda. Esse deployment específico inicia uma JVM e carrega seu lambda como Java puro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Answer all the questions and your lambda will be deployed and the necessary hooks to the API Gateway will be set up. If everything deploys successfully, the root URL of your microservice will be output to the console.  Something like this:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Responda a todas as perguntas e seu lambda será implantado e os hooks necessários para o API Gateway serão configurados. Se tudo for implantado com sucesso, o URL raiz do seu microsserviço será enviado para o console. Algo parecido com isto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Responses for binary types will be automatically encoded with base64.  This is different from the behavior using `quarkus:dev` which will return the raw bytes.  Amazon's API has additional restrictions requiring the base64 encoding.  In general, client code will automatically handle this encoding but in certain custom situations, you should be aware you may need to manually manage that encoding.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>As respostas para tipos binários serão automaticamente codificadas com base64. Isso é diferente do comportamento usando `quarkus:dev`, que retornará os bytes brutos. A API da Amazon tem restrições adicionais que exigem a codificação base64. Em geral, o código do cliente tratará automaticamente desta codificação, mas em determinadas situações personalizadas, deve estar ciente de que poderá ter de gerir manualmente essa codificação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>There is nothing special about the POM other than the inclusion of the `quarkus-amazon-lambda-http` extension (if you are deploying an AWS Gateway HTTP API) or the `quarkus-amazon-lambda-rest` extension (if you are deploying an AWS Gateway REST API).  These extensions automatically generate everything you might need for your lambda deployment.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Não há nada de especial no POM além da inclusão da extensão `quarkus-amazon-lambda-http` (se estiver implantando uma API HTTP do AWS Gateway) ou da extensão `quarkus-amazon-lambda-rest` (se estiver implantando uma API REST do AWS Gateway). Essas extensões geram automaticamente tudo o que pode ser necessário para o deploy do lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Also, at least in the generated Maven archetype `pom.xml`, the `quarkus-resteasy-reactive`, `quarkus-reactive-routes`, and `quarkus-undertow` dependencies are all optional.  Pick which HTTP framework(s) you want to use (Jakarta REST, Reactive Routes, and/or Servlet) and remove the other dependencies to shrink your deployment.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Além disso, pelo menos no arquétipo Maven gerado `pom.xml`, as dependências `quarkus-resteasy-reactive`, `quarkus-reactive-routes` e `quarkus-undertow` são todas opcionais. Escolha o(s) framework(s) HTTP que deseja usar (Jakarta REST, Rotas Reativas e/ou Servlet) e remova as outras dependências para reduzir sua implantação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The `sam.yaml` syntax is beyond the scope of this document.  There's a couple of things that must be highlighted just in case you are going to craft your own custom `sam.yaml` deployment files.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A sintaxe do `sam.yaml` está além do escopo deste documento. Há alguns aspectos que devem ser destacados, caso pretenda criar os seus próprios arquivos de deployment `sam.yaml` personalizados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The first thing to note is that for pure Java lambda deployments require a specific handler class.  Do not change the Lambda handler name.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A primeira coisa a observar é que, para deployments lambda Java puros, é necessário um handler class específico. Não altere o nome do handler Lambda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you want to go native, there's an environment variable that must be set for native GraalVM deployments.  If you look at `sam.native.yaml` you'll see this:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você deseja usar uma compilação nativa, há uma variável de ambiente que deve ser definida para deployments nativos do GraalVM. Se olhares para `sam.native.yaml` verás isto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Finally, there is one specific thing for AWS Gateway REST API deployments.  That API assumes that HTTP response bodies are text unless you explicitly tell it which media types are binary through configuration.  To make things easier, the Quarkus extension forces a binary (base 64) encoding of all HTTP response messages and the `sam.yaml` file must configure the API Gateway to assume all media types are binary:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por fim, há um aspeto específico para o deploy da API REST do AWS Gateway. Essa API assume que os corpos de resposta HTTP são texto, a menos que se diga explicitamente quais tipos de mídia são binários por meio de configuração. Para facilitar as coisas, a extensão Quarkus obriga a uma codificação binária (base 64) de todas as mensagens de resposta HTTP e o ficheiro `sam.yaml` tem de configurar a API Gateway para assumir que todos os tipos de media são binários:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are using RESTEasy Reactive and Jakarta REST, you can inject various AWS Context variables into your Jakarta REST resource classes using the Jakarta REST `@Context` annotation or anywhere else with the CDI `@Inject` annotation.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se estiver utilizando o RESTEasy Reactive e o Jakarta REST, pode injetar várias variáveis de contexto AWS nas suas resource classes Jakarta REST utilizando a anotação Jakarta REST `@Context` ou em qualquer outro lugar com a anotação CDI `@Inject`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the AWS HTTP API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent`.  Here is an example:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para a API HTTP do AWS, você pode injetar as variáveis do AWS `com.amazonaws.services.lambda.runtime.Context` e `com.amazonaws.services.lambda.runtime.events.APIGatewayV2HTTPEvent`. Eis um exemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For the AWS REST API you can inject the AWS variables `com.amazonaws.services.lambda.runtime.Context` and `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext`.  Here is an example:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para a API REST do AWS, você pode injetar as variáveis do AWS `com.amazonaws.services.lambda.runtime.Context` e `io.quarkus.amazon.lambda.http.model.AwsProxyRequestContext`. Eis um exemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>When you invoke an HTTP request on the API Gateway, the Gateway turns that HTTP request into a JSON event document that is forwarded to a Quarkus Lambda.  The Quarkus Lambda parses this json and converts in into an internal representation of an HTTP request that can be consumed by any HTTP framework Quarkus supports (Jakarta REST, servlet, Reactive Routes).</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Quando você invoca um pedido HTTP no API Gateway, o Gateway transforma esse pedido HTTP num documento de evento JSON que é reencaminhado para um Quarkus Lambda. O Quarkus Lambda analisa este json e o converte em uma representação interna de um pedido HTTP que pode ser consumido por qualquer estrutura HTTP suportada pelo Quarkus (Jakarta REST, servlet, Reactive Routes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>API Gateway supports many ways to securely invoke on your HTTP endpoints that are backed by Lambda and Quarkus.  If you enable it, Quarkus will automatically parse relevant parts of the https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html[event json document] and look for security based metadata and register a `java.security.Principal` internally that can be looked up in Jakarta REST by injecting a `jakarta.ws.rs.core.SecurityContext`, via `HttpServletRequest.getUserPrincipal()` in servlet, and `RouteContext.user()` in Reactive Routes.  If you want more security information, the `Principal` object can be typecast to a class that will give you more information.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O API Gateway suporta muitas formas de invocar com segurança os seus endpoints HTTP que são apoiados pelo Lambda e pelo Quarkus. Se o ativar, o Quarkus analisará automaticamente as partes relevantes do  link:https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html[documento json do evento] e procurará metadados baseados na segurança e registará internamente um `java.security.Principal` que pode ser consultado no Jakarta REST injectando um `jakarta.ws.rs.core.SecurityContext`, através de `HttpServletRequest.getUserPrincipal()` no servlet e `RouteContext.user()` nas rotas reactivas. Se quiser mais informações de segurança, o objeto `Principal` pode ser convertido para uma classe que lhe dará mais informações.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To enable this security feature, add this to your `application.properties` file:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para ativar esta funcionalidade de segurança, adicione isto ao seu arquivo `application.properties`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>HTTP `quarkus-amazon-lambda-http`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>HTTP `quarkus-amazon-lambda-http`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Auth Type</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Auth Type</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cognito JWT</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Cognito JWT</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.amazon.lambda.http.CognitoPrincipal`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`io.quarkus.amazon.lambda.http.CognitoPrincipal`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.jwt.claims.cognito:username`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`requestContext.authorizer.jwt.claims.cognito:username`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.amazon.lambda.http.IAMPrincipal`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`io.quarkus.amazon.lambda.http.IAMPrincipal`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.iam.userId`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`requestContext.authorizer.iam.userId`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`io.quarkus.amazon.lambda.http.CustomPrincipal`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`io.quarkus.amazon.lambda.http.CustomPrincipal`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.lambda.principalId`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`requestContext.authorizer.lambda.principalId`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>REST `quarkus-amazon-lambda-rest`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>REST `quarkus-amazon-lambda-rest`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Cognito</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Cognito</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`requestContext.authorizer.claims.cognito:username`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`requestContext.authorizer.claims.cognito:username`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If the `cognito:groups` claim is present, then Quarkus will extract and map those groups to Quarkus roles which can then be used in authorization with annotations like `@RolesAllowed`.  If you do not want to map `cognito:groups` to Quarkus roles, then you must explicitly disable it in configuration:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se a reivindicação `cognito:groups` estiver presente, o Quarkus extrairá e mapeará esses grupos para as funções do Quarkus que podem então ser utilizadas na autorização com anotações como `@RolesAllowed`. Se não pretender mapear `cognito:groups` para as funções do Quarkus, você terá que desativar explicitamente na configuração:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, it expects roles in a space delimited list enclosed in brackets i.e. `[ user admin ]`.  You can specify the regular expression to use to find individual roles in the claim string too:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, ele espera funções numa lista delimitada por espaços entre parênteses, ou seja, `[ user admin ]`. Também pode especificar a expressão regular a utilizar para encontrar funções individuais na cadeia de reivindicação:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>The default support for AWS security only maps the principal name to Quarkus security APIs and does nothing to map claims or roles or permissions.  You have full control on how security metadata in the lambda HTTP event is mapped to Quarkus Security APIs using implementations of the `io.quarkus.amazon.lambda.http.LambdaIdentityProvider` interface.  By implementing this interface, you can do things like define role mappings for your principal or publish additional attributes provided by IAM or Cognito or your Custom Lambda security integration.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O suporte padrão para a segurança AWS apenas mapeia o nome principal para as APIs de segurança do Quarkus e não faz nada para mapear reivindicações, funções ou permissões. Você tem total controle sobre a forma como os metadados de segurança no evento HTTP lambda são mapeados para as APIs de segurança do Quarkus utilizando implementações da interface `io.quarkus.amazon.lambda.http.LambdaIdentityProvider`. Ao implementar esta interface, pode fazer coisas como definir mapeamentos de funções para o seu principal ou publicar atributos adicionais fornecidos pelo IAM ou Cognito ou pela sua integração de segurança Lambda personalizada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For HTTP, the important method to override is `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)`.  From this you will allocate a SecurityIdentity based on how you want to map security data from `APIGatewayV2HTTPEvent`</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para HTTP, o método importante para ser substituído é o `LambdaIdentityProvider.authenticate(APIGatewayV2HTTPEvent event)`. A partir daí, atribuirá uma SecurityIdentity com base na forma como pretende mapear os dados de segurança de `APIGatewayV2HTTPEvent`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For REST, the important method to override is `LambdaIdentityProvider.authenticate(AwsProxyRequest event)`.  From this you will allocate a SecurityIdentity based on how you want to map security data from `AwsProxyRequest`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para REST, o método importante para ser substituído é o `LambdaIdentityProvider.authenticate(AwsProxyRequest event)`. A partir daí, atribuirá uma SecurityIdentity com base na forma como pretende mapear os dados de segurança de `AwsProxyRequest`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Your implemented provider must be a CDI bean.  Here's an example:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O seu provider implementado deve ser um bean CDI. Eis um exemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus should automatically discover this implementation and use it instead of the default implementation discussed earlier.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus deve descobrir automaticamente esta implementação e utilizá-la em vez da implementação padrão referida anteriormente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you are testing your application with `sam local` you can hardcode a principal name to use when your application runs by setting the `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME` environment variable</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você estiver testando a sua aplicação com `sam local`, pode definir um nome principal para utilizar quando a sua aplicação for executada, definindo a variável de ambiente `QUARKUS_AWS_LAMBDA_FORCE_USER_NAME`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>SnapStart</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>SnapStart</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To optimize your application for Lambda SnapStart, check xref:amazon-snapstart.adoc[the SnapStart Configuration Documentation].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para otimizar a sua aplicação para o Lambda SnapStart, consulte  link:amazon-snapstart.html[a documentação de configuração do SnapStart].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>You have installed at least one extension that provides an `IdentityProvider` based on username and password, such as xref:security-jdbc.adoc[Elytron JDBC].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Você instalou pelo menos uma extensão que fornece um `IdentityProvider` baseado no usename e no password, como o  link:security-jdbc.html[Elytron JDBC].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For testing purposes, you can configure the required user credentials, user name, secret, and roles, in the `application.properties` file.  For example:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para efeitos de teste, você pode configurar as credenciais de usuário necessárias, username, secret e roles no arquivo `application.properties`. Por exemplo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For information about other methods that you can use to configure the required user credentials, see the xref:security-testing.adoc#configuring-user-information[Configuring User Information] section of the Quarkus "Security Testing" guide.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para obter informações sobre outros métodos que você pode utilizar para configurar as credenciais de usuário necessárias, consulte a seção  link:security-testing.html#configuring-user-information[Configurar as informações do usuario] do guia "Teste de segurança" do Quarkus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Configuring user names, secrets, and roles in the `application.properties` file is only suitable for testing scenarios.  If you are securing a production application, always use a database to store this information.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A configuração de nomes de username, secrets e roles no arquivo `application.properties` só é adequada para cenários de teste. Se estiver protegendo uma aplicação em produção, utilize sempre uma base de dados para armazenar estas informações.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>For a more detailed walk-through that shows you how to configure Basic authentication together with Jakarta Persistence for storing user credentials in a database, see the xref:security-basic-authentication-tutorial.adoc[Secure a Quarkus application with Basic authentication and Jakarta Persistence] guide.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para obter um guia mais detalhado que mostra como configurar a autenticação básica juntamente com o Jakarta Persistence para armazenar credenciais de usuário numa base de dados, consulte o guia  link:security-basic-authentication-tutorial.html[Proteger uma aplicação Quarkus com autenticação básica e o Jakarta Persistence].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html[SnapStart] is a snapshotting and restore mechanism reducing drastically the cold startup time of Java functions on AWS.  This document explains the various settings you can use to leverage this feature.  It is not a reference documentation on SnapStart, and it will not cover how SnapStart works in details.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>link:https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html[O SnapStart] é um mecanismo de _snapshotting_ e restauração que reduz drasticamente o tempo de inicialização a frio das funções Java na AWS. Este documento explica as várias configurações que podem ser usadas para aproveitar esse recurso. Não se trata de uma documentação de referência sobre o SnapStart e não abordará como o SnapStart funciona em detalhes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This feature is only available on AWS Lambda, and not in all regions.  Please check the AWS documentation to verify the eligibility of your AWS region.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Esta funcionalidade só está disponível na AWS Lambda e não em todas as regiões. Consulte a documentação da AWS para verificar a elegibilidade da sua região da AWS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use the Quarkus AWS Lambda extension, SnapStart optimizations are automatically enabled.  However, you can enable/disable it explicitly using:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você utilizar a extensão Quarkus AWS Lambda, as otimizações do SnapStart são automaticamente ativadas. No entanto, você pode ativar/desativar explicitamente utilizando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Classloading has a huge impact on your function execution time.  This optimization allows preloading classes during the snapshotting process of SnapStart.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O _classloading_ tem um enorme impacto no tempo de execução da sua função. Esta otimização permite pré-carregar classes durante o processo de _snapshotting_ do SnapStart.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>To compute the list of classes, we recommend deploying your function and setting the `JAVA_TOOL_OPTIONS` environment variable to `-verbose:class`.  Then execute your function and retrieve the log (in CloudWatch).  You should be able to extract the class names using sed/awk or any text editor.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Para calcular a lista de classes, recomendamos fazer o _deploy_ da sua função e definir a variável de ambiente JAVA_TOOL_OPTIONS como -verbose:class. Em seguida, execute sua função e recupere o registro (no CloudWatch). Você deverá ser capaz de extrair os nomes das classes usando o sed/awk ou qualquer editor de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, Quarkus generates the class list of the classes included in your application (including the classes generated by Quarkus).  So, you do not have to repeat them in the `quarkus-preload-classes.txt` file.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, o Quarkus gera a lista de classes das classes incluídas na sua aplicação (incluindo as classes geradas pelo Quarkus). Assim, você não precisa repeti-las no arquivo `quarkus-preload-classes.txt`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>By default, when the classes are preloaded, they are also _initialized_, meaning it also resolves the dependent classes.  You can disable this behavior using:</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Por padrão, quando as classes são pré-carregadas, elas também são _inicializadas_, o que significa que também resolve as classes dependentes. É possível desativar este comportamento utilizando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Client _priming_ is a technique that allows initializing a client during the snapshotting process, so it's already fully functional during the application runtime.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Client _priming_ é uma técnica que permite inicializar um client durante o processo de _snapshotting,_ para que já esteja totalmente funcional durante o tempo de execução da aplicação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>initialize the client in a `static` block, which, thanks to class preloading will be executed before the snapshot</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>inicializar o client num bloco `static`, que, graças ao pré-carregamento da classe, será executado antes do snapshot</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Implementing priming using a static block may prevent the native compilation of your application.  Client initialization may start threads or open connections which are not compatible with the native compilation if the class is initialized at build time.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Implementar o priming usando um bloco estático pode impedir a compilação nativa da sua aplicação. A inicialização do client pode iniciar threads ou abrir conexões que não são compatíveis com a compilação nativa se a classe for inicializada no momento da compilação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>It is also recommended to use _tiered compilation_ when using SnapStart.  To achieve this, set the `JAVA_TOOL_OPTIONS` environment property to `-XX:+TieredCompilation -XX:TieredStopAtLevel=1`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Também é recomendável usar _tiered compilation_ ao usar o SnapStart. Para isso, defina a propriedade de ambiente `JAVA_TOOL_OPTIONS` como `-XX:+TieredCompilation -XX:TieredStopAtLevel=1`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>As a Quarkus developer, you configure the Quarkus OpenID Connect (OIDC) extension by setting the following properties in the `src/main/resources/application.properties` file.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Como programador do Quarkus, você configura a extensão Quarkus OpenID Connect (OIDC) definindo as seguintes propriedades no diretório `src/main/resources/application.properties`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>xref:security-oidc-bearer-token-authentication-tutorial.adoc[Protect a service application by using OpenID Connect (OIDC) Bearer token authentication]</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>link:security-oidc-bearer-token-authentication-tutorial.html[Proteger uma aplicação de serviço usando a autenticação de token Bearer OpenID Connect (OIDC)]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Identity providers</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Identity providers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>In the Quarkus Security framework, identity providers play a crucial role in authentication and authorization by verifying user identities.  `IdentityProvider` creates a `SecurityIdentity` instance, which gets used during user authentication to verify and authorize access requests to your Quarkus application.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>No Quarkus Security framework, os identity providers desempenham um papel crucial na autenticação e autorização, verificando as identidades dos usuários. `IdentityProvider` cria uma instância `SecurityIdentity`, que é utilizada durante a autenticação do usuário para verificar e autorizar os pedidos de acesso à sua aplicação Quarkus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>`IdentityProvider` converts the authentication credentials provided by `HttpAuthenticationMechanism` to a `SecurityIdentity` instance.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>`IdentityProvider` converte as credenciais de autenticação fornecidas por `HttpAuthenticationMechanism` para uma instância `SecurityIdentity`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Some extensions, for example, `OIDC`, `OAuth2`, and `SmallRye JWT`, have inline `IdentityProvider` implementations specific to the supported authentication flow.  For example, `quarkus-oidc` uses its own `IdentityProvider` to convert a token to a `SecurityIdentity` instance.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Algumas extensões, por exemplo, `OIDC`, `OAuth2`, e `SmallRye JWT`, têm implementações em linha `IdentityProvider` específicas para o fluxo de autenticação suportado. Por exemplo, `quarkus-oidc` usa seu próprio `IdentityProvider` para converter um token em uma instância `SecurityIdentity`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>If you use Basic or form-based authentication, you must add an `IdentityProvider` instance to convert a username and password to a `SecurityIdentity` instance.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Se você utilizar a Basic ou form-based, você precisará adicionar uma instãncia `IdentityProvider` para converter um username e um password em uma instância `SecurityIdentity`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications are optimised for low memory usage and fast startup times.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Aplicações Quarkus são otimizadas para baixo uso de memória e tempos de inicialização rápidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>/guides/getting-started</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>/guias/começar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus DI solution is based on the [Contexts and Dependency Injection for Java 2.0](https://docs.jboss.org/cdi/spec/2.0/cdi-spec) specification. This guide explains the basics of CDI.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>A solução Quarkus DI é baseada na especificação [Contexts and Dependency Injection for Java 2.0] https://docs.jboss.org/cdi/spec/2.0/cdi-spec . Este guia explica os princípios básicos do CDI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Testing in JVM mode
* Testing in native mode
* Injection of resources into tests
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia aborda: 
* Testes no modo JVM 
* Testes no modo nativo 
* Injeção de recursos nos testes
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide explains how to use the OpenAPI extension to generate an OpenAPI descriptor and get a Swagger UI frontend to test your REST endpoints.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia explica como usar a extensão OpenAPI para gerar um descritor OpenAPI e obter um front-end da interface do usuário do Swagger para testar seus endpoints REST.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn more about configuring Quarkus' Vert.x based HTTP layer - and Undertow if you are using servlets.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Saiba mais sobre como configurar a camada HTTP baseada em Vert.x do Quarkus - e Undertow se você estiver usando servlets.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Liquibase MongoDB</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Liquibase MongoDB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the usage of MongoDB using active records and repositories.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia aborda o uso do MongoDB usando &lt;i&gt;active records&lt;/i&gt; e repositórios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers the usage of MongoDB using active records and repositories in a Kotlin project.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia aborda o uso do MongoDB usando &lt;i&gt;active records&lt;/i&gt; e repositórios em um projeto Kotlin.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Secure your web endpoints with authorizations.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Proteja os seus Web Endpoints com autorizações.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Customize Quarkus' security layer behavior.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Personalize o comportamento da camada de segurança do Quarkus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide walks you through the process of creating a Quarkus application with OptaPlanner's constraint solving Artificial Intelligence (AI).</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia orienta você pelo processo de criação de um aplicativo Quarkus com a Inteligência Artificial (IA) de resolução de restrições do OptaPlanner.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Using AI to optimize a schedule with OptaPlanner</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Usando IA para otimizar um cronograma com o OptaPlanner</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>jbang Integration</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>integração jbang</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>gRPC</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>gRPC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Maven configuration
* Creating a new project
* Dealing with extensions
* Development mode
* Debugging
* Import in your IDE
* Building a native executable
* Build a container friendly executable
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia abrange:
* Configuração do Maven
* Criação de um novo projeto
* Lidar com extensões
* Modo de desenvolvimento
*Depuração
* Importar em seu IDE
* Construção de um executável nativo
* Construa um executável amigável para contêineres
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers:
* Gradle configuration
* Creating a new project
* Dealing with extensions
* Development mode
* Debugging
* Import in your IDE
* Building a native executable
* Build a container friendly executable
</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia abrange:
* Configuração Gradle
* Criação de um novo projeto
* Lidar com extensões
* Modo de desenvolvimento
*Depuração
* Importar em seu IDE
* Construção de um executável nativo
* Construa um executável amigável para contêineres
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use mutable jars to rebuild your application with different build time configurations.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Use JARs mutáveis para reconstruir sua aplicação com diferentes configurações de tempo de compilação.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Use Spring Boot's `@ConfigurationProperties` in place of MicroProfile Config annotations</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Use o '@ConfigurationProperties' do Spring Boot no lugar das anotações do MicroProfile Config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>This guide covers how to use GCP Secret Manager in Quarkus to consume configuration properties directly or via your `application.properties`.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Este guia aborda como usar o GCP Secret Manager no Quarkus para consumir propriedades de configuração diretamente ou por meio de seu 'application.properties'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to integrate your extension with Quarkus' CDI container.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Saiba como integrar sua extensão com o contêiner CDI do Quarkus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Learn how to get your extension contribute features to the Dev UI.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Saiba como fazer com que a sua extensão contribua com funcionalidades para a interface do usuário do desenvolvedor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Contributing to Dev UI</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Contribuindo para a interface do usuário do desenvolvedor</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>November 19, 2019</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>19 de novembro de 2019</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>December 6, 2019</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>6 de dezembro de 2019</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>May 2, 2019</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>maio 2, 2019</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>September 24, 2019</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>24 de setembro de 2019</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Multiple ways to connect with others via forum, stack, chat, or email groups.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Várias maneiras de se conectar com outras pessoas por meio de fóruns, Stack Overflow, bate-papo ou grupos de e-mail.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus applications are designed to run in containers.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Aplicações Quarkus são projetadas para serem executadas em contêineres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Quarkus is published in Maven Central, check out link:/extensions[which extensions] you need and just import them in your `pom.xml` to get Quarkus. We recommend you start your Quarkus experience via our link:/get-started[Getting Started guides].</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>O Quarkus é publicado no Maven Central, confira link:/extensions[quais extensões] você precisa e basta importá-los em seu 'pom.xml' para obter o Quarkus. Recomendamos que você comece sua experiência com o Quarkus através do nosso link:/get-started[Guias de introdução].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en">
        <seg>Think of Quarkus extensions as your project dependencies. Extensions configure, boot and integrate a framework or technology into your Quarkus application. They also do all of the heavy lifting of providing the right information to GraalVM for your application to compile natively. This will allow 3rd party projects to easily take advantage of the work we have done to make it easier to target GraalVM.</seg>
      </tuv>
      <tuv xml:lang="pt_BR">
        <seg>Pense nas extensões do Quarkus como suas dependências de projeto. As extensões configuram, inicializam e integram uma estrutura ou tecnologia em seu aplicativo Quarkus. Eles também fazem todo o trabalho pesado de fornecer as informações certas para GraalVM para sua aplicação compilar nativamente. Isso permitirá que os projetos de terceiros aproveitem facilmente o trabalho que fizemos para facilitar o direcionamento do GraalVM.</seg>
      </tuv>
    </tu>
  </body>
</tmx>
